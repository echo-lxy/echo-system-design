---
title: 主从复制
date: 2024-09-16 03:24:06
permalink: /pages/ebc8dc/
---

::: note 提出问题是一切智慧的开端

1. 为什么 Redis 早期的 `SYNC` 操作在断线重连时效率低下？
2. 如何通过 `replication offset` 和 `replication backlog` 实现高效的部分重同步？
3. 运行ID在主从断线重连时如何帮助确定同步方式？
4. `PSYNC` 如何优化断线后重连时的主从复制效率？
5. 为什么即使有TCP传输，Redis 仍需通过心跳机制确保数据一致？

:::

## 前言

![image-20240916215426114](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162154182.png)

Redis 中，用户可以通过 *SLAVEOF* 命令或者设置 slaveof 选项，去让一个 redis server 去复制 另一个 redis server，我们它们分别称为 slave（从机）与 master（主机）

开始之前，我假设你已经了解 主从复制功能的使用方法

## 旧版复制

Redis 的复制功能分为

* **同步**：用于将从服务器的数据库状态更新至主服务器当前所处的数据库状态
* **命令传播**：用于在主服务器的状态被修改时，实时将修改命令告知从服务器

### 第一步：同步

当客户端首次想从服务器发送 SLAVEOF 命令的时候，要 slave 复制 master 时，就要执行 同步 SYNC  操作

![image-20240916230021699](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162300726.png)

执行步骤：

1. slave 向 master 发送 SYNC 命令
2. 收到 SYNC 命令后的主服务器执行 BGSAVE 命令，并用缓冲区记录从当前开始的所有写命令
3. BGSAVE 执行完毕时，master 会将 BGSAVE 命令生成的 RDB 文件发送给 slave
4. slave 接受并载入这个 RDB 文件
5. master  将先前缓冲区中的所有写命令发送给 slave，slave 执行后将状态更新至 master 当前状态

![image-20240916223511189](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162235256.png)

### 第二步：命令传播

当首次同步之后，主机状态发生变化时，主机会发送实时传播写命令给从机，使其状态一致

### 旧版的缺陷

在同步中存在以下两种情况

* 初次复制：从机开始对一个以前没有复制过的主机进行复制
* 断线后重复制：处于命令传播阶段的从机与主机断连然后自动新连接上了之后，对主机进行的复制

我们可以预料，断线后重复制没有必要同步全量的RDB文件，只需要同步断线期间缺失的命令即可

::: warning SYNC 命令是一个非常耗费资源的操作

每次执行SYNC命令，主从服务器需要执行以下动作:

1. 主服务器需要执行 BGSAVE 命令来生成 RDB 文件，这个生成操作会耗费主服务
   器大量的 CPU、内存和磁盘 I/O 资源。
2. 主服务器需要将自己生成的 RDB 文件发送给从服务器，这个发送操作会耗费主从服务器大量的网络资源，并对主服务器响应命令请求的时间产生影响。
3. 接收到 RDB 文件的从服务器需要载入主服务器发来的RDB文件，并且在载入期间，从服务器会因为阻寒而没办法处理命令请求

因为 SYNC 命令是一个如此耗费资源的操作，所以 Redis 有必要保证在真正有需要时才执行SYNC 命令

:::

## 新版复制

新版复制的出现是为了解决 旧版复制功能在断线重复制 情况时的低效问题

> Redis 从2.8开始，使用 PSYNC 命令代替 SYNC 命令来执行复制时的同步操作

PSYNC 有两种模式

* 「完整重同步」：用于处理初次复制情况，和 SYNC 命令执行步骤基本一样
* 「部分重同步」：用于处理断线后重复制情况，当从服务器在断线后重新连接主服务器时，如果条件允许，主服务器可以将主从服务器连接断开期间执行的写命令发送给从服务器，从服务器只要接收并执行这些写命令，就可以将数据库更新至主服务器当前所处的状态

PSYNC 中的部分重同步模式 有效解决了旧版复制功能在处理断线后重复制出现的低效问题

![image-20240916230006676](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162300714.png)

### 部分重同步的实现

部分重同步功能的关键三部分

* *replication offset*：主机的复制偏移量 和 从机的复制偏移量
* *replication backlog*：主机的复制积压缓存区 
* *run ID*：主机的运行 ID 

#### 复制偏移量

执行复制的双方都会分别维护一个 「复制偏移量」

* 主服务器每次向从服务器传播N个字节的数据时，就将自己的「复制偏移量」的值加上N
* 从服务器每次收到主服务器传播来的N个字节的数据时，就将自己的「复制偏移量」的值加上N

示例图如下：

![image-20240916230453157](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162304188.png)

![image-20240916230903948](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162309988.png)

通过对比主从服务器的复制偏移量，程序可以很容易地知道主从服务器是否处于一致状态：

* 如果主从服务器处于一致状态，那么主从服务器两者的偏移量总是相同的
* 如果主从服务器两者的偏移量并不相同，那么说明主从服务器并未处于一致状态

#### 复制积压缓冲区

「复制积压缓冲区」是由主服务器维护的一个固定长度的先进先出队列，默认大小为 1MB

当主机进行命令传播的时候，他不仅会将写命令发送给所有从服务器，还会将写命令入队到复制积压缓冲区里面

![image-20240916231101419](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162311457.png)

因此，主服务器的「复制积压缓冲区」里面会保存着一部分最近传播的写命令，并且「复制积压缓冲区」会为队列中的每个字节记录相应的复制偏移量

![image-20240916231138657](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162311697.png)

当从服务器重新连上主服务器时，从服务器会通过 *PSYNC* 命令将自己的复制偏移量 offset 发送给主服务器，主服务器会根据这个复制偏移量来决定对从服务器执行何种同步操作

* 如果 offset 偏移量之后的数据(也即是偏移量 offset+1 开始的数据)仍然存在于「复制积压缓冲区」里面，那么主服务器将对从服务器执行部分重同步操作
* 相反，如果 offset 偏移量之后的数据已经不存在于「复制积压缓冲区」，那么主服务器将对从服务器执行完整重同步操作。

回到之前我们展示的断线重连的例子：

1. 当从服务器 A 断线之后，它立即重新连接主服务器，并向主服务器发送 *PSYNC* 命令，报告自己的复制偏移量为10086

2. 主服务器收到从服务器发来的 *PSYNC* 命令以及偏移量 10086 之后，主服务器将检查偏移量 10086 之后的数据是否存在于「复制积压缓冲区」里面，结果发现这些数据仍然存在，于是主服务器向从服务器发送 *+CONTINUE* 回复，表示数据同步将以部分重同步模式来进行
3. 接着主服务器会将「复制积压缓冲区」 10086 偏移量之后的所有数据(偏移量为10087至10119)都发送给从服务器
4. 从服务器只要接收这33字节的缺失数据，就可以回到与主服务器一致的状态

![image-20240916231429983](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162314022.png)

#### 服务器运行 ID

除了复制偏移量和复制积压缓冲区之外，实现部分重同步还需要用到「服务器运行 ID」

* 每个 Redis 服务器，不论主机还是从机，都会有自己的运行 ID。
* 运行ID在服务器启动时自动生成，由40个随机的十六进制字符组成，例如53b9b28df8042fdc9ab5e3fcbbbabff1d5dce2b3

「服务器运行 ID」的使用流程是：

1. 当从服务器对主服务器进行初次复制时，主服务器会将自己的运行 ID 传送给从服务器而从服务器则会将这个运行 ID 保存起来。

2. 当从服务器断线并重新连上一个主服务器时，从服务器将向当前连接的主服务器发送之前保存的运行 ID:

   * 如果从服务器保存的运行ID和当前连接的主服务器的运行ID相同，那么说明从服务器断线之前复制的就是当前连接的这个主服务器，主服务器可以继续尝试执行部分重同步操作

   * 相反地，如果从服务器保存的运行ID和当前连接的主服务器的运行ID并不相同，那么说明从服务器断线之前复制的主服务器并不是当前连接的这个主服务器，主服务器将对从服务器执行完整重同步操作


### 深入 PSYNC 命令

我们已经学习了 *replication offset*、*replication backlog*、*run ID*

接下来我们来学习 *PSYNC* 的完整细节

*PSYNC* 命令的调用方法有两种

* 「从服务器的初次复制」：如果从服务器以前没有复制过任何主服务器，或者之前执行过`SLAVEOF no one`命令，那么从服务器在开始一次新的复制时将向主服务器发送 `PSYNC ? -1` 命令主动请求主服务器进行完整重同步（因为这时不可能执行部分重同步）
* 「从服务器的再次复制」：相反地，如果从服务器已经复制过某个主服务器，那么从服务器在开始一次新的复制时将向主服务器发送 `PSYNC <runid> <offset>` 命令：其中runid是上一次复制的主服务器的运行ID，而offset则是从服务器当前的复制偏移量，接收到这个命令的主服务器会通过这两个参数来判断应该对从服务器执行哪种同步操作

根据情况，接收到 *PSYNC* 命令的主服务器会向从服务器返回以下三种回复的其中一种：

* 如果主服务器返回`+FULLRESYNC <runid> <offset>`回复，那么表示主服务器将与从服务器执行完整重同步操作：其中runid是这个主服务器的运行ID，从服务器会将这个ID保存起来，在下一次发送PSYNC命令时使用;而offset则是主服务器当前的复制偏移量，从服务器会将这个值作为自己的初始化偏移量
* 如果主服务器返回`+CONTINUE`回复，那么表示主服务器将与从服务器执行部分重同步操作，从服务器只要等着主服务器将自己缺少的那部分数据发送过来就可以了
* 如果主服务器返回`-ERR`回复，那么表示主服务器的版本低于Redis 2.8，它识别不了PSYNC命令，从服务器将向主服务器发送SYNC命令，并与主服务器执行完整同步操作

![image-20240916232103714](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162321766.png)

## 复制流程串联

之前我们讲述了新旧版本的复制细节，现在我们将整个复制流程串联到 Redis 主线之中

#### 步骤 1：设置主服务器的地址和端口

当客户端向从机发送 `SLAVEOF 127.0.0.16379` 命令的时候：

```c
struct redisServer{
    ...
    
    //主服务器的地址
    char *masterhost;
    //主服务器的端口
    int masterport;
    
    ...
};
```

从机在 redisServer 结构体 中设置主服务器的地址和端口

::: warning

SLAVEOF命令是一个异步命令，在完成masterhost属性和masterport属性的设置工作之后，从服务器将向发送SLAVEOF命令的客户端返回OK，表示复制指令已经被接收，而实际的复制工作将在 OK返回之后才真正开始执行。

:::

#### 步骤 2：建立套接字连接

在SLAVEOF命令执行之后，从服务器将根据命令所设置的IP地址和端口，创建连向主服务器的套接字连接

![image-20240916232654277](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162326318.png)

如果从服务器创建的套接字能成功连接(connect)到主服务器，那么从服务器将为这个套接字关联一个专门用于处理复制工作的文件事件处理器，这个处理器将负责执行后续的复制工作，比如接收RDB文件，以及接收主服务器传播来的写命令，诸如此类

而主服务器在接受(accept)从服务器的套接字连接之后，将为该套接字创建相应的客户端状态，并将从服务器**看作是一个连接到主服务器的客户端来对待**，这时从服务器将同时具有服务器(server)和客户端(client)两个身份:从服务器可以向主服务器发送命令请求，而主服务器则会向从服务器返回命令回复，

#### 步骤 3：发送 PING 命令

**一图以蔽之**

![image-20240916232918955](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162329994.png)

#### 步骤 4：身份验证

从服务器在收到主服务器返回的"PONG"回复之后，下一步要做的就是决定是否进行身份验证:

* 如果从服务器设置了masterauth选项，那么进行身份验证
* 如果从服务器没有设置masterauth选项，那么不进行身份验证

在需要进行身份验证的情况下，从服务器**主动**将向主服务器发送一条AUTH命令，命令的参数为从服务器masterauth选项的值

![image-20240916233047333](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162330372.png)

整个流程如下所示



![image-20240916233107656](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162331709.png)

#### 步骤 5：发送端口信息

在身份验证步骤之后，从服务器将执行命令`REPLCONF listening-port <port-number>`，向主服务器**发送从服务器的监听端口号**
![image-20240916233230639](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162332673.png)

主服务器在接收到这个命令之后，会将端口号记录在从服务器所对应的客户端状态的slave listening port属性中:

```c
typedef struct redisClient
    ...
    //从服务器的监听端口号
    int slave listening port;
    ...
}redisClient;
```

> slave_listening_port 属性目前唯一的作用就是在主服务器执行INFO replication 命令时打印出从服务器的端口号

#### 步骤 6：同步

在这一步，从服务器将向主服务器发送PSYNC命令，执行同步操作，并将自己的数据库更新至主服务器数据库当前所处的状态。
值得一提的是，在同步操作执行之前，只有从服务器是主服务器的客户端，但是在执行同步操作之后，主服务器也会成为从服务器的客户端

* 如果PSYNC命令执行的是完整重同步操作，那么主服务器需要成为从服务器的客户端，才能将保存在缓冲区里面的写命令发送给从服务器执行。
* 如果PSYNC命令执行的是部分重同步操作，那么主服务器需要成为从服务器的客户端，才能向从服务器发送保存在复制积压缓冲区里面的写命令。

因此，在同步操作执行之后，**主从服务器双方都是对方的客户端**，它们可以互相向对方发送命令请求，或者互相向对方返回命令回复

**正因为主服务器成为了从服务器的客户端**，所以主服务器才可以通过发送写命令来改变从服务器的数据库状态，不仅同步操作需要用到这一点，这也是主服务器对从服务器执行命令传播的基础操作

![image-20240916233549490](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162335542.png)

#### 步骤 7：命令传播

当完成了同步之后，主从服务器就会进入命令传播阶段，这时主服务器只要一直将自己执行的写命令发送给从服务器，而从服务器只要一直接收并执行主服务器发来的写命令，就可以保证主从服务器一直保持一致了

## 心跳检测

在命令传播阶段，从服务器默认会以每秒一次的频率，向主服务器发送命令`REPLCONF ACK <replication offset>`

其中replication offset是从服务器当前的复制偏移量。

发送REPLCONFACK命令对于主从服务器有三个作用

* 检测主从服务器的网络连接状态
* 辅助实现 min-slaves 选项
* 检测命令丢失

#### 检测主从服务器的网络连接状态

主从服务器可以通过发送和接收REPLCONFACK命令来检查两者之间的网络连接是否正常:如果主服务器超过一秒钟没有收到从服务器发来的REPLCONFACK命令，那么主服务器就知道主从服务器之间的连接出现问题了

#### 辅助实现 min-slaves 配置选项

Redis 的 `min-slaves-to-write` 和 `min-slaves-max-lag` 两个选项可以防止主服务器在不安全的情况下执行写命令

举个例子，如果我们向主服务器提供以下设置

* min-slaves-to-write 3
* min-slaves-max-lag 10

那么在从服务器的数量少于3个，或者三个从服务器的延迟(lag)值都大于或等于10秒时，主服务器将拒绝执行写命令

#### 检测命令丢失

如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发送 REPLCONF ACK 命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量，然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器

**已经使用 TCP 了，为什么还要保证消息可靠传达?**

![有了TCP为什么还要保证可靠性传达](https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409170039124.png)



::: warning

- 在传输层，TCP的三次握手保证了双方通讯的可靠性，稳定性。简而言之，用户发送的消息， 在忽视应用层的情况下，无论如何都会从自身主机的 “发送缓冲区” 抵达对方主机的 “接收缓冲区”
- 在应用层，数据包有可能因为用户突然的切后台或者是弱网状态导致没法从操作系统内核抵达应用层，反之也是如此, 为此,我们需要在应用层做好可靠传输协议的保证，防止数据丢失的情况

:::

## 主从复制的触发时机

1. **从节点首次启动或重新连接时**：从节点连接到主节点后，触发全量或增量同步。
2. **主节点有数据更新时**：主节点每次执行写操作后，增量数据会实时同步给从节点。
3. **主节点的手动或自动备份操作**：执行 `BGSAVE`、`BGREWRITEAOF` 等命令时，可能触发主从数据同步。
4. **主从配置变更或故障转移时**：如通过 Sentinel 或集群模式进行故障转移，或者手动执行 `SLAVEOF` 命令时，从节点会重新与新的主节点同步。
5. **从节点主动请求同步**：从节点落后于主节点的数据或出现不一致时，会主动请求主节点重新同步。
6. **复制积压缓冲区溢出**：如果从节点长时间未同步，主节点的缓冲区溢出，触发全量同步。

## 总结

* Redis 2.8 以前的复制功能不能高效地处理断线后重复制情况，但Redis 2.8新添加的部分重同步功能可以解决这个问题。
* 部分重同步通过复制偏移量、复制积压缓冲区、服务器运行ID三个部分来实现
* 在复制操作刚开始的时候，从服务器会成为主服务器的客户端，并通过向主服务器发送命令请求来执行复制步骤，而在复制操作的后期，主从服务器会互相成为对方的客户端。
* 主服务器通过向从服务器传播命令来更新从服务器的状态，保持主从服务器一致而从服务器则通过向主服务器发送命令来进行心跳检测，以及命令丢失检测。

## 参考文献

[彻底搞懂Redis主从复制原理及实战 - cooffeeli - 博客园 (cnblogs.com)](https://www.cnblogs.com/cooffeeli/p/redis_master_slave.html)

[深入学习Redis（3）：主从复制 - 编程迷思 - 博客园 (cnblogs.com)](https://www.cnblogs.com/kismetv/p/9236731.html)
