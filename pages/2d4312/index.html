<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ZSet 设计与实现 | EchoDesign</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="系统设计之「讲解 + 面试指南」，水滴石穿，设计无银弹！">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.c76c3453.css" as="style"><link rel="preload" href="/assets/js/app.bd2af867.js" as="script"><link rel="preload" href="/assets/js/2.933750c6.js" as="script"><link rel="preload" href="/assets/js/64.f22c5bcd.js" as="script"><link rel="preload" href="/assets/js/7.7eb70372.js" as="script"><link rel="prefetch" href="/assets/js/10.2cc95be8.js"><link rel="prefetch" href="/assets/js/100.298ad15f.js"><link rel="prefetch" href="/assets/js/101.99b73fec.js"><link rel="prefetch" href="/assets/js/11.c7521a10.js"><link rel="prefetch" href="/assets/js/12.38d1989d.js"><link rel="prefetch" href="/assets/js/13.65d33f38.js"><link rel="prefetch" href="/assets/js/14.397b7600.js"><link rel="prefetch" href="/assets/js/15.b3c76984.js"><link rel="prefetch" href="/assets/js/16.60cde607.js"><link rel="prefetch" href="/assets/js/17.acb3bf3d.js"><link rel="prefetch" href="/assets/js/18.e491edb6.js"><link rel="prefetch" href="/assets/js/19.daf31819.js"><link rel="prefetch" href="/assets/js/20.cb4a5c13.js"><link rel="prefetch" href="/assets/js/21.049c5e3f.js"><link rel="prefetch" href="/assets/js/22.ff4c8ad5.js"><link rel="prefetch" href="/assets/js/23.4d814163.js"><link rel="prefetch" href="/assets/js/24.615412d4.js"><link rel="prefetch" href="/assets/js/25.1d172890.js"><link rel="prefetch" href="/assets/js/26.96f3c12e.js"><link rel="prefetch" href="/assets/js/27.90323e82.js"><link rel="prefetch" href="/assets/js/28.95a1fb6b.js"><link rel="prefetch" href="/assets/js/29.371a40e1.js"><link rel="prefetch" href="/assets/js/3.5c09ac9d.js"><link rel="prefetch" href="/assets/js/30.ac997df0.js"><link rel="prefetch" href="/assets/js/31.df4cc39d.js"><link rel="prefetch" href="/assets/js/32.13b70e91.js"><link rel="prefetch" href="/assets/js/33.06627774.js"><link rel="prefetch" href="/assets/js/34.6671ead6.js"><link rel="prefetch" href="/assets/js/35.37ae6824.js"><link rel="prefetch" href="/assets/js/36.4602e394.js"><link rel="prefetch" href="/assets/js/37.51145580.js"><link rel="prefetch" href="/assets/js/38.40fe2658.js"><link rel="prefetch" href="/assets/js/39.84b6e82e.js"><link rel="prefetch" href="/assets/js/4.73518a0f.js"><link rel="prefetch" href="/assets/js/40.591baf2a.js"><link rel="prefetch" href="/assets/js/41.f961e422.js"><link rel="prefetch" href="/assets/js/42.b34f1599.js"><link rel="prefetch" href="/assets/js/43.5a509601.js"><link rel="prefetch" href="/assets/js/44.64fd3383.js"><link rel="prefetch" href="/assets/js/45.844e1064.js"><link rel="prefetch" href="/assets/js/46.7c2fa3a4.js"><link rel="prefetch" href="/assets/js/47.9bed4c1b.js"><link rel="prefetch" href="/assets/js/48.16e1233b.js"><link rel="prefetch" href="/assets/js/49.eaa08b9e.js"><link rel="prefetch" href="/assets/js/5.94727770.js"><link rel="prefetch" href="/assets/js/50.4fb0caa1.js"><link rel="prefetch" href="/assets/js/51.ad7a3e32.js"><link rel="prefetch" href="/assets/js/52.18c75eba.js"><link rel="prefetch" href="/assets/js/53.f76e624c.js"><link rel="prefetch" href="/assets/js/54.3098ec9f.js"><link rel="prefetch" href="/assets/js/55.35c5cbfa.js"><link rel="prefetch" href="/assets/js/56.67ae905d.js"><link rel="prefetch" href="/assets/js/57.204f4e75.js"><link rel="prefetch" href="/assets/js/58.7144aef6.js"><link rel="prefetch" href="/assets/js/59.28ca51b4.js"><link rel="prefetch" href="/assets/js/6.0b558b79.js"><link rel="prefetch" href="/assets/js/60.66a7f41d.js"><link rel="prefetch" href="/assets/js/61.08b4acf0.js"><link rel="prefetch" href="/assets/js/62.5cc838f8.js"><link rel="prefetch" href="/assets/js/63.392eea42.js"><link rel="prefetch" href="/assets/js/65.0b2ab47d.js"><link rel="prefetch" href="/assets/js/66.2ae7a107.js"><link rel="prefetch" href="/assets/js/67.79dd6daf.js"><link rel="prefetch" href="/assets/js/68.1b76c178.js"><link rel="prefetch" href="/assets/js/69.7ac52a2f.js"><link rel="prefetch" href="/assets/js/70.7279b1df.js"><link rel="prefetch" href="/assets/js/71.f44644ed.js"><link rel="prefetch" href="/assets/js/72.c8cf2fab.js"><link rel="prefetch" href="/assets/js/73.526febf1.js"><link rel="prefetch" href="/assets/js/74.d9ad1a67.js"><link rel="prefetch" href="/assets/js/75.7c86d41a.js"><link rel="prefetch" href="/assets/js/76.757a0ce9.js"><link rel="prefetch" href="/assets/js/77.7b3f6980.js"><link rel="prefetch" href="/assets/js/78.31a353ef.js"><link rel="prefetch" href="/assets/js/79.173bbc8c.js"><link rel="prefetch" href="/assets/js/8.0ec7f6e8.js"><link rel="prefetch" href="/assets/js/80.d8713e74.js"><link rel="prefetch" href="/assets/js/81.d124398a.js"><link rel="prefetch" href="/assets/js/82.3b90a7cc.js"><link rel="prefetch" href="/assets/js/83.f3a9ee0c.js"><link rel="prefetch" href="/assets/js/84.eeb423e8.js"><link rel="prefetch" href="/assets/js/85.4cd3a775.js"><link rel="prefetch" href="/assets/js/86.931cbb70.js"><link rel="prefetch" href="/assets/js/87.526ca8f2.js"><link rel="prefetch" href="/assets/js/88.93192130.js"><link rel="prefetch" href="/assets/js/89.e6cb2516.js"><link rel="prefetch" href="/assets/js/9.6e274fca.js"><link rel="prefetch" href="/assets/js/90.e90dd5ad.js"><link rel="prefetch" href="/assets/js/91.4150a0c3.js"><link rel="prefetch" href="/assets/js/92.6b777d4b.js"><link rel="prefetch" href="/assets/js/93.f8975bc4.js"><link rel="prefetch" href="/assets/js/94.7dffa77f.js"><link rel="prefetch" href="/assets/js/95.16e48ffc.js"><link rel="prefetch" href="/assets/js/96.5ed2d348.js"><link rel="prefetch" href="/assets/js/97.4d4bfff5.js"><link rel="prefetch" href="/assets/js/98.10f4b27a.js"><link rel="prefetch" href="/assets/js/99.4a895015.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c76c3453.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="EchoDesign" class="logo"> <span class="site-name can-hide">EchoDesign</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 深度剖析</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 深度剖析</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>一、前言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>二、基础知识</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bdae41/" class="sidebar-link">String 设计与实现</a></li><li><a href="/pages/bd1e41/" class="sidebar-link">List 设计与实现</a></li><li><a href="/pages/2d4311/" class="sidebar-link">Hash 设计与实现</a></li><li><a href="/pages/2d4312/" aria-current="page" class="active sidebar-link">ZSet 设计与实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/2d4312/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/2d4312/#sorted-set-基本结构" class="sidebar-link">Sorted Set 基本结构</a></li><li class="sidebar-sub-header level2"><a href="/pages/2d4312/#跳表的设计与实现" class="sidebar-link">跳表的设计与实现</a></li><li class="sidebar-sub-header level2"><a href="/pages/2d4312/#哈希表和跳表的组合使用" class="sidebar-link">哈希表和跳表的组合使用</a></li><li class="sidebar-sub-header level2"><a href="/pages/2d4312/#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level2"><a href="/pages/2d4312/#参考资料" class="sidebar-link">参考资料</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>三、主线任务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>四、支线任务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>五、集群</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Redis 系统设计</span></li><li data-v-06225672><span data-v-06225672>二、基础知识</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-14</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">ZSet 设计与实现<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><div class="custom-block note"><p class="custom-block-title">提出问题是一切智慧的开端</p> <ol><li>Sorted Set 如何高效支持范围查询和单点查询？</li> <li>Redis 为什么使用跳表而非红黑树实现有序集合？</li> <li>跳表的多层链表如何优化查找性能？</li> <li>跳表中随机生成结点层数有什么优势？如何影响插入和查询效率？</li> <li>跳表和哈希表在 Sorted Set 中如何协同工作保持数据一致性？</li> <li>若哈希表和跳表数据不一致，Sorted Set 是否还能高效查询？</li> <li>跳表和哈希表组合的设计对其他数据结构和系统开发的启示？</li></ol></div> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>有序集合（Sorted Set）：它本身是集合类型，同时也可以支持集合中的元素带有权重，并按权重排序</p> <p>但是，为什么 Sorted Set 能同时提供以下两种操作接口，以及它们的复杂度分别是 <code>O(logN)+M</code> 和 <code>O(1)</code> 呢？</p> <ul><li>ZRANGEBYSCORE：按照元素权重返回一个范围内的元素</li> <li>ZSCORE：返回某个元素的权重值</li></ul> <p>实际上，这个问题背后的本质是：<strong>为什么 Sorted Set 既能支持高效的范围查询，同时还能以 O(1) 复杂度获取元素权重值？</strong></p> <p>这其实就和 Sorted Set 底层的设计实现有关了</p> <ul><li>Sorted Set 能支持范围查询，这是因为它的核心数据结构设计采用了跳表</li> <li>它又能以常数复杂度获取元素权重，这是因为它同时采用了哈希表进行索引</li></ul> <p>那么，你是不是很好奇，Sorted Set 是如何把这两种数据结构结合在一起的？它们又是如何进行协作的呢？</p> <p>让 echo 来给你介绍下 Sorted Set 采用的<strong>双索引</strong>的设计思想和实现。理解和掌握这种双索引的设计思想，对于我们实现数据库系统是具有非常重要的参考价值的。</p> <p>好，接下来，我们就先来看看 Sorted Set 的基本结构</p> <h2 id="sorted-set-基本结构"><a href="#sorted-set-基本结构" class="header-anchor">#</a> Sorted Set 基本结构</h2> <blockquote><p>Redis 源码中，Sorted Set 的代码文件和其他数据类型不太一样，它并不像哈希表的 dict.c/dict.h，或是压缩列表的 ziplist.c/ziplist.h，具有专门的数据结构实现和定义文件</p> <p>Sorted Set 的<strong>实现代码在 <strong><a href="https://github.com/redis/redis/blob/5.0/src/t_zset.c" target="_blank" rel="noopener noreferrer">t_zset.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <strong>文件中</strong>，包括 Sorted Set 的各种操作实现，同时 Sorted Set 相关的</strong>结构定义在</strong><a href="https://github.com/redis/redis/blob/5.0/src/server.h" target="_blank" rel="noopener noreferrer">server.h<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a><strong>文件中</strong>。如果你想要了解学习 Sorted Set 的模块和操作，注意要从 t_zset.c 和 server.h 这两个文件中查找</p></blockquote> <p>我们可以先来看下它的结构定义。Sorted Set 结构体的名称为 zset，其中包含了两个成员，分别是哈希表 dict 和跳表 zsl，如下所示。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zset</span> <span class="token punctuation">{</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zset<span class="token punctuation">;</span>
</code></pre></div><p>Sorted Set 这种同时采用跳表和哈希表两个索引结构的设计思想。这种设计思想充分融合了：</p> <ul><li>跳表高效支持范围查询（如 ZRANGEBYSCORE 操作）</li> <li>以及哈希表高效支持单点查询（如 ZSCORE 操作）的特征</li></ul> <p>这样一来，我们就可以在一个数据结构中，<strong>同时高效支持范围查询和单点查询</strong>，这是单一索引结构比较难达到的效果</p> <div class="custom-block tip"><p class="custom-block-title">提示</p> <p>感觉很多数据结构如果要支持 O(1)的查询复杂度的话，底层都得用 hash，比如常规 LRU 算法下的也有 hash 的影子 <a href="/pages/87589a">LRU 算法</a></p></div> <p>既然 Sorted Set 采用了跳表和哈希表两种索引结构来组织数据，我们在实现 Sorted Set 时就会面临以下两个问题：</p> <ul><li><strong>跳表或是哈希表中，各自保存了什么样的数据？</strong></li> <li><strong>跳表和哈希表保存的数据是如何保持一致的？</strong></li></ul> <p>因为我已经在 <a href="/pages/2d4311/">Hash</a> 中给你介绍了 Redis 中哈希表的实现思路，所以接下来，echo 给你介绍下跳表的设计和实现</p> <h2 id="跳表的设计与实现"><a href="#跳表的设计与实现" class="header-anchor">#</a> 跳表的设计与实现</h2> <p>首先，我们来了解下什么是跳表（skiplist）。</p> <p>「跳表」其实是一种<strong>多层的有序链表</strong></p> <blockquote><p>为了便于说明，我把跳表中的层次从低到高排个序，最底下一层称为 level0，依次往上是 level1、level2 等</p></blockquote> <p>下图展示的是一个 3 层的跳表。其中，头结点中包含了三个指针，分别作为 leve0 到 level2 上的头指针。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162047280.png" alt="image-20240916204727231"></p> <p>可以看到，在 level 0 上一共有 7 个结点，分别是 3、11、23、33、42、51、62，这些结点会通过指针连接起来，同时头结点中的 level0 指针会指向结点 3。然后，在这 7 个结点中，结点 11、33 和 51 又都包含了一个指针，同样也依次连接起来，且头结点的 level 1 指针会指向结点 11。这样一来，这 3 个结点就组成了 level 1 上的所有结点。</p> <p>最后，结点 33 中还包含了一个指针，这个指针会指向尾结点，同时，头结点的 level 2 指针会指向结点 33，这就形成了 level 2，只不过 level 2 上只有 1 个结点 33。</p> <p>在对跳表有了直观印象后，我们再来看看跳表实现的具体数据结构</p> <h3 id="跳表数据结构"><a href="#跳表数据结构" class="header-anchor">#</a> 跳表数据结构</h3> <p>我们先来看下跳表结点的结构定义</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token punctuation">{</span>
    <span class="token comment">//Sorted Set中的元素</span>
    sds ele<span class="token punctuation">;</span>
    <span class="token comment">//元素权重值</span>
    <span class="token keyword">double</span> score<span class="token punctuation">;</span>
    <span class="token comment">//后向指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>backward<span class="token punctuation">;</span>
    <span class="token comment">//节点的level数组，保存每层上的前向指针和跨度</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistLevel</span> <span class="token punctuation">{</span>
        <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>forward<span class="token punctuation">;</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> span<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> level<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplistNode<span class="token punctuation">;</span>
</code></pre></div><ul><li><strong>因为 Sorted Set 中既要保存元素，也要保存元素的权重</strong>，所以对应到跳表结点的结构定义中，就对应了 sds 类型的变量 ele，以及 double 类型的变量 score。此外，为了便于从跳表的尾结点进行倒序查找，每个跳表结点中还保存了一个后向指针（*backward），指向该结点的前一个结点。</li> <li><strong>因为跳表是一个多层的有序链表，每一层也是由多个结点通过指针连接起来的</strong>。因此在跳表结点的结构定义中，还包含了一个 zskiplistLevel 结构体类型的 <strong>level 数组</strong>。</li></ul> <p>level 数组中的每一个元素对应了一个 zskiplistLevel 结构体，也对应了跳表的一层。而 zskiplistLevel 结构体定义了一个指向下一结点的前向指针（*forward），这就使得结点可以在某一层上和后续结点连接起来。同时，zskiplistLevel 结构体中还定义了，这是用来记录结点在某一层上的 <strong>跨度</strong> <code>*forward</code> 指针和该指针指向的结点之间，跨越了 level0 上的几个结点。</p> <p>我们来看下面这张图，其中就展示了 33 结点的 level 数组和跨度情况。可以看到，33 结点的 level 数组有三个元素，分别对应了三层 level 上的指针。此外，在 level 数组中，level 2、level1 和 level 0 的跨度 span 值依次是 3、2、1。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162050649.png" alt="image-20240916205021593"></p> <p>最后，因为跳表中的结点都是按序排列的，所以，对于跳表中的某个结点，我们可以把从头结点到该结点的查询路径上，各个结点在所查询层次上的<code>*forward</code> 指针跨度，做一个累加。这个累加值就可以用来计算该结点在整个跳表中的顺序，另外这个结构特点还可以用来实现 Sorted Set 的 rank 操作，比如 ZRANK、ZREVRANK 等。</p> <p>了解了跳表结点的定义后，我们可以来看看跳表的定义。在跳表的结构中，定义了跳表的头结点和尾结点、跳表的长度，以及跳表的最大层数</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zskiplist</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">zskiplistNode</span> <span class="token operator">*</span>header<span class="token punctuation">,</span> <span class="token operator">*</span>tail<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> length<span class="token punctuation">;</span>
    <span class="token keyword">int</span> level<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zskiplist<span class="token punctuation">;</span>
</code></pre></div><p>因为跳表的每个结点都是通过指针连接起来的，所以我们在使用跳表时，只需要从跳表结构体中获得头结点或尾结点，就可以通过结点指针访问到跳表中的各个结点</p> <p>那么，当我们在 Sorted Set 中查找元素时，就对应到了 Redis 在跳表中查找结点，而此时，查询代码是否需要像查询常规链表那样，逐一顺序查询比较链表中的每个结点呢？</p> <p>其实是不用的，因为这里的查询代码，可以<strong>使用跳表结点中的 level 数组来加速查询</strong></p> <h3 id="跳表结点查询"><a href="#跳表结点查询" class="header-anchor">#</a> 跳表结点查询</h3> <p>事实上，当查询一个结点时，跳表会先<strong>从头结点的最高层开始</strong>，查找下一个结点。而由于跳表结点同时保存了元素和权重，所以跳表在比较结点时，相应地有<strong>两个判断条件</strong>：</p> <ol><li>当查找到的结点保存的元素权重，比要查找的权重小时，跳表就会继续访问该层上的下一个结点。</li> <li>当查找到的结点保存的元素权重，等于要查找的权重时，跳表会再检查该结点保存的 SDS 类型数据，是否比要查找的 SDS 数据小。如果结点数据小于要查找的数据时，跳表仍然会继续访问该层上的下一个结点。</li></ol> <p>但是，<strong>当上述两个条件都不满足时，跳表就会用到当前查找到的结点的 level 数组了</strong>。跳表会使用当前结点 level 数组里的下一层指针，然后沿着下一层指针继续查找，这就相当于跳到了下一层接着查找。</p> <p>这部分的代码逻辑如下所示，因为在跳表中进行查找、插入、更新或删除操作时，都需要用到查询的功能，你可以重点了解下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//获取跳表的表头</span>
x <span class="token operator">=</span> zsl<span class="token operator">-&gt;</span>header<span class="token punctuation">;</span>
<span class="token comment">//从最大层数开始逐一遍历</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> zsl<span class="token operator">-&gt;</span>level<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token keyword">while</span> <span class="token punctuation">(</span>x<span class="token operator">-&gt;</span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>x<span class="token operator">-&gt;</span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-&gt;</span>score <span class="token operator">&lt;</span> score <span class="token operator">||</span> <span class="token punctuation">(</span>x<span class="token operator">-&gt;</span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-&gt;</span>score <span class="token operator">==</span> score
    <span class="token operator">&amp;&amp;</span> <span class="token function">sdscmp</span><span class="token punctuation">(</span>x<span class="token operator">-&gt;</span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token operator">-&gt;</span>ele<span class="token punctuation">,</span>ele<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      x <span class="token operator">=</span> x<span class="token operator">-&gt;</span>level<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>forward<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="跳表结点层数设置"><a href="#跳表结点层数设置" class="header-anchor">#</a> 跳表结点层数设置</h3> <p>这样一来，有了 level 数组之后，一个跳表结点就可以在多层上被访问到了。而一个结点的 level 数组的层数也就决定了，该结点可以在几层上被访问到。</p> <p>所以，当我们要决定结点层数时，实际上是要决定 level 数组具体有几层。</p> <p>一种设计方法是，让每一层上的结点数约是下一层上结点数的一半，就像下面这张图展示的。第 0 层上的结点数是 7，第 1 层上的结点数是 3，约是第 0 层上结点数的一半。而第 2 层上的结点就 33 一个，约是第 1 层结点数的一半。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162052862.png" alt="image-20240916205229822"></p> <p>这种设计方法带来的好处是，当跳表从最高层开始进行查找时，由于每一层结点数都约是下一层结点数的一半，这种查找过程就类似于二分查找，<strong>查找复杂度可以降低到 O(logN)</strong>。</p> <p>但这种设计方法也会带来负面影响，那就是为了维持相邻两层上结点数的比例为 2:1，一旦有新的结点插入或是有结点被删除，那么插入或删除处的结点，及其后续结点的层数都需要进行调整，而这样就带来了额外的开销。</p> <p>我先来给你举个例子，看下不维持结点数比例的影响，这样虽然可以不调整层数，但是会增加查询复杂度。</p> <p>首先，假设当前跳表有 3 个结点，其数值分别是 3、11、23，如下图所示。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162052093.png" alt="image-20240916205252049"></p> <p>接着，假设现在要插入一个结点 15，如果我们不调整其他结点的层数，而是直接插入结点 15 的话，那么插入后，跳表 level 0 和 level 1 两层上的结点数比例就变成了为 4:1，如下图所示。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162053726.png" alt="image-20240916205300685"></p> <p>而假设我们持续插入多个结点，但是仍然不调整其他结点的层数，这样一来，level0 上的结点数就会越来越多，如下图所示。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162053326.png" alt="image-20240916205307275"></p> <p>相应的，如果我们要查找大于 11 的结点，就需要在 level 0 的结点中依次顺序查找，复杂度就是 O(N) 了。所以，为了降低查询复杂度，我们就需要维持相邻层结点数间的关系。</p> <p>好，接下来，我们再来看下维持相邻层结点数为 2:1 时的影响。</p> <p>比如，我们可以把结点 23 的 level 数组中增加一层指针，如下图所示。这样一来，level 0 和 level 1 上的结点数就维持在了 2:1。但相应的代价就是，我们也需要给 level 数组重新分配空间，以便增加一层指针。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162053297.png" alt="image-20240916205315261"></p> <p>类似的，如果我们要在有 7 个结点的跳表中删除结点 33，那么结点 33 后面的所有结点都要进行调整：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162053246.png" alt="image-20240916205328198"></p> <p>调整后的跳表如下图所示。你可以看到，结点 42 和 62 都要新增 level 数组空间，这样能分别保存 3 层的指针和 2 层的指针，而结点 51 的 level 数组则需要减少一层。也就是说，这样的调整会带来额外的操作开销。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162053484.png" alt="image-20240916205336438"></p> <p>因此，为了避免上述问题，跳表在创建结点时，采用的是另一种设计方法，即<strong>随机生成每个结点的层数</strong>。此时，相邻两层链表上的结点数并不需要维持在严格的 2:1 关系。这样一来，当新插入一个结点时，只需要修改前后结点的指针，而其他结点的层数就不需要随之改变了，这就降低了插入操作的复杂度。</p> <p>在 Redis 源码中，跳表结点层数是由 <strong>zslRandomLevel 函数</strong>决定。zslRandomLevel 函数会把层数初始化为 1，这也是结点的最小层数。然后，该函数会生成随机数，如果随机数的值小于 ZSKIPLIST_P（指跳表结点增加层数的概率，值为 0.25），那么层数就增加 1 层。因为随机数取值到[0,0.25) 范围内的概率不超过 25%，所以这也就表明了，每增加一层的概率不超过 25%。下面的代码展示了 zslRandomLevel 函数的执行逻辑，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ZSKIPLIST_MAXLEVEL</span> <span class="token expression"><span class="token number">64</span>  </span><span class="token comment">//最大层数为64</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ZSKIPLIST_P</span> <span class="token expression"><span class="token number">0.25</span>       </span><span class="token comment">//随机数的值为0.25</span></span>
<span class="token keyword">int</span> <span class="token function">zslRandomLevel</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//初始化层为1</span>
    <span class="token keyword">int</span> level <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token number">0xFFFF</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token punctuation">(</span>ZSKIPLIST_P <span class="token operator">*</span> <span class="token number">0xFFFF</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        level <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>level<span class="token operator">&lt;</span>ZSKIPLIST_MAXLEVEL<span class="token punctuation">)</span> <span class="token operator">?</span> level <span class="token operator">:</span> ZSKIPLIST_MAXLEVEL<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好，现在我们就了解了跳表的基本结构、查询方式和结点层数设置方法，那么下面我们接着来学习下，Sorted Set 中是如何将跳表和哈希表组合起来使用的，以及是如何保持这两个索引结构中的数据是一致的。</p> <h2 id="哈希表和跳表的组合使用"><a href="#哈希表和跳表的组合使用" class="header-anchor">#</a> 哈希表和跳表的组合使用</h2> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">zset</span> <span class="token punctuation">{</span>
    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>
    zskiplist <span class="token operator">*</span>zsl<span class="token punctuation">;</span>
<span class="token punctuation">}</span> zset<span class="token punctuation">;</span>
</code></pre></div><p>Sorted Set 中已经同时包含了 hash 和 skiplist，这就是组合使用两者的第一步。然后，我们还可以在 Sorted Set 的创建代码（<a href="https://github.com/redis/redis/blob/5.0/src/t_zset.c" target="_blank" rel="noopener noreferrer">t_zset.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文件）中，进一步看到跳表和哈希表被相继创建</p> <p>当创建一个 zset 时，代码中会相继调用 **dictCreate 函数 **创建 zset 中的哈希表，以及调用 **zslCreate 函数 **创建跳表，如下所示。</p> <div class="language-c extra-class"><pre class="language-c"><code> zs <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>zs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 zs<span class="token operator">-&gt;</span>dict <span class="token operator">=</span> <span class="token function">dictCreate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>zsetDictType<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 zs<span class="token operator">-&gt;</span>zsl <span class="token operator">=</span> <span class="token function">zslCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>我们要想组合使用它们，必须保持这两个索引结构中的数据一致</strong>。简单来说，这就需要我们在往跳表中插入数据时，同时也向哈希表中插入数据。</p> <p>而这种保持两个索引结构一致的做法其实也不难，当往 Sorted Set 中插入数据时，zsetAdd 函数就会被调用。所以，我们可以通过阅读 Sorted Set 的元素添加函数 zsetAdd 了解到。下面我们就来分析一下 zsetAdd 函数的执行过程。</p> <p><strong>首先，zsetAdd 函数会判定 Sorted Set 采用的是 ziplist 还是 skiplist 的编码方式</strong>。zsetAdd 函数会判定 Sorted Set 采用的是 ziplist 还是 skiplist 的编码方式。</p> <p>注意，在不同编码方式下，zsetAdd 函数的执行逻辑也有所区别。这一讲我们重点关注的是 skiplist 的编码方式，所以接下来，我们就主要来看看当采用 skiplist 编码方式时，zsetAdd 函数的逻辑是什么样的。</p> <p>zsetAdd 函数会先使用哈希表的 dictFind 函数，查找要插入的元素是否存在。如果不存在，就直接调用跳表元素插入函数 zslInsert 和哈希表元素插入函数 dictAdd，将新元素分别插入到跳表和哈希表中。</p> <p>这里你需要注意的是，Redis 并没有把哈希表的操作嵌入到跳表本身的操作函数中，而是在 zsetAdd 函数中依次执行以上两个函数。这样设计的好处是保持了跳表和哈希表两者操作的独立性。</p> <ul><li><strong>然后，如果 zsetAdd 函数通过 dictFind 函数发现要插入的元素已经存在，那么 zsetAdd 函数会判断是否要增加元素的权重值</strong></li></ul> <p>如果权重值发生了变化，zsetAdd 函数就会调用 zslUpdateScore 函数，更新跳表中的元素权重值。紧接着，zsetAdd 函数会把哈希表中该元素（对应哈希表中的 key）的 value 指向跳表结点中的权重值，这样一来，哈希表中元素的权重值就可以保持最新值了。</p> <p>下面的代码显示了 zsetAdd 函数的执行流程，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code> <span class="token comment">//如果采用ziplist编码方式时，zsetAdd函数的处理逻辑</span>
 <span class="token keyword">if</span> <span class="token punctuation">(</span>zobj<span class="token operator">-&gt;</span>encoding <span class="token operator">==</span> OBJ_ENCODING_ZIPLIST<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token comment">//如果采用skiplist编码方式时，zsetAdd函数的处理逻辑</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>zobj<span class="token operator">-&gt;</span>encoding <span class="token operator">==</span> OBJ_ENCODING_SKIPLIST<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        zset <span class="token operator">*</span>zs <span class="token operator">=</span> zobj<span class="token operator">-&gt;</span>ptr<span class="token punctuation">;</span>
        zskiplistNode <span class="token operator">*</span>znode<span class="token punctuation">;</span>
        dictEntry <span class="token operator">*</span>de<span class="token punctuation">;</span>
        <span class="token comment">//从哈希表中查询新增元素</span>
        de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>zs<span class="token operator">-&gt;</span>dict<span class="token punctuation">,</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//如果能查询到该元素</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>de <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">/* NX? Return, same element already exists. */</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>nx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token operator">*</span>flags <span class="token operator">|=</span> ZADD_NOP<span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token comment">//从哈希表中查询元素的权重</span>
            curscore <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>


            <span class="token comment">//如果要更新元素权重值</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>incr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//更新权重值</span>
               <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span>


            <span class="token comment">//如果权重发生变化了</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>score <span class="token operator">!=</span> curscore<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//更新跳表结点</span>
                znode <span class="token operator">=</span> <span class="token function">zslUpdateScore</span><span class="token punctuation">(</span>zs<span class="token operator">-&gt;</span>zsl<span class="token punctuation">,</span>curscore<span class="token punctuation">,</span>ele<span class="token punctuation">,</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token comment">//让哈希表元素的值指向跳表结点的权重</span>
                <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>znode<span class="token operator">-&gt;</span>score<span class="token punctuation">;</span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
       <span class="token comment">//如果新元素不存在</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>xx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            ele <span class="token operator">=</span> <span class="token function">sdsdup</span><span class="token punctuation">(</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//新插入跳表结点</span>
            znode <span class="token operator">=</span> <span class="token function">zslInsert</span><span class="token punctuation">(</span>zs<span class="token operator">-&gt;</span>zsl<span class="token punctuation">,</span>score<span class="token punctuation">,</span>ele<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//新插入哈希表元素</span>
            <span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token function">dictAdd</span><span class="token punctuation">(</span>zs<span class="token operator">-&gt;</span>dict<span class="token punctuation">,</span>ele<span class="token punctuation">,</span><span class="token operator">&amp;</span>znode<span class="token operator">-&gt;</span>score<span class="token punctuation">)</span> <span class="token operator">==</span> DICT_OK<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><p>总之，你可以记住的是，Sorted Set 先是通过在它的数据结构中同时定义了跳表和哈希表，来实现同时使用这两种索引结构。然后，Sorted Set 在执行数据插入或是数据更新的过程中，会依次在跳表和哈希表中插入或更新相应的数据，从而保证了跳表和哈希表中记录的信息一致。</p> <p>这样一来，Sorted Set 既可以使用跳表支持数据的范围查询，还能使用哈希表支持根据元素直接查询它的权重。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <ol><li><strong>Sorted Set 的设计目标</strong>
Redis 的 Sorted Set 数据类型需要同时支持两种查询需求：
<ul><li><strong>范围查询</strong>：根据元素的权重范围进行查询。</li> <li><strong>单点查询</strong>：快速查找特定元素及其权重。</li></ul></li> <li><strong>跳表的设计</strong> <ul><li><strong>跳表结构</strong>：跳表是一个多层的有序链表，顶层结点数最少，底层结点数最多。</li> <li><strong>查询过程</strong>：查询时，从顶层开始，通过高层节点大跨度跳跃查找，如果找到第一个大于待查元素的结点，就转向下一层继续查找，直到找到待查元素。</li> <li><strong>优化查询效率</strong>：这种从高层到低层的分层查找方式，极大地减少了查询的时间开销，相比普通链表的线性查找，跳表的查询效率更高。</li> <li><strong>随机层数</strong>：跳表采用随机算法确定每个结点的层数，避免新增结点时发生连锁更新，提高插入效率。</li></ul></li> <li><strong>哈希表的引入</strong> <ul><li><strong>哈希表作为索引</strong>：Sorted Set 还将每个元素保存在哈希表中，元素作为哈希表的 key，其权重作为 value。</li> <li><strong>单点查询效率提升</strong>：通过哈希表可以直接查找到特定元素及其权重，相较于跳表的范围查找，哈希表的查找效率更高，更适合针对单个元素的查询。</li></ul></li> <li><strong>组合索引设计</strong> <ul><li><strong>跳表 + 哈希表</strong>：Redis Sorted Set 通过组合使用跳表和哈希表两种数据结构，实现了既支持范围查询（跳表），又能快速进行单点查询（哈希表）的设计。</li> <li><strong>设计优势</strong>：这种组合设计使得 Redis Sorted Set 能在不同的查询场景下兼顾效率，既避免了跳表插入时的性能问题，又利用哈希表提升了单点查询速度。</li></ul></li> <li><strong>设计思路的应用</strong> <ul><li><strong>系统开发启示</strong>：在实际系统开发中，组合使用多种索引结构可以有效提升数据管理的效率。Redis Sorted Set 的设计思路是一个典型案例，值得在其他开发场景中借鉴。</li></ul></li></ol> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li><p><a href="https://time.geekbang.org/column/intro/100084301?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noopener noreferrer">极客时间：Redis源码剖析与实战<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener noreferrer">Redis设计与实现 <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://github.com/redis/redis/blob/5.0/src/ae.c" target="_blank" rel="noopener noreferrer">Github：redis 源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/Redis 系统设计/02.二、基础知识/10.ZSet 设计与实现.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新于:</span> <span class="time">2024/09/18, 11:29:27</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/2d4311/" class="prev">Hash 设计与实现</a></span> <span class="next"><a href="/pages/34fa27/">Linux 中的 IO 多路复用</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.bd2af867.js" defer></script><script src="/assets/js/2.933750c6.js" defer></script><script src="/assets/js/64.f22c5bcd.js" defer></script><script src="/assets/js/7.7eb70372.js" defer></script>
  </body>
</html>
