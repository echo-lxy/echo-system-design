<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis 中的延迟监控 | EchoDesign</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="系统设计之「讲解 + 面试指南」，水滴石穿，设计无银弹！">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.c76c3453.css" as="style"><link rel="preload" href="/assets/js/app.59640afe.js" as="script"><link rel="preload" href="/assets/js/2.933750c6.js" as="script"><link rel="preload" href="/assets/js/76.15d5bea9.js" as="script"><link rel="preload" href="/assets/js/7.7eb70372.js" as="script"><link rel="prefetch" href="/assets/js/10.2cc95be8.js"><link rel="prefetch" href="/assets/js/100.2b21dce5.js"><link rel="prefetch" href="/assets/js/101.96ca71f6.js"><link rel="prefetch" href="/assets/js/11.21625d3b.js"><link rel="prefetch" href="/assets/js/12.915fdd22.js"><link rel="prefetch" href="/assets/js/13.8ddd597e.js"><link rel="prefetch" href="/assets/js/14.1141ec27.js"><link rel="prefetch" href="/assets/js/15.d5a34c66.js"><link rel="prefetch" href="/assets/js/16.e52ba8b4.js"><link rel="prefetch" href="/assets/js/17.acb3bf3d.js"><link rel="prefetch" href="/assets/js/18.e491edb6.js"><link rel="prefetch" href="/assets/js/19.a22c1d8c.js"><link rel="prefetch" href="/assets/js/20.fe7d08c7.js"><link rel="prefetch" href="/assets/js/21.24c0f101.js"><link rel="prefetch" href="/assets/js/22.dd779f94.js"><link rel="prefetch" href="/assets/js/23.4d814163.js"><link rel="prefetch" href="/assets/js/24.891fe6fb.js"><link rel="prefetch" href="/assets/js/25.41dca26b.js"><link rel="prefetch" href="/assets/js/26.6337eac0.js"><link rel="prefetch" href="/assets/js/27.de80589e.js"><link rel="prefetch" href="/assets/js/28.6922a65b.js"><link rel="prefetch" href="/assets/js/29.7325b5ce.js"><link rel="prefetch" href="/assets/js/3.e62a71e4.js"><link rel="prefetch" href="/assets/js/30.e32f6b31.js"><link rel="prefetch" href="/assets/js/31.a532917f.js"><link rel="prefetch" href="/assets/js/32.13b70e91.js"><link rel="prefetch" href="/assets/js/33.d10d51bb.js"><link rel="prefetch" href="/assets/js/34.6671ead6.js"><link rel="prefetch" href="/assets/js/35.2760ed8d.js"><link rel="prefetch" href="/assets/js/36.5b9e5792.js"><link rel="prefetch" href="/assets/js/37.51145580.js"><link rel="prefetch" href="/assets/js/38.cddf1060.js"><link rel="prefetch" href="/assets/js/39.8a83e688.js"><link rel="prefetch" href="/assets/js/4.73518a0f.js"><link rel="prefetch" href="/assets/js/40.591baf2a.js"><link rel="prefetch" href="/assets/js/41.f961e422.js"><link rel="prefetch" href="/assets/js/42.b34f1599.js"><link rel="prefetch" href="/assets/js/43.5a509601.js"><link rel="prefetch" href="/assets/js/44.64fd3383.js"><link rel="prefetch" href="/assets/js/45.685623ac.js"><link rel="prefetch" href="/assets/js/46.7624d38c.js"><link rel="prefetch" href="/assets/js/47.5646b068.js"><link rel="prefetch" href="/assets/js/48.8de239a3.js"><link rel="prefetch" href="/assets/js/49.15d8e916.js"><link rel="prefetch" href="/assets/js/5.94727770.js"><link rel="prefetch" href="/assets/js/50.4fb0caa1.js"><link rel="prefetch" href="/assets/js/51.ef213b56.js"><link rel="prefetch" href="/assets/js/52.18c75eba.js"><link rel="prefetch" href="/assets/js/53.f76e624c.js"><link rel="prefetch" href="/assets/js/54.3098ec9f.js"><link rel="prefetch" href="/assets/js/55.0edcba5d.js"><link rel="prefetch" href="/assets/js/56.9df87e2e.js"><link rel="prefetch" href="/assets/js/57.be37bfce.js"><link rel="prefetch" href="/assets/js/58.ca1aa081.js"><link rel="prefetch" href="/assets/js/59.7b7e3faf.js"><link rel="prefetch" href="/assets/js/6.0b558b79.js"><link rel="prefetch" href="/assets/js/60.96815912.js"><link rel="prefetch" href="/assets/js/61.f48524d4.js"><link rel="prefetch" href="/assets/js/62.82fff0c9.js"><link rel="prefetch" href="/assets/js/63.41ff19e4.js"><link rel="prefetch" href="/assets/js/64.9b3def35.js"><link rel="prefetch" href="/assets/js/65.0b2ab47d.js"><link rel="prefetch" href="/assets/js/66.2ae7a107.js"><link rel="prefetch" href="/assets/js/67.196ec80b.js"><link rel="prefetch" href="/assets/js/68.cab1ea3b.js"><link rel="prefetch" href="/assets/js/69.5f61d937.js"><link rel="prefetch" href="/assets/js/70.7279b1df.js"><link rel="prefetch" href="/assets/js/71.4f744076.js"><link rel="prefetch" href="/assets/js/72.44c999da.js"><link rel="prefetch" href="/assets/js/73.526febf1.js"><link rel="prefetch" href="/assets/js/74.26f8d9a5.js"><link rel="prefetch" href="/assets/js/75.7c86d41a.js"><link rel="prefetch" href="/assets/js/77.7b3f6980.js"><link rel="prefetch" href="/assets/js/78.31a353ef.js"><link rel="prefetch" href="/assets/js/79.173bbc8c.js"><link rel="prefetch" href="/assets/js/8.7a3679f1.js"><link rel="prefetch" href="/assets/js/80.78a31e84.js"><link rel="prefetch" href="/assets/js/81.8d6c43d2.js"><link rel="prefetch" href="/assets/js/82.3b90a7cc.js"><link rel="prefetch" href="/assets/js/83.f3a9ee0c.js"><link rel="prefetch" href="/assets/js/84.eeb423e8.js"><link rel="prefetch" href="/assets/js/85.4cd3a775.js"><link rel="prefetch" href="/assets/js/86.931cbb70.js"><link rel="prefetch" href="/assets/js/87.47ba635a.js"><link rel="prefetch" href="/assets/js/88.93192130.js"><link rel="prefetch" href="/assets/js/89.b5690031.js"><link rel="prefetch" href="/assets/js/9.36f81190.js"><link rel="prefetch" href="/assets/js/90.cdc8eb8f.js"><link rel="prefetch" href="/assets/js/91.87a85466.js"><link rel="prefetch" href="/assets/js/92.6b777d4b.js"><link rel="prefetch" href="/assets/js/93.f8975bc4.js"><link rel="prefetch" href="/assets/js/94.1eade7f0.js"><link rel="prefetch" href="/assets/js/95.96f5db04.js"><link rel="prefetch" href="/assets/js/96.fc68b295.js"><link rel="prefetch" href="/assets/js/97.0a9a6187.js"><link rel="prefetch" href="/assets/js/98.10f4b27a.js"><link rel="prefetch" href="/assets/js/99.4a895015.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c76c3453.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="EchoDesign" class="logo"> <span class="site-name can-hide">EchoDesign</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>一、前言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二、基础知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>三、主线任务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>四、支线任务</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b43a19/" class="sidebar-link">LRU 策略</a></li><li><a href="/pages/b43a89/" class="sidebar-link">LFU 策略</a></li><li><a href="/pages/f44fbe/" class="sidebar-link">Redis 过期策略</a></li><li><a href="/pages/9b17a6/" class="sidebar-link">RDB 持久化</a></li><li><a href="/pages/9b17a7/" class="sidebar-link">AOF 持久化</a></li><li><a href="/pages/aa75e9/" aria-current="page" class="active sidebar-link">Redis 中的延迟监控</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/aa75e9/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/aa75e9/#延迟监控框架的实现" class="sidebar-link">延迟监控框架的实现</a></li><li class="sidebar-sub-header level2"><a href="/pages/aa75e9/#慢命令日志的实现" class="sidebar-link">慢命令日志的实现</a></li><li class="sidebar-sub-header level2"><a href="/pages/aa75e9/#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level2"><a href="/pages/aa75e9/#参考资料" class="sidebar-link">参考资料</a></li></ul></li><li><a href="/pages/61d908/" class="sidebar-link">发布与订阅</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>五、集群</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Redis 系统设计</span></li><li data-v-06225672><span data-v-06225672>四、支线任务</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-15</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">Redis 中的延迟监控<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><div class="custom-block note"><p class="custom-block-title">提出问题是一切智慧的开端</p> <ol><li>Redis 是以低延迟著称的数据库，那么当它的响应速度变慢时，如何快速诊断出问题所在？</li> <li>你知道 Redis 的哪些事件可能导致它运行缓慢吗？它们是如何被监控的？</li> <li>当 Redis 的某个命令执行变慢时，我们如何捕捉这些“慢命令”并进行详细分析？</li> <li>在 Redis 延迟监控中，如何通过采样机制高效记录每类事件的执行时长？</li> <li>为什么 Redis 需要为延迟事件和慢命令分别设计不同的监控和日志机制？这两者的核心区别是什么？</li> <li>Redis 如何通过“时间序列”的方式保存和分析多次延迟事件的数据，以便为后续问题排查提供更多线索？</li> <li>在延迟监控中，Redis 是如何通过统计延迟事件的最大值、最小值、均值等数据来帮助用户诊断问题的？</li> <li>Redis 的慢命令日志能提供哪些关键信息？如何通过这些信息定位到具体的慢命令和它的来源？</li></ol></div> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>Redis的一个显著特征就是<strong>能提供低延迟的数据访问</strong>。而如果Redis在运行过程中变慢了，我们就需要有方法能监控到哪些命令执行变慢了。更进一步的需求，就是我们需要有方法监控到，是Redis运行过程中的哪些事件导致Redis变慢了。这样一来，我们就既可以检查这些慢命令，分析它们的操作类型和访问的数据量，进而提出应对方法，也可以检查监控记录的事件，分析事件发生的原因并提出应对方法</p> <p>那么，为了满足这些需求，我们就需要有一套监控框架</p> <ul><li>一方面能监测导致Redis变慢的事件</li> <li>另一方面，能监控并记录变慢的命令。</li></ul> <p>其实，这也是我们在开发后端系统时，经常会面临的一个运维开发需求，也就是<strong>如何监控后端系统的运行状态</strong>。</p> <p>echo 来带你了解Redis的延迟监控框架和慢命令日志的设计与实现。</p> <h2 id="延迟监控框架的实现"><a href="#延迟监控框架的实现" class="header-anchor">#</a> 延迟监控框架的实现</h2> <p>实际上，Redis 在运行过程中，以下表格中给出的几类事件都会导致 Redis 变慢，我们通常也把这些事件称为<strong>延迟事件</strong>。你可以参考表格中的这些事件类型，以及它们在源码中对应的事件名称。</p> <table><thead><tr><th>事件类型</th> <th>源码中对应名称</th></tr></thead> <tbody><tr><td>命令事件</td> <td>command、fast-command</td></tr> <tr><td>AOF事件</td> <td>aof-write-pending-fsync, aof-write-active-child, aof-write-alone, aof-fstat, aof-rewrite-diff-write, aof-rename</td></tr> <tr><td>fork事件</td> <td>fork</td></tr> <tr><td>过期Key事件</td> <td>expire-cycie</td></tr> <tr><td>缓存替换事件</td> <td>eviction-del, eviction-cycie</td></tr></tbody></table> <p>那么针对这些事件，Redis实现了延迟监控框架，通过采样的方式来记录它们的执行情况。当需要排查问题时，延迟监控框架提供了<strong>latency history命令</strong>，以便运维人员检查这些事件。</p> <p>下面，我们就来看下记录事件执行情况的数据结构。因为延迟监控框架是在<a href="https://github.com/redis/redis/tree/5.0/src/latency.h" target="_blank" rel="noopener noreferrer">latency.h<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="https://github.com/redis/redis/tree/5.0/src/latency.c" target="_blank" rel="noopener noreferrer">latency.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文件中实现的，你也可以在这两个文件中找到相应的数据结构和函数。</p> <h3 id="记录事件执行情况的数据结构"><a href="#记录事件执行情况的数据结构" class="header-anchor">#</a> 记录事件执行情况的数据结构</h3> <p>首先，Redis是使用了<strong>latencySample结构体</strong>，来记录延迟事件的采样时间和事件的实际执行时长，这个结构体的代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">latencySample</span> <span class="token punctuation">{</span>
    <span class="token class-name">int32_t</span> time<span class="token punctuation">;</span>  <span class="token comment">//事件的采样时间</span>
    <span class="token class-name">uint32_t</span> latency<span class="token punctuation">;</span>  <span class="token comment">//事件的执行时长（以毫秒为单位）</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>而在latencySample这个结构体基础上，Redis又设计了<strong>latencyTimeSeries结构体</strong>，这个结构体使用了一个latencySample类型的数组，记录了针对某一类事件的一系列采样结果，这样就可以为分析Redis变慢提供更多的事件信息。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">latencyTimeSeries</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> idx<span class="token punctuation">;</span>  <span class="token comment">//采样事件数组的写入位置</span>
    <span class="token class-name">uint32_t</span> max<span class="token punctuation">;</span>  <span class="token comment">//当前事件的最大延迟</span>
    <span class="token keyword">struct</span> <span class="token class-name">latencySample</span> samples<span class="token punctuation">[</span>LATENCY_TS_LEN<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">//采样事件数组，记录LATENCY_TS_LEN个采样结果，LATENCY_TS_LEN默认为160</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>另外，也因为延迟监控框架要记录的延迟事件有很多种，所以 Redis 还进一步设计了一个<strong>哈希表latency_events</strong>，作为全局变量server的一个成员变量，用来记录不同事件的采样结果数组，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
   …
   dict <span class="token operator">*</span>latency_events<span class="token punctuation">;</span>
   …
<span class="token punctuation">}</span>
</code></pre></div><p>这个哈希表是在Redis server启动初始化的函数initServer中，通过调用latencyMonitorInit函数来完成创建的，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
    <span class="token function">latencyMonitorInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
 
<span class="token keyword">void</span> <span class="token function">latencyMonitorInit</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    server<span class="token punctuation">.</span>latency_events <span class="token operator">=</span> <span class="token function">dictCreate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>latencyTimeSeriesDictType<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好，了解了记录延迟事件的数据结构和初始化操作后，我们再来看下事件采样是如何实现的。</p> <h3 id="如何实现延迟事件的采样"><a href="#如何实现延迟事件的采样" class="header-anchor">#</a> 如何实现延迟事件的采样？</h3> <p>延迟事件的<strong>采样函数是latencyAddSample</strong>，它的函数原型如下所示。它的参数中包含了要记录的事件名称，这实际是对应了latency_events哈希表中的一个哈希项。此外，它的参数中还包括该事件的执行时长。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">latencyAddSample</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>event<span class="token punctuation">,</span> <span class="token class-name">mstime_t</span> latency<span class="token punctuation">)</span>
</code></pre></div><p>latencyAddSample函数的执行逻辑并不复杂，主要可以分成三步。</p> <p><strong>首先</strong>，它会根据传入的事件名称，在latency_events哈希表中查找该事件。如果该事件对应的哈希项还不存在，它就会在哈希表中加入该事件，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//查找事件对应的哈希项</span>
<span class="token keyword">struct</span> <span class="token class-name">latencyTimeSeries</span> <span class="token operator">*</span>ts <span class="token operator">=</span> <span class="token function">dictFetchValue</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>latency_events<span class="token punctuation">,</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>
…
<span class="token keyword">if</span> <span class="token punctuation">(</span>ts <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//如果哈希项为空，就新建哈希项</span>
    ts <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>ts<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ts<span class="token operator">-&gt;</span>idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    ts<span class="token operator">-&gt;</span>max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>ts<span class="token operator">-&gt;</span>samples<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>ts<span class="token operator">-&gt;</span>samples<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">dictAdd</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>latency_events<span class="token punctuation">,</span><span class="token function">zstrdup</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">,</span>ts<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//在哈希表中插入哈希项</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>然后</strong>，latencyAddSample函数会根据传入的事件执行时间，更新当前记录的该类事件的最大执行时间，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>latency <span class="token operator">&gt;</span> ts<span class="token operator">-&gt;</span>max<span class="token punctuation">)</span> ts<span class="token operator">-&gt;</span>max <span class="token operator">=</span> latency<span class="token punctuation">;</span>
</code></pre></div><p><strong>最后</strong>，latencyAddSample函数会实际记录当前的采样结果。</p> <p>不过在这一步，如果它发现当前的采样结果，和前一个采样结果是在同一秒中获得的，并且如果当前采样结果的事件执行时长，大于前一个采样结果的话，那么latencyAddSample函数就会直接更新前一个采样结果中记录的执行时长了，而不是新插入一个采样结果。</p> <p>否则的话，latencyAddSample函数才会新插入一个采样结果。这样设计的目的，也是为了避免在同一秒中记录过多的采样结果。</p> <p>下面的代码展示了latencyAddSample函数实际记录采样结果的逻辑，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//获得同类事件的前一个采样结果</span>
prev <span class="token operator">=</span> <span class="token punctuation">(</span>ts<span class="token operator">-&gt;</span>idx <span class="token operator">+</span> LATENCY_TS_LEN <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> LATENCY_TS_LEN<span class="token punctuation">;</span>
<span class="token comment">//如果当前和前一个采样结果在同一秒中</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>ts<span class="token operator">-&gt;</span>samples<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">.</span>time <span class="token operator">==</span> now<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
    <span class="token comment">//如果当前采用结果的执行时长大于前一个采样结果</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>latency <span class="token operator">&gt;</span> ts<span class="token operator">-&gt;</span>samples<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">.</span>latency<span class="token punctuation">)</span> 
        <span class="token comment">//直接更新前一个采样结果的执行时长</span>
        ts<span class="token operator">-&gt;</span>samples<span class="token punctuation">[</span>prev<span class="token punctuation">]</span><span class="token punctuation">.</span>latency <span class="token operator">=</span> latency<span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//否则，新插入当前的采样结果</span>
ts<span class="token operator">-&gt;</span>samples<span class="token punctuation">[</span>ts<span class="token operator">-&gt;</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>time <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ts<span class="token operator">-&gt;</span>samples<span class="token punctuation">[</span>ts<span class="token operator">-&gt;</span>idx<span class="token punctuation">]</span><span class="token punctuation">.</span>latency <span class="token operator">=</span> latency<span class="token punctuation">;</span>
</code></pre></div><p>而在这里，你也要注意一点，就是latencyAddSample函数在记录采样结果时，<strong>会重复使用采样结果数组latencyTimeSeries</strong>。所以，如果采样结果数量超过数组默认大小时，旧的采样结果是会被覆盖掉的。如果你要记录更多的采样结果，就需要扩大latencyTimeSeries数组的长度。</p> <p>那么，latencyAddSample函数是在什么时候调用进行采样的呢?</p> <p>其实，latencyAddSample函数是被封装在了<strong>latencyAddSampleIfNeeded函数</strong>中。在latencyAddSampleIfNeeded函数中，它只会在事件执行时长超过latency-monitor-threshold配置项的值时，才调用latencyAddSample函数记录采样结果。你可以看看下面给出的latencyAddSampleIfNeeded函数定义。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span>var<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>latency_monitor_threshold <span class="token operator">&amp;&amp;</span>  <span class="token punctuation">(</span>var<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> server<span class="token punctuation">.</span>latency_monitor_threshold<span class="token punctuation">)</span>
          <span class="token function">latencyAddSample</span><span class="token punctuation">(</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span>var<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
    
</code></pre></div><p>而latencyAddSampleIfNeeded函数，实际上会在刚才介绍的延迟事件发生时被调用。这里我来给你举两个例子。</p> <p>比如，当Redis命令通过call函数（在server.c文件中）执行时，call函数就会调用latencyAddSampleIfNeeded函数进行采样，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> CMD_CALL_SLOWLOG <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">!=</span> execCommand<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//根据命令数据结构中flags的CMD_FAST标记，决定当前是fast-command事件还是command事件</span>
    <span class="token keyword">char</span> <span class="token operator">*</span>latency_event <span class="token operator">=</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CMD_FAST<span class="token punctuation">)</span> <span class="token operator">?</span>
        <span class="token string">&quot;fast-command&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;command&quot;</span><span class="token punctuation">;</span>
    <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span>latency_event<span class="token punctuation">,</span>duration<span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    …
<span class="token punctuation">}</span>
</code></pre></div><p>再比如，当Redis调用flushAppendOnlyFile函数写AOF文件时，如果AOF文件刷盘的配置项是AOF_FSYNC_ALWAYS，那么flushAppendOnlyFile函数就会调用latencyAddSampleIfNeeded函数，记录aof-fsync-always延迟事件的采样结果，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">flushAppendOnlyFile</span><span class="token punctuation">(</span><span class="token keyword">int</span> force<span class="token punctuation">)</span> <span class="token punctuation">{</span>
…
<span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fsync <span class="token operator">==</span> AOF_FSYNC_ALWAYS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token function">latencyStartMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用latencyStartMonitor函数开始计时</span>
<span class="token function">redis_fsync</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_fd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//实际将数据写入磁盘</span>
        <span class="token function">latencyEndMonitor</span><span class="token punctuation">(</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用latencyEndMonitor结束计时，并计算时长</span>
        <span class="token function">latencyAddSampleIfNeeded</span><span class="token punctuation">(</span><span class="token string">&quot;aof-fsync-always&quot;</span><span class="token punctuation">,</span>latency<span class="token punctuation">)</span><span class="token punctuation">;</span>
…<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么在这里，你需要注意的是，Redis源码在调用latencyAddSampleIfNeeded函数记录采样结果时，经常会在延迟事件执行前，调用<strong>latencyStartMonitor函数</strong>开始计时，并在事件执行结束后，调用<strong>latencyEndMonitor函数</strong>结束计时和计算事件执行时长。</p> <p>此外，你也可以在阅读Redis源码的工具中，比如sublime、sourceinsight等，通过查找函数关系调用，找到latencyAddSampleIfNeeded函数被调用的其他地方。</p> <p>好了，到这里，Redis延迟监控框架就能通过latencyAddSampleIfNeeded函数，来记录延迟事件的采样结果了。而实际上，Redis延迟监控框架还实现了延迟分析，并能提供应对延迟变慢的建议，我们再来看下。</p> <h3 id="延迟分析和提供应对措施建议"><a href="#延迟分析和提供应对措施建议" class="header-anchor">#</a> 延迟分析和提供应对措施建议</h3> <p>首先，Redis是提供了latency doctor命令，来给出延迟分析结果和应对方法建议的。当我们执行这条命令的时候，Redis就会使用latencyCommand函数来处理。而在处理这个命令时，latencyCommand函数会调用<strong>createLatencyReport函数</strong>，来生成延迟分析报告和应对方法建议。</p> <p>具体来说，createLatencyReport函数会针对latency_events哈希表中记录的每一类事件，先调用analyzeLatencyForEvent函数，计算获得采样的延迟事件执行时长的均值、最大/最小值等统计结果。具体的统计计算过程，你可以仔细阅读下analyzeLatencyForEvent函数的源码。</p> <p>然后，createLatencyReport函数会针对这类事件，结合Redis配置项等信息给出应对措施。</p> <p>其实，在createLatencyReport函数中，<strong>它定义了多个int变量，当这些变量的值为1时，就表示建议Redis使用者采用一种应对高延迟的措施</strong>。我在下面的代码中展示了部分应对措施对应的变量，你可以看下。另外你也可以阅读createLatencyReport函数源码，去了解所有的措施。</p> <div class="language-c extra-class"><pre class="language-c"><code>sds <span class="token function">createLatencyReport</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
    <span class="token keyword">int</span> advise_slowlog_enabled <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>  <span class="token comment">//建议启用slowlog</span>
    <span class="token keyword">int</span> advise_slowlog_tuning <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//建议重新配置slowlog阈值</span>
    <span class="token keyword">int</span> advise_slowlog_inspect <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//建议检查slowlog结果</span>
    <span class="token keyword">int</span> advise_disk_contention <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   <span class="token comment">//建议减少磁盘竞争</span>
    …
<span class="token punctuation">}</span>
</code></pre></div><p>我们也来简单举个例子。比如说，针对command事件，createLatencyReport函数就会根据slowlog的设置情况，给出启用slowlog、调整slowlog阈值、检查slowlog日志结果和避免使用bigkey的应对建议。这部分代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">strcasecmp</span><span class="token punctuation">(</span>event<span class="token punctuation">,</span><span class="token string">&quot;command&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
   <span class="token comment">//如果没有启用slowlog，则建议启用slowlog</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>slowlog_log_slower_than <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       advise_slowlog_enabled <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
       advices<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>  
    <span class="token comment">//如果slowlog使用的命令时长阈值太大，建议调整slowlog阈值</span>
	<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>slowlog_log_slower_than<span class="token operator">/</span><span class="token number">1000</span> <span class="token operator">&gt;</span>server<span class="token punctuation">.</span>latency_monitor_threshold<span class="token punctuation">)</span><span class="token punctuation">{</span>
        advise_slowlog_tuning <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        advices<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//建议检查slowlog结果</span>
    advise_slowlog_inspect <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
    <span class="token comment">//建议避免使用bigkey</span>
    advise_large_objects <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 
    advices <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以，像createLatencyReport函数这样在计算延迟统计结果的同时，也给出应对措施的设计就很不错，这也是从Redis开发者的角度给出的建议，它更具有针对性。</p> <p>好了，到这里，我们就了解了延迟监控框架的实现。接下来，我们再来学习下Redis中慢命令日志的实现。</p> <h2 id="慢命令日志的实现"><a href="#慢命令日志的实现" class="header-anchor">#</a> 慢命令日志的实现</h2> <p>Redis是使用了一个较为简单的方法来记录慢命令日志，也就是用一个列表，把执行时间超出慢命令日志执行时间阈值的命令记录下来。</p> <p>在Redis全局变量server对应的数据结构redisServer中，有一个list类型的成员变量<strong>slowlog</strong>，它就是用来记录慢命令日志的列表的，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
    …
    list <span class="token operator">*</span>slowlog<span class="token punctuation">;</span>
    …
<span class="token punctuation">}</span>
</code></pre></div><p>而实现慢命令日志记录功能的代码是在<a href="https://github.com/redis/redis/tree/5.0/src/slowlog.c" target="_blank" rel="noopener noreferrer">slowlog.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文件中。这里的主要函数是<strong>slowlogPushEntryIfNeeded</strong>，它的原型如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">slowlogPushEntryIfNeeded</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> duration<span class="token punctuation">)</span>
</code></pre></div><p>从代码中你可以看到，这个函数的参数包含了当前执行命令及其参数argv，以及当前命令的执行时长duration。</p> <p>这个函数的逻辑也不复杂，它会判断当前命令的执行时长duration，是否大于 redis.conf 配置文件中的慢命令日志阈值 slowlog-log-slower-than。如果大于的话，它就会调用slowlogCreateEntry函数，为这条命令创建一条慢命令日志项，并调用listAddNodeHeader函数，把这条日志项加入到日志列表头，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//当前命令的执行时长是否大于配置项</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>duration <span class="token operator">&gt;=</span> server<span class="token punctuation">.</span>slowlog_log_slower_than<span class="token punctuation">)</span>
   <span class="token function">listAddNodeHead</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slowlog<span class="token punctuation">,</span> <span class="token function">slowlogCreateEntry</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>argv<span class="token punctuation">,</span>argc<span class="token punctuation">,</span>duration<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>当然，如果日志列表中记录了太多日志项，它消耗的内存资源也会增加。所以slowlogPushEntryIfNeeded函数在添加日志项时，会判断整个日志列表的长度是否超过配置项slowlog-max-len。一旦超过了，它就会把列表末尾的日志项删除，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//如果日志列表超过阈值长度，就删除列表末尾的日志项</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slowlog<span class="token punctuation">)</span> <span class="token operator">&gt;</span> server<span class="token punctuation">.</span>slowlog_max_len<span class="token punctuation">)</span>
        <span class="token function">listDelNode</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slowlog<span class="token punctuation">,</span><span class="token function">listLast</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>slowlog<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>现在，我们也就了解了记录慢命令日志项的主要函数，slowlogPushEntryIfNeeded的基本逻辑了。然后我们再来看下，它在记录日志项时调用的<strong>slowlogCreateEntry函数</strong>。</p> <p>这个函数是用来创建一个慢命令日志项。慢命令日志项的数据结构是slowlogEntry，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">slowlogEntry</span> <span class="token punctuation">{</span>
    <span class="token comment">//日志项对应的命令及参数</span>
    robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">;</span>     
    <span class="token comment">//日志项对应的命令及参数个数</span>
    <span class="token keyword">int</span> argc<span class="token punctuation">;</span>        
    <span class="token comment">//日志项的唯一ID</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span> 
    <span class="token comment">//日志项对应命令的执行时长（以微秒为单位）</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> duration<span class="token punctuation">;</span>  
    <span class="token comment">//日志项对应命令的执行时间戳</span>
    <span class="token class-name">time_t</span> time<span class="token punctuation">;</span>        
    <span class="token comment">//日志项对应命令的发送客户端名称</span>
    sds cname<span class="token punctuation">;</span>      
    <span class="token comment">//日志项对应命令的发送客户端网络地址</span>
    sds peerid<span class="token punctuation">;</span>         
<span class="token punctuation">}</span> slowlogEntry<span class="token punctuation">;</span>
</code></pre></div><p>从slowLogEntry的定义中，你可以看到，它会把慢命令及其参数，以及发送命令的客户端网络地址记录下来。<strong>这样设计的好处是</strong>，当我们分析慢命令日志时，就可以直接看到慢命令本身及其参数了，而且可以知道发送命令的客户端信息。而这些信息，就有利于我们排查慢命令的起因和来源。</p> <p>比如说，如果我们发现日志中记录的命令参数非常多，那么它就可能是一条操作bigkey的命令。</p> <p>当然，考虑到内存资源有限，slowlogCreateEntry函数在创建慢命令日志项时，也会判断命令参数个数。如果命令参数个数，超出了阈值SLOWLOG_ENTRY_MAX_ARGC这个宏定义的大小（默认32）时，它就不会记录超出阈值的参数了，而是记录下剩余的参数个数。这样一来，慢命令日志项中就既记录了部分命令参数，有助于排查问题，也避免了记录过多参数，占用过多内存。</p> <p>下面的代码展示了slowlogCreateEntry的基本执行逻辑，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code>slowlogEntry <span class="token operator">*</span><span class="token function">slowlogCreateEntry</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> robj <span class="token operator">*</span><span class="token operator">*</span>argv<span class="token punctuation">,</span> <span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> duration<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//分配日志项空间</span>
    slowlogEntry <span class="token operator">*</span>se <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>se<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token comment">//待记录的参数个数，默认为当前命令的参数个数</span>
    <span class="token keyword">int</span> j<span class="token punctuation">,</span> slargc <span class="token operator">=</span> argc<span class="token punctuation">;</span>  

    <span class="token comment">//如果当前命令参数个数超出阈值，则只记录阈值个数的参数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>slargc <span class="token operator">&gt;</span> SLOWLOG_ENTRY_MAX_ARGC<span class="token punctuation">)</span> slargc <span class="token operator">=</span> SLOWLOG_ENTRY_MAX_ARGC<span class="token punctuation">;</span>
    se<span class="token operator">-&gt;</span>argc <span class="token operator">=</span> slargc<span class="token punctuation">;</span>
    …
    <span class="token comment">//逐一记录命令及参数</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> slargc<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//如果命令参数个数超出阈值，使用最后一个参数记录当前命令实际剩余的参数个数</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>slargc <span class="token operator">!=</span> argc <span class="token operator">&amp;&amp;</span> j <span class="token operator">==</span> slargc<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  
          se<span class="token operator">-&gt;</span>argv<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>OBJ_STRING<span class="token punctuation">,</span>
                    <span class="token function">sdscatprintf</span><span class="token punctuation">(</span><span class="token function">sdsempty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">&quot;... (%d more arguments)&quot;</span><span class="token punctuation">,</span>
                    argc<span class="token operator">-</span>slargc<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            …  <span class="token comment">//将命令参数填充到日志项中</span>
            <span class="token punctuation">}</span><span class="token punctuation">}</span>
    … <span class="token comment">//将命令执行时长、客户端地址等信息填充到日志项中</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好了，到这里，你就了解了慢命令日志的实现。最后，你也要注意，<strong>慢命令日志只会记录超出执行时长阈值的命令信息</strong>，而不会像延迟监控框架那样记录多种事件。所以，记录日志的函数slowlogPushEntryIfNeeded，只会在命令执行函数call（在server.c文件中）中被调用，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">call</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
   	<span class="token comment">//命令执行前计时</span>
    start <span class="token operator">=</span> server<span class="token punctuation">.</span>ustime<span class="token punctuation">;</span> 
    <span class="token comment">//命令实际执行</span>
    c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span><span class="token function">proc</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token comment">//命令执行完成计算耗时</span>
    duration <span class="token operator">=</span> <span class="token function">ustime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>start<span class="token punctuation">;</span> 
    …
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> CMD_CALL_SLOWLOG <span class="token operator">&amp;&amp;</span> c<span class="token operator">-&gt;</span>cmd<span class="token operator">-&gt;</span>proc <span class="token operator">!=</span> execCommand<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        …
        <span class="token comment">//调用 slowlogPushEntryIfNeeded 函数记录慢命令</span>
        <span class="token function">slowlogPushEntryIfNeeded</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>argv<span class="token punctuation">,</span>c<span class="token operator">-&gt;</span>argc<span class="token punctuation">,</span>duration<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    …
<span class="token punctuation">}</span>
</code></pre></div><h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>Redis实现的延迟监控框架和慢命令日志。</p> <p>你要知道，Redis源码会针对可能导致Redis运行变慢的五类事件，在它们执行时进行<strong>采样</strong>。而一旦这些事件的执行时长超过阈值时，监控框架就会将采样结果记录下来，以便后续分析使用。这种针对延迟事件进行采样记录的监控方法，其实是很值得我们学习的。</p> <p>而慢命令日志的实现则较为简单，就是针对运行时长超出阈值的命令，使用一个<strong>列表</strong>把它们记录下来，这里面包括了命令及参数，以及发送命令的客户端信息，这样可以方便运维人员查看分析。</p> <p>当然，Redis源码中实现的延迟监控框架主要是关注导致延迟增加的事件，它记录的延迟事件，也是和Redis运行过程中可能会导致运行变慢的操作<strong>紧耦合</strong>的。此外，Redis的INFO命令也提供了Redis运行时的监控信息，不过你要知道，INFO命令的实现，主要是在全局变量server的成员变量中，用来记录Redis实例的实时运行状态或是资源使用情况的。</p> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li><p><a href="https://time.geekbang.org/column/intro/100084301?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noopener noreferrer">极客时间：Redis源码剖析与实战<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener noreferrer">Redis设计与实现 <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://github.com/redis/redis/blob/5.0/src/ae.c" target="_blank" rel="noopener noreferrer">Github：redis 源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/Redis 系统设计/04.四、支线任务/20.Redis 中的延迟监控.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新于:</span> <span class="time">2024/09/18, 11:29:27</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/9b17a7/" class="prev">AOF 持久化</a></span> <span class="next"><a href="/pages/61d908/">发布与订阅</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.59640afe.js" defer></script><script src="/assets/js/2.933750c6.js" defer></script><script src="/assets/js/76.15d5bea9.js" defer></script><script src="/assets/js/7.7eb70372.js" defer></script>
  </body>
</html>
