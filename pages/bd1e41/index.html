<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>List 设计与实现 | Echo 系统设计之美</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="水滴石穿，设计无银弹">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.473bdd25.css" as="style"><link rel="preload" href="/assets/js/app.3449399e.js" as="script"><link rel="preload" href="/assets/js/2.933750c6.js" as="script"><link rel="preload" href="/assets/js/41.5525b2c4.js" as="script"><link rel="preload" href="/assets/js/7.7eb70372.js" as="script"><link rel="prefetch" href="/assets/js/10.8539d2c4.js"><link rel="prefetch" href="/assets/js/11.71fe9642.js"><link rel="prefetch" href="/assets/js/12.915fdd22.js"><link rel="prefetch" href="/assets/js/13.d9d26d25.js"><link rel="prefetch" href="/assets/js/14.397b7600.js"><link rel="prefetch" href="/assets/js/15.13af8159.js"><link rel="prefetch" href="/assets/js/16.2b4d4184.js"><link rel="prefetch" href="/assets/js/17.1f44d5e0.js"><link rel="prefetch" href="/assets/js/18.504b80bb.js"><link rel="prefetch" href="/assets/js/19.c5a27579.js"><link rel="prefetch" href="/assets/js/20.b5e0fdf1.js"><link rel="prefetch" href="/assets/js/21.af1069aa.js"><link rel="prefetch" href="/assets/js/22.af583a75.js"><link rel="prefetch" href="/assets/js/23.f8a8e8e0.js"><link rel="prefetch" href="/assets/js/24.88b84218.js"><link rel="prefetch" href="/assets/js/25.db0f299d.js"><link rel="prefetch" href="/assets/js/26.dc5ac22f.js"><link rel="prefetch" href="/assets/js/27.e82ff876.js"><link rel="prefetch" href="/assets/js/28.6b737928.js"><link rel="prefetch" href="/assets/js/29.ebd14054.js"><link rel="prefetch" href="/assets/js/3.aa815192.js"><link rel="prefetch" href="/assets/js/30.ed6ead0e.js"><link rel="prefetch" href="/assets/js/31.89a26765.js"><link rel="prefetch" href="/assets/js/32.f1016cda.js"><link rel="prefetch" href="/assets/js/33.fa9fdf81.js"><link rel="prefetch" href="/assets/js/34.9740832c.js"><link rel="prefetch" href="/assets/js/35.ac8dd46f.js"><link rel="prefetch" href="/assets/js/36.8aa375d9.js"><link rel="prefetch" href="/assets/js/37.381f3758.js"><link rel="prefetch" href="/assets/js/38.b82e8635.js"><link rel="prefetch" href="/assets/js/39.5259c5c3.js"><link rel="prefetch" href="/assets/js/4.73518a0f.js"><link rel="prefetch" href="/assets/js/40.92a2ab0c.js"><link rel="prefetch" href="/assets/js/42.825c6423.js"><link rel="prefetch" href="/assets/js/43.1f07064b.js"><link rel="prefetch" href="/assets/js/44.f4a3c564.js"><link rel="prefetch" href="/assets/js/45.52725702.js"><link rel="prefetch" href="/assets/js/46.73e4ddcb.js"><link rel="prefetch" href="/assets/js/47.7372c922.js"><link rel="prefetch" href="/assets/js/48.4ae5a7da.js"><link rel="prefetch" href="/assets/js/49.5d33831c.js"><link rel="prefetch" href="/assets/js/5.1875cdb3.js"><link rel="prefetch" href="/assets/js/50.ededdb64.js"><link rel="prefetch" href="/assets/js/51.88874359.js"><link rel="prefetch" href="/assets/js/52.a86508e6.js"><link rel="prefetch" href="/assets/js/53.a8d66d87.js"><link rel="prefetch" href="/assets/js/54.89dcf983.js"><link rel="prefetch" href="/assets/js/55.30c89211.js"><link rel="prefetch" href="/assets/js/56.249d1e23.js"><link rel="prefetch" href="/assets/js/57.ae215963.js"><link rel="prefetch" href="/assets/js/6.0b558b79.js"><link rel="prefetch" href="/assets/js/8.0ec7f6e8.js"><link rel="prefetch" href="/assets/js/9.6e274fca.js">
    <link rel="stylesheet" href="/assets/css/0.styles.473bdd25.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Echo 系统设计之美" class="logo"> <span class="site-name can-hide">Echo 系统设计之美</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧑‍💻实战系统设计" class="dropdown-title"><!----> <span class="title" style="display:;">🧑‍💻实战系统设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/84cb49/" class="nav-link">设计基础设施</a></li><li class="dropdown-item"><!----> <a href="/pages/a95d7d/" class="nav-link">设计热门应用</a></li><li class="dropdown-item"><!----> <a href="/pages/def08a/" class="nav-link">场景设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧑‍💻实战系统设计" class="dropdown-title"><!----> <span class="title" style="display:;">🧑‍💻实战系统设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/84cb49/" class="nav-link">设计基础设施</a></li><li class="dropdown-item"><!----> <a href="/pages/a95d7d/" class="nav-link">设计热门应用</a></li><li class="dropdown-item"><!----> <a href="/pages/def08a/" class="nav-link">场景设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>指南</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>基础</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/bdae41/" class="sidebar-link">String 设计与实现</a></li><li><a href="/pages/bd1e41/" aria-current="page" class="active sidebar-link">List 设计与实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/bd1e41/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/bd1e41/#ziplist-设计与实现" class="sidebar-link">ziplist 设计与实现</a></li><li class="sidebar-sub-header level2"><a href="/pages/bd1e41/#quicklist-设计与实现" class="sidebar-link">quicklist 设计与实现</a></li><li class="sidebar-sub-header level2"><a href="/pages/bd1e41/#listpack-设计与实现" class="sidebar-link">listpack 设计与实现</a></li><li class="sidebar-sub-header level2"><a href="/pages/bd1e41/#对比" class="sidebar-link">对比</a></li><li class="sidebar-sub-header level2"><a href="/pages/bd1e41/#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/pages/2d4311/" class="sidebar-link">Hash 设计与实现</a></li><li><a href="/pages/2d4312/" class="sidebar-link">ZSet 设计与实现</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>主线</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>支线</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>集群</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Redis 系统设计</span></li><li data-v-06225672><span data-v-06225672>基础</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-16</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">List 设计与实现<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><div class="custom-block note"><p class="custom-block-title">提出问题是一切智慧的开端</p> <ol><li>为什么 Redis 设计了三种类似但不同的底层数据结构 ziplist、quicklist、listpack？</li> <li>ziplist 为什么会面临查找效率降低和内存连锁更新的问题？</li> <li>quicklist 是如何解决 ziplist 的性能瓶颈的？</li> <li>listpack 是如何避免 ziplist 的连锁更新问题的？</li> <li>如何在实际开发中选择适合的 Redis List 底层结构，以平衡内存使用和性能？</li> <li>ziplist 在 Redis 设计中有哪些优点被保留了下来，即使它存在性能不足？</li> <li>当数据插入量大时，quicklist 如何避免内存频繁重新分配而保持高效？</li></ol></div> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>Redis 中的 List 的底层有三种数据结构</p> <ul><li>ziplist</li> <li>quicklist</li> <li>listpack</li></ul> <p>ziplist 的最大特点，就是它被设计成一种 <strong>内存紧凑型</strong> 的数据结构，占用一块连续的内存空间，以达到节省内存的目的</p> <p>但是，<strong>在计算机系统中，任何一个设计都是有利有弊的</strong>。对于 ziplist 来说，这个道理同样成立。</p> <p>虽然 ziplist 节省了内存开销，可它也存在两个设计代价</p> <ul><li>「不能保存过多的元素」，否则访问性能会降低</li> <li>「不能保存过大的元素」，否则容易导致内存重新分配，甚至可能引发连锁更新的问题。所谓的连锁更新，简单来说，就是 ziplist 中的每一项都要被重新分配内存空间，造成 ziplist 的性能降低</li></ul> <p>因此，针对 ziplist 在设计上的不足，Redis 在演进的过程中，新增设计了两种数据结构</p> <ul><li>quicklist</li> <li>istpack</li></ul> <p>它们设计目标，是 <strong>尽可能地保持 ziplist 节省内存的优势，同时避免 ziplist 潜在的性能下降问题</strong></p> <h2 id="ziplist-设计与实现"><a href="#ziplist-设计与实现" class="header-anchor">#</a> ziplist 设计与实现</h2> <h3 id="ziplist-和-整数集合-的设计"><a href="#ziplist-和-整数集合-的设计" class="header-anchor">#</a> ziplist 和 整数集合 的设计</h3> <p>首先你要知道，List、Hash 和 Sorted Set 这三种数据类型，都可以使用压缩列表（ziplist）来保存数据。压缩列表的函数定义和实现代码分别在 ziplist.h 和 ziplist.c 中</p> <p>不过，我们在 ziplist.h 文件中其实根本看不到压缩列表的结构体定义。这是因为压缩列表本身就是一块连续的内存空间，它通过使用不同的编码来保存数据</p> <p>这里为了方便理解压缩列表的设计与实现，我们先来看看它的<strong>创建函数 ziplistNew</strong>，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">ziplistNew</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//初始分配的大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> bytes <span class="token operator">=</span> ZIPLIST_HEADER_SIZE<span class="token operator">+</span>ZIPLIST_END_SIZE<span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">;</span>
    …
   <span class="token comment">//将列表尾设置为ZIP_END</span>
    zl<span class="token punctuation">[</span>bytes<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ZIP_END<span class="token punctuation">;</span>
    <span class="token keyword">return</span> zl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实际上，<code>ziplistNew</code> 函数的逻辑很简单，就是创建一块连续的内存空间，大小为 <code>ZIPLIST_HEADER_SIZE</code> 和 <code>ZIPLIST_END_SIZE</code> 的总和，然后再把该连续空间的最后一个字节赋值为 <code>ZIP_END</code>，表示列表结束。</p> <p>这三个宏分别表示 ziplist 的列表头大小、列表尾大小和列表尾字节内容</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//ziplist的列表头大小，包括2个32 bits整数和1个16bits整数，分别表示压缩列表的总字节数，列表最后一个元素的离列表头的偏移，以及列表中的元素个数</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ZIPLIST_HEADER_SIZE</span>     <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint32_t</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token operator">+</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint16_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token comment">//ziplist的列表尾大小，包括1个8 bits整数，表示列表结束。</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ZIPLIST_END_SIZE</span>        <span class="token expression"><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">uint8_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token comment">//ziplist的列表尾字节内容</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">ZIP_END</span> <span class="token expression"><span class="token number">255</span></span></span>
</code></pre></div><p>那么，在创建一个新的 ziplist 后，该列表的内存布局就如下图所示。注意，此时列表中还没有实际的数据。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409161954992.png" alt="image-20240916195417942"></p> <p>然后，当我们往 ziplist 中插入数据时，ziplist 就会根据数据是字符串还是整数，以及它们的大小进行不同的编码。这种<strong>根据数据大小进行相应编码</strong>的设计思想，正是 Redis 为了节省内存而采用的</p> <p>ziplist 列表项包括三部分内容，分别是<strong>前一项的长度（prevlen）</strong>、<strong>当前项长度信息的编码结果（encoding）</strong>，以及<strong>当前项的实际数据（data）</strong>。下面的图展示了列表项的结构（图中除列表项之外的内容分别是 ziplist 内存空间的起始和尾部）。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409161954391.png" alt="image-20240916195445322"></p> <p>实际上，所谓的编码技术，就是指 <strong>用不同数量的字节来表示保存的信息</strong>。在 ziplist 中，编码技术主要应用在列表项中的 prevlen 和 encoding 这两个元数据上。而当前项的实际数据 data，则正常用整数或是字符串来表示。</p> <p>所以这里，我们就先来看下 <strong>prevlen 的编码设计</strong>。ziplist 中会包含多个列表项，每个列表项都是紧挨着彼此存放的，如下图所示。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409161955955.png" alt="image-20240916195507893"></p> <p>而为了方便查找，每个列表项中都会记录前一项的长度。因为每个列表项的长度不一样，所以如果使用相同的字节大小来记录 prevlen，就会造成内存空间浪费。</p> <p>我给你举个例子，假设我们统一使用 4 字节记录 prevlen，如果前一个列表项只是一个字符串“redis”，长度为 5 个字节，那么我们用 1 个字节（8 bits）就能表示 256 字节长度（2 的 8 次方等于 256）的字符串了。此时，prevlen 用 4 字节记录，其中就有 3 字节是浪费掉了。</p> <p>好，我们再回过头来看，ziplist 在对 prevlen 编码时，会先调用 <strong>zipStorePrevEntryLength 函数</strong>，用于判断前一个列表项是否小于 254 字节。如果是的话，那么 prevlen 就使用 1 字节表示；否则，zipStorePrevEntryLength 函数就调用 zipStorePrevEntryLengthLarge 函数进一步编码。这部分代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//判断prevlen的长度是否小于ZIP_BIG_PREVLEN，ZIP_BIG_PREVLEN等于254</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>len <span class="token operator">&lt;</span> ZIP_BIG_PREVLEN<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">//如果小于254字节，那么返回prevlen为1字节</span>
   p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> len<span class="token punctuation">;</span>
   <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token comment">//否则，调用zipStorePrevEntryLengthLarge进行编码</span>
   <span class="token keyword">return</span> <span class="token function">zipStorePrevEntryLengthLarge</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>也就是说，<strong>zipStorePrevEntryLengthLarge 函数</strong>会先将 prevlen 的第 1 字节设置为 254，然后使用内存拷贝函数 memcpy，将前一个列表项的长度值拷贝至 prevlen 的第 2 至第 5 字节。最后，zipStorePrevEntryLengthLarge 函数返回 prevlen 的大小，为 5 字节。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//将prevlen的第1字节设置为ZIP_BIG_PREVLEN，即254</span>
    p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> ZIP_BIG_PREVLEN<span class="token punctuation">;</span>
  <span class="token comment">//将前一个列表项的长度值拷贝至prevlen的第2至第5字节，其中sizeof(len)的值为4</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>p<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>len<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    …
<span class="token punctuation">}</span>
<span class="token comment">//返回prevlen的大小，为5字节</span>
<span class="token keyword">return</span> <span class="token number">1</span><span class="token operator">+</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>好，在了解了 prevlen 使用 1 字节和 5 字节两种编码方式后，我们再来学习下 <strong>encoding 的编码方法</strong>。</p> <p>我们知道，一个列表项的实际数据，既可以是整数也可以是字符串。整数可以是 16、32、64 等字节长度，同时字符串的长度也可以大小不一。</p> <p>所以，ziplist 在 zipStoreEntryEncoding 函数中，针对整数和字符串，就分别使用了不同字节长度的编码结果。下面的代码展示了 zipStoreEntryEncoding 函数的部分代码，你可以看到当数据是不同长度字符串或是整数时，编码结果的长度 len 大小不同。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//默认编码结果是1字节</span>
<span class="token keyword">unsigned</span> <span class="token keyword">char</span> len <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token comment">//如果是字符串数据</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">ZIP_IS_STR</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//字符串长度小于等于63字节（16进制为0x3f）</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>rawlen <span class="token operator">&lt;=</span> <span class="token number">0x3f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//默认编码结果是1字节</span>
        …
    <span class="token punctuation">}</span>
    <span class="token comment">//字符串长度小于等于16383字节（16进制为0x3fff）</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>rawlen <span class="token operator">&lt;=</span> <span class="token number">0x3fff</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//编码结果是2字节</span>
        len <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
        …
    <span class="token punctuation">}</span>
    <span class="token comment">//字符串长度大于16383字节</span>

    <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">//编码结果是5字节</span>
        len <span class="token operator">+=</span> <span class="token number">4</span><span class="token punctuation">;</span>
        …
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 如果数据是整数，编码结果是1字节*/</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>p<span class="token punctuation">)</span> <span class="token keyword">return</span> len<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>简而言之，针对不同长度的数据，使用不同大小的元数据信息（prevlen 和 encoding），这种方法可以有效地节省内存开销</p> <p>除了 ziplist 之外，Redis 还设计了一个内存友好的数据结构，这就是<strong>整数集合（intset）</strong>，它是作为底层结构来实现 Set 数据类型的。</p> <p>和 SDS 嵌入式字符串、ziplist 类似，整数集合也是一块连续的内存空间，这一点我们从整数集合的定义中就可以看到。intset.h 和 intset.c 分别包括了整数集合的定义和实现</p> <p>下面的代码展示了 intset 的结构定义。我们可以看到，整数集合结构体中记录数据的部分，就是一个 int8_t 类型的整数数组 contents。从内存使用的角度来看，整数数组就是一块连续内存空间，所以这样就避免了内存碎片，并提升了内存使用效率</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">intset</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint32_t</span> encoding<span class="token punctuation">;</span>
    <span class="token class-name">uint32_t</span> length<span class="token punctuation">;</span>
    <span class="token class-name">int8_t</span> contents<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> intset<span class="token punctuation">;</span>
</code></pre></div><h3 id="扩展-节省内存的数据访问"><a href="#扩展-节省内存的数据访问" class="header-anchor">#</a> 扩展：节省内存的数据访问</h3> <p>我们知道，在 Redis 实例运行时，有些数据是会被经常访问的，比如常见的整数，Redis 协议中常见的回复信息，包括操作成功（“OK”字符串）、操作失败（ERR），以及常见的报错信息。</p> <p>所以，为了避免在内存中反复创建这些经常被访问的数据，Redis 就采用了<strong>共享对象</strong>的设计思想。这个设计思想很简单，就是把这些常用数据创建为共享对象，当上层应用需要访问它们时，直接读取就行。</p> <p>现在我们就来做个假设。有 1000 个客户端，都要保存“3”这个整数。如果 Redis 为每个客户端，都创建了一个值为 3 的 redisObject，那么内存中就会有大量的冗余。而使用了共享对象方法后，Redis 在内存中只用保存一个 3 的 redisObject 就行，这样就有效节省了内存空间。</p> <p>以下代码展示的是 server.c 文件中，<strong>创建共享对象的函数 createSharedObjects</strong>，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">createSharedObjects</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   …
   <span class="token comment">//常见回复信息</span>
   shared<span class="token punctuation">.</span>ok <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>OBJ_STRING<span class="token punctuation">,</span><span class="token function">sdsnew</span><span class="token punctuation">(</span><span class="token string">&quot;+OK\r\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   shared<span class="token punctuation">.</span>err <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>OBJ_STRING<span class="token punctuation">,</span><span class="token function">sdsnew</span><span class="token punctuation">(</span><span class="token string">&quot;-ERR\r\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   …
   <span class="token comment">//常见报错信息</span>
 shared<span class="token punctuation">.</span>nokeyerr <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>OBJ_STRING<span class="token punctuation">,</span><span class="token function">sdsnew</span><span class="token punctuation">(</span><span class="token string">&quot;-ERR no such key\r\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 shared<span class="token punctuation">.</span>syntaxerr <span class="token operator">=</span> <span class="token function">createObject</span><span class="token punctuation">(</span>OBJ_STRING<span class="token punctuation">,</span><span class="token function">sdsnew</span><span class="token punctuation">(</span><span class="token string">&quot;-ERR syntax error\r\n&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">//0到9999的整数</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> OBJ_SHARED_INTEGERS<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        shared<span class="token punctuation">.</span>integers<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span>
          <span class="token function">makeObjectShared</span><span class="token punctuation">(</span><span class="token function">createObject</span><span class="token punctuation">(</span>OBJ_STRING<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        …
    <span class="token punctuation">}</span>
   …
<span class="token punctuation">}</span>
</code></pre></div><h3 id="ziplist-的不足"><a href="#ziplist-的不足" class="header-anchor">#</a> ziplist 的不足</h3> <p>你已经知道，一个 ziplist 数据结构在内存中的布局，就是一块连续的内存空间。这块空间的起始部分是大小固定的 10 字节元数据，其中记录了 ziplist 的总字节数、最后一个元素的偏移量以及列表元素的数量，而这 10 字节后面的内存空间则保存了实际的列表数据。在 ziplist 的最后部分，是一个 1 字节的标识（固定为 255），用来表示 ziplist 的结束，如下图所示：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409161958569.png" alt="image-20240916195800505"></p> <p>不过，虽然 ziplist 通过紧凑的内存布局来保存数据，节省了内存空间，但是 ziplist 也面临着随之而来的两个不足：</p> <ul><li><strong>查找复杂度高</strong></li> <li><strong>潜在的连锁更新风险</strong></li></ul> <p>那么下面，我们就分别来了解下这两个问题</p> <h4 id="查找复杂度高"><a href="#查找复杂度高" class="header-anchor">#</a> 查找复杂度高</h4> <p>因为 ziplist 头尾元数据的大小是固定的，所以可以很快找到 首部元素和尾部元素，但问题是</p> <ul><li>当要查找中间元素时，ziplist 就得从列表头或列表尾遍历才行</li> <li>更糟糕的是，如果 ziplist 里面保存的是字符串，ziplist 在查找某个元素时，还需要逐一判断元素的每个字符，这样又进一步增加了复杂度</li> <li>ziplist 在插入元素时，如果内存空间不够了，ziplist 还需要重新分配一块连续的内存空间，而这还会进一步引发<strong>连锁更新</strong>的问题</li></ul> <p>也正因为如此，我们在使用 ziplist 保存 Hash 或 Sorted Set 数据时，都会在 redis.conf 文件中，通过 hash-max-ziplist-entries 和 zset-max-ziplist-entries 两个参数，来控制保存在 ziplist 中的元素个数</p> <h4 id="连锁更新风险"><a href="#连锁更新风险" class="header-anchor">#</a> 连锁更新风险</h4> <p>我们知道，因为 ziplist 必须使用一块连续的内存空间来保存数据，所以当新插入一个元素时，ziplist 就需要计算其所需的空间大小，并申请相应的内存空间。这一系列操作，我们可以从 ziplist 的元素插入函数 __ziplistInsert 中看到。</p> <p><strong>__ziplistInsert 函数首先会计算获得当前 ziplist 的长度</strong>，这个步骤通过 <code>ZIPLIST_BYTES</code> 宏定义就可以完成，如下所示。同时，该函数还声明了 reqlen 变量，用于记录插入元素后所需的新增空间大小。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//获取当前ziplist长度curlen；声明reqlen变量，用来记录新插入元素所需的长度</span>
<span class="token class-name">size_t</span> curlen <span class="token operator">=</span> <span class="token function">intrev32ifbe</span><span class="token punctuation">(</span><span class="token function">ZIPLIST_BYTES</span><span class="token punctuation">(</span>zl<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> reqlen<span class="token punctuation">;</span>
</code></pre></div><p>然后，<strong>__ziplistInsert 函数会判断当前要插入的位置是否是列表末尾</strong>。如果不是末尾，那么就需要获取位于当前插入位置的元素的 prevlen 和 prevlensize。这部分代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//如果插入的位置不是ziplist末尾，则获取前一项长度</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> ZIP_END<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ZIP_DECODE_PREVLEN</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> prevlensize<span class="token punctuation">,</span> prevlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    …
<span class="token punctuation">}</span>
</code></pre></div><p>实际上，在 ziplist 中，每一个元素都会记录其<strong>前一项的长度，也就是 prevlen</strong>。然后，为了节省内存开销，ziplist 会使用不同的空间记录 prevlen，这个 <strong>prevlen 空间大小就是 prevlensize</strong>。</p> <p>举个简单的例子，当在一个元素 A 前插入一个新的元素 B 时，A 的 prevlen 和 prevlensize 都要根据 B 的长度进行相应的变化。</p> <p>那么现在，我们假设 A 的 prevlen 原本只占用 1 字节（也就是 prevlensize 等于 1），而能记录的前一项长度最大为 253 字节。此时，如果 B 的长度超过了 253 字节，A 的 prevlen 就需要使用 5 个字节来记录（prevlen 具体的编码方式，你可以复习回顾下第 4 讲），这样就需要申请额外的 4 字节空间了。不过，如果元素 B 的插入位置是列表末尾，那么插入元素 B 时，我们就不用考虑后面元素的 prevlen 了</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409161959761.png" alt="image-20240916195907680"></p> <p>因此，为了保证 ziplist 有足够的内存空间，来保存插入元素以及插入位置元素的 prevlen 信息，<strong>__ziplistInsert 函数在获得插入位置元素的 prevlen 和 prevlensize 后，紧接着就会计算插入元素的长度</strong>。</p> <p>现在我们已知，一个 ziplist 元素包括了 prevlen、encoding 和实际数据 data 三个部分。所以，在计算插入元素的所需空间时，__ziplistInsert 函数也会分别计算这三个部分的长度。这个计算过程一共可以分成四步来完成。</p> <ul><li><strong>第一步，计算实际插入元素的长度。</strong></li></ul> <p>首先你要知道，这个计算过程和插入元素是整数还是字符串有关。__ziplistInsert 函数会先调用 zipTryEncoding 函数，这个函数会判断插入元素是否为整数。如果是整数，就按照不同的整数大小，计算 encoding 和实际数据 data 各自所需的空间；如果是字符串，那么就先把字符串长度记录为所需的新增空间大小。这一过程的代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">zipTryEncoding</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>slen<span class="token punctuation">,</span><span class="token operator">&amp;</span>value<span class="token punctuation">,</span><span class="token operator">&amp;</span>encoding<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          reqlen <span class="token operator">=</span> <span class="token function">zipIntSize</span><span class="token punctuation">(</span>encoding<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          reqlen <span class="token operator">=</span> slen<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
</code></pre></div><ul><li>第二步，调用 zipStorePrevEntryLength 函数，将插入位置元素的 prevlen 也计算到所需空间中。</li></ul> <p>这是因为在插入元素后，__ziplistInsert 函数可能要为插入位置的元素分配新增空间。这部分代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code>reqlen <span class="token operator">+=</span> <span class="token function">zipStorePrevEntryLength</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>prevlen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>第三步，调用 zipStoreEntryEncoding 函数，根据字符串的长度，计算相应 encoding 的大小。</li></ul> <p>在刚才的第一步中，**ziplistInsert 函数对于字符串数据，只是记录了字符串本身的长度，所以在第三步中，**ziplistInsert 函数还会调用 zipStoreEntryEncoding 函数，根据字符串的长度来计算相应的 encoding 大小，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code>reqlen <span class="token operator">+=</span> <span class="token function">zipStoreEntryEncoding</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>encoding<span class="token punctuation">,</span>slen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>好了，到这里，__ziplistInsert 函数就已经在 reqlen 变量中，记录了插入元素的 prevlen 长度、encoding 大小，以及实际数据 data 的长度。这样一来，插入元素的整体长度就有了，这也是插入位置元素的 prevlen 所要记录的大小。</p> <ul><li>第四步，调用 zipPrevLenByteDiff 函数，判断插入位置元素的 prevlen 和实际所需的 prevlen 大小。</li></ul> <p>最后，__ziplistInsert 函数会调用 zipPrevLenByteDiff 函数，用来判断插入位置元素的 prevlen 和实际所需的 prevlen，这两者间的大小差别。这部分代码如下所示，prevlen 的大小差别是使用 nextdiff 来记录的：</p> <div class="language-c extra-class"><pre class="language-c"><code>nextdiff <span class="token operator">=</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">!=</span> ZIP_END<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">zipPrevLenByteDiff</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span>reqlen<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><p>那么在这里，如果 nextdiff 大于 0，就表明插入位置元素的空间不够，需要新增 nextdiff 大小的空间，以便能保存新的 prevlen。然后，<strong>__ziplistInsert 函数在新增空间时，就会调用 ziplistResize 函数，来重新分配 ziplist 所需的空间</strong>。</p> <p>ziplistResize 函数接收的参数分别是待重新分配的 ziplist 和重新分配的空间大小。而 __ziplistInsert 函数传入的重新分配大小的参数，是三个长度之和。</p> <p>那么是哪三个长度之和呢？</p> <p>这三个长度分别是 ziplist 现有大小（curlen）、待插入元素自身所需的新增空间（reqlen），以及插入位置元素 prevlen 所需的新增空间（nextdiff）。下面的代码显示了 ziplistResize 函数的调用和参数传递逻辑：</p> <div class="language-c extra-class"><pre class="language-c"><code>zl <span class="token operator">=</span> <span class="token function">ziplistResize</span><span class="token punctuation">(</span>zl<span class="token punctuation">,</span>curlen<span class="token operator">+</span>reqlen<span class="token operator">+</span>nextdiff<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>进一步，那么 ziplistResize 函数在获得三个长度总和之后，具体是如何扩容呢？</p> <p>我们可以进一步看下 ziplistResize 函数的实现，这个函数会调用 <strong>zrealloc 函数</strong>，来完成空间的重新分配，而重新分配的空间大小就是由<strong>传入参数 len</strong> 决定的。这样，我们就了解到了 ziplistResize 函数涉及到内存分配操作，因此如果我们往 ziplist 频繁插入过多数据的话，就可能引起多次内存分配，从而会对 Redis 性能造成影响。</p> <p>下面的代码显示了 ziplistResize 函数的部分实现，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">ziplistResize</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//对zl进行重新内存空间分配，重新分配的大小是len</span>
    zl <span class="token operator">=</span> <span class="token function">zrealloc</span><span class="token punctuation">(</span>zl<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    …
    zl<span class="token punctuation">[</span>len<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> ZIP_END<span class="token punctuation">;</span>
    <span class="token keyword">return</span> zl<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好了，到这里，我们就了解了 ziplist 在新插入元素时，会计算其所需的新增空间，并进行重新分配。而当新插入的元素较大时，就会引起插入位置的元素 prevlensize 增加，进而就会导致插入位置的元素所占空间也增加。</p> <p>而如此一来，这种空间新增就会引起连锁更新的问题。</p> <p>实际上，所谓的<strong>连锁更新</strong>，就是指当一个元素插入后，会引起当前位置元素新增 prevlensize 的空间。而当前位置元素的空间增加后，又会进一步引起该元素的后续元素，其 prevlensize 所需空间的增加。</p> <p>这样，一旦插入位置后续的所有元素，都会因为前序元素的 prevlenszie 增加，而引起自身空间也要增加，这种每个元素的空间都需要增加的现象，就是连锁更新。我画了下面这张图，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409161959782.png" alt="image-20240916195950700"></p> <p>连锁更新一旦发生，就会导致 ziplist 占用的内存空间要多次重新分配，这就会直接影响到 ziplist 的访问性能。</p> <p>所以说，虽然 ziplist 紧凑型的内存布局能节省内存开销，但是如果保存的元素数量增加了，或是元素变大了，ziplist 就会面临性能问题。那么，有没有什么方法可以避免 ziplist 的问题呢</p> <p>这就是接下来我要给你介绍的 quicklist 和 listpack，这两种数据结构的设计思想了</p> <h2 id="quicklist-设计与实现"><a href="#quicklist-设计与实现" class="header-anchor">#</a> quicklist 设计与实现</h2> <p>我们先来学习下 quicklist 的实现思路。</p> <p>quicklist 的设计，其实是结合了链表和 ziplist 各自的优势。简单来说，<strong>一个 quicklist 就是一个链表，而链表中的每个元素又是一个 ziplist</strong></p> <p>我们来看下 quicklist 的数据结构，这是在<a href="https://github.com/redis/redis/tree/5.0/src/quicklist.h" target="_blank" rel="noopener noreferrer">quicklist.h<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文件中定义的，而 quicklist 的具体实现是在<a href="https://github.com/redis/redis/tree/5.0/src/quicklist.c" target="_blank" rel="noopener noreferrer">quicklist.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文件中。</p> <p>首先，quicklist 元素的定义，也就是 quicklistNode。因为 quicklist 是一个链表，所以每个 quicklistNode 中，都包含了分别指向它前序和后序节点的<strong>指针</strong>prev 和 next**。同时，每个 quicklistNode 又是一个 ziplist，所以，在 quicklistNode 的结构体中，还有指向 ziplist 的**指针 zl。</p> <p>此外，quicklistNode 结构体中还定义了一些属性，比如 ziplist 的字节大小、包含的元素个数、编码格式、存储方式等。下面的代码显示了 quicklistNode 的结构体定义，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>     <span class="token comment">//前一个quicklistNode</span>
    <span class="token keyword">struct</span> <span class="token class-name">quicklistNode</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>     <span class="token comment">//后一个quicklistNode</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>zl<span class="token punctuation">;</span>              <span class="token comment">//quicklistNode指向的ziplist</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> sz<span class="token punctuation">;</span>                <span class="token comment">//ziplist的字节大小</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> count <span class="token operator">:</span> <span class="token number">16</span><span class="token punctuation">;</span>        <span class="token comment">//ziplist中的元素个数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> encoding <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">//编码格式，原生字节数组或压缩存储</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> container <span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">//存储方式</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> recompress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//数据是否被压缩</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> attempted_compress <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">//数据能否被压缩</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> extra <span class="token operator">:</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token comment">//预留的bit位</span>
<span class="token punctuation">}</span> quicklistNode<span class="token punctuation">;</span>
</code></pre></div><p>了解了 quicklistNode 的定义，我们再来看下 quicklist 的结构体定义。</p> <p>quicklist 作为一个链表结构，在它的数据结构中，是定义了<strong>整个 quicklist 的头、尾指针</strong>，这样一来，我们就可以通过 quicklist 的数据结构，来快速定位到 quicklist 的链表头和链表尾。</p> <p>此外，quicklist 中还定义了 quicklistNode 的个数、所有 ziplist 的总元素个数等属性。quicklist 的结构定义如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">quicklist</span> <span class="token punctuation">{</span>
    quicklistNode <span class="token operator">*</span>head<span class="token punctuation">;</span>      <span class="token comment">//quicklist的链表头</span>
    quicklistNode <span class="token operator">*</span>tail<span class="token punctuation">;</span>      <span class="token comment">//quicklist的链表尾</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> count<span class="token punctuation">;</span>     <span class="token comment">//所有ziplist中的总元素个数</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> len<span class="token punctuation">;</span>       <span class="token comment">//quicklistNodes的个数</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> quicklist<span class="token punctuation">;</span>
</code></pre></div><p>然后，从 quicklistNode 和 quicklist 的结构体定义中，我们就能画出下面这张 quicklist 的示意图。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162000522.png" alt="image-20240916200049462"></p> <p>而也正因为 quicklist 采用了链表结构，所以当插入一个新的元素时，quicklist 首先就会检查插入位置的 ziplist 是否能容纳该元素，这是通过 <strong>_quicklistNodeAllowInsert 函数</strong>来完成判断的。</p> <p>_quicklistNodeAllowInsert 函数会计算新插入元素后的大小（new_sz），这个大小等于 quicklistNode 的当前大小（node-&gt;sz）、插入元素的大小（sz），以及插入元素后 ziplist 的 prevlen 占用大小。</p> <p>在计算完大小之后，_quicklistNodeAllowInsert 函数会依次判断新插入的数据大小（sz）是否满足要求，即<strong>单个 ziplist 是否不超过 8KB，或是单个 ziplist 里的元素个数是否满足要求</strong>。</p> <p>只要这里面的一个条件能满足，quicklist 就可以在当前的 quicklistNode 中插入新元素，否则 quicklist 就会新建一个 quicklistNode，以此来保存新插入的元素。</p> <p>下面代码显示了是否允许在当前 quicklistNode 插入数据的判断逻辑，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">int</span> new_sz <span class="token operator">=</span> node<span class="token operator">-&gt;</span>sz <span class="token operator">+</span> sz <span class="token operator">+</span> ziplist_overhead<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">likely</span><span class="token punctuation">(</span><span class="token function">_quicklistNodeSizeMeetsOptimizationRequirement</span><span class="token punctuation">(</span>new_sz<span class="token punctuation">,</span> fill<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">sizeMeetsSafetyLimit</span><span class="token punctuation">(</span>new_sz<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>node<span class="token operator">-&gt;</span>count <span class="token operator">&lt;</span> fill<span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">else</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><p>这样一来，quicklist 通过控制每个 quicklistNode 中，ziplist 的大小或是元素个数，就有效减少了在 ziplist 中新增或修改元素后，发生连锁更新的情况，从而提供了更好的访问性能。</p> <p>而 Redis 除了设计了 quicklist 结构来应对 ziplist 的问题以外，还在 5.0 版本中新增了 listpack 数据结构，用来彻底避免连锁更新。下面我们就继续来学习下它的设计实现思路。</p> <h2 id="listpack-设计与实现"><a href="#listpack-设计与实现" class="header-anchor">#</a> listpack 设计与实现</h2> <p>listpack 也叫紧凑列表，它的特点就是<strong>用一块连续的内存空间来紧凑地保存数据</strong>，同时为了节省内存空间，<strong>listpack 列表项使用了多种编码方式，来表示不同长度的数据</strong>，这些数据包括整数和字符串。</p> <p>和 listpack 相关的实现文件是<a href="https://github.com/redis/redis/blob/5.0/src/listpack.c" target="_blank" rel="noopener noreferrer">listpack.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，头文件包括<a href="https://github.com/redis/redis/tree/5.0/src/listpack.h" target="_blank" rel="noopener noreferrer">listpack.h<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="https://github.com/redis/redis/tree/5.0/src/listpack_malloc.h" target="_blank" rel="noopener noreferrer">listpack_malloc.h<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。我们先来看下 listpack 的<strong>创建函数 lpNew</strong>，因为从这个函数的代码逻辑中，我们可以了解到 listpack 的整体结构。</p> <p>lpNew 函数创建了一个空的 listpack，一开始分配的大小是 LP_HDR_SIZE 再加 1 个字节。LP_HDR_SIZE 宏定义是在 listpack.c 中，它默认是 6 个字节，其中 4 个字节是记录 listpack 的总字节数，2 个字节是记录 listpack 的元素数量。</p> <p>此外，listpack 的最后一个字节是用来标识 listpack 的结束，其默认值是宏定义 LP_EOF。和 ziplist 列表项的结束标记一样，LP_EOF 的值也是 255。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">lpNew</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//分配LP_HRD_SIZE+1</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>lp <span class="token operator">=</span> <span class="token function">lp_malloc</span><span class="token punctuation">(</span>LP_HDR_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lp <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">//设置listpack的大小</span>
    <span class="token function">lpSetTotalBytes</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span>LP_HDR_SIZE<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//设置listpack的元素个数，初始值为0</span>
    <span class="token function">lpSetNumElements</span><span class="token punctuation">(</span>lp<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//设置listpack的结尾标识为LP_EOF，值为255</span>
    lp<span class="token punctuation">[</span>LP_HDR_SIZE<span class="token punctuation">]</span> <span class="token operator">=</span> LP_EOF<span class="token punctuation">;</span>
    <span class="token keyword">return</span> lp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你可以看看下面这张图，展示的就是大小为 LP_HDR_SIZE 的 listpack 头和值为 255 的 listpack 尾。当有新元素插入时，该元素会被插在 listpack 头和尾之间。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162001409.png" alt="image-20240916200137358"></p> <p>好了，了解了 listpack 的整体结构后，我们再来看下 listpack 列表项的设计。</p> <p>和 ziplist 列表项类似，listpack 列表项也包含了元数据信息和数据本身。不过，为了避免 ziplist 引起的连锁更新问题，listpack 中的每个列表项不再像 ziplist 列表项那样，保存其前一个列表项的长度，<strong>它只会包含三个方面内容</strong>，分别是当前元素的编码类型（entry-encoding）、元素数据 (entry-data)，以及编码类型和元素数据这两部分的长度 (entry-len)，如下图所示。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162001838.png" alt="image-20240916200146785"></p> <p>这里，关于 listpack 列表项的设计，你需要重点掌握两方面的要点，分别是列表项元素的编码类型，以及列表项避免连锁更新的方法。下面我就带你具体了解下。</p> <h3 id="listpack-列表项编码方法"><a href="#listpack-列表项编码方法" class="header-anchor">#</a> listpack 列表项编码方法</h3> <p>我们先来看下 listpack 元素的编码类型。如果你看了 listpack.c 文件，你会发现该文件中有大量类似 LP_ENCODING<strong>XX_BIT_INT 和 LP_ENCODING</strong>XX_BIT_STR 的宏定义，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LP_ENCODING_7BIT_UINT</span> <span class="token expression"><span class="token number">0</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LP_ENCODING_6BIT_STR</span> <span class="token expression"><span class="token number">0x80</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LP_ENCODING_13BIT_INT</span> <span class="token expression"><span class="token number">0xC0</span></span></span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LP_ENCODING_64BIT_INT</span> <span class="token expression"><span class="token number">0xF4</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LP_ENCODING_32BIT_STR</span> <span class="token expression"><span class="token number">0xF0</span></span></span>
</code></pre></div><p>这些宏定义其实就对应了 listpack 的元素编码类型。具体来说，<strong>listpack 元素会对不同长度的整数和字符串进行编码</strong>，这里我们分别来看下。</p> <p>首先，对于<strong>整数编码</strong>来说，当 listpack 元素的编码类型为 LP_ENCODING_7BIT_UINT 时，表示元素的实际数据是一个 7 bit 的无符号整数。又因为 LP_ENCODING_7BIT_UINT 本身的宏定义值为 0，所以编码类型的值也相应为 0，占 1 个 bit。</p> <p>此时，编码类型和元素实际数据共用 1 个字节，这个字节的最高位为 0，表示编码类型，后续的 7 位用来存储 7 bit 的无符号整数，如下图所示：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162002422.png" alt="image-20240916200200371"></p> <p>而当编码类型为 LP_ENCODING_13BIT_INT 时，这表示元素的实际数据是 13 bit 的整数。同时，因为 LP_ENCODING_13BIT_INT 的宏定义值为 0xC0，转换为二进制值是 1100 0000，所以，这个二进制值中的后 5 位和后续的 1 个字节，共 13 位，会用来保存 13bit 的整数。而该二进制值中的前 3 位 110，则用来表示当前的编码类型。我画了下面这张图，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162002531.png" alt=""></p> <p>好，在了解了 LP_ENCODING_7BIT_UINT 和 LP_ENCODING_13BIT_INT 这两种编码类型后，剩下的 LP_ENCODING_16BIT_INT、LP_ENCODING_24BIT_INT、LP_ENCODING_32BIT_INT 和 LP_ENCODING_64BIT_INT，你应该也就能知道它们的编码方式了。</p> <p>这四种类型是分别用 2 字节（16 bit）、3 字节（24 bit）、4 字节（32 bit）和 8 字节（64 bit）来保存整数数据。同时，它们的编码类型本身占 1 字节，编码类型值分别是它们的宏定义值。</p> <p>然后，对于<strong>字符串编码</strong>来说，一共有三种类型，分别是 LP_ENCODING_6BIT_STR、LP_ENCODING_12BIT_STR 和 LP_ENCODING_32BIT_STR。从刚才的介绍中，你可以看到，整数编码类型名称中 BIT 前面的数字，表示的是整数的长度。因此类似的，字符串编码类型名称中 BIT 前的数字，表示的就是字符串的长度。</p> <p>比如，当编码类型为 LP_ENCODING_6BIT_STR 时，编码类型占 1 字节。该类型的宏定义值是 0x80，对应的二进制值是 1000 0000，这其中的前 2 位是用来标识编码类型本身，而后 6 位保存的是字符串长度。然后，列表项中的数据部分保存了实际的字符串。</p> <p>下面的图展示了三种字符串编码类型和数据的布局，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162002153.png" alt="image-20240916200218058"></p> <h3 id="listpack-避免连锁更新的实现方式"><a href="#listpack-避免连锁更新的实现方式" class="header-anchor">#</a> listpack 避免连锁更新的实现方式</h3> <p>最后，我们再来了解下 listpack 列表项是如何避免连锁更新的。</p> <p>在 listpack 中，因为每个列表项只记录自己的长度，而不会像 ziplist 中的列表项那样，会记录前一项的长度。所以，当我们在 listpack 中新增或修改元素时，实际上只会涉及每个列表项自己的操作，而不会影响后续列表项的长度变化，这就避免了连锁更新。</p> <p>不过，你可能会有疑问：<strong>如果 listpack 列表项只记录当前项的长度，那么 listpack 支持从左向右正向查询列表，或是从右向左反向查询列表吗？</strong></p> <p>其实，listpack 是能支持正、反向查询列表的。</p> <p><strong>当应用程序从左向右正向查询 listpack 时</strong>，我们可以先调用 lpFirst 函数。该函数的参数是指向 listpack 头的指针，它在执行时，会让指针向右偏移 LP_HDR_SIZE 大小，也就是跳过 listpack 头。你可以看下 lpFirst 函数的代码，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">lpFirst</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>lp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lp <span class="token operator">+=</span> LP_HDR_SIZE<span class="token punctuation">;</span> <span class="token comment">//跳过listpack头部6个字节</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>lp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> LP_EOF<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>  <span class="token comment">//如果已经是listpack的末尾结束字节，则返回NULL</span>
    <span class="token keyword">return</span> lp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后，再调用 lpNext 函数，该函数的参数包括了指向 listpack 某个列表项的指针。lpNext 函数会进一步调用 lpSkip 函数，并传入当前列表项的指针，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">lpNext</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>lp<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>p<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    p <span class="token operator">=</span> <span class="token function">lpSkip</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//调用lpSkip函数，偏移指针指向下一个列表项</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> LP_EOF<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后，lpSkip 函数会先后调用 lpCurrentEncodedSize 和 lpEncodeBacklen 这两个函数。</p> <p>lpCurrentEncodedSize 函数是根据当前列表项第 1 个字节的取值，来计算当前项的编码类型，并根据编码类型，计算当前项编码类型和实际数据的总长度。然后，lpEncodeBacklen 函数会根据编码类型和实际数据的长度之和，进一步计算列表项最后一部分 entry-len 本身的长度。</p> <p>这样一来，lpSkip 函数就知道当前项的编码类型、实际数据和 entry-len 的总长度了，也就可以将当前项指针向右偏移相应的长度，从而实现查到下一个列表项的目的。</p> <p>下面代码展示了 lpEncodeBacklen 函数的基本计算逻辑，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token function">lpEncodeBacklen</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">char</span> <span class="token operator">*</span>buf<span class="token punctuation">,</span> <span class="token class-name">uint64_t</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//编码类型和实际数据的总长度小于等于127，entry-len长度为1字节</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;=</span> <span class="token number">127</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> <span class="token number">16383</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//编码类型和实际数据的总长度大于127但小于16383，entry-len长度为2字节</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> <span class="token number">2097151</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//编码类型和实际数据的总长度大于16383但小于2097151，entry-len长度为3字节</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> <span class="token number">268435455</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//编码类型和实际数据的总长度大于2097151但小于268435455，entry-len长度为4字节</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//否则，entry-len长度为5字节</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token keyword">return</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我也画了一张图，展示了从左向右遍历 listpack 的基本过程，你可以再回顾下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162002083.png" alt="image-20240916200230974"></p> <p>好，了解了从左向右正向查询 listpack，我们再来看下<strong>从右向左反向查询 listpack</strong>。</p> <p>首先，我们根据 listpack 头中记录的 listpack 总长度，就可以直接定位到 listapck 的尾部结束标记。然后，我们可以调用 lpPrev 函数，该函数的参数包括指向某个列表项的指针，并返回指向当前列表项前一项的指针。</p> <p>lpPrev 函数中的关键一步就是调用 lpDecodeBacklen 函数。lpDecodeBacklen 函数会从右向左，逐个字节地读取当前列表项的 entry-len。</p> <p>那么，<strong>lpDecodeBacklen 函数如何判断 entry-len 是否结束了呢？</strong></p> <p>这就依赖于 entry-len 的编码方式了。entry-len 每个字节的最高位，是用来表示当前字节是否为 entry-len 的最后一个字节，这里存在两种情况，分别是：</p> <ul><li>最高位为 1，表示 entry-len 还没有结束，当前字节的左边字节仍然表示 entry-len 的内容；</li> <li>最高位为 0，表示当前字节已经是 entry-len 最后一个字节了。</li></ul> <p>而 entry-len 每个字节的低 7 位，则记录了实际的长度信息。这里你需要注意的是，entry-len 每个字节的低 7 位采用了<strong>大端模式存储</strong>，也就是说，entry-len 的低位字节保存在内存高地址上。</p> <p>我画了下面这张图，展示了 entry-len 这种特别的编码方式，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162002084.png" alt="image-20240916200241006"></p> <p>实际上，正是因为有了 entry-len 的特别编码方式，lpDecodeBacklen 函数就可以从当前列表项起始位置的指针开始，向左逐个字节解析，得到前一项的 entry-len 值。这也是 lpDecodeBacklen 函数的返回值。而从刚才的介绍中，我们知道 entry-len 记录了编码类型和实际数据的长度之和。</p> <p>因此，lpPrev 函数会再调用 lpEncodeBacklen 函数，来计算得到 entry-len 本身长度，这样一来，我们就可以得到前一项的总长度，而 lpPrev 函数也就可以将指针指向前一项的起始位置了。所以按照这个方法，listpack 就实现了从右向左的查询功能。</p> <h2 id="对比"><a href="#对比" class="header-anchor">#</a> 对比</h2> <table><thead><tr><th>特性</th> <th>ziplist</th> <th>quicklist</th> <th>listpack</th></tr></thead> <tbody><tr><td>设计复杂度</td> <td>较为复杂，包含前一个节点长度字段</td> <td>复杂</td> <td>更加简化，没有前一个节点长度字段</td></tr> <tr><td>内存占用</td> <td>存在冗余字段，内存利用率较低</td> <td>高</td> <td>更加紧凑，内存占用低</td></tr> <tr><td>操作复杂度</td> <td>插入、删除操作需要更新前向节点长度，较慢</td> <td>中</td> <td>操作简单高效，无需处理前向节点长度，但是也要移动</td></tr> <tr><td>内存移动问题</td> <td>频繁插入删除可能导致大范围内存移动</td> <td>中</td> <td>仍存在内存移动问题，但操作更加简单</td></tr> <tr><td>适用场景</td> <td>小 hash，小 zset</td> <td>list</td> <td>小 hash，小 zset，小 stream</td></tr></tbody></table> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409162019509.jpeg" alt="img"></p> <div class="custom-block note"><p class="custom-block-title">笔记</p> <p>echo 认为，ziplist 和 listpack 适用于元素较少时的存储，一旦元素变多就需采用 quicklist 这种类似于 linkedlist 的结构来进行存储，但是 quicklist 的 node 有两种选择，分别是 ziplist 和 listpack，在最新的版本中貌似都是采用 listpack 来实现的</p></div> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>本文从 ziplist 的设计不足出发，到学习 quicklist 和 listpack 的设计思想</p> <p>你要知道，ziplist 的不足主要在于<strong>一旦 ziplist 中元素个数多了，它的查找效率就会降低</strong>。而且如果在 ziplist 里新增或修改数据，ziplist 占用的内存空间还需要<strong>重新分配</strong>；更糟糕的是，ziplist 新增某个元素或修改某个元素时，可能会导致后续元素的 prevlen 占用空间都发生变化，从而引起<strong>连锁更新</strong>问题，导致每个元素的空间都要重新分配，这就会导致 ziplist 的访问性能下降。</p> <p>所以，为了应对 ziplist 的问题，Redis 先是在 3.0 版本中设计实现了 quicklist。quicklist 结构在 ziplist 基础上，使用链表将 ziplist 串联起来，链表的每个元素就是一个 ziplist。这种设计<strong>减少了数据插入时内存空间的重新分配，以及内存数据的拷贝</strong>。同时，quicklist 限制了每个节点上 ziplist 的大小，一旦一个 ziplist 过大，就会采用新增 quicklist 节点的方法。</p> <p>不过，又因为 quicklist 使用 quicklistNode 结构指向每个 ziplist，无疑增加了内存开销。为了<strong>减少内存开销，并进一步避免 ziplist 连锁更新问题</strong>，Redis 在 5.0 版本中，就设计实现了 listpack 结构。listpack 结构沿用了 ziplist 紧凑型的内存布局，把每个元素都紧挨着放置</p> <p>listpack 中每个列表项不再包含前一项的长度了，因此当某个列表项中的数据发生变化，导致列表项长度变化时，其他列表项的长度是不会受影响的，因而这就避免了 ziplist 面临的连锁更新问题。</p> <p>总而言之，Redis 在内存紧凑型列表的设计与实现上，从 ziplist 到 quicklist，再到 listpack，你可以看到 Redis 在内存空间开销和访问性能之间的设计取舍，这一系列的设计变化，是非常值得你学习的</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/Redis 系统设计/02.基础/02.List 设计与实现.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新于:</span> <span class="time">2024/09/17, 05:13:55</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/bdae41/" class="prev">String 设计与实现</a></span> <span class="next"><a href="/pages/2d4311/">Hash 设计与实现</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.3449399e.js" defer></script><script src="/assets/js/2.933750c6.js" defer></script><script src="/assets/js/41.5525b2c4.js" defer></script><script src="/assets/js/7.7eb70372.js" defer></script>
  </body>
</html>
