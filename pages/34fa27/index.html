<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Linux 中的 IO 多路复用 | Echo 系统设计之美</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="水滴石穿，设计无银弹">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.bc6beed4.css" as="style"><link rel="preload" href="/assets/js/app.aaad5302.js" as="script"><link rel="preload" href="/assets/js/2.933750c6.js" as="script"><link rel="preload" href="/assets/js/44.ff4f9547.js" as="script"><link rel="preload" href="/assets/js/7.7eb70372.js" as="script"><link rel="prefetch" href="/assets/js/10.2cc95be8.js"><link rel="prefetch" href="/assets/js/11.c7521a10.js"><link rel="prefetch" href="/assets/js/12.c0ea1b08.js"><link rel="prefetch" href="/assets/js/13.d9d26d25.js"><link rel="prefetch" href="/assets/js/14.1141ec27.js"><link rel="prefetch" href="/assets/js/15.61830f0a.js"><link rel="prefetch" href="/assets/js/16.f2ccbb47.js"><link rel="prefetch" href="/assets/js/17.1f44d5e0.js"><link rel="prefetch" href="/assets/js/18.e689f555.js"><link rel="prefetch" href="/assets/js/19.68db5844.js"><link rel="prefetch" href="/assets/js/20.b5e0fdf1.js"><link rel="prefetch" href="/assets/js/21.af1069aa.js"><link rel="prefetch" href="/assets/js/22.af583a75.js"><link rel="prefetch" href="/assets/js/23.f8a8e8e0.js"><link rel="prefetch" href="/assets/js/24.88b84218.js"><link rel="prefetch" href="/assets/js/25.acf70158.js"><link rel="prefetch" href="/assets/js/26.381f581c.js"><link rel="prefetch" href="/assets/js/27.e82ff876.js"><link rel="prefetch" href="/assets/js/28.6b737928.js"><link rel="prefetch" href="/assets/js/29.ebd14054.js"><link rel="prefetch" href="/assets/js/3.d9533589.js"><link rel="prefetch" href="/assets/js/30.ed6ead0e.js"><link rel="prefetch" href="/assets/js/31.89a26765.js"><link rel="prefetch" href="/assets/js/32.9a158243.js"><link rel="prefetch" href="/assets/js/33.a9dfc110.js"><link rel="prefetch" href="/assets/js/34.9740832c.js"><link rel="prefetch" href="/assets/js/35.017688d8.js"><link rel="prefetch" href="/assets/js/36.69f4f9a7.js"><link rel="prefetch" href="/assets/js/37.381f3758.js"><link rel="prefetch" href="/assets/js/38.3f232ff8.js"><link rel="prefetch" href="/assets/js/39.5259c5c3.js"><link rel="prefetch" href="/assets/js/4.73518a0f.js"><link rel="prefetch" href="/assets/js/40.6da9cd20.js"><link rel="prefetch" href="/assets/js/41.5525b2c4.js"><link rel="prefetch" href="/assets/js/42.9f3d0d39.js"><link rel="prefetch" href="/assets/js/43.d6629a36.js"><link rel="prefetch" href="/assets/js/45.bcc663f0.js"><link rel="prefetch" href="/assets/js/46.bf329f04.js"><link rel="prefetch" href="/assets/js/47.bcbfaada.js"><link rel="prefetch" href="/assets/js/48.9c747df7.js"><link rel="prefetch" href="/assets/js/49.4732d3cb.js"><link rel="prefetch" href="/assets/js/5.dd198b3d.js"><link rel="prefetch" href="/assets/js/50.9bff482f.js"><link rel="prefetch" href="/assets/js/51.8c80377e.js"><link rel="prefetch" href="/assets/js/52.37d81e55.js"><link rel="prefetch" href="/assets/js/53.88841637.js"><link rel="prefetch" href="/assets/js/54.1a887e66.js"><link rel="prefetch" href="/assets/js/55.3c3f2203.js"><link rel="prefetch" href="/assets/js/56.590fc579.js"><link rel="prefetch" href="/assets/js/57.a2182867.js"><link rel="prefetch" href="/assets/js/58.28ea8ba4.js"><link rel="prefetch" href="/assets/js/59.d771376d.js"><link rel="prefetch" href="/assets/js/6.0b558b79.js"><link rel="prefetch" href="/assets/js/8.0ec7f6e8.js"><link rel="prefetch" href="/assets/js/9.6e274fca.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bc6beed4.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Echo 系统设计之美" class="logo"> <span class="site-name can-hide">Echo 系统设计之美</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧑‍💻实战系统设计" class="dropdown-title"><!----> <span class="title" style="display:;">🧑‍💻实战系统设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/84cb49/" class="nav-link">设计基础设施</a></li><li class="dropdown-item"><!----> <a href="/pages/a95d7d/" class="nav-link">设计热门应用</a></li><li class="dropdown-item"><!----> <a href="/pages/def08a/" class="nav-link">场景设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧑‍💻实战系统设计" class="dropdown-title"><!----> <span class="title" style="display:;">🧑‍💻实战系统设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/84cb49/" class="nav-link">设计基础设施</a></li><li class="dropdown-item"><!----> <a href="/pages/a95d7d/" class="nav-link">设计热门应用</a></li><li class="dropdown-item"><!----> <a href="/pages/def08a/" class="nav-link">场景设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>指南</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>主线</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/34fa27/" aria-current="page" class="active sidebar-link">Linux 中的 IO 多路复用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/34fa27/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/34fa27/#linux-如何实现-io-多路复用" class="sidebar-link">Linux 如何实现 IO 多路复用</a></li><li class="sidebar-sub-header level2"><a href="/pages/34fa27/#总结" class="sidebar-link">总结</a></li></ul></li><li><a href="/pages/d4ecb9/" class="sidebar-link">Redis Server 初始化</a></li><li><a href="/pages/d6b00d/" class="sidebar-link">Redis 的 Reactor 模型</a></li><li><a href="/pages/264b06/" class="sidebar-link">深入 Redis 事件驱动框架</a></li><li><a href="/pages/e6d8ef/" class="sidebar-link">Redis 的执行模式</a></li><li><a href="/pages/b4aed2/" class="sidebar-link">简述 Redis 多线程 IO</a></li><li><a href="/pages/030696/" class="sidebar-link">深入 Redis 的多IO线程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>支线</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>集群</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Redis 系统设计</span></li><li data-v-06225672><span data-v-06225672>主线</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-15</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Linux 中的 IO 多路复用<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><div class="custom-block note"><p class="custom-block-title">提出问题是一切智慧的开端</p> <ul><li><p>为什么 Redis 这样高并发的应用选择了 epoll，而不是 select 或 poll？</p></li> <li><p>在设计一个高并发服务器时，如何选择最适合的 IO 模型？</p></li> <li><p>当服务器面对成千上万的连接时，什么样的机制可以让你高效管理这些连接？</p></li> <li><p>高并发场景中，epoll 是如何通过事件通知机制避免性能瓶颈的？</p></li> <li><p>多路复用机制会监听套接字上的哪些事件？</p></li> <li><p>多路复用机制可以监听多少个套接字？</p></li> <li><p>当有套接字就绪时，多路复用机制要如何找到就绪的套接字？</p></li></ul></div> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>Redis 作为一个 Client-Server 架构的数据库，其源码中少不了用来实现网络通信的部分。通常系统实现网络通信的基本方法是 <strong>使用 Socket 编程模型</strong>，但是，由于基本的 Socket 编程模型是单线程阻塞的 ....</p> <p>所以当要处理<strong>高并发</strong>请求时，有两种方案</p> <ul><li>多线程，让每个线程负责处理一个客户端的请求。而 Redis <strong>负责客户端请求解析和处理的线程只有一个</strong>，那么如果直接采用基本 Socket 模型，就会影响 Redis 支持高并发的客户端访问。</li> <li>IO 多路复用，为了实现高并发的网络通信，我们常用的 Linux 操作系统，就提供了 select、poll 和 epoll 三种编程模型，而在 Linux 上运行的 Redis，通常就会采用其中的 <strong>epoll 模型</strong>来进行网络通信。</li></ul> <h3 id="简述传统-socket-模型"><a href="#简述传统-socket-模型" class="header-anchor">#</a> 简述传统 Socket 模型</h3> <p>我们看下使用 Socket 模型实现网络通信时的关键操作，以此帮助我们分析 Socket 模型中的不足</p> <p>首先，当我们需要让服务器端和客户端进行通信时，可以在服务器端通过以下三步，来创建监听客户端连接的监听套接字（Listening Socket）：</p> <ol><li>调用 socket 函数，创建一个套接字。我们通常把这个套接字称为主动套接字（Active Socket）</li> <li>调用 bind 函数，将主动套接字和当前服务器的 IP 和监听端口进行绑定</li> <li>调用 listen 函数，将主动套接字转换为监听套接字，开始监听客户端的连接</li> <li>调用 accept函数，在完成上述三步之后，服务器端就可以接收客户端的连接请求了。为了能及时地收到客户端的连接请求，我们可以运行一个循环流程，在该流程中调用 accept 函数，用于接收客户端连接请求</li> <li>最后，服务器端可以通过调用 recv 或 send 函数，在刚才返回的已连接套接字上，接收并处理读写请求，或是将数据发送给客户端</li></ol> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>accept 函数是阻塞函数，也就是说，如果此时一直没有客户端连接请求，那么，服务器端的执行流程会一直阻塞在 accept 函数。一旦有客户端连接请求到达，accept 将不再阻塞，而是处理连接请求，和客户端建立连接，并返回已连接套接字（Connected Socket）</p></div> <div class="language-Java extra-class"><pre class="language-java"><code>listenSocket <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用socket系统调用创建一个主动套接字</span>
<span class="token function">bind</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//绑定地址和端口</span>
<span class="token function">listen</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将默认的主动套接字转换为服务器使用的被动套接字，也就是监听套接字</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//循环监听是否有客户端连接请求到来</span>
   connSocket <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//接受客户端连接</span>
   <span class="token function">recv</span><span class="token punctuation">(</span>connsocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//从客户端读取数据，只能同时处理一个客户端</span>
   <span class="token function">send</span><span class="token punctuation">(</span>connsocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//给客户端返回数据，只能同时处理一个客户端</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你会发现，虽然上述代码能够实现服务器端和客户端之间的通信，但是程序每调用一次 accept 函数，<strong>只能处理一个客户端连接</strong></p> <p>因此，如果想要处理多个并发客户端的请求，我们就需要使用<strong>多线程</strong>的方法，来处理通过 accept 函数建立的多个客户端连接上的请求</p> <p>使用这种方法后，我们需要在 accept 函数返回已连接套接字后，创建一个线程，并将已连接套接字传递给创建的线程，由该线程负责这个连接套接字上后续的数据读写。同时，服务器端的执行流程会再次调用 accept 函数，等待下一个客户端连接</p> <p>以下给出的示例代码，就展示了使用多线程来提升服务器端的并发客户端处理能力：</p> <div class="language-Java extra-class"><pre class="language-java"><code>listenSocket <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用socket系统调用创建一个主动套接字</span>
<span class="token function">bind</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//绑定地址和端口</span>
<span class="token function">listen</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将默认的主动套接字转换为服务器使用的被动套接字，即监听套接字</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//循环监听是否有客户端连接到来</span>
   connSocket <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//接受客户端连接，返回已连接套接字</span>
   <span class="token function">pthread_create</span><span class="token punctuation">(</span>processData<span class="token punctuation">,</span> connSocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建新线程对已连接套接字进行处理</span>

<span class="token punctuation">}</span>

<span class="token comment">//处理已连接套接字上的读写请求</span>
<span class="token function">processData</span><span class="token punctuation">(</span>connSocket<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token function">recv</span><span class="token punctuation">(</span>connsocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//从客户端读取数据，只能同时处理一个客户端</span>
   <span class="token function">send</span><span class="token punctuation">(</span>connsocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//给客户端返回数据，只能同时处理一个客户端</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="展望-io-多路复用"><a href="#展望-io-多路复用" class="header-anchor">#</a> 展望 IO 多路复用</h3> <p>虽然上述方法能提升服务器端的并发处理能力，遗憾的是</p> <p><strong>Redis 的主执行流程是由一个线程在执行，无法使用多线程的方式来提升并发处理能力。</strong></p> <p>所以，该方法对 Redis 并不起作用。那么，还有没有什么其他方法，能帮助 Redis 提升并发客户端的处理能力呢？</p> <p>这就要用到操作系统提供的 <strong>IO 多路复用功能</strong>了</p> <p>在基本的 Socket 编程模型中，accept 函数只能在一个监听套接字上监听客户端的连接，recv 函数也只能在一个已连接套接字上，等待客户端发送的请求。</p> <p>而 IO 多路复用机制，可以让程序通过调用多路复用函数，同时监听多个套接字上的请求。这里既可以包括监听套接字上的连接请求，也可以包括已连接套接字上的读写请求。这样当有一个或多个套接字上有请求时，多路复用函数就会返回。此时，程序就可以处理这些就绪套接字上的请求，比如读取就绪的已连接套接字上的请求内容。</p> <p>因为 Linux 操作系统在实际应用中比较广泛，所以讲解 Linux 上的 IO 多路复用机制。</p> <p>Linux 提供的 IO 多路复用机制主要有三种，分别是</p> <ul><li>select</li> <li>poll</li> <li>epoll</li></ul> <p>下面，我们就分别来学习下这三种机制的实现思路和使用方法。然后，我们再来看看，为什么 Redis 通常是选择使用 epoll 这种机制来实现网络通信</p> <h2 id="linux-如何实现-io-多路复用"><a href="#linux-如何实现-io-多路复用" class="header-anchor">#</a> Linux 如何实现 IO 多路复用</h2> <h3 id="select-机制-多路复用的基本实现"><a href="#select-机制-多路复用的基本实现" class="header-anchor">#</a> select 机制：多路复用的基本实现</h3> <p>select 机制中的一个重要函数就是 <strong>select 函数</strong></p> <p>对于 select 函数来说，它的参数包括</p> <ul><li>监听的文件描述符数量<code>__nfds</code></li> <li>被监听描述符的三个集合<code>*__readfds</code>、<code>*__writefds</code>和<code>*__exceptfds</code></li> <li>监听时阻塞等待的超时时长<code>*__timeout</code></li></ul> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">select</span> <span class="token punctuation">(</span><span class="token keyword">int</span> __nfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>__readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>__writefds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>__exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>__timeout<span class="token punctuation">)</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">注意</p> <p>Linux 针对每一个套接字都会有一个文件描述符，也就是一个非负整数，用来唯一标识该套接字，<strong>在多路复用机制的函数中，Linux 通常会用文件描述符作为参数</strong>。有了文件描述符，函数也就能找到对应的套接字，进而进行监听、读写等操作</p></div> <p>select 函数的参数<code>__readfds</code>、<code>__writefds</code>和<code>__exceptfds</code>表示的是，被监听描述符的集合，其实就是被监听套接字的集合。那么，<strong>为什么会有三个集合呢？</strong></p> <p>这就和我刚才提出的第一个问题相关，也就是<strong>多路复用机制会监听哪些事件</strong>。select 函数使用三个集合，表示监听的三类事件，分别是</p> <ul><li>读数据事件（对应<code>__readfds</code>集合）</li> <li>写数据事件（对应<code>__writefds</code>集合）</li> <li>异常事件（对应<code>__exceptfds</code>集合）</li></ul> <p>我们进一步可以看到，参数 <strong>readfds、writefds 和 exceptfds</strong> 的类型是 fd_set 结构体，它主要定义部分如下所示。其中，<code>__fd_mask</code>类型是 long int 类型的别名，<strong>FD_SETSIZE 和</strong>NFDBITS 这两个宏定义的大小默认为 1024 和 32</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   …
   __fd_mask  __fds_bits<span class="token punctuation">[</span>__FD_SETSIZE <span class="token operator">/</span> __NFDBITS<span class="token punctuation">]</span><span class="token punctuation">;</span>
   …
<span class="token punctuation">}</span> fd_set
</code></pre></div><p>所以，fd_set 结构体的定义，其实就是一个 long int 类型的数组，该数组中一共有 32 个元素（1024/32=32），每个元素是 32 位（long int 类型的大小），而每一位可以用来表示一个文件描述符的状态</p> <p>好了，了解了 fd_set 结构体的定义，我们就可以回答刚才提出的第二个问题了。<strong>select 函数对每一个描述符集合，都可以监听 1024 个描述符</strong>。</p> <p>接下来，我们再来了解下 <strong>如何使用 select 机制来实现网络通信</strong>。</p> <ol><li>首先，我们<strong>在调用 select 函数前，可以先创建好传递给 select 函数的描述符集合，然后再创建监听套接字</strong>。而为了让创建的监听套接字能被 select 函数监控，我们需要把这个套接字的描述符加入到创建好的描述符集合中。</li> <li>然后，我们就可以<strong>调用 select 函数，并把创建好的描述符集合作为参数传递给 select 函数</strong>。程序在调用 select 函数后，会发生<strong>阻塞</strong>。而当 select 函数检测到有描述符<strong>就绪</strong>后，就会<strong>结束阻塞</strong>，并返回就绪的文件描述符个数。</li> <li>此时，我们就可以在描述符集合中查找哪些描述符就绪了。然后，我们对已就绪描述符对应的套接字进行处理。比如，如果是__readfds 集合中有描述符就绪，这就表明这些就绪描述符对应的套接字上，有读事件发生，此时，我们就在该套接字上读取数据</li></ol> <p>而因为 select 函数一次可以监听 1024 个文件描述符的状态，所以 select 函数在返回时，也可能会一次返回多个就绪的文件描述符。这样一来，我们就可以使用一个循环流程，依次对就绪描述符对应的套接字进行读写或异常处理操作。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409171344187.png" alt="image-20240917134414085"></p> <p>下面的代码展示的是使用 select 函数，进行并发客户端处理的关键步骤和主要函数调用：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> sock_fd<span class="token punctuation">,</span>conn_fd<span class="token punctuation">;</span> <span class="token comment">//监听套接字和已连接套接字的变量</span>
sock_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//创建套接字</span>
<span class="token function">bind</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span>   <span class="token comment">//绑定套接字</span>
<span class="token function">listen</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span> <span class="token comment">//在套接字上进行监听，将套接字转为监听套接字</span>

fd_set rset<span class="token punctuation">;</span>  <span class="token comment">//被监听的描述符集合，关注描述符上的读事件</span>

<span class="token keyword">int</span> max_fd <span class="token operator">=</span> sock_fd

<span class="token comment">//初始化rset数组，使用FD_ZERO宏设置每个元素为0</span>
<span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//使用FD_SET宏设置rset数组中位置为sock_fd的文件描述符为1，表示需要监听该文件描述符</span>
<span class="token function">FD_SET</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//设置超时时间</span>
<span class="token keyword">struct</span> <span class="token class-name">timeval</span> timeout<span class="token punctuation">;</span>
timeout<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
timeout<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">//调用select函数，检测rset数组保存的文件描述符是否已有读事件就绪，返回就绪的文件描述符个数</span>
   n <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>max_fd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>

   <span class="token comment">//调用FD_ISSET宏，在rset数组中检测sock_fd对应的文件描述符是否就绪</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//如果sock_fd已经就绪，表明已有客户端连接；调用accept函数建立连接</span>
       conn_fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">//设置rset数组中位置为conn_fd的文件描述符为1，表示需要监听该文件描述符</span>
       <span class="token function">FD_SET</span><span class="token punctuation">(</span>conn_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">//依次检查已连接套接字的文件描述符</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxfd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//调用FD_ISSET宏，在rset数组中检测文件描述符是否就绪</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">//有数据可读，进行读数据处理</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不过，你或许会发现 select 函数存在 <strong>两个设计上的不足</strong>：</p> <ul><li>select 函数对单个进程能监听的文件描述符数量是<strong>有限制</strong>的，它能监听的文件描述符个数由__FD_SETSIZE 决定，默认值是 1024。</li> <li>当 select 函数返回后，我们需要<strong>遍历</strong>描述符集合，才能找到具体是哪些描述符就绪了。这个遍历过程会产生一定开销，从而降低程序的性能。</li></ul> <p>所以，为了解决 select 函数受限于 1024 个文件描述符的不足，poll 函数对此做了改进</p> <h3 id="poll-机制-不受限的文件描述符数量"><a href="#poll-机制-不受限的文件描述符数量" class="header-anchor">#</a> poll 机制：不受限的文件描述符数量</h3> <p>poll 机制的主要函数是 poll 函数，我们先来看下它的原型定义，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>__fds<span class="token punctuation">,</span> <span class="token class-name">nfds_t</span> __nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> __timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>其中，参数 fds 是 pollfd 结构体数组，参数 nfds 表示的是 fds 数组的元素个数，而timeout 表示 poll 函数阻塞的超时时间。</p> <p>pollfd 结构体里包含了要监听的描述符，以及该描述符上要监听的事件类型。这个我们可以从 pollfd 结构体的定义中看出来，如下所示。pollfd 结构体中包含了三个成员变量 fd、events 和 revents，分别表示要监听的文件描述符、要监听的事件类型和实际发生的事件类型。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>         <span class="token comment">//进行监听的文件描述符</span>
    <span class="token keyword">short</span> <span class="token keyword">int</span> events<span class="token punctuation">;</span>       <span class="token comment">//要监听的事件类型</span>
    <span class="token keyword">short</span> <span class="token keyword">int</span> revents<span class="token punctuation">;</span>      <span class="token comment">//实际发生的事件类型</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>pollfd 结构体中要监听和实际发生的事件类型，是通过以下三个宏定义来表示的，分别是 POLLRDNORM、POLLWRNORM 和 POLLERR，它们分别表示可读、可写和错误事件。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLRDNORM</span>  <span class="token expression"><span class="token number">0x040</span>       </span><span class="token comment">//可读事件</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLWRNORM</span>  <span class="token expression"><span class="token number">0x100</span>       </span><span class="token comment">//可写事件</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLERR</span>     <span class="token expression"><span class="token number">0x008</span>       </span><span class="token comment">//错误事件</span></span>
</code></pre></div><p>好了，了解了 poll 函数的参数后，我们来看下如何使用 poll 函数完成网络通信。这个流程主要可以分成三步：</p> <ol><li>创建 pollfd 数组和监听套接字，并进行绑定；</li> <li>将监听套接字加入 pollfd 数组，并设置其监听读事件，也就是客户端的连接请求；</li> <li>循环调用 poll 函数，检测 pollfd 数组中是否有就绪的文件描述符。</li></ol> <p>而在第三步的循环过程中，其处理逻辑又分成了两种情况：</p> <ul><li>如果是连接套接字就绪，这表明是有客户端连接，我们可以调用 accept 接受连接，并创建已连接套接字，并将其加入 pollfd 数组，并监听读事件；</li> <li>如果是已连接套接字就绪，这表明客户端有读写请求，我们可以调用 recv/send 函数处理读写请求。</li></ul> <p>我画了下面这张图，展示了使用 poll 函数的流程，你可以学习掌握下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409171348928.png" alt="image-20240917134801867"></p> <p>另外，为了便于你掌握在代码中使用 poll 函数，我也写了一份示例代码，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> sock_fd<span class="token punctuation">,</span>conn_fd<span class="token punctuation">;</span> <span class="token comment">//监听套接字和已连接套接字的变量</span>
sock_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//创建套接字</span>
<span class="token function">bind</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span>   <span class="token comment">//绑定套接字</span>
<span class="token function">listen</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span> <span class="token comment">//在套接字上进行监听，将套接字转为监听套接字</span>

<span class="token comment">//poll函数可以监听的文件描述符数量，可以大于1024</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_OPEN</span> <span class="token expression"><span class="token operator">=</span> <span class="token number">2048</span></span></span>

<span class="token comment">//pollfd结构体数组，对应文件描述符</span>
<span class="token keyword">struct</span> <span class="token class-name">pollfd</span> client<span class="token punctuation">[</span>MAX_OPEN<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">//将创建的监听套接字加入pollfd数组，并监听其可读事件</span>
client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> sock_fd<span class="token punctuation">;</span>
client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLRDNORM<span class="token punctuation">;</span>
maxfd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment">//初始化client数组其他元素为-1</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_OPEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">//调用poll函数，检测client数组里的文件描述符是否有就绪的，返回就绪的文件描述符个数</span>
   n <span class="token operator">=</span> <span class="token function">poll</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> maxfd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">//如果监听套件字的文件描述符有可读事件，则进行处理</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLRDNORM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//有客户端连接；调用accept函数建立连接</span>
       conn_fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

       <span class="token comment">//保存已建立连接套接字</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_OPEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> conn_fd<span class="token punctuation">;</span> <span class="token comment">//将已建立连接的文件描述符保存到client数组</span>
           client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLRDNORM<span class="token punctuation">;</span> <span class="token comment">//设置该文件描述符监听可读事件</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       maxfd <span class="token operator">=</span> i<span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">//依次检查已连接套接字的文件描述符</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_OPEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> <span class="token punctuation">(</span>POLLRDNORM <span class="token operator">|</span> POLLERR<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">//有数据可读或发生错误，进行读数据处理或错误处理</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实，和 select 函数相比，poll 函数的改进之处主要就在于，<strong>它允许一次监听超过 1024 个文件描述符</strong>。但是当调用了 poll 函数后，我们仍然需要遍历每个文件描述符，检测该描述符是否就绪，然后再进行处理。</p> <p><strong>那么，有没有办法可以避免遍历每个描述符呢？</strong> 这就是我接下来向你介绍的 epoll 机制</p> <h3 id="epoll-机制-避免遍历每个描述符"><a href="#epoll-机制-避免遍历每个描述符" class="header-anchor">#</a> epoll 机制：避免遍历每个描述符</h3> <p>首先，epoll 机制是使用 epoll_event 结构体，来记录待监听的文件描述符及其监听的事件类型的，这和 poll 机制中使用 pollfd 结构体比较类似。</p> <p>那么，对于 epoll_event 结构体来说，其中包含了 epoll_data_t 联合体变量，以及整数类型的 events 变量。epoll_data_t 联合体中有记录文件描述符的成员变量 fd，而 events 变量会取值使用不同的宏定义值，来表示 epoll_data_t 变量中的文件描述符所关注的事件类型，比如一些常见的事件类型包括以下这几种。</p> <ul><li>EPOLLIN：读事件，表示文件描述符对应套接字有数据可读。</li> <li>EPOLLOUT：写事件，表示文件描述符对应套接字有数据要写。</li> <li>EPOLLERR：错误事件，表示文件描述符对于套接字出错。</li></ul> <p>下面的代码展示了 epoll_event 结构体以及 epoll_data 联合体的定义，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>  <span class="token comment">//记录文件描述符</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token class-name">epoll_data_t</span><span class="token punctuation">;</span>


<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span>
<span class="token punctuation">{</span>
  <span class="token class-name">uint32_t</span> events<span class="token punctuation">;</span>  <span class="token comment">//epoll监听的事件类型</span>
  <span class="token class-name">epoll_data_t</span> data<span class="token punctuation">;</span> <span class="token comment">//应用程序数据</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>好了，现在我们知道，在使用 select 或 poll 函数的时候，创建好文件描述符集合或 pollfd 数组后，就可以往数组中添加我们需要监听的文件描述符。</p> <p>但是对于 epoll 机制来说，我们则需要先调用 epoll_create 函数，创建一个 epoll 实例。这个 epoll 实例内部维护了两个结构，分别是<strong>记录要监听的文件描述符</strong>和<strong>已经就绪的文件描述符</strong>，而对于已经就绪的文件描述符来说，它们会被返回给用户程序进行处理。</p> <p>所以，我们在使用 epoll 机制时，就不用像使用 select 和 poll 一样，遍历查询哪些文件描述符已经就绪了。这样一来， epoll 的效率就比 select 和 poll 有了更高的提升。</p> <p>在创建了 epoll 实例后，我们需要再使用 epoll_ctl 函数，给被监听的文件描述符添加监听事件类型，以及使用 epoll_wait 函数获取就绪的文件描述符。</p> <p>我画了一张图，展示了使用 epoll 进行网络通信的流程，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409171348223.png" alt="image-20240917134850159"></p> <p>下面的代码展示了使用 epoll 函数的流程，你也可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> sock_fd<span class="token punctuation">,</span>conn_fd<span class="token punctuation">;</span> <span class="token comment">//监听套接字和已连接套接字的变量</span>
sock_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//创建套接字</span>
<span class="token function">bind</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span>   <span class="token comment">//绑定套接字</span>
<span class="token function">listen</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span> <span class="token comment">//在套接字上进行监听，将套接字转为监听套接字</span>

epfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span>EPOLL_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建epoll实例，</span>
<span class="token comment">//创建epoll_event结构体数组，保存套接字对应文件描述符和监听事件类型</span>
ep_events <span class="token operator">=</span> <span class="token punctuation">(</span>epoll_event<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>epoll_event<span class="token punctuation">)</span> <span class="token operator">*</span> EPOLL_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//创建epoll_event变量</span>
<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> ee
<span class="token comment">//监听读事件</span>
ee<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN<span class="token punctuation">;</span>
<span class="token comment">//监听的文件描述符是刚创建的监听套接字</span>
ee<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> sock_fd<span class="token punctuation">;</span>

<span class="token comment">//将监听套接字加入到监听列表中</span>
<span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> sock_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ee<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">//等待返回已经就绪的描述符</span>
   n <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> ep_events<span class="token punctuation">,</span> EPOLL_SIZE<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">//遍历所有就绪的描述符</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//如果是监听套接字描述符就绪，表明有一个新客户端连接到来</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>ep_events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">==</span> sock_fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          conn_fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用accept()建立连接</span>
          ee<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN<span class="token punctuation">;</span>
          ee<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> conn_fd<span class="token punctuation">;</span>
          <span class="token comment">//添加对新创建的已连接套接字描述符的监听，监听后续在已连接套接字上的读事件</span>
          <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> conn_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ee<span class="token punctuation">)</span><span class="token punctuation">;</span>

       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//如果是已连接套接字描述符就绪，则可以读数据</span>
           <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//读取数据并处理</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好了，到这里，你就了解了 epoll 函数的使用方法了。实际上，也正是因为 epoll 能自定义监听的描述符数量，以及可以直接返回就绪的描述符，Redis 在设计和实现网络通信框架时，就基于 epoll 机制中的 epoll_create、epoll_ctl 和 epoll_wait 等函数和读写事件，进行了封装开发，实现了用于网络通信的事件驱动框架，从而使得 Redis 虽然是单线程运行，但是仍然能高效应对高并发的客户端访问。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>echo 给你介绍了 Redis 网络通信依赖的操作系统底层机制，也就是 IO 多路复用机制</p> <p>由于 Redis 是单线程程序，如果使用基本的 Socket 编程模型的话，只能对一个监听套接字或一个已连接套接字进行监听。而当 Redis 实例面临很多并发的客户端时，这种处理方式的效率就会很低。</p> <p>所以，和基本的 Socket 通信相比，使用 IO 多路复用机制，就可以一次性获得就绪的多个套接字，从而避免了逐个检测套接字的开销。</p> <p>我是以最常用的 Linux 操作系统为例，给你具体介绍了 Linux 系统提供的三种 IO 多路复用机制，分别是 select、poll 和 epoll。这三种机制在能监听的描述符数量和查找就绪描述符的方法上是不一样的</p> <table><thead><tr><th>多路复用机制</th> <th>监听的文件描述符数量</th> <th>查找就绪的文件描述符</th></tr></thead> <tbody><tr><td>select</td> <td>最多 1024</td> <td>遍历所有描述符</td></tr> <tr><td>poll</td> <td>不受限</td> <td>遍历所有描述符</td></tr> <tr><td>epoll</td> <td>与使用</td> <td>epoll_wait 自动返回就绪的描述符，未就绪的描述符不返回</td></tr></tbody></table></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/Redis 系统设计/03.主线/01.Linux 中的 IO 多路复用.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新于:</span> <span class="time">2024/09/17, 08:34:31</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/2d4312/" class="prev">ZSet 设计与实现</a></span> <span class="next"><a href="/pages/d4ecb9/">Redis Server 初始化</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.aaad5302.js" defer></script><script src="/assets/js/2.933750c6.js" defer></script><script src="/assets/js/44.ff4f9547.js" defer></script><script src="/assets/js/7.7eb70372.js" defer></script>
  </body>
</html>
