<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入 Redis 的多IO线程 | Echo 系统设计之美</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="水滴石穿，设计无银弹">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.bc6beed4.css" as="style"><link rel="preload" href="/assets/js/app.aaad5302.js" as="script"><link rel="preload" href="/assets/js/2.933750c6.js" as="script"><link rel="preload" href="/assets/js/50.9bff482f.js" as="script"><link rel="preload" href="/assets/js/7.7eb70372.js" as="script"><link rel="prefetch" href="/assets/js/10.2cc95be8.js"><link rel="prefetch" href="/assets/js/11.c7521a10.js"><link rel="prefetch" href="/assets/js/12.c0ea1b08.js"><link rel="prefetch" href="/assets/js/13.d9d26d25.js"><link rel="prefetch" href="/assets/js/14.1141ec27.js"><link rel="prefetch" href="/assets/js/15.61830f0a.js"><link rel="prefetch" href="/assets/js/16.f2ccbb47.js"><link rel="prefetch" href="/assets/js/17.1f44d5e0.js"><link rel="prefetch" href="/assets/js/18.e689f555.js"><link rel="prefetch" href="/assets/js/19.68db5844.js"><link rel="prefetch" href="/assets/js/20.b5e0fdf1.js"><link rel="prefetch" href="/assets/js/21.af1069aa.js"><link rel="prefetch" href="/assets/js/22.af583a75.js"><link rel="prefetch" href="/assets/js/23.f8a8e8e0.js"><link rel="prefetch" href="/assets/js/24.88b84218.js"><link rel="prefetch" href="/assets/js/25.acf70158.js"><link rel="prefetch" href="/assets/js/26.381f581c.js"><link rel="prefetch" href="/assets/js/27.e82ff876.js"><link rel="prefetch" href="/assets/js/28.6b737928.js"><link rel="prefetch" href="/assets/js/29.ebd14054.js"><link rel="prefetch" href="/assets/js/3.d9533589.js"><link rel="prefetch" href="/assets/js/30.ed6ead0e.js"><link rel="prefetch" href="/assets/js/31.89a26765.js"><link rel="prefetch" href="/assets/js/32.9a158243.js"><link rel="prefetch" href="/assets/js/33.a9dfc110.js"><link rel="prefetch" href="/assets/js/34.9740832c.js"><link rel="prefetch" href="/assets/js/35.017688d8.js"><link rel="prefetch" href="/assets/js/36.69f4f9a7.js"><link rel="prefetch" href="/assets/js/37.381f3758.js"><link rel="prefetch" href="/assets/js/38.3f232ff8.js"><link rel="prefetch" href="/assets/js/39.5259c5c3.js"><link rel="prefetch" href="/assets/js/4.73518a0f.js"><link rel="prefetch" href="/assets/js/40.6da9cd20.js"><link rel="prefetch" href="/assets/js/41.5525b2c4.js"><link rel="prefetch" href="/assets/js/42.9f3d0d39.js"><link rel="prefetch" href="/assets/js/43.d6629a36.js"><link rel="prefetch" href="/assets/js/44.ff4f9547.js"><link rel="prefetch" href="/assets/js/45.bcc663f0.js"><link rel="prefetch" href="/assets/js/46.bf329f04.js"><link rel="prefetch" href="/assets/js/47.bcbfaada.js"><link rel="prefetch" href="/assets/js/48.9c747df7.js"><link rel="prefetch" href="/assets/js/49.4732d3cb.js"><link rel="prefetch" href="/assets/js/5.dd198b3d.js"><link rel="prefetch" href="/assets/js/51.8c80377e.js"><link rel="prefetch" href="/assets/js/52.37d81e55.js"><link rel="prefetch" href="/assets/js/53.88841637.js"><link rel="prefetch" href="/assets/js/54.1a887e66.js"><link rel="prefetch" href="/assets/js/55.3c3f2203.js"><link rel="prefetch" href="/assets/js/56.590fc579.js"><link rel="prefetch" href="/assets/js/57.a2182867.js"><link rel="prefetch" href="/assets/js/58.28ea8ba4.js"><link rel="prefetch" href="/assets/js/59.d771376d.js"><link rel="prefetch" href="/assets/js/6.0b558b79.js"><link rel="prefetch" href="/assets/js/8.0ec7f6e8.js"><link rel="prefetch" href="/assets/js/9.6e274fca.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bc6beed4.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Echo 系统设计之美" class="logo"> <span class="site-name can-hide">Echo 系统设计之美</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧑‍💻实战系统设计" class="dropdown-title"><!----> <span class="title" style="display:;">🧑‍💻实战系统设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/84cb49/" class="nav-link">设计基础设施</a></li><li class="dropdown-item"><!----> <a href="/pages/a95d7d/" class="nav-link">设计热门应用</a></li><li class="dropdown-item"><!----> <a href="/pages/def08a/" class="nav-link">场景设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧑‍💻实战系统设计" class="dropdown-title"><!----> <span class="title" style="display:;">🧑‍💻实战系统设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/84cb49/" class="nav-link">设计基础设施</a></li><li class="dropdown-item"><!----> <a href="/pages/a95d7d/" class="nav-link">设计热门应用</a></li><li class="dropdown-item"><!----> <a href="/pages/def08a/" class="nav-link">场景设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>指南</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>主线</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/34fa27/" class="sidebar-link">Linux 中的 IO 多路复用</a></li><li><a href="/pages/d4ecb9/" class="sidebar-link">Redis Server 初始化</a></li><li><a href="/pages/d6b00d/" class="sidebar-link">Redis 的 Reactor 模型</a></li><li><a href="/pages/264b06/" class="sidebar-link">深入 Redis 事件驱动框架</a></li><li><a href="/pages/e6d8ef/" class="sidebar-link">Redis 的执行模式</a></li><li><a href="/pages/b4aed2/" class="sidebar-link">简述 Redis 多线程 IO</a></li><li><a href="/pages/030696/" aria-current="page" class="active sidebar-link">深入 Redis 的多IO线程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/030696/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/030696/#多-io-线程的初始化" class="sidebar-link">多 IO 线程的初始化</a></li><li class="sidebar-sub-header level2"><a href="/pages/030696/#io-线程的运行函数-iothreadmain" class="sidebar-link">IO 线程的运行函数 IOThreadMain</a></li><li class="sidebar-sub-header level2"><a href="/pages/030696/#如何推迟客户端读操作" class="sidebar-link">如何推迟客户端读操作？</a></li><li class="sidebar-sub-header level2"><a href="/pages/030696/#如何推迟客户端写操作" class="sidebar-link">如何推迟客户端写操作？</a></li><li class="sidebar-sub-header level2"><a href="/pages/030696/#如何把待读客户端分配给-io-线程执行" class="sidebar-link">如何把待读客户端分配给 IO 线程执行？</a></li><li class="sidebar-sub-header level2"><a href="/pages/030696/#如何把待写客户端分配给-io-线程执行" class="sidebar-link">如何把待写客户端分配给 IO 线程执行？</a></li><li class="sidebar-sub-header level2"><a href="/pages/030696/#总结" class="sidebar-link">总结</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>支线</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>集群</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Redis 系统设计</span></li><li data-v-06225672><span data-v-06225672>主线</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-17</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">深入 Redis 的多IO线程<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><div class="custom-block note"><p class="custom-block-title">提出问题是一切智慧的开端</p> <ul><li>多线程 IO 如何缓解高并发下的网络瓶颈？</li> <li>为什么 Redis 6 只将多线程用于 IO，而不是命令执行？这种设计的优点？</li> <li>启用多 IO 线程后，如何确保请求处理的顺序和一致性？</li> <li>Redis 如何决定推迟读写操作？这对性能有何影响？</li> <li>在什么情况下启用多 IO 线程反而会导致性能下降？如何避免？</li> <li>IO 线程队列满载时系统会发生什么？如何防止任务堆积？</li> <li>多线程 IO 是否适合所有场景？如何判断是否应该启用？</li></ul></div> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>我们知道 Redis server 启动后的进程会以单线程的方式，执行客户端请求解析和处理工作。但是，Redis server 也会通过 bioInit 函数启动三个后台线程，来处理后台任务。也就是说，Redis 不再让主线程执行一些耗时操作，比如同步写、删除等，而是交给后台线程异步完成，从而避免了对主线程的阻塞</p> <p>实际上，在 2020 年 5 月推出的 Redis 6.0 版本中，Redis 在执行模型中还进一步使用了多线程来处理 IO 任务，这样设计的目的，就是为了充分利用当前服务器的多核特性，使用多核运行多线程，让多线程帮助加速数据读取、命令解析以及数据写回的速度，提升 Redis 整体性能</p> <p><strong>那么，这些多线程具体是在什么时候启动，又是通过什么方式来处理 IO 请求的呢？</strong></p> <p>echo 接下来给你介绍下 Redis 6.0 实现的多 IO 线程机制。通过这部分内容的学习，你可以充分了解到 Redis 6.0 是如何通过多线程来提升 IO 请求处理效率的。这样你也就可以结合实际业务来评估，自己是否需要使用 Redis 6.0 了。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>你需要下载 <a href="https://github.com/redis/redis/tree/6.0" target="_blank" rel="noopener noreferrer">Redis 6.0.15<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的源码，以便能查看到和多 IO 线程机制相关的代码</p></div> <h2 id="多-io-线程的初始化"><a href="#多-io-线程的初始化" class="header-anchor">#</a> 多 IO 线程的初始化</h2> <p><a href="/pages/e6d8ef/">Redis 的执行模式</a> 中有提到：Redis 5.0 中的三个后台线程，是 server 在初始化过程的最后，调用 InitSeverLast 函数，而 InitServerLast 函数再进一步调用 bioInit 函数来完成的。如果我们在 Redis 6.0 中查看 InitServerLast 函数，会发现和 Redis 5.0 相比，该函数在调完 bioInit 函数后，又调用了 <strong>initThreadedIO 函数</strong>。而 initThreadedIO 函数正是用来初始化多 IO 线程的，这部分的代码调用如下所示：</p> <div class="language-C extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">InitServerLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">bioInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">initThreadedIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//调用initThreadedIO函数初始化IO线程</span>
    <span class="token function">set_jemalloc_bg_thread</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>jemalloc_bg_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    server<span class="token punctuation">.</span>initial_memory_usage <span class="token operator">=</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以下面，我们就来看下 initThreadedIO 函数的主要执行流程，这个函数是在 <a href="https://github.com/redis/redis/tree/5.0/src/networking.c" target="_blank" rel="noopener noreferrer">networking.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件中实现的。</p> <p>**首先，initThreadedIO 函数会设置 IO 线程的激活标志。**这个激活标志保存在 redisServer 结构体类型的全局变量 server 当中，对应 redisServer 结构体的成员变量 io_threads_active。initThreadedIO 函数会把 io_threads_active 初始化为 0，表示 IO 线程还没有被激活。这部分代码如下所示：</p> <div class="language-C extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">initThreadedIO</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  server<span class="token punctuation">.</span>io_threads_active <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  …
<span class="token punctuation">}</span>
</code></pre></div><div class="custom-block warning"><p class="custom-block-title">注意</p> <p>刚才提到的<strong>全局变量 server</strong> 是 Redis server 运行时，用来保存各种全局信息的结构体变量。我在给你介绍 Redis server 初始化过程的时候，提到过 Redis server 的各种参数初始化配置，都是保存在这个全局变量 server 中的。所以，当你在阅读 Redis 源码时，如果在某个函数中看到变量 server，要知道其实就是这个全局变量。</p></div> <p>**紧接着，initThreadedIO 函数会对设置的 IO 线程数量进行判断。**这个数量就是保存在全局变量 server 的成员变量 io_threads_num 中的。那么在这里，IO 线程的数量判断会有三种结果。</p> <ul><li><p>如果 IO 线程数量为 1，就表示只有 1 个主 IO 线程，initThreadedIO 函数就直接返回了。此时，Redis server 的 IO 线程和 Redis 6.0 之前的版本是相同的。</p> <ul><li><code>if (server.io_threads_num == 1) return;</code></li></ul></li> <li><p>如果 IO 线程数量大于宏定义 IO_THREADS_MAX_NUM（默认值为 128），那么 initThreadedIO 函数会报错，并退出整个程序</p> <ul><li><div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_num <span class="token operator">&gt;</span> IO_THREADS_MAX_NUM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        …  <span class="token comment">//报错日志记录</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//退出程序</span>
 <span class="token punctuation">}</span>
</code></pre></div></li></ul></li> <li><p>如果 IO 线程数量大于 1，并且小于宏定义 IO_THREADS_MAX_NUM，那么，initThreadedIO 函数会执行一个循环流程，该流程的循环次数就是设置的 IO 线程数量</p></li></ul> <p>在该循环流程中，initThreadedIO 函数就会给以下四个数组进行初始化操作</p> <ul><li><strong>io_threads_list 数组</strong>：保存了每个 IO 线程要处理的客户端列表，将数组每个元素初始化为一个 List 类型的列表</li> <li><strong>io_threads_pending 数组</strong>：保存等待每个 IO 线程处理的客户端个数</li> <li><strong>io_threads_mutex 数组</strong>：保存线程互斥锁</li> <li><strong>io_threads 数组</strong>：保存每个 IO 线程的描述符</li></ul> <p>这四个数组的定义都在 networking.c 文件中，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token class-name">pthread_t</span> io_threads<span class="token punctuation">[</span>IO_THREADS_MAX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">//记录线程描述符的数组</span>
<span class="token class-name">pthread_mutex_t</span> io_threads_mutex<span class="token punctuation">[</span>IO_THREADS_MAX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//记录线程互斥锁的数组</span>
<span class="token keyword">_Atomic</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> io_threads_pending<span class="token punctuation">[</span>IO_THREADS_MAX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//记录线程待处理的客户端个数</span>
list <span class="token operator">*</span>io_threads_list<span class="token punctuation">[</span>IO_THREADS_MAX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">//记录线程对应处理的客户端</span>
</code></pre></div><p>然后，在对这些数组进行初始化的同时，initThreadedIO 函数还会根据 IO 线程数量，<strong>调用 pthread_create 函数创建相应数量的线程</strong>。我在上节课给你介绍过，pthread_create 函数的参数包括创建线程要运行的函数和函数参数（*tidp、*attr、*start_routine、*arg）。</p> <p>所以，对于 initThreadedIO 函数来说，它创建的线程要运行的函数是 <strong>IOThreadMain</strong>，参数是当前创建线程的编号。不过要注意的是，这个编号是从 1 开始的，编号为 0 的线程其实是运行 Redis server 主流程的主 IO 线程。</p> <p>以下代码就展示了 initThreadedIO 函数对数组的初始化，以及创建 IO 线程的过程，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 
    io_threads_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">listCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//编号为0的线程是主IO线程</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> 

    <span class="token class-name">pthread_t</span> tid<span class="token punctuation">;</span>
    <span class="token comment">//初始化io_threads_mutex数组</span>
    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>io_threads_mutex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  
    <span class="token comment">//初始化io_threads_pending数组</span>
    io_threads_pending<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>   
    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>io_threads_mutex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//调用pthread_create函数创建IO线程，线程运行函数为IOThreadMain</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>IOThreadMain<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	… <span class="token comment">//出错处理</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//初始化io_threads数组，设置值为线程标识</span>
    io_threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tid<span class="token punctuation">;</span>  
<span class="token punctuation">}</span>
</code></pre></div><p>好了，现在我们再来看下，刚才介绍的 IO 线程启动后要运行的函数 IOThreadMain。了解这个函数，可以帮助我们掌握 IO 线程实际做的工作</p> <h2 id="io-线程的运行函数-iothreadmain"><a href="#io-线程的运行函数-iothreadmain" class="header-anchor">#</a> IO 线程的运行函数 IOThreadMain</h2> <p>IOThreadMain 函数也是在 networking.c 文件中定义的，它的主要执行逻辑是一个 <strong>while(1) 循环</strong>。在这个循环中，IOThreadMain 函数会把 io_threads_list 数组中，每个 IO 线程对应的列表读取出来。</p> <p>就像我在前面给你介绍的一样，io_threads_list 数组中会针对每个 IO 线程，使用一个列表记录该线程要处理的客户端。所以，IOThreadMain 函数就会从每个 IO 线程对应的列表中，进一步取出要处理的客户端，然后判断线程要执行的操作标记。这个操作标记是用变量 io_threads_op 表示的，它有两种取值。</p> <ul><li><strong>io_threads_op 的值为宏定义 IO_THREADS_OP_WRITE</strong>：这表明该 IO 线程要做的是写操作，线程会调用 writeToClient 函数将数据写回客户端。</li> <li><strong>io_threads_op 的值为宏定义 IO_THREADS_OP_READ</strong>：这表明该 IO 线程要做的是读操作，线程会调用 readQueryFromClient 函数从客户端读取数据。</li></ul> <p>这部分的代码逻辑你可以看看下面的代码。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">IOThreadMain</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>myid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       listIter li<span class="token punctuation">;</span>
       listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>
       <span class="token comment">//获取 IO 线程要处理的客户端列表</span>
       <span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//从客户端列表中获取一个客户端</span>
          <span class="token keyword">if</span> <span class="token punctuation">(</span>io_threads_op <span class="token operator">==</span> IO_THREADS_OP_WRITE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
             <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//如果线程操作是写操作，则调用writeToClient将数据写回客户端</span>
           <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>io_threads_op <span class="token operator">==</span> IO_THREADS_OP_READ<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//如果线程操作是读操作，则调用readQueryFromClient从客户端读取数据</span>
           <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
              <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">&quot;io_threads_op value is unknown&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
           <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       <span class="token function">listEmpty</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//处理完所有客户端后，清空该线程的客户端列表</span>
       io_threads_pending<span class="token punctuation">[</span>id<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">//将该线程的待处理任务数量设置为0</span>

	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我也画了下面这张图，展示了 IOThreadMain 函数的基本流程，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409171444793.png" alt="image-20240917144454718"></p> <p>好了，到这里你应该就了解了，每一个 IO 线程运行时，都会不断检查是否有等待它处理的客户端。如果有，就根据操作类型，从客户端读取数据或是将数据写回客户端。你可以看到，这些操作都是 Redis 要和客户端完成的 IO 操作，所以，这也是为什么我们把这些线程称为 IO 线程的原因。</p> <p>那么，你看到这里，可能也会产生一些疑问，<strong>IO 线程要处理的客户端是如何添加到 io_threads_list 数组中的呢？</strong></p> <p>这就要说到 Redis server 对应的全局变量 server 了。server 变量中有两个 List 类型的成员变量：clients_pending_write 和 clients_pending_read，它们分别记录了待写回数据的客户端和待读取数据的客户端，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//待写回数据的客户端</span>
    list <span class="token operator">*</span>clients_pending_write<span class="token punctuation">;</span>  
    <span class="token comment">//待读取数据的客户端</span>
    list <span class="token operator">*</span>clients_pending_read<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你要知道，Redis server 在接收到客户端请求和给客户端返回数据的过程中，会根据一定条件，推迟客户端的读写操作，并分别把待读写的客户端保存到这两个列表中。然后，Redis server 在每次进入事件循环前，会再把列表中的客户端添加到 io_threads_list 数组中，交给 IO 线程进行处理。</p> <p>所以接下来，我们就先来看下，Redis 是如何推迟客户端的读写操作，并把这些客户端添加到 clients_pending_write 和 clients_pending_read 这两个列表中的。</p> <h2 id="如何推迟客户端读操作"><a href="#如何推迟客户端读操作" class="header-anchor">#</a> 如何推迟客户端读操作？</h2> <p>Redis server 在和一个客户端建立连接后，就会开始监听这个客户端上的可读事件，而处理可读事件的回调函数是 <strong>readQueryFromClient</strong>。我在xxx中给你介绍了这个过程，你可以再去回顾下。</p> <p>那么这里，我们再来看下 Redis 6.0 版本中的 readQueryFromClient 函数。这个函数一开始会先从传入参数 conn 中获取客户端 c，紧接着就调用 postponeClientRead 函数，来判断是否推迟从客户端读取数据。这部分的执行逻辑如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">connGetPrivateData</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//从连接数据结构中获取客户</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">postponeClientRead</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">//判断是否推迟从客户端读取数据</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>现在，我们就来看下 <strong>postponeClientRead 函数</strong>的执行逻辑。这个函数会根据四个条件判断能否推迟从客户端读取数据。</p> <p><strong>条件一：全局变量 server 的 io_threads_active 值为 1</strong></p> <p>这表示多 IO 线程已经激活。我刚才说过，这个变量值在 initThreadedIO 函数中是会被初始化为 0 的，也就是说，多 IO 线程初始化后，默认还没有激活（我一会儿还会给你介绍这个变量值何时被设置为 1）。</p> <p><strong>条件二：全局变量 server 的 io_threads_do_read 值为 1</strong></p> <p>这表示多 IO 线程可以用于处理延后执行的客户端读操作。这个变量值是在 Redis 配置文件 redis.conf 中，通过配置项 io-threads-do-reads 设置的，默认值为 no，也就是说，多 IO 线程机制默认并不会用于客户端读操作。所以，如果你想用多 IO 线程处理客户端读操作，就需要把 io-threads-do-reads 配置项设为 yes。</p> <p><strong>条件三：ProcessingEventsWhileBlocked 变量值为 0</strong></p> <p>这表示 processEventsWhileBlokced 函数没有在执行。ProcessingEventsWhileBlocked 是一个全局变量，它会在 processEventsWhileBlokced 函数执行时被设置为 1，在 processEventsWhileBlokced 函数执行完成时被设置为 0。</p> <p>而 processEventsWhileBlokced 函数是在<a href="https://github.com/redis/redis/tree/5.0/src/networking.c" target="_blank" rel="noopener noreferrer">networking.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文件中实现的。当 Redis 在读取 RDB 文件或是 AOF 文件时，这个函数会被调用，用来处理事件驱动框架捕获到的事件。这样就避免了因读取 RDB 或 AOF 文件造成 Redis 阻塞，而无法及时处理事件的情况。所以，当 processEventsWhileBlokced 函数执行处理客户端可读事件时，这些客户端读操作是不会被推迟执行的。</p> <p><strong>条件四：客户端现有标识不能有 CLIENT_MASTER、CLIENT_SLAVE 和 CLIENT_PENDING_READ</strong></p> <p>其中，CLIENT_MASTER 和 CLIENT_SLAVE 标识分别表示客户端是用于主从复制的客户端，也就是说，这些客户端不会推迟读操作。CLIENT_PENDING_READ 本身就表示一个客户端已经被设置为推迟读操作了，所以，对于已带有 CLIENT_PENDING_READ 标识的客户端，postponeClientRead 函数就不会再推迟它的读操作了。</p> <p>总之，只有前面这四个条件都满足了，postponeClientRead 函数才会推迟当前客户端的读操作。具体来说，postponeClientRead 函数会给该客户端设置 CLIENT_PENDING_REA 标识，并调用 listAddNodeHead 函数，把这个客户端添加到全局变量 server 的 clients_pending_read 列表中。</p> <p>我把 postponeClientRead 函数的代码放在这里，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">postponeClientRead</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//判断IO线程是否激活，</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_active <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>io_threads_do_reads <span class="token operator">&amp;&amp;</span>      
         <span class="token operator">!</span>ProcessingEventsWhileBlocked <span class="token operator">&amp;&amp;</span>
        <span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLIENT_MASTER<span class="token operator">|</span>CLIENT_SLAVE<span class="token operator">|</span>CLIENT_PENDING_READ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        c<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> CLIENT_PENDING_READ<span class="token punctuation">;</span> <span class="token comment">//给客户端的flag添加CLIENT_PENDING_READ标记，表示推迟该客户端的读操作</span>
        <span class="token function">listAddNodeHead</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将客户端添加到clients_pending_read列表中</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好，现在你已经知道，Redis 是在客户端读事件回调函数 readQueryFromClient 中，通过调用 postponeClientRead 函数来判断和推迟客户端读操作。下面，我再带你来看下 Redis 是如何推迟客户端写操作的</p> <h2 id="如何推迟客户端写操作"><a href="#如何推迟客户端写操作" class="header-anchor">#</a> 如何推迟客户端写操作？</h2> <p>Redis 在执行了客户端命令，要给客户端返回结果时，会调用 **addReply 函数 **将待返回结果写入客户端输出缓冲区。</p> <p>而在 addReply 函数的一开始，该函数会调用 <strong>prepareClientToWrite 函数</strong>，来判断是否推迟执行客户端写操作。下面代码展示了 addReply 函数对 prepareClientToWrite 函数的调用，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">addReply</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> robj <span class="token operator">*</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">prepareClientToWrite</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以这里，我们继续来看下 prepareClientToWrite 函数。这个函数会根据客户端设置的标识进行一系列的判断。其中，该函数会调用 <strong>clientHasPendingReplies 函数</strong>，判断当前客户端是否还有留存在输出缓冲区中的数据等待写回。</p> <p>如果没有的话，那么，prepareClientToWrite 就会调用 <strong>clientInstallWriteHandler 函数</strong>，再进一步判断能否推迟该客户端写操作。下面的代码展示了这一调用过程，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">prepareClientToWrite</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token comment">//如果当前客户端没有待写回数据，调用clientInstallWriteHandler函数</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">clientInstallWriteHandler</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么这样一来，我们其实就知道了，能否推迟客户端写操作，最终是由 clientInstallWriteHandler 函数来决定的，这个函数会判断两个条件。</p> <ul><li><strong>条件一</strong>：客户端没有设置过 CLIENT_PENDING_WRITE 标识，即没有被推迟过执行写操作。</li> <li><strong>条件二</strong>：客户端所在实例没有进行主从复制，或者客户端所在实例是主从复制中的从节点，但全量复制的 RDB 文件已经传输完成，客户端可以接收请求。</li></ul> <p>一旦这两个条件都满足了，clientInstallWriteHandler 函数就会把客户端标识设置为 CLIENT_PENDING_WRITE，表示推迟该客户端的写操作。同时，clientInstallWriteHandler 函数会把这个客户端添加到全局变量 server 的待写回客户端列表中，也就是 clients_pending_write 列表中。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">clientInstallWriteHandler</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//如果客户端没有设置过CLIENT_PENDING_WRITE标识，并且客户端没有在进行主从复制，或者客户端是主从复制中的从节点，已经能接收请求</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_PENDING_WRITE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>replstate <span class="token operator">==</span> REPL_STATE_NONE <span class="token operator">||</span>
         <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>replstate <span class="token operator">==</span> SLAVE_STATE_ONLINE <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>c<span class="token operator">-&gt;</span>repl_put_online_on_ack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">//将客户端的标识设置为待写回，即CLIENT_PENDING_WRITE</span>
        c<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> CLIENT_PENDING_WRITE<span class="token punctuation">;</span>
        <span class="token function">listAddNodeHead</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将可获得加入clients_pending_write列表</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了便于你更好地理解，我画了一张图，展示了 Redis 推迟客户端写操作的函数调用关系，你可以再回顾下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409171450799.png" alt="image-20240917145036743"></p> <p>不过，当 Redis 使用 clients_pending_read 和 clients_pending_write 两个列表，保存了推迟执行的客户端后，**这些客户端又是如何分配给多 IO 线程执行的呢？**这就和下面两个函数相关了。</p> <ul><li>handleClientsWithPendingReadsUsingThreads 函数：该函数主要负责将 clients_pending_read 列表中的客户端分配给 IO 线程进行处理。</li> <li>handleClientsWithPendingWritesUsingThreads 函数：该函数主要负责将 clients_pending_write 列表中的客户端分配给 IO 线程进行处理。</li></ul> <p>所以接下来，我们就来看下这两个函数的具体操作。</p> <h2 id="如何把待读客户端分配给-io-线程执行"><a href="#如何把待读客户端分配给-io-线程执行" class="header-anchor">#</a> 如何把待读客户端分配给 IO 线程执行？</h2> <p>首先，我们来了解 <strong>handleClientsWithPendingReadsUsingThreads 函数</strong>。这个函数是在 beforeSleep 函数中调用的。</p> <p>在 Redis 6.0 版本的代码中，事件驱动框架同样是调用 aeMain 函数来执行事件循环流程，该循环流程会调用 aeProcessEvents 函数处理各种事件。而在 aeProcessEvents 函数实际调用 aeApiPoll 函数捕获 IO 事件之前，beforeSleep 函数会被调用。</p> <p>这个过程如下图所示，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409171451107.png" alt="image-20240917145125065"></p> <p>handleClientsWithPendingReadsUsingThreads 函数的主要执行逻辑可以分成四步。</p> <p><strong>第一步</strong>，该函数会先根据全局变量 server 的 io_threads_active 成员变量，判定 IO 线程是否激活，并且根据 server 的 io_threads_do_reads 成员变量，判定用户是否设置了 Redis 可以用 IO 线程处理待读客户端。只有在 IO 线程激活，并且 IO 线程可以用于处理待读客户端时，handleClientsWithPendingReadsUsingThreads 函数才会继续执行，否则该函数就直接结束返回了。这一步的判断逻辑如以下代码所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>io_threads_active <span class="token operator">||</span> <span class="token operator">!</span>server<span class="token punctuation">.</span>io_threads_do_reads<span class="token punctuation">)</span> 
<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>第二步</strong>，handleClientsWithPendingReadsUsingThreads 函数会获取 clients_pending_read 列表的长度，这代表了要处理的待读客户端个数。然后，该函数会从 clients_pending_read 列表中逐一取出待处理的客户端，并用客户端在列表中的序号，对 IO 线程数量进行取模运算。</p> <p>这样一来，我们就可以根据取模得到的余数，把该客户端分配给对应的 IO 线程进行处理。紧接着，handleClientsWithPendingReadsUsingThreads 函数会<strong>调用 listAddNodeTail 函数，把分配好的客户端添加到 io_threads_list 列表的相应元素中</strong>。我刚才给你介绍过，io_threads_list 数组的每个元素是一个列表，对应保存了每个 IO 线程要处理的客户端。</p> <p>为了便于你理解，我来给你举个例子。</p> <p>假设 IO 线程数量设置为 3，clients_pending_read 列表中一共有 5 个待读客户端，它们在列表中的序号分别是 0，1，2，3 和 4。在这一步中，0 号到 4 号客户端对线程数量 3 取模的结果分别是 0，1，2，0，1，这也对应了即将处理这些客户端的 IO 线程编号。这也就是说，0 号客户端由 0 号线程处理，1 号客户端有 1 号线程处理，以此类推。你可以看到，这个分配方式其实就是把待处理客户端，以<strong>轮询方式</strong>逐一分配给各个 IO 线程。</p> <p>我画了下面这张图，展示了这个分配结果，你可以再看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409171451572.png" alt="image-20240917145140527"></p> <p>以下代码展示的就是以轮询方式将客户端分配给 IO 线程的执行逻辑：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> item_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">int</span> target_id <span class="token operator">=</span> item_id <span class="token operator">%</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span>
        <span class="token function">listAddNodeTail</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>target_id<span class="token punctuation">]</span><span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
        item_id<span class="token operator">++</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre></div><p>这样，当 handleClientsWithPendingReadsUsingThreads 函数完成客户端的 IO 线程分配之后，它会将 IO 线程的操作标识设置为<strong>读操作</strong>，也就是 IO_THREADS_OP_READ。然后，它会遍历 io_threads_list 数组中的每个元素列表长度，等待每个线程处理的客户端数量，赋值给 io_threads_pending 数组。这一过程如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code> io_threads_op <span class="token operator">=</span> IO_THREADS_OP_READ<span class="token punctuation">;</span>
 <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        io_threads_pending<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">;</span>
 <span class="token punctuation">}</span>
</code></pre></div><p><strong>第三步</strong>，handleClientsWithPendingReadsUsingThreads 函数会将 io_threads_list 数组 0 号列表（也就是 io_threads_list[0]元素）中的待读客户端逐一取出来，并调用 readQueryFromClient 函数进行处理。</p> <p>其实，handleClientsWithPendingReadsUsingThreads 函数本身就是由 IO 主线程执行的，而 io_threads_list 数组对应的 0 号线程正是 IO 主线程，所以，这里就是让主 IO 线程来处理它的待读客户端。</p> <div class="language-c extra-class"><pre class="language-c"><code>  <span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//获取0号列表中的所有客户端</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">listEmpty</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//处理完后，清空0号列表</span>
</code></pre></div><p>紧接着，handleClientsWithPendingReadsUsingThreads 函数会执行一个 while(1) 循环，等待所有 IO 线程完成待读客户端的处理，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">unsigned</span> <span class="token keyword">long</span> pending <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
            pending <span class="token operator">+=</span> io_threads_pending<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><p><strong>第四步</strong>，handleClientsWithPendingReadsUsingThreads 函数会再次遍历一遍 clients_pending_read 列表，依次取出其中的客户端。紧接着，它会判断客户端的标识中是否有 CLIENT_PENDING_COMMAND。如果有 CLIENT_PENDING_COMMAND 标识，表明该客户端中的命令已经被某一个 IO 线程解析过，已经可以被执行了。</p> <p>此时，handleClientsWithPendingReadsUsingThreads 函数会调用 processCommandAndResetClient 函数执行命令。最后，它会直接调用 processInputBuffer 函数解析客户端中所有命令并执行。</p> <p>这部分的代码逻辑如下所示，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ln <span class="token operator">=</span> <span class="token function">listFirst</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">)</span><span class="token punctuation">;</span>
        client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">//如果命令已经解析过，则执行该命令</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_PENDING_COMMAND<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>CLIENT_PENDING_COMMAND<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">processCommandAndResetClient</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">{</span>      
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token comment">//解析并执行所有命令</span>
        <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好了，到这里，你就了解了 clients_pending_read 列表中的待读客户端，是如何经过以上四个步骤来分配给 IO 线程进行处理的。下图展示了这个主要过程，你可以再回顾下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409171451258.png" alt="image-20240917145158198"></p> <p>那么，接下来，我们再来看下待写客户端的分配和处理。</p> <h2 id="如何把待写客户端分配给-io-线程执行"><a href="#如何把待写客户端分配给-io-线程执行" class="header-anchor">#</a> 如何把待写客户端分配给 IO 线程执行？</h2> <p>和待读客户端的分配处理类似，待写客户端分配处理是由 <strong>handleClientsWithPendingWritesUsingThreads 函数</strong>来完成的。该函数也是在 beforeSleep 函数中被调用的。</p> <p>handleClientsWithPendingWritesUsingThreads 函数的主要流程同样也可以分成 4 步，其中，第 2、3 和 4 步的执行逻辑，和 handleClientsWithPendingReadsUsingThreads 函数类似。</p> <p>简单来说，在第 2 步，handleClientsWithPendingWritesUsingThreads 函数会把待写客户端，按照<strong>轮询方式</strong>分配给 IO 线程，添加到 io_threads_list 数组各元素中。</p> <p>然后，在第 3 步，handleClientsWithPendingWritesUsingThreads 函数会让主 IO 线程处理其待写客户端，并执行 while(1) 循环等待所有 IO 线程完成处理。</p> <p>在第 4 步，handleClientsWithPendingWritesUsingThreads 函数会再次检查 clients_pending_write 列表中，是否还有待写的客户端。如果有的话，并且这些客户端还有留存在缓冲区中的数据，那么，handleClientsWithPendingWritesUsingThreads 函数就会调用 connSetWriteHandler 函数注册可写事件，而这个可写事件对应的回调函数是 <strong>sendReplyToClient 函数</strong>。</p> <p>等到事件循环流程再次执行时，刚才 handleClientsWithPendingWritesUsingThreads 函数注册的可写事件就会被处理，紧接着 sendReplyToClient 函数会执行，它会直接调用 writeToClient 函数，把客户端缓冲区中的数据写回。</p> <p>这里，<strong>你需要注意的是</strong>，connSetWriteHandler 函数最终会映射为 connSocketSetWriteHandler 函数，而 connSocketSetWriteHandler 函数是在<a href="https://github.com/redis/redis/tree/5.0/src/connection.c" target="_blank" rel="noopener noreferrer">connection.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文件中实现的。connSocketSetWriteHandler 函数会调用 aeCreateFileEvent 函数创建 AE_WRITABLE 事件，这就是刚才介绍的可写事件的注册（关于 aeCreateFileEvent 函数的使用，你也可以再回顾下第 11 讲）。</p> <p>不过，和 handleClientsWithPendingReadsUsingThreads 函数不同的是在第 1 步，handleClientsWithPendingWritesUsingThreads 函数，<strong>会判断 IO 线程数量是否为 1，或者待写客户端数量是否小于 IO 线程数量的 2 倍。</strong></p> <p>如果这两个条件中有一个条件成立，那么 handleClientsWithPendingWritesUsingThreads 函数就不会用多线程来处理客户端了，而是会调用 handleClientsWithPendingWrites 函数由主 IO 线程直接处理待写客户端。这样做的目的，主要是为了在待写客户端数量不多时，避免采用多线程，从而<strong>节省 CPU 开销</strong>。</p> <p>这一步的条件判断逻辑如下所示。其中，stopThreadedIOIfNeeded 函数主要是用来判断待写客户端数量，是否不足为 IO 线程数量的 2 倍。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_num <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token function">stopThreadedIOIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>另外，handleClientsWithPendingWritesUsingThreads 函数在第 1 步中，还会<strong>判断 IO 线程是否已激活</strong>。如果没有激活，它就会调用 startThreadedIO 函数，把全局变量 server 的 io_threads_active 成员变量值设置为 1，表示 IO 线程已激活。这步判断操作如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>io_threads_active<span class="token punctuation">)</span> <span class="token function">startThreadedIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>总之你要知道的就是，Redis 是通过 handleClientsWithPendingWritesUsingThreads 函数，把待写客户端按轮询方式分配给各个 IO 线程，并由它们来负责写回数据的。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>今天这节课，我给你介绍了 Redis 6.0 中新设计实现的<strong>多 IO 线程机制</strong>。这个机制的设计主要是为了使用多个 IO 线程，来并发处理客户端读取数据、解析命令和写回数据。使用了多线程后，Redis 就可以充分利用服务器的多核特性，从而<strong>提高 IO 效率</strong>。</p> <p>总结来说，Redis 6.0 先是在初始化过程中，根据用户设置的 IO 线程数量，创建对应数量的 IO 线程。</p> <p>当 Redis server 初始化完成后正常运行时，它会在 readQueryFromClient 函数中通过调用 postponeClientRead 函数来决定是否推迟客户端读操作。同时，Redis server 会在 addReply 函数中通过调用 prepareClientToWrite 函数，来决定是否推迟客户端写操作。而待读写的客户端会被分别加入到 clients_pending_read 和 clients_pending_write 两个列表中。</p> <p>这样，每当 Redis server 要进入事件循环流程前，都会在 beforeSleep 函数中分别调用 handleClientsWithPendingReadsUsingThreads 函数和 handleClientsWithPendingWritesUsingThreads 函数，将待读写客户端<strong>以轮询方式分配给 IO 线程</strong>，加入到 IO 线程的待处理客户端列表 io_threads_list 中。</p> <p>而 IO 线程一旦运行后，本身会一直检测 io_threads_list 中的客户端，如果有待读写客户端，IO 线程就会调用 readQueryFromClient 或 writeToClient 函数来进行处理。</p> <p>最后，我也想再提醒你一下，<strong>多 IO 线程本身并不会执行命令</strong>，它们只是利用多核并行地读取数据和解析命令，或是将 server 数据写回（下节课我还会结合分布式锁的原子性保证，来给你介绍这一部分的源码实现。）。所以，<strong>Redis 执行命令的线程还是主 IO 线程</strong>。这一点对于你理解多 IO 线程机制很重要，可以避免你误解 Redis 有多线程同时执行命令。</p> <p>这样一来，我们原来针对 Redis 单个主 IO 线程做的优化仍然有效，比如避免 bigkey、避免阻塞操作等。</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/Redis 系统设计/03.主线/15.深入 Redis 的多IO线程.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新于:</span> <span class="time">2024/09/17, 08:34:31</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/b4aed2/" class="prev">简述 Redis 多线程 IO</a></span> <span class="next"><a href="/pages/b43a19/">LRU 策略</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.aaad5302.js" defer></script><script src="/assets/js/2.933750c6.js" defer></script><script src="/assets/js/50.9bff482f.js" defer></script><script src="/assets/js/7.7eb70372.js" defer></script>
  </body>
</html>
