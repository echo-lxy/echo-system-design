<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>IO 多路复用详解 | EchoDesign</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="系统设计之「讲解 + 面试指南」，水滴石穿，设计无银弹！">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.c76c3453.css" as="style"><link rel="preload" href="/assets/js/app.9830b779.js" as="script"><link rel="preload" href="/assets/js/2.933750c6.js" as="script"><link rel="preload" href="/assets/js/38.40fe2658.js" as="script"><link rel="preload" href="/assets/js/7.7eb70372.js" as="script"><link rel="prefetch" href="/assets/js/10.2cc95be8.js"><link rel="prefetch" href="/assets/js/100.2b21dce5.js"><link rel="prefetch" href="/assets/js/101.96ca71f6.js"><link rel="prefetch" href="/assets/js/11.c7521a10.js"><link rel="prefetch" href="/assets/js/12.38d1989d.js"><link rel="prefetch" href="/assets/js/13.850793b0.js"><link rel="prefetch" href="/assets/js/14.1141ec27.js"><link rel="prefetch" href="/assets/js/15.12d1dea8.js"><link rel="prefetch" href="/assets/js/16.60cde607.js"><link rel="prefetch" href="/assets/js/17.acb3bf3d.js"><link rel="prefetch" href="/assets/js/18.e491edb6.js"><link rel="prefetch" href="/assets/js/19.daf31819.js"><link rel="prefetch" href="/assets/js/20.cb4a5c13.js"><link rel="prefetch" href="/assets/js/21.24c0f101.js"><link rel="prefetch" href="/assets/js/22.dd779f94.js"><link rel="prefetch" href="/assets/js/23.4d814163.js"><link rel="prefetch" href="/assets/js/24.891fe6fb.js"><link rel="prefetch" href="/assets/js/25.41dca26b.js"><link rel="prefetch" href="/assets/js/26.6337eac0.js"><link rel="prefetch" href="/assets/js/27.de80589e.js"><link rel="prefetch" href="/assets/js/28.95a1fb6b.js"><link rel="prefetch" href="/assets/js/29.371a40e1.js"><link rel="prefetch" href="/assets/js/3.e62a71e4.js"><link rel="prefetch" href="/assets/js/30.e32f6b31.js"><link rel="prefetch" href="/assets/js/31.a532917f.js"><link rel="prefetch" href="/assets/js/32.13b70e91.js"><link rel="prefetch" href="/assets/js/33.64ab8d0c.js"><link rel="prefetch" href="/assets/js/34.6d3cc288.js"><link rel="prefetch" href="/assets/js/35.2760ed8d.js"><link rel="prefetch" href="/assets/js/36.be98cc35.js"><link rel="prefetch" href="/assets/js/37.82be3556.js"><link rel="prefetch" href="/assets/js/39.84b6e82e.js"><link rel="prefetch" href="/assets/js/4.73518a0f.js"><link rel="prefetch" href="/assets/js/40.591baf2a.js"><link rel="prefetch" href="/assets/js/41.f961e422.js"><link rel="prefetch" href="/assets/js/42.b34f1599.js"><link rel="prefetch" href="/assets/js/43.5a509601.js"><link rel="prefetch" href="/assets/js/44.64fd3383.js"><link rel="prefetch" href="/assets/js/45.685623ac.js"><link rel="prefetch" href="/assets/js/46.7624d38c.js"><link rel="prefetch" href="/assets/js/47.5646b068.js"><link rel="prefetch" href="/assets/js/48.a1b270df.js"><link rel="prefetch" href="/assets/js/49.ee9681bc.js"><link rel="prefetch" href="/assets/js/5.94727770.js"><link rel="prefetch" href="/assets/js/50.b424b2c0.js"><link rel="prefetch" href="/assets/js/51.ef213b56.js"><link rel="prefetch" href="/assets/js/52.18c75eba.js"><link rel="prefetch" href="/assets/js/53.f76e624c.js"><link rel="prefetch" href="/assets/js/54.3098ec9f.js"><link rel="prefetch" href="/assets/js/55.4c46841d.js"><link rel="prefetch" href="/assets/js/56.10e3f10b.js"><link rel="prefetch" href="/assets/js/57.36581a94.js"><link rel="prefetch" href="/assets/js/58.e5a83b70.js"><link rel="prefetch" href="/assets/js/59.7b7e3faf.js"><link rel="prefetch" href="/assets/js/6.0b558b79.js"><link rel="prefetch" href="/assets/js/60.66a7f41d.js"><link rel="prefetch" href="/assets/js/61.52ab8e4e.js"><link rel="prefetch" href="/assets/js/62.cc8fdced.js"><link rel="prefetch" href="/assets/js/63.41ff19e4.js"><link rel="prefetch" href="/assets/js/64.9b3def35.js"><link rel="prefetch" href="/assets/js/65.0b2ab47d.js"><link rel="prefetch" href="/assets/js/66.2ae7a107.js"><link rel="prefetch" href="/assets/js/67.79dd6daf.js"><link rel="prefetch" href="/assets/js/68.1b76c178.js"><link rel="prefetch" href="/assets/js/69.7ac52a2f.js"><link rel="prefetch" href="/assets/js/70.7279b1df.js"><link rel="prefetch" href="/assets/js/71.4f744076.js"><link rel="prefetch" href="/assets/js/72.44c999da.js"><link rel="prefetch" href="/assets/js/73.526febf1.js"><link rel="prefetch" href="/assets/js/74.26f8d9a5.js"><link rel="prefetch" href="/assets/js/75.dc7fdd0f.js"><link rel="prefetch" href="/assets/js/76.32858593.js"><link rel="prefetch" href="/assets/js/77.7b3f6980.js"><link rel="prefetch" href="/assets/js/78.31a353ef.js"><link rel="prefetch" href="/assets/js/79.173bbc8c.js"><link rel="prefetch" href="/assets/js/8.0ec7f6e8.js"><link rel="prefetch" href="/assets/js/80.78a31e84.js"><link rel="prefetch" href="/assets/js/81.8d6c43d2.js"><link rel="prefetch" href="/assets/js/82.3b90a7cc.js"><link rel="prefetch" href="/assets/js/83.f3a9ee0c.js"><link rel="prefetch" href="/assets/js/84.eeb423e8.js"><link rel="prefetch" href="/assets/js/85.4cd3a775.js"><link rel="prefetch" href="/assets/js/86.931cbb70.js"><link rel="prefetch" href="/assets/js/87.78b2eebd.js"><link rel="prefetch" href="/assets/js/88.605444aa.js"><link rel="prefetch" href="/assets/js/89.b5690031.js"><link rel="prefetch" href="/assets/js/9.6e274fca.js"><link rel="prefetch" href="/assets/js/90.cdc8eb8f.js"><link rel="prefetch" href="/assets/js/91.8ad18b18.js"><link rel="prefetch" href="/assets/js/92.b554f1c7.js"><link rel="prefetch" href="/assets/js/93.fb2397b7.js"><link rel="prefetch" href="/assets/js/94.1eade7f0.js"><link rel="prefetch" href="/assets/js/95.96f5db04.js"><link rel="prefetch" href="/assets/js/96.5ed2d348.js"><link rel="prefetch" href="/assets/js/97.4d4bfff5.js"><link rel="prefetch" href="/assets/js/98.10f4b27a.js"><link rel="prefetch" href="/assets/js/99.4a895015.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c76c3453.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="EchoDesign" class="logo"> <span class="site-name can-hide">EchoDesign</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 深度剖析</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 深度剖析</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>一、前言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>二、基础知识</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/c0367e/" aria-current="page" class="active sidebar-link">IO 多路复用详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/c0367e/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/c0367e/#select" class="sidebar-link">select</a></li><li class="sidebar-sub-header level2"><a href="/pages/c0367e/#poll" class="sidebar-link">poll</a></li><li class="sidebar-sub-header level2"><a href="/pages/c0367e/#epoll" class="sidebar-link">epoll</a></li></ul></li><li><a href="/pages/3f7882/" class="sidebar-link">零拷贝详解</a></li><li><a href="/pages/cb89e4/" class="sidebar-link">Future 和 Promise</a></li><li><a href="/pages/9b88cb/" class="sidebar-link">TCP 拆包与粘包</a></li><li><a href="/pages/cab36c/" class="sidebar-link">心跳机制详解</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>三、主线任务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>四、深入 Netty 核心</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>五、深入 Netty 内存管理</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Netty 系统设计</span></li><li data-v-06225672><span data-v-06225672>二、基础知识</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-19</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">IO 多路复用详解<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>在<code>非阻塞IO</code>这一小节的开头，我们提到<code>网络IO模型</code>的演变都是围绕着---<strong>如何用尽可能少的线程去处理更多的连接</strong>这个核心需求开始展开的。</p> <p>本小节我们来谈谈<code>IO多路复用模型</code>，那么什么是<code>多路</code>？，什么又是<code>复用</code>呢？</p> <p>我们还是以这个核心需求来对这两个概念展开阐述：</p> <ul><li><strong>多路</strong>：我们的核心需求是要用尽可能少的线程来处理尽可能多的连接，这里的<code>多路</code>指的就是我们需要处理的众多连接。</li> <li><strong>复用</strong>：核心需求要求我们使用<code>尽可能少的线程</code>，<code>尽可能少的系统开销</code>去处理<code>尽可能多</code>的连接（<code>多路</code>），那么这里的<code>复用</code>指的就是用<code>有限的资源</code>，比如用一个线程或者固定数量的线程去处理众多连接上的读写事件。换句话说，在<code>阻塞IO模型</code>中一个连接就需要分配一个独立的线程去专门处理这个连接上的读写，到了<code>IO多路复用模型</code>中，多个连接可以<code>复用</code>这一个独立的线程去处理这多个连接上的读写。</li></ul> <p>好了，<code>IO多路复用模型</code>的概念解释清楚了，那么<strong>问题的关键</strong>是我们如何去实现这个<code>复用</code>，也就是如何让一个独立的线程去处理众多连接上的读写事件呢？</p> <p>这个问题其实在<code>非阻塞IO模型</code>中已经给出了它的答案，在<code>非阻塞IO模型</code>中，利用<code>非阻塞</code>的系统IO调用去不断的轮询众多连接的<code>Socket</code>接收缓冲区看是否有数据到来，如果有则处理，如果没有则继续轮询下一个<code>Socket</code>。这样就达到了用一个线程去处理众多连接上的读写事件了。</p> <p><strong>但是</strong><code>非阻塞IO模型</code>最大的问题就是需要不断的发起<code>系统调用</code>去轮询各个<code>Socket</code>中的接收缓冲区是否有数据到来，<code>频繁</code>的<code>系统调用</code>随之带来了大量的上下文切换开销。随着并发量的提升，这样也会导致非常严重的性能问题。</p> <p><strong>那么如何避免频繁的系统调用同时又可以实现我们的核心需求呢？</strong></p> <p>这就需要操作系统的内核来支持这样的操作，我们可以把频繁的轮询操作交给操作系统内核来替我们完成，这样就避免了在<code>用户空间</code>频繁的去使用系统调用来轮询所带来的性能开销。</p> <p>正如我们所想，操作系统内核也确实为我们提供了这样的功能实现，下面我们来一起看下操作系统对<code>IO多路复用模型</code>的实现。</p> <h2 id="select"><a href="#select" class="header-anchor">#</a> select</h2> <p><code>select</code>是操作系统内核提供给我们使用的一个<code>系统调用</code>，它解决了在<code>非阻塞IO模型</code>中需要不断的发起<code>系统IO调用</code>去轮询<code>各个连接上的Socket</code>接收缓冲区所带来的<code>用户空间</code>与<code>内核空间</code>不断切换的<code>系统开销</code>。</p> <p><code>select</code>系统调用将<code>轮询</code>的操作交给了<code>内核</code>来帮助我们完成，从而避免了在<code>用户空间</code>不断的发起轮询所带来的的系统性能开销。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409190918459.png" alt="图片"></p> <ul><li><p>首先用户线程在发起<code>select</code>系统调用的时候会<code>阻塞</code>在<code>select</code>系统调用上。此时，用户线程从<code>用户态</code>切换到了<code>内核态</code>完成了一次<code>上下文切换</code></p></li> <li><p>用户线程将需要监听的<code>Socket</code>对应的文件描述符<code>fd</code>数组通过<code>select</code>系统调用传递给内核。此时，用户线程将<code>用户空间</code>中的文件描述符<code>fd</code>数组<code>拷贝</code>到<code>内核空间</code>。</p></li></ul> <p>这里的<strong>文件描述符数组</strong>其实是一个<code>BitMap</code>，<code>BitMap</code>下标为<code>文件描述符fd</code>，下标对应的值为：<code>1</code>表示该<code>fd</code>上有读写事件，<code>0</code>表示该<code>fd</code>上没有读写事件。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409190918284.png" alt="图片"></p> <p><strong>文件描述符fd</strong>其实就是一个<code>整数值</code>，在Linux中一切皆文件，<code>Socket</code>也是一个文件。描述进程所有信息的数据结构<code>task_struct</code>中有一个属性<code>struct files_struct *files</code>，它最终指向了一个数组，数组里存放了进程打开的所有文件列表，文件信息封装在<code>struct file</code>结构体中，这个数组存放的类型就是<code>struct file</code>结构体，<code>数组的下标</code>则是我们常说的文件描述符<code>fd</code>。</p> <ul><li>当用户线程调用完<code>select</code>后开始进入<code>阻塞状态</code>，<code>内核</code>开始轮询遍历<code>fd</code>数组，查看<code>fd</code>对应的<code>Socket</code>接收缓冲区中是否有数据到来。如果有数据到来，则将<code>fd</code>对应<code>BitMap</code>的值设置为<code>1</code>。如果没有数据到来，则保持值为<code>0</code>。</li></ul> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p><strong>注意</strong>这里内核会修改原始的<code>fd</code>数组！！</p></div> <ul><li><p>内核遍历一遍<code>fd</code>数组后，如果发现有些<code>fd</code>上有IO数据到来，则将修改后的<code>fd</code>数组返回给用户线程。此时，会将<code>fd</code>数组从<code>内核空间</code>拷贝到<code>用户空间</code>。</p></li> <li><p>当内核将修改后的<code>fd</code>数组返回给用户线程后，用户线程解除<code>阻塞</code>，由用户线程开始遍历<code>fd</code>数组然后找出<code>fd</code>数组中值为<code>1</code>的<code>Socket</code>文件描述符。最后对这些<code>Socket</code>发起系统调用读取数据。</p></li></ul> <div class="custom-block note"><p class="custom-block-title">笔记</p> <p><code>select</code>不会告诉用户线程具体哪些<code>fd</code>上有IO数据到来，只是在<code>IO活跃</code>的<code>fd</code>上打上标记，将打好标记的完整<code>fd</code>数组返回给用户线程，所以用户线程还需要遍历<code>fd</code>数组找出具体哪些<code>fd</code>上有<code>IO数据</code>到来。</p></div> <ul><li>由于内核在遍历的过程中已经修改了<code>fd</code>数组，所以在用户线程遍历完<code>fd</code>数组后获取到<code>IO就绪</code>的<code>Socket</code>后，就需要<code>重置</code>fd数组，并重新调用<code>select</code>传入重置后的<code>fd</code>数组，让内核发起新的一轮遍历轮询。</li></ul> <h3 id="api介绍"><a href="#api介绍" class="header-anchor">#</a> API介绍</h3> <p>当我们熟悉了<code>select</code>的原理后，就很容易理解内核给我们提供的<code>select API</code>了。</p> <div class="language- extra-class"><pre class="language-text"><code> int select(int maxfdp1,fd_set *readset,fd_set *writeset,fd_set *exceptset,const struct timeval *timeout)
</code></pre></div><p>从<code>select API</code>中我们可以看到，<code>select</code>系统调用是在规定的<code>超时时间内</code>，监听（<code>轮询</code>）用户感兴趣的文件描述符集合上的<code>可读</code>,<code>可写</code>,<code>异常</code>三类事件。</p> <ul><li><code>maxfdp1 ：</code> select传递给内核监听的文件描述符集合中数值最大的文件描述符<code>+1</code>，目的是用于限定内核遍历范围。比如：<code>select</code>监听的文件描述符集合为<code>{0,1,2,3,4}</code>，那么<code>maxfdp1</code>的值为<code>5</code>。</li> <li><code>fd_set *readset：</code> 对<code>可读事件</code>感兴趣的文件描述符集合。</li> <li><code>fd_set *writeset：</code> 对<code>可写事件</code>感兴趣的文件描述符集合。</li> <li><code>fd_set *exceptset：</code>对<code>异常事件</code>感兴趣的文件描述符集合。</li></ul> <blockquote><p>这里的<code>fd_set</code>就是我们前边提到的<code>文件描述符数组</code>，是一个<code>BitMap</code>结构。</p></blockquote> <ul><li><code>const struct timeval *timeout：</code>select系统调用超时时间，在这段时间内，内核如果没有发现有<code>IO就绪</code>的文件描述符，就直接返回。</li></ul> <p>上小节提到，在<code>内核</code>遍历完<code>fd</code>数组后，发现有<code>IO就绪</code>的<code>fd</code>，则会将该<code>fd</code>对应的<code>BitMap</code>中的值设置为<code>1</code>，并将修改后的<code>fd</code>数组，返回给用户线程。</p> <p>在用户线程中需要重新遍历<code>fd</code>数组，找出<code>IO就绪</code>的<code>fd</code>出来，然后发起真正的读写调用。</p> <p>下面介绍下在用户线程中重新遍历<code>fd</code>数组的过程中，我们需要用到的<code>API</code>：</p> <ul><li><code>void FD_ZERO(fd_set *fdset)：</code>清空指定的文件描述符集合，即让<code>fd_set</code>中不在包含任何文件描述符。</li> <li><code>void FD_SET(int fd, fd_set *fdset)：</code>将一个给定的文件描述符加入集合之中。</li></ul> <blockquote><p>每次调用<code>select</code>之前都要通过<code>FD_ZERO</code>和<code>FD_SET</code>重新设置文件描述符，因为文件描述符集合会在<code>内核</code>中<code>被修改</code>。</p></blockquote> <ul><li><code>int FD_ISSET(int fd, fd_set *fdset)：</code>检查集合中指定的文件描述符是否可以读写。用户线程<code>遍历</code>文件描述符集合,调用该方法检查相应的文件描述符是否<code>IO就绪</code>。</li> <li><code>void FD_CLR(int fd, fd_set *fdset)：</code>将一个给定的文件描述符从集合中删除</li></ul> <h3 id="性能开销"><a href="#性能开销" class="header-anchor">#</a> 性能开销</h3> <p>虽然<code>select</code>解决了<code>非阻塞IO模型</code>中频繁发起<code>系统调用</code>的问题，但是在整个<code>select</code>工作过程中，我们还是看出了<code>select</code>有些不足的地方。</p> <ul><li>在发起<code>select</code>系统调用以及返回时，用户线程各发生了一次<code>用户态</code>到<code>内核态</code>以及<code>内核态</code>到<code>用户态</code>的上下文切换开销。<strong>发生2次上下文<code>切换</code></strong></li> <li>在发起<code>select</code>系统调用以及返回时，用户线程在<code>内核态</code>需要将<code>文件描述符集合</code>从用户空间<code>拷贝</code>到内核空间。以及在内核修改完<code>文件描述符集合</code>后，又要将它从内核空间<code>拷贝</code>到用户空间。<strong>发生2次文件描述符集合的<code>拷贝</code></strong></li> <li>虽然由原来在<code>用户空间</code>发起轮询<code>优化成了</code>在<code>内核空间</code>发起轮询但<code>select</code>不会告诉用户线程到底是哪些<code>Socket</code>上发生了<code>IO就绪</code>事件，只是对<code>IO就绪</code>的<code>Socket</code>作了标记，用户线程依然要<code>遍历</code>文件描述符集合去查找具体<code>IO就绪</code>的<code>Socket</code>。时间复杂度依然为<code>O(n)</code>。</li></ul> <blockquote><p>大部分情况下，网络连接并不总是活跃的，如果<code>select</code>监听了大量的客户端连接，只有少数的连接活跃，然而使用轮询的这种方式会随着连接数的增大，效率会越来越低。</p></blockquote> <ul><li><code>内核</code>会对原始的<code>文件描述符集合</code>进行修改。导致每次在用户空间重新发起<code>select</code>调用时，都需要对<code>文件描述符集合</code>进行<code>重置</code>。</li> <li><code>BitMap</code>结构的文件描述符集合，长度为固定的<code>1024</code>,所以只能监听<code>0~1023</code>的文件描述符。</li> <li><code>select</code>系统调用 不是线程安全的。</li></ul> <p>以上<code>select</code>的不足所产生的<code>性能开销</code>都会随着并发量的增大而<code>线性增长</code>。</p> <p>很明显<code>select</code>也不能解决<code>C10K</code>问题，只适用于<code>1000</code>个左右的并发连接场景。</p> <h2 id="poll"><a href="#poll" class="header-anchor">#</a> poll</h2> <p><code>poll</code>相当于是改进版的<code>select</code>，但是工作原理基本和<code>select</code>没有本质的区别。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">poll</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>fds<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> timeout<span class="token punctuation">)</span>
    
<span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span>   fd<span class="token punctuation">;</span>         <span class="token comment">/* 文件描述符 */</span>
    <span class="token keyword">short</span> events<span class="token punctuation">;</span>     <span class="token comment">/* 需要监听的事件 */</span>
    <span class="token keyword">short</span> revents<span class="token punctuation">;</span>    <span class="token comment">/* 实际发生的事件 由内核修改设置 */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p><code>select</code>中使用的文件描述符集合是采用的固定长度为1024的<code>BitMap</code>结构的<code>fd_set</code>，而<code>poll</code>换成了一个<code>pollfd</code>结构没有固定长度的数组，这样就没有了最大描述符数量的限制（当然还会受到系统文件描述符限制）</p> <p><code>poll</code>只是改进了<code>select</code>只能监听<code>1024</code>个文件描述符的数量限制，但是并没有在性能方面做出改进。和<code>select</code>上本质并没有多大差别。</p> <ul><li>同样需要在<code>内核空间</code>和<code>用户空间</code>中对文件描述符集合进行<code>轮询</code>，查找出<code>IO就绪</code>的<code>Socket</code>的时间复杂度依然为<code>O(n)</code>。</li> <li>同样需要将<code>包含大量文件描述符的集合</code>整体在<code>用户空间</code>和<code>内核空间</code>之间<code>来回复制</code>，<strong>无论这些文件描述符是否就绪</strong>。他们的开销都会随着文件描述符数量的增加而线性增大。</li> <li><code>select，poll</code>在每次新增，删除需要监听的socket时，都需要将整个新的<code>socket</code>集合全量传至<code>内核</code>。</li></ul> <p><code>poll</code>同样不适用高并发的场景。依然无法解决<code>C10K</code>问题。</p> <h2 id="epoll"><a href="#epoll" class="header-anchor">#</a> epoll</h2> <p>通过上边对<code>select,poll</code>核心原理的介绍，我们看到<code>select,poll</code>的性能瓶颈主要体现在下面三个地方：</p> <ul><li>因为内核不会保存我们要监听的<code>socket</code>集合，所以在每次调用<code>select,poll</code>的时候都需要传入，传出全量的<code>socket</code>文件描述符集合。这导致了大量的文件描述符在<code>用户空间</code>和<code>内核空间</code>频繁的来回复制。</li> <li>由于内核不会通知具体<code>IO就绪</code>的<code>socket</code>，只是在这些<code>IO就绪</code>的socket上打好标记，所以当<code>select</code>系统调用返回时，在<code>用户空间</code>还是需要<code>完整遍历</code>一遍<code>socket</code>文件描述符集合来获取具体<code>IO就绪</code>的<code>socket</code>。</li> <li>在<code>内核空间</code>中也是通过遍历的方式来得到<code>IO就绪</code>的<code>socket</code>。</li></ul> <p>下面我们来看下<code>epoll</code>是如何解决这些问题的。在介绍<code>epoll</code>的核心原理之前，我们需要介绍下理解<code>epoll</code>工作过程所需要的一些核心基础知识。</p> <h3 id="socket的创建"><a href="#socket的创建" class="header-anchor">#</a> Socket的创建</h3> <p>服务端线程调用<code>accept</code>系统调用后开始<code>阻塞</code>，当有客户端连接上来并完成<code>TCP三次握手</code>后，<code>内核</code>会创建一个对应的<code>Socket</code>作为服务端与客户端通信的<code>内核</code>接口。</p> <p>在Linux内核的角度看来，一切皆是文件，<code>Socket</code>也不例外，当内核创建出<code>Socket</code>之后，会将这个<code>Socket</code>放到当前进程所打开的文件列表中管理起来。</p> <p>下面我们来看下进程管理这些打开的文件列表相关的内核数据结构是什么样的？在了解完这些数据结构后，我们会更加清晰的理解<code>Socket</code>在内核中所发挥的作用。并且对后面我们理解<code>epoll</code>的创建过程有很大的帮助。</p> <h4 id="进程中管理文件列表结构"><a href="#进程中管理文件列表结构" class="header-anchor">#</a> 进程中管理文件列表结构</h4> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409190920121.png" alt="图片"></p> <p><code>struct tast_struct</code>是内核中用来表示进程的一个数据结构，它包含了进程的所有信息。本小节我们只列出和文件管理相关的属性。</p> <p>其中进程内打开的所有文件是通过一个数组<code>fd_array</code>来进行组织管理，数组的下标即为我们常提到的<code>文件描述符</code>，数组中存放的是对应的文件数据结构<code>struct file</code>。每打开一个文件，内核都会创建一个<code>struct file</code>与之对应，并在<code>fd_array</code>中找到一个空闲位置分配给它，数组中对应的下标，就是我们在<code>用户空间</code>用到的<code>文件描述符</code>。</p> <blockquote><p>对于任何一个进程，默认情况下，文件描述符 <code>0</code>表示 <code>stdin 标准输入</code>，文件描述符 <code>1</code>表示<code>stdout 标准输出</code>，文件描述符<code>2</code>表示<code>stderr 标准错误输出</code>。</p></blockquote> <p>进程中打开的文件列表<code>fd_array</code>定义在内核数据结构<code>struct files_struct</code>中，在<code>struct fdtable</code>结构中有一个指针<code>struct fd **fd</code>指向<code>fd_array</code>。</p> <p><strong>由于本小节讨论的是内核网络系统部分的数据结构</strong>，所以这里拿<code>Socket</code>文件类型来举例说明：</p> <p>用于封装文件元信息的内核数据结构<code>struct file</code>中的<code>private_data</code>指针指向具体的<code>Socket</code>结构。</p> <p><code>struct file</code>中的<code>file_operations</code>属性定义了文件的操作函数，不同的文件类型，对应的<code>file_operations</code>是不同的，针对<code>Socket</code>文件类型，这里的<code>file_operations</code>指向<code>socket_file_ops</code>。</p> <blockquote><p>我们在<code>用户空间</code>对<code>Socket</code>发起的读写等系统调用，进入内核首先会调用的是<code>Socket</code>对应的<code>struct file</code>中指向的<code>socket_file_ops</code>。<strong>比如</strong>：对<code>Socket</code>发起<code>write</code>写操作，在内核中首先被调用的就是<code>socket_file_ops</code>中定义的<code>sock_write_iter</code>。<code>Socket</code>发起<code>read</code>读操作内核中对应的则是<code>sock_read_iter</code>。</p></blockquote> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> socket_file_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>owner <span class="token operator">=</span>  THIS_MODULE<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>llseek <span class="token operator">=</span>  no_llseek<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>read_iter <span class="token operator">=</span>  sock_read_iter<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>write_iter <span class="token operator">=</span>  sock_write_iter<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>poll <span class="token operator">=</span>    sock_poll<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>unlocked_ioctl <span class="token operator">=</span> sock_ioctl<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>mmap <span class="token operator">=</span>    sock_mmap<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>release <span class="token operator">=</span>  sock_close<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>fasync <span class="token operator">=</span>  sock_fasync<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>sendpage <span class="token operator">=</span>  sock_sendpage<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>splice_write <span class="token operator">=</span> generic_splice_sendpage<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>splice_read <span class="token operator">=</span>  sock_splice_read<span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><h4 id="socket内核结构"><a href="#socket内核结构" class="header-anchor">#</a> Socket内核结构</h4> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409190922929.png" alt="图片"></p> <p>在我们进行网络程序的编写时会首先创建一个<code>Socket</code>，然后基于这个<code>Socket</code>进行<code>bind</code>，<code>listen</code>，我们先将这个<code>Socket</code>称作为<code>监听Socket</code>。</p> <ol><li>当我们调用<code>accept</code>后，内核会基于<code>监听Socket</code>创建出来一个新的<code>Socket</code>专门用于与客户端之间的网络通信。并将<code>监听Socket</code>中的<code>Socket操作函数集合</code>（<code>inet_stream_ops</code>）<code>ops</code>赋值到新的<code>Socket</code>的<code>ops</code>属性中。</li></ol> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">proto_ops</span> inet_stream_ops <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>bind <span class="token operator">=</span> inet_bind<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>connect <span class="token operator">=</span> inet_stream_connect<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>accept <span class="token operator">=</span> inet_accept<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>poll <span class="token operator">=</span> tcp_poll<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>listen <span class="token operator">=</span> inet_listen<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>sendmsg <span class="token operator">=</span> inet_sendmsg<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>recvmsg <span class="token operator">=</span> inet_recvmsg<span class="token punctuation">,</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>这里需要注意的是，<code>监听的 socket</code>和真正用来网络通信的 <code>Socket</code>，是两个 Socket，一个叫作<code>监听 Socket</code>，一个叫作<code>已连接的Socket</code>。</p></blockquote> <ol start="2"><li>接着内核会为<code>已连接的Socket</code>创建<code>struct file</code>并初始化，并把Socket文件操作函数集合（<code>socket_file_ops</code>）赋值给<code>struct file</code>中的<code>f_ops</code>指针。然后将<code>struct socket</code>中的<code>file</code>指针指向这个新分配申请的<code>struct file</code>结构体。</li></ol> <blockquote><p>内核会维护两个队列：</p> <ul><li>一个是已经完成<code>TCP三次握手</code>，连接状态处于<code>established</code>的连接队列。内核中为<code>icsk_accept_queue</code>。</li> <li>一个是还没有完成<code>TCP三次握手</code>，连接状态处于<code>syn_rcvd</code>的半连接队列。</li></ul></blockquote> <ol start="3"><li>然后调用<code>socket-&gt;ops-&gt;accept</code>，从<code>Socket内核结构图</code>中我们可以看到其实调用的是<code>inet_accept</code>，该函数会在<code>icsk_accept_queue</code>中查找是否有已经建立好的连接，如果有的话，直接从<code>icsk_accept_queue</code>中获取已经创建好的<code>struct sock</code>。并将这个<code>struct sock</code>对象赋值给<code>struct socket</code>中的<code>sock</code>指针。</li></ol> <p><code>struct sock</code>在<code>struct socket</code>中是一个非常核心的内核对象，正是在这里定义了我们在介绍<code>网络包的接收发送流程</code>中提到的<code>接收队列</code>，<code>发送队列</code>，<code>等待队列</code>，<code>数据就绪回调函数指针</code>，<code>内核协议栈操作函数集合</code></p> <p>struct sock<code>在</code>struct socket<code>中是一个非常核心的内核对象，正是在这里定义了我们在介绍</code>网络包的接收发送流程<code>中提到的</code>接收队列<code>，</code>发送队列<code>，</code>等待队列<code>，</code>数据就绪回调函数指针<code>，</code>内核协议栈操作函数集合</p> <ul><li>根据创建<code>Socket</code>时发起的系统调用<code>sock_create</code>中的<code>protocol</code>参数(对于<code>TCP协议</code>这里的参数值为<code>SOCK_STREAM</code>)查找到对于 tcp 定义的操作方法实现集合 <code>inet_stream_ops</code> 和<code>tcp_prot</code>。并把它们分别设置到<code>socket-&gt;ops</code>和<code>sock-&gt;sk_prot</code>上。</li></ul> <blockquote><p>这里可以回看下本小节开头的《Socket内核结构图》捋一下他们之间的关系。</p></blockquote> <blockquote><p><code>socket</code>相关的操作接口定义在<code>inet_stream_ops</code>函数集合中，负责对上给用户提供接口。而<code>socket</code>与内核协议栈之间的操作接口定义在<code>struct sock</code>中的<code>sk_prot</code>指针上，这里指向<code>tcp_prot</code>协议操作函数集合。</p></blockquote> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">proto</span> tcp_prot <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token punctuation">.</span>name      <span class="token operator">=</span> <span class="token string">&quot;TCP&quot;</span><span class="token punctuation">,</span>
  <span class="token punctuation">.</span>owner      <span class="token operator">=</span> THIS_MODULE<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>close      <span class="token operator">=</span> tcp_close<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>connect    <span class="token operator">=</span> tcp_v4_connect<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>disconnect    <span class="token operator">=</span> tcp_disconnect<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>accept      <span class="token operator">=</span> inet_csk_accept<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>keepalive    <span class="token operator">=</span> tcp_set_keepalive<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>recvmsg    <span class="token operator">=</span> tcp_recvmsg<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>sendmsg    <span class="token operator">=</span> tcp_sendmsg<span class="token punctuation">,</span>
  <span class="token punctuation">.</span>backlog_rcv    <span class="token operator">=</span> tcp_v4_do_rcv<span class="token punctuation">,</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>之前提到的对<code>Socket</code>发起的系统IO调用，在内核中首先会调用<code>Socket</code>的文件结构<code>struct file</code>中的<code>file_operations</code>文件操作集合，然后调用<code>struct socket</code>中的<code>ops</code>指向的<code>inet_stream_ops</code>socket操作函数，最终调用到<code>struct sock</code>中<code>sk_prot</code>指针指向的<code>tcp_prot</code>内核协议栈操作函数接口集合。</p></blockquote> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409190923558.png" alt="图片"></p> <ul><li>将<code>struct sock</code> 对象中的<code>sk_data_ready</code> 函数指针设置为 <code>sock_def_readable</code>，在<code>Socket</code>数据就绪的时候内核会回调该函数。</li> <li><code>struct sock</code>中的<code>等待队列</code>中存放的是系统IO调用发生阻塞的<code>进程fd</code>，以及相应的<code>回调函数</code>。<strong>记住这个地方，后边介绍epoll的时候我们还会提到！</strong></li></ul> <ol start="4"><li>当<code>struct file</code>，<code>struct socket</code>，<code>struct sock</code>这些核心的内核对象创建好之后，最后就是把<code>socket</code>对象对应的<code>struct file</code>放到进程打开的文件列表<code>fd_array</code>中。随后系统调用<code>accept</code>返回<code>socket</code>的文件描述符<code>fd</code>给用户程序。</li></ol> <h3 id="阻塞io中用户进程阻塞以及唤醒原理"><a href="#阻塞io中用户进程阻塞以及唤醒原理" class="header-anchor">#</a> 阻塞IO中用户进程阻塞以及唤醒原理</h3> <p>在前边小节我们介绍<code>阻塞IO</code>的时候提到，当用户进程发起系统IO调用时，这里我们拿<code>read</code>举例，用户进程会在<code>内核态</code>查看对应<code>Socket</code>接收缓冲区是否有数据到来。</p> <ul><li><code>Socket</code>接收缓冲区有数据，则拷贝数据到<code>用户空间</code>，系统调用返回。</li> <li><code>Socket</code>接收缓冲区没有数据，则用户进程让出<code>CPU</code>进入<code>阻塞状态</code>，当数据到达接收缓冲区时，用户进程会被唤醒，从<code>阻塞状态</code>进入<code>就绪状态</code>，等待CPU调度。</li></ul> <p>本小节我们就来看下用户进程是如何<code>阻塞</code>在<code>Socket</code>上，又是如何在<code>Socket</code>上被唤醒的。<strong>理解这个过程很重要，对我们理解epoll的事件通知过程很有帮助</strong></p> <ul><li>首先我们在用户进程中对<code>Socket</code>进行<code>read</code>系统调用时，用户进程会从<code>用户态</code>转为<code>内核态</code>。</li> <li>在进程的<code>struct task_struct</code>结构找到<code>fd_array</code>，并根据<code>Socket</code>的文件描述符<code>fd</code>找到对应的<code>struct file</code>，调用<code>struct file</code>中的文件操作函数结合<code>file_operations</code>，<code>read</code>系统调用对应的是<code>sock_read_iter</code>。</li> <li>在<code>sock_read_iter</code>函数中找到<code>struct file</code>指向的<code>struct socket</code>，并调用<code>socket-&gt;ops-&gt;recvmsg</code>，这里我们知道调用的是<code>inet_stream_ops</code>集合中定义的<code>inet_recvmsg</code>。</li> <li>在<code>inet_recvmsg</code>中会找到<code>struct sock</code>，并调用<code>sock-&gt;skprot-&gt;recvmsg</code>,这里调用的是<code>tcp_prot</code>集合中定义的<code>tcp_recvmsg</code>函数。</li></ul> <blockquote><p>整个调用过程可以参考上边的《系统IO调用结构图》</p></blockquote> <p>熟悉了内核函数调用栈后，我们来看下系统IO调用在<code>tcp_recvmsg</code>内核函数中是如何将用户进程给阻塞掉的</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409190926378.png" alt="图片"></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">tcp_recvmsg</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">kiocb</span> <span class="token operator">*</span>iocb<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">msghdr</span> <span class="token operator">*</span>msg<span class="token punctuation">,</span>
  <span class="token class-name">size_t</span> len<span class="token punctuation">,</span> <span class="token keyword">int</span> nonblock<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token operator">*</span>addr_len<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略非核心代码<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token comment">//访问sock对象中定义的接收队列</span>
  <span class="token function">skb_queue_walk</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-&gt;</span>sk_receive_queue<span class="token punctuation">,</span> skb<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略非核心代码<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

  <span class="token comment">//没有收到足够数据，调用sk_wait_data 阻塞当前进程</span>
  <span class="token function">sk_wait_data</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">sk_wait_data</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sock</span> <span class="token operator">*</span>sk<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token operator">*</span>timeo<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
 <span class="token comment">//创建struct sock中等待队列上的元素wait_queue_t</span>
 <span class="token comment">//将进程描述符和回调函数autoremove_wake_function关联到wait_queue_t中</span>
 <span class="token function">DEFINE_WAIT</span><span class="token punctuation">(</span>wait<span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">// 调用 sk_sleep 获取 sock 对象下的等待队列的头指针wait_queue_head_t</span>
 <span class="token comment">// 调用prepare_to_wait将新创建的等待项wait_queue_t插入到等待队列中，并将进程状态设置为可打断 INTERRUPTIBLE</span>
 <span class="token function">prepare_to_wait</span><span class="token punctuation">(</span><span class="token function">sk_sleep</span><span class="token punctuation">(</span>sk<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>wait<span class="token punctuation">,</span> TASK_INTERRUPTIBLE<span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token function">set_bit</span><span class="token punctuation">(</span>SOCK_ASYNC_WAITDATA<span class="token punctuation">,</span> <span class="token operator">&amp;</span>sk<span class="token operator">-&gt;</span>sk_socket<span class="token operator">-&gt;</span>flags<span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token comment">// 通过调用schedule_timeout让出CPU，然后进行睡眠，导致一次上下文切换</span>
 rc <span class="token operator">=</span> <span class="token function">sk_wait_event</span><span class="token punctuation">(</span>sk<span class="token punctuation">,</span> timeo<span class="token punctuation">,</span> <span class="token operator">!</span><span class="token function">skb_queue_empty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>sk<span class="token operator">-&gt;</span>sk_receive_queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><ul><li>首先会在<code>DEFINE_WAIT</code>中创建<code>struct sock</code>中等待队列上的等待类型<code>wait_queue_t</code>。</li></ul> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DEFINE_WAIT</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token function">DEFINE_WAIT_FUNC</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> autoremove_wake_function<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">DEFINE_WAIT_FUNC</span><span class="token expression"><span class="token punctuation">(</span>name<span class="token punctuation">,</span> function<span class="token punctuation">)</span>    </span><span class="token punctuation">\</span>
 <span class="token expression"><span class="token class-name">wait_queue_t</span> name <span class="token operator">=</span> <span class="token punctuation">{</span>      </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">.</span>private <span class="token operator">=</span> current<span class="token punctuation">,</span>    </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">.</span>func  <span class="token operator">=</span> function<span class="token punctuation">,</span>    </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">.</span>task_list <span class="token operator">=</span> <span class="token function">LIST_HEAD_INIT</span><span class="token punctuation">(</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span>task_list<span class="token punctuation">)</span><span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
 <span class="token expression"><span class="token punctuation">}</span></span></span>
</code></pre></div><p>等待类型<code>wait_queue_t</code>中的<code>private</code>用来关联<code>阻塞</code>在当前<code>socket</code>上的用户进程<code>fd</code>。<code>func</code>用来关联等待项上注册的回调函数。这里注册的是<code>autoremove_wake_function</code>。</p> <ul><li>调用<code>sk_sleep(sk)</code>获取<code>struct sock</code>对象中的等待队列头指针<code>wait_queue_head_t</code>。</li> <li>调用<code>prepare_to_wait</code>将新创建的等待项<code>wait_queue_t</code>插入到等待队列中，并将进程设置为可打断 <code>INTERRUPTIBL</code>。</li> <li>调用<code>sk_wait_event</code>让出CPU，进程进入睡眠状态。</li></ul> <p>用户进程的<code>阻塞过程</code>我们就介绍完了，关键是要理解记住<code>struct sock</code>中定义的等待队列上的等待类型<code>wait_queue_t</code>的结构。后面<code>epoll</code>的介绍中我们还会用到它。</p> <p><strong>下面我们接着介绍当数据就绪后，用户进程是如何被唤醒的</strong></p> <p>在本文开始介绍《网络包接收过程》这一小节中我们提到：</p> <ul><li>当网络数据包到达网卡时，网卡通过<code>DMA</code>的方式将数据放到<code>RingBuffer</code>中。</li> <li>然后向CPU发起硬中断，在硬中断响应程序中创建<code>sk_buffer</code>，并将网络数据拷贝至<code>sk_buffer</code>中。</li> <li>随后发起软中断，内核线程<code>ksoftirqd</code>响应软中断，调用<code>poll函数</code>将<code>sk_buffer</code>送往内核协议栈做层层协议处理。</li> <li>在传输层<code>tcp_rcv 函数</code>中，去掉TCP头，根据<code>四元组（源IP，源端口，目的IP，目的端口）</code>查找对应的<code>Socket</code>。</li> <li>最后将<code>sk_buffer</code>放到<code>Socket</code>中的接收队列里。</li></ul> <p>上边这些过程是内核接收网络数据的完整过程，下边我们来看下，当数据包接收完毕后，用户进程是如何被唤醒的。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409190928958.png" alt="图片"></p> <ul><li><p>当软中断将<code>sk_buffer</code>放到<code>Socket</code>的接收队列上时，接着就会调用<code>数据就绪函数回调指针sk_data_ready</code>，前边我们提到，这个函数指针在初始化的时候指向了<code>sock_def_readable</code>函数。</p></li> <li><p>在<code>sock_def_readable</code>函数中会去获取<code>socket-&gt;sock-&gt;sk_wq</code>等待队列。在<code>wake_up_common</code>函数中从等待队列<code>sk_wq</code>中找出<code>一个</code>等待项<code>wait_queue_t</code>，回调注册在该等待项上的<code>func</code>回调函数（<code>wait_queue_t-&gt;func</code>）,创建等待项<code>wait_queue_t</code>是我们提到，这里注册的回调函数是<code>autoremove_wake_function</code>。</p></li></ul> <blockquote><p>即使是有多个进程都阻塞在同一个 socket 上，也只唤醒 1 个进程。其作用是为了避免惊群。</p></blockquote> <ul><li>在<code>autoremove_wake_function</code>函数中，根据等待项<code>wait_queue_t</code>上的<code>private</code>关联的<code>阻塞进程fd</code>调用<code>try_to_wake_up</code>唤醒阻塞在该<code>Socket</code>上的进程。</li></ul> <blockquote><p>记住<code>wait_queue_t</code>中的<code>func</code>函数指针，在<code>epoll</code>中这里会注册<code>epoll</code>的回调函数。</p></blockquote> <p>现在理解<code>epoll</code>所需要的基础知识我们就介绍完了，唠叨了这么多，下面终于正式进入本小节的主题<code>epoll</code>了。</p> <h3 id="epoll-create创建epoll对象"><a href="#epoll-create创建epoll对象" class="header-anchor">#</a> epoll_create创建epoll对象</h3> <p><code>epoll_create</code>是内核提供给我们创建<code>epoll</code>对象的一个系统调用，当我们在用户进程中调用<code>epoll_create</code>时，内核会为我们创建一个<code>struct eventpoll</code>对象，并且也有相应的<code>struct file</code>与之关联，同样需要把这个<code>struct eventpoll</code>对象所关联的<code>struct file</code>放入进程打开的文件列表<code>fd_array</code>中管理。</p> <blockquote><p>熟悉了<code>Socket</code>的创建逻辑，<code>epoll</code>的创建逻辑也就不难理解了。</p></blockquote> <blockquote><p><code>struct eventpoll</code>对象关联的<code>struct file</code>中的<code>file_operations 指针</code>指向的是<code>eventpoll_fops</code>操作函数集合。</p></blockquote> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">file_operations</span> eventpoll_fops <span class="token operator">=</span> <span class="token punctuation">{</span>
     <span class="token punctuation">.</span>release <span class="token operator">=</span> ep_eventpoll_release<span class="token punctuation">;</span>
     <span class="token punctuation">.</span>poll <span class="token operator">=</span> ep_eventpoll_poll<span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409190930088.png" alt="图片"></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token punctuation">{</span>

    <span class="token comment">//等待队列，阻塞在epoll上的进程会放在这里</span>
    <span class="token class-name">wait_queue_head_t</span> wq<span class="token punctuation">;</span>

    <span class="token comment">//就绪队列，IO就绪的socket连接会放在这里</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdllist<span class="token punctuation">;</span>

    <span class="token comment">//红黑树用来管理所有监听的socket连接</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_root</span> rbr<span class="token punctuation">;</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><code>wait_queue_head_t wq：</code>epoll中的等待队列，队列里存放的是<code>阻塞</code>在<code>epoll</code>上的用户进程。在<code>IO就绪</code>的时候<code>epoll</code>可以通过这个队列找到这些<code>阻塞</code>的进程并唤醒它们，从而执行<code>IO调用</code>读写<code>Socket</code>上的数据。</li></ul> <blockquote><p>这里注意与<code>Socket</code>中的等待队列区分！！！</p></blockquote> <ul><li><code>struct list_head rdllist：</code>epoll中的就绪队列，队列里存放的是都是<code>IO就绪</code>的<code>Socket</code>，被唤醒的用户进程可以直接读取这个队列获取<code>IO活跃</code>的<code>Socket</code>。无需再次遍历整个<code>Socket</code>集合。</li></ul> <blockquote><p>这里正是<code>epoll</code>比<code>select ，poll</code>高效之处，<code>select ，poll</code>返回的是全部的<code>socket</code>连接，我们需要在<code>用户空间</code>再次遍历找出真正<code>IO活跃</code>的<code>Socket</code>连接。而<code>epoll</code>只是返回<code>IO活跃</code>的<code>Socket</code>连接。用户进程可以直接进行IO操作。</p></blockquote> <ul><li><code>struct rb_root rbr :</code> 由于红黑树在<code>查找</code>，<code>插入</code>，<code>删除</code>等综合性能方面是最优的，所以epoll内部使用一颗红黑树来管理海量的<code>Socket</code>连接。</li></ul> <blockquote><p><code>select</code>用<code>数组</code>管理连接，<code>poll</code>用<code>链表</code>管理连接。</p></blockquote> <h3 id="epoll-ctl向epoll对象中添加监听的socket"><a href="#epoll-ctl向epoll对象中添加监听的socket" class="header-anchor">#</a> epoll_ctl向epoll对象中添加监听的Socket</h3> <p>当我们调用<code>epoll_create</code>在内核中创建出<code>epoll</code>对象<code>struct eventpoll</code>后，我们就可以利用<code>epoll_ctl</code>向<code>epoll</code>中添加我们需要管理的<code>Socket</code>连接了。</p> <ol><li>首先要在epoll内核中创建一个表示<code>Socket连接</code>的数据结构<code>struct epitem</code>，而在<code>epoll</code>中为了综合性能的考虑，采用一颗红黑树来管理这些海量<code>socket连接</code>。所以<code>struct epitem</code>是一个红黑树节点。</li></ol> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409190932959.png" alt="图片"></p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">epitem</span>
<span class="token punctuation">{</span>
    <span class="token comment">//指向所属epoll对象</span>
    <span class="token keyword">struct</span> <span class="token class-name">eventpoll</span> <span class="token operator">*</span>ep<span class="token punctuation">;</span> 
    <span class="token comment">//注册的感兴趣的事件,也就是用户空间的epoll_event     </span>
    <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> event<span class="token punctuation">;</span> 
    <span class="token comment">//指向epoll对象中的就绪队列</span>
    <span class="token keyword">struct</span> <span class="token class-name">list_head</span> rdllink<span class="token punctuation">;</span>  
    <span class="token comment">//指向epoll中对应的红黑树节点</span>
    <span class="token keyword">struct</span> <span class="token class-name">rb_node</span> rbn<span class="token punctuation">;</span>     
    <span class="token comment">//指向epitem所表示的socket-&gt;file结构以及对应的fd</span>
    <span class="token keyword">struct</span> <span class="token class-name">epoll_filefd</span> ffd<span class="token punctuation">;</span>                  
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>这里重点记住<code>struct epitem</code>结构中的<code>rdllink</code>以及<code>epoll_filefd</code>成员，后面我们会用到。</p></blockquote> <ol start="2"><li>在内核中创建完表示<code>Socket连接</code>的数据结构<code>struct epitem</code>后，我们就需要在<code>Socket</code>中的等待队列上创建等待项<code>wait_queue_t</code>并且注册<code>epoll的回调函数ep_poll_callback</code>。</li></ol> <p>通过<code>《阻塞IO中用户进程阻塞以及唤醒原理》</code>小节的铺垫，我想大家已经猜到这一步的意义所在了吧！当时在等待项<code>wait_queue_t</code>中注册的是<code>autoremove_wake_function</code>回调函数。还记得吗？</p> <blockquote><p>epoll的回调函数<code>ep_poll_callback</code>正是<code>epoll</code>同步IO事件通知机制的核心所在，也是区别于<code>select，poll</code>采用内核轮询方式的根本性能差异所在。</p></blockquote> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409190933396.png" alt="图片"></p> <p><strong>这里又出现了一个新的数据结构<code>struct eppoll_entry</code>，那它的作用是干什么的呢？大家可以结合上图先猜测下它的作用!</strong></p> <p>我们知道<code>socket-&gt;sock-&gt;sk_wq</code>等待队列中的类型是<code>wait_queue_t</code>，我们需要在<code>struct epitem</code>所表示的<code>socket</code>的等待队列上注册<code>epoll</code>回调函数<code>ep_poll_callback</code>。</p> <p>这样当数据到达<code>socket</code>中的接收队列时，内核会回调<code>sk_data_ready</code>，在<code>阻塞IO中用户进程阻塞以及唤醒原理</code>这一小节中，我们知道这个<code>sk_data_ready</code>函数指针会指向<code>sk_def_readable</code>函数，在<code>sk_def_readable</code>中会回调注册在等待队列里的等待项<code>wait_queue_t -&gt; func</code>回调函数<code>ep_poll_callback</code>。<strong>在<code>ep_poll_callback</code>中需要找到<code>epitem</code></strong>，将<code>IO就绪</code>的<code>epitem</code>放入<code>epoll</code>中的就绪队列中。</p> <p>而<code>socket</code>等待队列中类型是<code>wait_queue_t</code>无法关联到<code>epitem</code>。所以就出现了<code>struct eppoll_entry</code>结构体，它的作用就是关联<code>Socket</code>等待队列中的等待项<code>wait_queue_t</code>和<code>epitem</code>。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">eppoll_entry</span> <span class="token punctuation">{</span> 
    <span class="token comment">//指向关联的epitem</span>
    <span class="token keyword">struct</span> <span class="token class-name">epitem</span> <span class="token operator">*</span>base<span class="token punctuation">;</span> 

    <span class="token comment">// 关联监听socket中等待队列中的等待项 (private = null  func = ep_poll_callback)</span>
    <span class="token class-name">wait_queue_t</span> wait<span class="token punctuation">;</span>   

    <span class="token comment">// 监听socket中等待队列头指针</span>
    <span class="token class-name">wait_queue_head_t</span> <span class="token operator">*</span>whead<span class="token punctuation">;</span> 
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> 
</code></pre></div><p>这样在<code>ep_poll_callback</code>回调函数中就可以根据<code>Socket</code>等待队列中的等待项<code>wait</code>，通过<code>container_of宏</code>找到<code>eppoll_entry</code>，继而找到<code>epitem</code>了。</p> <blockquote><p><code>container_of</code>在Linux内核中是一个常用的宏，用于从包含在某个结构中的指针获得结构本身的指针，通俗地讲就是通过结构体变量中某个成员的首地址进而获得整个结构体变量的首地址。</p></blockquote> <blockquote><p>这里需要注意下这次等待项<code>wait_queue_t</code>中的<code>private</code>设置的是<code>null</code>，因为这里<code>Socket</code>是交给<code>epoll</code>来管理的，阻塞在<code>Socket</code>上的进程是也由<code>epoll</code>来唤醒。在等待项<code>wait_queue_t</code>注册的<code>func</code>是<code>ep_poll_callback</code>而不是<code>autoremove_wake_function</code>，<code>阻塞进程</code>并不需要<code>autoremove_wake_function</code>来唤醒，所以这里设置<code>private</code>为<code>null</code></p></blockquote> <ol start="3"><li>当在<code>Socket</code>的等待队列中创建好等待项<code>wait_queue_t</code>并且注册了<code>epoll</code>的回调函数<code>ep_poll_callback</code>，然后又通过<code>eppoll_entry</code>关联了<code>epitem</code>后。剩下要做的就是将<code>epitem</code>插入到<code>epoll</code>中的红黑树<code>struct rb_root rbr</code>中。</li></ol> <blockquote><p>这里可以看到<code>epoll</code>另一个优化的地方，<code>epoll</code>将所有的<code>socket</code>连接通过内核中的红黑树来集中管理。每次添加或者删除<code>socket连接</code>都是增量添加删除，而不是像<code>select，poll</code>那样每次调用都是全量<code>socket连接</code>集合传入内核。避免了<code>频繁大量</code>的<code>内存拷贝</code>。</p></blockquote> <h3 id="epoll-wait同步阻塞获取io就绪的socket"><a href="#epoll-wait同步阻塞获取io就绪的socket" class="header-anchor">#</a> epoll_wait同步阻塞获取IO就绪的Socket</h3> <ol><li>用户程序调用<code>epoll_wait</code>后，内核首先会查找epoll中的就绪队列<code>eventpoll-&gt;rdllist</code>是否有<code>IO就绪</code>的<code>epitem</code>。<code>epitem</code>里封装了<code>socket</code>的信息。如果就绪队列中有就绪的<code>epitem</code>，就将<code>就绪的socket</code>信息封装到<code>epoll_event</code>返回。</li> <li>如果<code>eventpoll-&gt;rdllist</code>就绪队列中没有<code>IO就绪</code>的<code>epitem</code>，则会创建等待项<code>wait_queue_t</code>，将用户进程的<code>fd</code>关联到<code>wait_queue_t-&gt;private</code>上，并在等待项<code>wait_queue_t-&gt;func</code>上注册回调函数<code>default_wake_function</code>。最后将等待项添加到<code>epoll</code>中的等待队列中。用户进程让出CPU，进入<code>阻塞状态</code>。</li></ol> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409190936059.png" alt="图片"></p> <blockquote><p>这里和<code>阻塞IO模型</code>中的阻塞原理是一样的，只不过在<code>阻塞IO模型</code>中注册到等待项<code>wait_queue_t-&gt;func</code>上的是<code>autoremove_wake_function</code>，并将等待项添加到<code>socket</code>中的等待队列中。这里注册的是<code>default_wake_function</code>，将等待项添加到<code>epoll</code>中的等待队列上。</p></blockquote> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409190936947.png" alt="图片"></p> <ol start="3"><li><strong>前边做了那么多的知识铺垫，下面终于到了<code>epoll</code>的整个工作流程了：</strong></li></ol> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409190936732.png" alt="图片"></p> <ul><li>当网络数据包在软中断中经过内核协议栈的处理到达<code>socket</code>的接收缓冲区时，紧接着会调用socket的数据就绪回调指针<code>sk_data_ready</code>，回调函数为<code>sock_def_readable</code>。在<code>socket</code>的等待队列中找出等待项，其中等待项中注册的回调函数为<code>ep_poll_callback</code>。</li> <li>在回调函数<code>ep_poll_callback</code>中，根据<code>struct eppoll_entry</code>中的<code>struct wait_queue_t wait</code>通过<code>container_of宏</code>找到<code>eppoll_entry</code>对象并通过它的<code>base</code>指针找到封装<code>socket</code>的数据结构<code>struct epitem</code>，并将它加入到<code>epoll</code>中的就绪队列<code>rdllist</code>中。</li> <li>随后查看<code>epoll</code>中的等待队列中是否有等待项，也就是说查看是否有进程阻塞在<code>epoll_wait</code>上等待<code>IO就绪</code>的<code>socket</code>。如果没有等待项，则软中断处理完成。</li> <li>如果有等待项，则回到注册在等待项中的回调函数<code>default_wake_function</code>,在回调函数中唤醒<code>阻塞进程</code>，并将就绪队列<code>rdllist</code>中的<code>epitem</code>的<code>IO就绪</code>socket信息封装到<code>struct epoll_event</code>中返回。</li> <li>用户进程拿到<code>epoll_event</code>获取<code>IO就绪</code>的socket，发起系统IO调用读取数据。</li></ul> <h3 id="再谈水平触发和边缘触发"><a href="#再谈水平触发和边缘触发" class="header-anchor">#</a> 再谈水平触发和边缘触发</h3> <p>网上有大量的关于这两种模式的讲解，大部分讲的比较模糊，感觉只是强行从概念上进行描述，看完让人难以理解。所以在这里，笔者想结合上边<code>epoll</code>的工作过程，再次对这两种模式做下自己的解读，力求清晰的解释出这两种工作模式的异同。</p> <p>经过上边对<code>epoll</code>工作过程的详细解读，我们知道，当我们监听的<code>socket</code>上有数据到来时，软中断会执行<code>epoll</code>的回调函数<code>ep_poll_callback</code>,在回调函数中会将<code>epoll</code>中描述<code>socket信息</code>的数据结构<code>epitem</code>插入到<code>epoll</code>中的就绪队列<code>rdllist</code>中。随后用户进程从<code>epoll</code>的等待队列中被唤醒，<code>epoll_wait</code>将<code>IO就绪</code>的<code>socket</code>返回给用户进程，随即<code>epoll_wait</code>会清空<code>rdllist</code>。</p> <p><strong>水平触发</strong>和<strong>边缘触发</strong>最关键的<strong>区别</strong>就在于当<code>socket</code>中的接收缓冲区还有数据可读时。<strong><code>epoll_wait</code>是否会清空<code>rdllist</code>。</strong></p> <ul><li><strong>水平触发</strong>：在这种模式下，用户线程调用<code>epoll_wait</code>获取到<code>IO就绪</code>的socket后，对<code>Socket</code>进行系统IO调用读取数据，假设<code>socket</code>中的数据只读了一部分没有全部读完，这时再次调用<code>epoll_wait</code>，<code>epoll_wait</code>会检查这些<code>Socket</code>中的接收缓冲区是否还有数据可读，如果还有数据可读，就将<code>socket</code>重新放回<code>rdllist</code>。所以当<code>socket</code>上的IO没有被处理完时，再次调用<code>epoll_wait</code>依然可以获得这些<code>socket</code>，用户进程可以接着处理<code>socket</code>上的IO事件。</li> <li><strong>边缘触发：</strong> 在这种模式下，<code>epoll_wait</code>就会直接清空<code>rdllist</code>，不管<code>socket</code>上是否还有数据可读。所以在边缘触发模式下，当你没有来得及处理<code>socket</code>接收缓冲区的剩下可读数据时，再次调用<code>epoll_wait</code>，因为这时<code>rdlist</code>已经被清空了，<code>socket</code>不会再次从<code>epoll_wait</code>中返回，所以用户进程就不会再次获得这个<code>socket</code>了，也就无法在对它进行IO处理了。<strong>除非，这个<code>socket</code>上有新的IO数据到达</strong>，根据<code>epoll</code>的工作过程，该<code>socket</code>会被再次放入<code>rdllist</code>中。</li></ul> <blockquote><p>如果你在<code>边缘触发模式</code>下，处理了部分<code>socket</code>上的数据，那么想要处理剩下部分的数据，就只能等到这个<code>socket</code>上再次有网络数据到达。</p></blockquote> <p>在<code>Netty</code>中实现的<code>EpollSocketChannel</code>默认的就是<code>边缘触发</code>模式。<code>JDK</code>的<code>NIO</code>默认是<code>水平触发</code>模式。</p> <h3 id="epoll对select-poll的优化总结"><a href="#epoll对select-poll的优化总结" class="header-anchor">#</a> epoll对select，poll的优化总结</h3> <ul><li><code>epoll</code>在内核中通过<code>红黑树</code>管理海量的连接，所以在调用<code>epoll_wait</code>获取<code>IO就绪</code>的socket时，不需要传入监听的socket文件描述符。从而避免了海量的文件描述符集合在<code>用户空间</code>和<code>内核空间</code>中来回复制。</li></ul> <blockquote><p><code>select，poll</code>每次调用时都需要传递全量的文件描述符集合，导致大量频繁的拷贝操作。</p></blockquote> <ul><li><code>epoll</code>仅会通知<code>IO就绪</code>的socket。避免了在用户空间遍历的开销。</li></ul> <blockquote><p><code>select，poll</code>只会在<code>IO就绪</code>的socket上打好标记，依然是全量返回，所以在用户空间还需要用户程序在一次遍历全量集合找出具体<code>IO就绪</code>的socket。</p></blockquote> <ul><li><code>epoll</code>通过在<code>socket</code>的等待队列上注册回调函数<code>ep_poll_callback</code>通知用户程序<code>IO就绪</code>的socket。避免了在内核中轮询的开销。</li></ul> <blockquote><p>大部分情况下<code>socket</code>上并不总是<code>IO活跃</code>的，在面对海量连接的情况下，<code>select，poll</code>采用内核轮询的方式获取<code>IO活跃</code>的socket，无疑是性能低下的核心原因。</p></blockquote> <p>根据以上<code>epoll</code>的性能优势，它是目前为止各大主流网络框架，以及反向代理中间件使用到的网络IO模型。</p> <p>利用<code>epoll</code>多路复用IO模型可以轻松的解决<code>C10K</code>问题。</p> <p><code>C100k</code>的解决方案也还是基于<code>C10K</code>的方案，通过<code>epoll</code> 配合线程池，再加上 CPU、内存和网络接口的性能和容量提升。大部分情况下，<code>C100K</code>很自然就可以达到。</p> <p>甚至<code>C1000K</code>的解决方法，本质上还是构建在 <code>epoll</code> 的<code>多路复用 I/O 模型</code>上。只不过，除了 I/O 模型之外，还需要从应用程序到 Linux 内核、再到 CPU、内存和网络等各个层次的深度优化，特别是需要借助硬件，来卸载那些原来通过软件处理的大量功能（<code>去掉大量的中断响应开销</code>，<code>以及内核协议栈处理的开销</code>）。</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/Netty 系统设计/10.二、基础知识/07.IO 多路复用详解.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新于:</span> <span class="time">2024/09/19, 08:16:36</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/bfab10/" class="prev">指南</a></span> <span class="next"><a href="/pages/3f7882/">零拷贝详解</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.9830b779.js" defer></script><script src="/assets/js/2.933750c6.js" defer></script><script src="/assets/js/38.40fe2658.js" defer></script><script src="/assets/js/7.7eb70372.js" defer></script>
  </body>
</html>
