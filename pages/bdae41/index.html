<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>String | Echo 系统设计之美</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="水滴石穿，设计无银弹">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.3b389ff4.css" as="style"><link rel="preload" href="/assets/js/app.e6c7c0bc.js" as="script"><link rel="preload" href="/assets/js/2.c1dbdf51.js" as="script"><link rel="preload" href="/assets/js/8.f8705c03.js" as="script"><link rel="prefetch" href="/assets/js/10.ce9e2824.js"><link rel="prefetch" href="/assets/js/11.4b96b543.js"><link rel="prefetch" href="/assets/js/12.2feff802.js"><link rel="prefetch" href="/assets/js/13.4332a769.js"><link rel="prefetch" href="/assets/js/14.464e0155.js"><link rel="prefetch" href="/assets/js/15.0d61cf57.js"><link rel="prefetch" href="/assets/js/16.506c965c.js"><link rel="prefetch" href="/assets/js/17.0b9e4b65.js"><link rel="prefetch" href="/assets/js/18.c7917c05.js"><link rel="prefetch" href="/assets/js/19.fad48692.js"><link rel="prefetch" href="/assets/js/20.ff68a659.js"><link rel="prefetch" href="/assets/js/21.93b2e430.js"><link rel="prefetch" href="/assets/js/22.e8989777.js"><link rel="prefetch" href="/assets/js/23.de5a9e3c.js"><link rel="prefetch" href="/assets/js/24.914d458e.js"><link rel="prefetch" href="/assets/js/25.b6565a06.js"><link rel="prefetch" href="/assets/js/26.977f0fd3.js"><link rel="prefetch" href="/assets/js/27.7bde72bc.js"><link rel="prefetch" href="/assets/js/28.e34d1ee9.js"><link rel="prefetch" href="/assets/js/29.b4c0912f.js"><link rel="prefetch" href="/assets/js/3.d5abcf7b.js"><link rel="prefetch" href="/assets/js/30.662f616d.js"><link rel="prefetch" href="/assets/js/31.8a8e803f.js"><link rel="prefetch" href="/assets/js/32.b41ef25a.js"><link rel="prefetch" href="/assets/js/33.24569bcc.js"><link rel="prefetch" href="/assets/js/34.dac446b7.js"><link rel="prefetch" href="/assets/js/35.f6fabb4e.js"><link rel="prefetch" href="/assets/js/36.85b2b5dc.js"><link rel="prefetch" href="/assets/js/37.da59a00f.js"><link rel="prefetch" href="/assets/js/38.655f6ff9.js"><link rel="prefetch" href="/assets/js/39.b0056866.js"><link rel="prefetch" href="/assets/js/4.d946b097.js"><link rel="prefetch" href="/assets/js/40.3ddc2c59.js"><link rel="prefetch" href="/assets/js/41.16557a6f.js"><link rel="prefetch" href="/assets/js/42.0e64221c.js"><link rel="prefetch" href="/assets/js/43.7976c385.js"><link rel="prefetch" href="/assets/js/44.71553edf.js"><link rel="prefetch" href="/assets/js/45.1313072b.js"><link rel="prefetch" href="/assets/js/46.c2baf55f.js"><link rel="prefetch" href="/assets/js/47.635abf6e.js"><link rel="prefetch" href="/assets/js/48.c68ae1bc.js"><link rel="prefetch" href="/assets/js/49.0ded727d.js"><link rel="prefetch" href="/assets/js/5.39afb5af.js"><link rel="prefetch" href="/assets/js/50.e00d3a7e.js"><link rel="prefetch" href="/assets/js/51.9da875f4.js"><link rel="prefetch" href="/assets/js/52.d552ff92.js"><link rel="prefetch" href="/assets/js/53.dffecfdc.js"><link rel="prefetch" href="/assets/js/54.e64b0f07.js"><link rel="prefetch" href="/assets/js/55.bf7710d3.js"><link rel="prefetch" href="/assets/js/56.2d336989.js"><link rel="prefetch" href="/assets/js/6.7a2f25e5.js"><link rel="prefetch" href="/assets/js/7.a5188780.js"><link rel="prefetch" href="/assets/js/9.b279253b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.3b389ff4.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Echo 系统设计之美" class="logo"> <span class="site-name can-hide">Echo 系统设计之美</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧑‍💻实战系统设计" class="dropdown-title"><!----> <span class="title" style="display:;">🧑‍💻实战系统设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/84cb49/" class="nav-link">设计基础设施</a></li><li class="dropdown-item"><!----> <a href="/pages/a95d7d/" class="nav-link">设计热门应用</a></li><li class="dropdown-item"><!----> <a href="/pages/def08a/" class="nav-link">场景设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧑‍💻实战系统设计" class="dropdown-title"><!----> <span class="title" style="display:;">🧑‍💻实战系统设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/84cb49/" class="nav-link">设计基础设施</a></li><li class="dropdown-item"><!----> <a href="/pages/a95d7d/" class="nav-link">设计热门应用</a></li><li class="dropdown-item"><!----> <a href="/pages/def08a/" class="nav-link">场景设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>指南</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/252196/" class="sidebar-link">介绍</a></li><li><a href="/pages/69fbd7/" class="sidebar-link">Redis 伪码蓝图【必看】</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ee2b16/" class="sidebar-link">list</a></li><li><a href="/pages/2d4311/" class="sidebar-link">Hash</a></li><li><a href="/pages/c7cf4a/" class="sidebar-link">ZSet</a></li><li><a href="/pages/2ab65e/" class="sidebar-link">内存友好的数据结构该如何细化设计？</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>主线</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/d4ecb9/" class="sidebar-link">Redis Server 初始化</a></li><li><a href="/pages/34fa27/" class="sidebar-link">Linux 中的 IO 多路复用</a></li><li><a href="/pages/d6b00d/" class="sidebar-link">Redis 的 Reactor 模型</a></li><li><a href="/pages/264b06/" class="sidebar-link">深入 Redis 事件驱动框架</a></li><li><a href="/pages/e6d8ef/" class="sidebar-link">Redis 的执行模式</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>支线</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b43a19/" class="sidebar-link">LRU 策略</a></li><li><a href="/pages/b43a89/" class="sidebar-link">LFU 策略</a></li><li><a href="/pages/f44fbe/" class="sidebar-link">Redis 过期策略</a></li><li><a href="/pages/9b17a6/" class="sidebar-link">RDB 持久化</a></li><li><a href="/pages/9b17a7/" class="sidebar-link">AOF 持久化</a></li><li><a href="/pages/aa75e9/" class="sidebar-link">Redis 中的延迟监控</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>集群</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/ebc8dc/" class="sidebar-link">主从复制</a></li><li><a href="/pages/af8752/" class="sidebar-link">哨兵</a></li><li><a href="/pages/040403/" class="sidebar-link">cluster</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Redis 系统设计</span></li><li data-v-06225672><span data-v-06225672>基础</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-16</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">String<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>字符串在我们平时的应用开发中十分常见，比如我们要记录用户信息、商品信息、状态信息等等，这些都会用到字符串。</p> <p>而对于 Redis 来说，键值对中的键是字符串，值有时也是字符串。我们在 Redis 中写入一条用户信息，记录了用户姓名、性别、所在城市等，这些都是字符串，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code>SET user<span class="token operator">:</span>id<span class="token operator">:</span><span class="token number">100</span> <span class="token punctuation">{</span><span class="token string">&quot;name&quot;</span><span class="token operator">:</span> <span class="token string">&quot;zhangsan&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;gender&quot;</span><span class="token operator">:</span> <span class="token string">&quot;M&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;city&quot;</span><span class="token operator">:</span><span class="token string">&quot;beijing&quot;</span><span class="token punctuation">}</span>
</code></pre></div><p>此外，Redis 实例和客户端交互的命令和数据，也都是用字符串表示的。</p> <p>一个好的字符串模块设计，需要尽量满足以下三个要求：</p> <ul><li>能支持丰富且高效的字符串操作，比如字符串追加、拷贝、比较、获取长度等</li> <li>能保存任意的二进制数据，比如图片等</li> <li>能尽可能地节省内存开销</li></ul> <p>其实，如果你开发过 C 语言程序，你应该就知道，在 C 语言中可以使用 字符数组 <em>char</em> 来实现字符串。同时，C 语言标准库 string.h 中也定义了多种字符串的操作函数，比如字符串比较函数 strcmp、字符串长度计算函数 strlen、字符串追加函数 strcat 等，这样就便于开发者直接调用这些函数来完成字符串操作。</p> <p>所以这样看起来，<strong>Redis 好像完全可以复用 C 语言中对字符串的实现呀？</strong></p> <p>但实际上，我们在使用 C 语言字符串时，经常需要手动检查和分配字符串空间，而这就会增加代码开发的工作量。而且，图片等数据还无法用字符串保存，也就限制了应用范围。</p> <p>那么，从系统设计的角度来看，我们该如何设计实现字符串呢？</p> <p>其实，Redis 设计了<strong>简单动态字符串</strong>（Simple Dynamic String，SDS）的结构，用来表示字符串。相比于 C 语言中的字符串实现，SDS 这种字符串的实现方式，会<strong>提升字符串的操作效率，并且可以用来保存二进制数据</strong>。</p> <p>所以今天这节课，我就来给你介绍下 SDS 结构的设计思想和实现技巧，这样你就既可以掌握 char* 实现方法的不足和 SDS 的优势，还能学习到紧凑型内存结构的实现技巧。如果你要在自己的系统软件中实现字符串类型，就可以参考 Redis 的设计思想，来更好地提升操作效率，节省内存开销。</p> <p>好，接下来，我们先来了解下为什么 Redis 没有复用 C 语言的字符串实现方法。</p> <h2 id="char-有啥不好"><a href="#char-有啥不好" class="header-anchor">#</a> <code>char*</code> 有啥不好</h2> <p>实际上，要想解答这个问题，我们需要先知道 char* 字符串数组的结构特点，还有 Redis 对字符串的需求是什么，所以下面我们就来具体分析一下。</p> <h3 id="char-的结构设计"><a href="#char-的结构设计" class="header-anchor">#</a> <code>char*</code> 的结构设计</h3> <p>首先，我们来看看 char* 字符数组的结构。</p> <p><code>char*</code> 字符数组的结构很简单，就是。比如，下图显示的就是字符串“redis”的 char 一块连续的内存空间，依次存放了字符串中的每一个字符数组结构。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409161739553.png" alt="image-20240916173944511"></p> <p>从图中可以看到，字符数组的最后一个字符是“\0”，这个字符的作用是什么呢？其实，C 语言在对字符串进行操作时，char* 指针只是指向字符数组的起始位置，而<strong>字符数组的结尾位置就用“\0”表示，意思是指字符串的结束。</strong></p> <p>这样一来，C 语言标准库中字符串的操作函数，就会通过检查字符数组中是否有“\0”，来判断字符串是否结束。比如，strlen 函数就是一种字符串操作函数，它可以返回一个字符串的长度。这个函数会遍历字符数组中的每一个字符，并进行计数，直到检查的字符为“\0”。此时，strlen 函数会停止计数，返回已经统计到的字符个数。下图显示了 strlen 函数的执行流程：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409161740231.png" alt="image-20240916174001168"></p> <p>我们再通过一段代码，来看下**“\0”结束字符对字符串长度的影响**。这里我创建了两个字符串变量 a 和 b，分别给它们赋值为“red\0is”和“redis\0”。然后，我用 strlen 函数计算这两个字符串长度，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
     <span class="token keyword">char</span> <span class="token operator">*</span>a <span class="token operator">=</span> <span class="token string">&quot;red\0is&quot;</span><span class="token punctuation">;</span>
     <span class="token keyword">char</span> <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token string">&quot;redis\0&quot;</span><span class="token punctuation">;</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%lu\n&quot;</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%lu\n&quot;</span><span class="token punctuation">,</span> <span class="token function">strlen</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>当程序执行完这段代码后，输出的结果分别是 3 和 5，表示 a 和 b 的长度分别是 3 个字符和 5 个字符。这是因为 a 中在“red”这 3 个字符后，就有了结束字符“\0”，而 b 中的结束字符是在“redis”5 个字符后。</p> <p>也就是说，char* 字符串以“\0”表示字符串的结束，其实会给我们保存数据带来一定的负面影响。如果我们要保存的数据中，本身就有“\0”，那么数据在“\0”处就会被截断，而这就<strong>不符合 Redis 希望能保存任意二进制数据的需求了。</strong></p> <h3 id="操作函数复杂度"><a href="#操作函数复杂度" class="header-anchor">#</a> 操作函数复杂度</h3> <p>而除了 char* 字符数组结构的设计问题以外，使用“\0”作为字符串的结束字符，虽然可以让字符串操作函数判断字符串的结束位置，但它也会带来另一方面的负面影响，也就是会导致操作函数的复杂度增加。</p> <p>我还是以 strlen 函数为例，该函数需要遍历字符数组中的每一个字符，才能得到字符串长度，所以这个操作函数的复杂度是 O(N)。</p> <p>我们再来看另一个常用的操作函数：<strong>字符串追加函数 strcat</strong>。strcat 函数是将一个源字符串 src 追加到一个目标字符串的末尾。该函数的代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code>  <span class="token keyword">char</span> <span class="token operator">*</span><span class="token function">strcat</span><span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span>dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>src<span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token comment">//将目标字符串复制给tmp变量</span>
     <span class="token keyword">char</span> <span class="token operator">*</span>tmp <span class="token operator">=</span> dest<span class="token punctuation">;</span>
     <span class="token comment">//用一个while循环遍历目标字符串，直到遇到“\0”跳出循环，指向目标字符串的末尾</span>
     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">*</span>dest<span class="token punctuation">)</span>
        dest<span class="token operator">++</span><span class="token punctuation">;</span>
     <span class="token comment">//将源字符串中的每个字符逐一赋值到目标字符串中，直到遇到结束字符</span>
     <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">*</span>dest<span class="token operator">++</span> <span class="token operator">=</span> <span class="token operator">*</span>src<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token char">'\0'</span> <span class="token punctuation">)</span>
     <span class="token keyword">return</span> tmp<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>从代码中可以看到，strcat 函数和 strlen 函数类似，复杂度都很高，也都需要先通过遍历字符串才能得到目标字符串的末尾。然后对于 strcat 函数来说，还要再遍历源字符串才能完成追加。另外，它在把源字符串追加到目标字符串末尾时，还需要确认目标字符串具有足够的可用空间，否则就无法追加。</p> <p>所以，这就要求开发人员在调用 strcat 时，要保证目标字符串有足够的空间，不然就需要开发人员动态分配空间，从而增加了编程的复杂度。而操作函数的复杂度一旦增加，就会影响字符串的操作效率，这就 <strong>不符合 Redis 对字符串高效操作的需求</strong>了。</p> <p>好了，综合以上在 C 语言中使用 char* 实现字符串的两大不足之处以后，我们现在就需要找到新的实现字符串的方式了。所以接下来，我们就来学习下，Redis 是如何对字符串的实现进行设计考虑的。</p> <h2 id="sds-的设计思想"><a href="#sds-的设计思想" class="header-anchor">#</a> SDS 的设计思想</h2> <p>因为 Redis 是使用 C 语言开发的，所以为了保证能尽量复用 C 标准库中的字符串操作函数，Redis 保留了使用字符数组来保存实际的数据。但是，和 C 语言仅用字符数组不同，Redis 还专门设计了 SDS（即简单动态字符串）的数据结构。下面我们一起来看看。</p> <h3 id="sds-结构设计"><a href="#sds-结构设计" class="header-anchor">#</a> SDS 结构设计</h3> <p>首先，SDS 结构里包含了一个字符数组 buf[]，用来保存实际数据。同时，SDS 结构里还包含了三个元数据，分别是<strong>字符数组现有长度 len</strong>、<strong>分配给字符数组的空间长度 alloc</strong>，以及 <strong>SDS 类型 flags</strong>。其中，Redis 给 len 和 alloc 这两个元数据定义了多种数据类型，进而可以用来表示不同类型的 SDS，稍后我会给你具体介绍。下图显示了 SDS 的结构，你可以先看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409161741377.png" alt="image-20240916174113695"></p> <p>另外，如果你在 Redis 源码中查找过 SDS 的定义，那你可能会看到，Redis 使用 typedef 给 char* 类型定义了一个别名，这个别名就是 sds，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">char</span> <span class="token operator">*</span>sds<span class="token punctuation">;</span>
</code></pre></div><p>其实，这是因为 SDS 本质还是字符数组，只是在字符数组基础上增加了额外的元数据。在 Redis 中需要用到字符数组时，就直接使用 sds 这个别名。</p> <p>同时，在创建新的字符串时，Redis 会调用 SDS 创建函数 sdsnewlen。sdsnewlen 函数会新建 sds 类型变量（也就是 char* 类型变量），并新建 SDS 结构体，把 SDS 结构体中的数组 buf[] 赋给 sds 类型变量。最后，sdsnewlen 函数会把要创建的字符串拷贝给 sds 变量。下面的代码就显示了 sdsnewlen 函数的这个操作逻辑，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code>sds <span class="token function">sdsnewlen</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>init<span class="token punctuation">,</span> <span class="token class-name">size_t</span> initlen<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>sh<span class="token punctuation">;</span>  <span class="token comment">//指向SDS结构体的指针</span>
    sds s<span class="token punctuation">;</span>     <span class="token comment">//sds类型变量，即char*字符数组</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    sh <span class="token operator">=</span> <span class="token function">s_malloc</span><span class="token punctuation">(</span>hdrlen<span class="token operator">+</span>initlen<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//新建SDS结构，并分配内存空间</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    s <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span>sh<span class="token operator">+</span>hdrlen<span class="token punctuation">;</span>              <span class="token comment">//sds类型变量指向SDS结构体中的buf数组，sh指向SDS结构体起始位置，hdrlen是SDS结构体中元数据的长度</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>initlen <span class="token operator">&amp;&amp;</span> init<span class="token punctuation">)</span>
        <span class="token function">memcpy</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> init<span class="token punctuation">,</span> initlen<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//将要传入的字符串拷贝给sds变量s</span>
    s<span class="token punctuation">[</span>initlen<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>               <span class="token comment">//变量s末尾增加\0，表示字符串结束</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好了，了解了 SDS 结构的定义后，我们再来看看，相比传统 C 语言字符串，SDS 操作效率的改进之处。</p> <h3 id="sds-操作效率"><a href="#sds-操作效率" class="header-anchor">#</a> SDS 操作效率</h3> <p>因为 SDS 结构中记录了字符数组已占用的空间和被分配的空间，这就比传统 C 语言实现的字符串能带来更高的操作效率。</p> <p>我还是以字符串追加操作为例。Redis 中实现字符串追加的函数是 sds.c 文件中的 <strong>sdscatlen 函数</strong>。这个函数的参数一共有三个，分别是目标字符串 s、源字符串 t 和要追加的长度 len，源码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code>sds <span class="token function">sdscatlen</span><span class="token punctuation">(</span>sds s<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">void</span> <span class="token operator">*</span>t<span class="token punctuation">,</span> <span class="token class-name">size_t</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//获取目标字符串s的当前长度</span>
    <span class="token class-name">size_t</span> curlen <span class="token operator">=</span> <span class="token function">sdslen</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//根据要追加的长度len和目标字符串s的现有长度，判断是否要增加新的空间</span>
    s <span class="token operator">=</span> <span class="token function">sdsMakeRoomFor</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token comment">//将源字符串t中len长度的数据拷贝到目标字符串结尾</span>
    <span class="token function">memcpy</span><span class="token punctuation">(</span>s<span class="token operator">+</span>curlen<span class="token punctuation">,</span> t<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//设置目标字符串的最新长度：拷贝前长度curlen加上拷贝长度</span>
    <span class="token function">sdssetlen</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> curlen<span class="token operator">+</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//拷贝后，在目标字符串结尾加上\0</span>
    s<span class="token punctuation">[</span>curlen<span class="token operator">+</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token char">'\0'</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通过分析这个函数的源码，我们可以看到 sdscatlen 的实现较为简单，其执行过程分为三步：</p> <ul><li>首先，获取目标字符串的当前长度，并调用 sdsMakeRoomFor 函数，根据当前长度和要追加的长度，判断是否要给目标字符串新增空间。这一步主要是保证，目标字符串有足够的空间接收追加的字符串。</li> <li>其次，在保证了目标字符串的空间足够后，将源字符串中指定长度 len 的数据追加到目标字符串。</li> <li>最后，设置目标字符串的最新长度。</li></ul> <p>我画了一张图，显示了 sdscatlen 的执行过程，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409161742164.png" alt="image-20240916174222100"></p> <p>所以，到这里你就能发现，和 C 语言中的字符串操作相比，SDS 通过记录字符数组的使用长度和分配空间大小，避免了对字符串的遍历操作，降低了操作开销，进一步就可以帮助诸多字符串操作更加高效地完成，比如创建、追加、复制、比较等，这一设计思想非常值得我们学习。</p> <p>此外，SDS 把目标字符串的<strong>空间检查和扩容封装在了 sdsMakeRoomFor 函数中</strong>，并且在涉及字符串空间变化的操作中，如追加、复制等，会直接调用该函数。</p> <p>这一设计实现，就避免了开发人员因忘记给目标字符串扩容，而导致操作失败的情况。比如，我们使用函数 strcpy (char *dest, const char *src) 时，如果 src 的长度大于 dest 的长度，代码中我们也没有做检查的话，就会造成内存溢出。所以这种封装操作的设计思想，同样值得我们学习。</p> <p>那么，除了使用元数据记录字符串数组长度和封装操作的设计思想，SDS 还有什么优秀的设计与实现值得我们学习呢？这就和我刚才给你介绍的 Redis 对内存节省的需求相关了。</p> <p>所以接下来，我们就来看看 SDS 在编程技巧上是如何实现节省内存的。</p> <h2 id="紧凑型字符串结构的编程技巧"><a href="#紧凑型字符串结构的编程技巧" class="header-anchor">#</a> 紧凑型字符串结构的编程技巧</h2> <p>前面我提到，SDS 结构中有一个元数据 flags，表示的是 SDS 类型。事实上，SDS 一共设计了 5 种类型，分别是 sdshdr5、sdshdr8、sdshdr16、sdshdr32 和 sdshdr64。这 5 种类型的<strong>主要区别就在于</strong>，它们数据结构中的字符数组现有长度 len 和分配空间长度 alloc，这两个元数据的数据类型不同。</p> <p>因为 sdshdr5 这一类型 Redis 已经不再使用了，所以我们这里主要来了解下剩余的 4 种类型。以 sdshdr8 为例，它的定义如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>
    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* 字符数组现有长度*/</span>
    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* 字符数组的已分配空间，不包括结构体和\0结束字符*/</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* SDS类型*/</span>
    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/*字符数组*/</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>我们可以看到，现有长度 len 和已分配空间 alloc 的数据类型都是 uint8_t。<strong>uint8_t 是 8 位无符号整型</strong>，会占用 1 字节的内存空间。当字符串类型是 sdshdr8 时，它能表示的字符数组长度（包括数组最后一位\0）不会超过 256 字节（2 的 8 次方等于 256）。</p> <p>而对于 sdshdr16、sdshdr32、sdshdr64 三种类型来说，它们的 len 和 alloc 数据类型分别是 uint16_t、uint32_t、uint64_t，即它们能表示的字符数组长度，分别不超过 2 的 16 次方、32 次方和 64 次方。这两个元数据各自占用的内存空间在 sdshdr16、sdshdr32、sdshdr64 类型中，则分别是 2 字节、4 字节和 8 字节。</p> <p>实际上，**SDS 之所以设计不同的结构头（即不同类型），是为了能灵活保存不同大小的字符串，从而有效节省内存空间。**因为在保存不同大小的字符串时，结构头占用的内存空间也不一样，这样一来，在保存小字符串时，结构头占用空间也比较少。</p> <p>否则，假设 SDS 都设计一样大小的结构头，比如都使用 uint64_t 类型表示 len 和 alloc，那么假设要保存的字符串是 10 个字节，而此时结构头中 len 和 alloc 本身就占用了 16 个字节了，比保存的数据都多了。所以这样的设计对内存并不友好，也不满足 Redis 节省内存的需求。</p> <p>好了，除了设计不同类型的结构头，Redis 在编程上还<strong>使用了专门的编译优化来节省内存空间</strong>。在刚才介绍的 sdshdr8 结构定义中，我们可以看到，在 struct 和 sdshdr8 之间使用了<strong>attribute</strong> ((<strong>packed</strong>))，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span>
</code></pre></div><p>其实这里，<strong>attribute</strong> ((<strong>packed</strong>))的作用就是告诉编译器，在编译 sdshdr8 结构时，不要使用字节对齐的方式，而是<strong>采用紧凑的方式分配内存</strong>。这是因为在默认情况下，编译器会按照 8 字节对齐的方式，给变量分配内存。也就是说，即使一个变量的大小不到 8 个字节，编译器也会给它分配 8 个字节。</p> <p>为了方便你理解，我给你举个例子。假设我定义了一个结构体 s1，它有两个成员变量，类型分别是 char 和 int，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">struct</span> <span class="token class-name">s1</span> <span class="token punctuation">{</span>
        <span class="token keyword">char</span> a<span class="token punctuation">;</span>
        <span class="token keyword">int</span> b<span class="token punctuation">;</span>
     <span class="token punctuation">}</span> ts1<span class="token punctuation">;</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%lu\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ts1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>虽然 char 类型占用 1 个字节，int 类型占用 4 个字节，但是如果你运行这段代码，就会发现打印出来的结果是 8。这就是因为在默认情况下，编译器会给 s1 结构体分配 8 个字节的空间，而这样其中就有 3 个字节被浪费掉了。</p> <p>为了节省内存，Redis 在这方面的设计上可以说是精打细算的。所以，Redis 采用了<strong>attribute</strong> ((<strong>packed</strong>))属性定义结构体，这样一来，结构体实际占用多少内存空间，编译器就分配多少空间。</p> <p>比如，我用<strong>attribute</strong> ((<strong>packed</strong>))属性定义结构体 s2，同样包含 char 和 int 两个类型的成员变量，代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code>  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
  <span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token keyword">struct</span> <span class="token keyword">__attribute__</span><span class="token punctuation">(</span><span class="token punctuation">(</span>packed<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">s2</span><span class="token punctuation">{</span>
        <span class="token keyword">char</span> a<span class="token punctuation">;</span>
        <span class="token keyword">int</span> b<span class="token punctuation">;</span>
     <span class="token punctuation">}</span> ts2<span class="token punctuation">;</span>
     <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%lu\n&quot;</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>ts2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
</code></pre></div><p>当你运行这段代码时，你可以看到，打印的结果是 5，表示编译器用了紧凑型内存分配，s2 结构体只占用 5 个字节的空间。</p> <p>好了，总而言之，如果你在开发程序时，希望能节省数据结构的内存开销，就可以把<strong>attribute</strong> ((<strong>packed</strong>))这个编程方法用起来。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>这节课我主要给你介绍了 Redis 中字符串的设计与实现。你要知道，字符串的实现需要考虑操作高效、能保存任意二进制数据，以及节省内存的需求。而 Redis 中设计实现字符串的方式，就非常值得你学习和借鉴。</p> <p>因此这节课，你需要重点关注三个要点，分别是：</p> <ul><li>C 语言中使用 char* 实现字符串的不足，主要是因为使用“\0”表示字符串结束，操作时需遍历字符串，效率不高，并且无法完整表示包含“\0”的数据，因而这就无法满足 Redis 的需求。</li> <li>Redis 中字符串的设计思想与实现方法。Redis 专门设计了 SDS 数据结构，在字符数组的基础上，增加了字符数组长度和分配空间大小等元数据。这样一来，需要基于字符串长度进行的追加、复制、比较等操作，就可以直接读取元数据，效率也就提升了。而且，SDS 不通过字符串中的“\0”字符判断字符串结束，而是直接将其作为二进制数据处理，可以用来保存图片等二进制数据。</li> <li>SDS 中是通过设计不同 SDS 类型来表示不同大小的字符串，并使用<strong>attribute</strong> ((<strong>packed</strong>))这个编程小技巧，来实现紧凑型内存布局，达到节省内存的目的。</li></ul> <p>字符串看起来简单，但通过今天这节课的学习，你可以看到实现字符串有很多需要精巧设计的地方。C 语言字符串的实现方法和 SDS 的联系与区别，也是 Redis 面试时经常会被问到的问题，所以我也希望你能通过今天这节课，掌握好它俩的区别。</p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/01.Redis 系统设计/02.基础/01.String.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2024/09/16, 10:01:40</span></div></div> <div class="page-nav-wapper"><!----> <!----></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e6c7c0bc.js" defer></script><script src="/assets/js/2.c1dbdf51.js" defer></script><script src="/assets/js/8.f8705c03.js" defer></script>
  </body>
</html>
