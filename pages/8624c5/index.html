<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Count-Min Sketch | Echo 系统设计之美</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="水滴石穿，设计无银弹">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.bc6beed4.css" as="style"><link rel="preload" href="/assets/js/app.aaad5302.js" as="script"><link rel="preload" href="/assets/js/2.933750c6.js" as="script"><link rel="preload" href="/assets/js/10.2cc95be8.js" as="script"><link rel="preload" href="/assets/js/7.7eb70372.js" as="script"><link rel="prefetch" href="/assets/js/11.c7521a10.js"><link rel="prefetch" href="/assets/js/12.c0ea1b08.js"><link rel="prefetch" href="/assets/js/13.d9d26d25.js"><link rel="prefetch" href="/assets/js/14.1141ec27.js"><link rel="prefetch" href="/assets/js/15.61830f0a.js"><link rel="prefetch" href="/assets/js/16.f2ccbb47.js"><link rel="prefetch" href="/assets/js/17.1f44d5e0.js"><link rel="prefetch" href="/assets/js/18.e689f555.js"><link rel="prefetch" href="/assets/js/19.68db5844.js"><link rel="prefetch" href="/assets/js/20.b5e0fdf1.js"><link rel="prefetch" href="/assets/js/21.af1069aa.js"><link rel="prefetch" href="/assets/js/22.af583a75.js"><link rel="prefetch" href="/assets/js/23.f8a8e8e0.js"><link rel="prefetch" href="/assets/js/24.88b84218.js"><link rel="prefetch" href="/assets/js/25.acf70158.js"><link rel="prefetch" href="/assets/js/26.381f581c.js"><link rel="prefetch" href="/assets/js/27.e82ff876.js"><link rel="prefetch" href="/assets/js/28.6b737928.js"><link rel="prefetch" href="/assets/js/29.ebd14054.js"><link rel="prefetch" href="/assets/js/3.d9533589.js"><link rel="prefetch" href="/assets/js/30.ed6ead0e.js"><link rel="prefetch" href="/assets/js/31.89a26765.js"><link rel="prefetch" href="/assets/js/32.9a158243.js"><link rel="prefetch" href="/assets/js/33.a9dfc110.js"><link rel="prefetch" href="/assets/js/34.9740832c.js"><link rel="prefetch" href="/assets/js/35.017688d8.js"><link rel="prefetch" href="/assets/js/36.69f4f9a7.js"><link rel="prefetch" href="/assets/js/37.381f3758.js"><link rel="prefetch" href="/assets/js/38.3f232ff8.js"><link rel="prefetch" href="/assets/js/39.5259c5c3.js"><link rel="prefetch" href="/assets/js/4.73518a0f.js"><link rel="prefetch" href="/assets/js/40.6da9cd20.js"><link rel="prefetch" href="/assets/js/41.5525b2c4.js"><link rel="prefetch" href="/assets/js/42.9f3d0d39.js"><link rel="prefetch" href="/assets/js/43.d6629a36.js"><link rel="prefetch" href="/assets/js/44.ff4f9547.js"><link rel="prefetch" href="/assets/js/45.bcc663f0.js"><link rel="prefetch" href="/assets/js/46.bf329f04.js"><link rel="prefetch" href="/assets/js/47.bcbfaada.js"><link rel="prefetch" href="/assets/js/48.9c747df7.js"><link rel="prefetch" href="/assets/js/49.4732d3cb.js"><link rel="prefetch" href="/assets/js/5.dd198b3d.js"><link rel="prefetch" href="/assets/js/50.9bff482f.js"><link rel="prefetch" href="/assets/js/51.8c80377e.js"><link rel="prefetch" href="/assets/js/52.37d81e55.js"><link rel="prefetch" href="/assets/js/53.88841637.js"><link rel="prefetch" href="/assets/js/54.1a887e66.js"><link rel="prefetch" href="/assets/js/55.3c3f2203.js"><link rel="prefetch" href="/assets/js/56.590fc579.js"><link rel="prefetch" href="/assets/js/57.a2182867.js"><link rel="prefetch" href="/assets/js/58.28ea8ba4.js"><link rel="prefetch" href="/assets/js/59.d771376d.js"><link rel="prefetch" href="/assets/js/6.0b558b79.js"><link rel="prefetch" href="/assets/js/8.0ec7f6e8.js"><link rel="prefetch" href="/assets/js/9.6e274fca.js">
    <link rel="stylesheet" href="/assets/css/0.styles.bc6beed4.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Echo 系统设计之美" class="logo"> <span class="site-name can-hide">Echo 系统设计之美</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧑‍💻实战系统设计" class="dropdown-title"><!----> <span class="title" style="display:;">🧑‍💻实战系统设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/84cb49/" class="nav-link">设计基础设施</a></li><li class="dropdown-item"><!----> <a href="/pages/a95d7d/" class="nav-link">设计热门应用</a></li><li class="dropdown-item"><!----> <a href="/pages/def08a/" class="nav-link">场景设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧑‍💻实战系统设计" class="dropdown-title"><!----> <span class="title" style="display:;">🧑‍💻实战系统设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/84cb49/" class="nav-link">设计基础设施</a></li><li class="dropdown-item"><!----> <a href="/pages/a95d7d/" class="nav-link">设计热门应用</a></li><li class="dropdown-item"><!----> <a href="/pages/def08a/" class="nav-link">场景设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>热门算法</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/fccd91/" class="sidebar-link">Bloom Filter</a></li><li><a href="/pages/1e28a2/" class="sidebar-link">Consistent Hashing</a></li><li><a href="/pages/8624c5/" aria-current="page" class="active sidebar-link">Count-Min Sketch</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/8624c5/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/8624c5/#cms简介" class="sidebar-link">CMS简介</a></li><li class="sidebar-sub-header level2"><a href="/pages/8624c5/#cms-的具体实现" class="sidebar-link">CMS 的具体实现</a></li><li class="sidebar-sub-header level2"><a href="/pages/8624c5/#cms-的参数选择" class="sidebar-link">CMS 的参数选择</a></li><li class="sidebar-sub-header level2"><a href="/pages/8624c5/#count-mean-min-sketch" class="sidebar-link">Count-Mean-Min-Sketch</a></li><li class="sidebar-sub-header level2"><a href="/pages/8624c5/#参考文献" class="sidebar-link">参考文献</a></li></ul></li><li><a href="/pages/87589a/" class="sidebar-link">LRU</a></li><li><a href="/pages/7d22be/" class="sidebar-link">LFU</a></li><li><a href="/pages/2d43d1/" class="sidebar-link">hash &amp; rehash</a></li><li><a href="/pages/44dcc2/" class="sidebar-link">Timing Wheels</a></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>热门算法</span></li><li data-v-06225672><span data-v-06225672>热门算法</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-14</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Count-Min Sketch<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><div class="custom-block danger"><p class="custom-block-title">提出问题是一切智慧的开端</p> <ol><li>在面对亿级数据流时，如何在不占用过多内存的情况下，实时统计某个元素的出现频率？</li> <li>为什么在大数据场景下，使用普通的哈希表（HashMap）进行频率统计往往不可行？</li> <li>Count-Min Sketch 是如何通过牺牲部分准确性，换取高效的频率查询能力的？</li> <li>你如何在 Count-Min Sketch 中确保低频数据的计数不受哈希冲突影响，保证统计结果的合理性？</li> <li>如何根据允许的误差范围和冲突概率，优化 Count-Min Sketch 的哈希函数数量和内存空间配置？</li> <li>在什么场景下 Count-Mean-Min Sketch 能有效改善 CMS 在处理长尾数据时的准确性？</li> <li>如果你正在构建一个需要实时统计用户访问频率的系统，如何在内存和准确性之间权衡选择 Count-Min Sketch？</li></ol></div> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p><strong>问题：</strong> 如果老板让你<strong>统计一个实时的数据流中元素出现的频率</strong>，并且准备随时回答某个元素出现的频率，不需要的精确的计数，那该怎么办？</p> <h4 id="hashmap-解决"><a href="#hashmap-解决" class="header-anchor">#</a> hashmap 解决</h4> <p>在大数据场景下，比如网页的 TopK 问题，爬虫的是否访问过的问题，都是一种出现频次相关的问题，那么在系统设计的时候，如何选择策略和数据结构去存储相关的数据是最高效合适的呢？</p> <p>计算元素的出现频次，如果出现与普通的场景下，简单的方案就是用 hashmap 来记录元素出现的次数：</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token comment">// 用HashMap存储元素及其频率</span>
<span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> freq <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 统计频率</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">String</span> e <span class="token operator">:</span> elements<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>freq<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	freq<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    	freq<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> freq<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>但是这种方式在大量数据流的情况下，如果存在大量唯一元素的情况下，会占用大量的内存，导致其<strong>无法应对大数据场景</strong>，因此在”时间换空间” 的策略选择中，这里就需要考虑通过时间，或者准确率等其他的因素来换空间。</p> <p>通常来说，针对大数据场景，会无限扩张的数据结构显然是不适用的，所以希望能用固定的空间来进行计数的管理，同时希望尽量不要影响到运行的时间，换言之，可以<strong>牺牲掉一定的准确性，来实现节省空间的效果</strong>。</p> <p>基于上述需求，我们可以想到 Hash 算法：将无限大的空间映射到固定的 size 的输出上；而大数据场景下的 Hash 会遇到冲突会被无限放大的问题</p> <p>如何解决冲突是最核心的问题</p> <ul><li>基于概率数据结构实现的 Bloom Filter 算法采取多 Hash 的方法来减少冲突</li> <li>而其衍生出来的 CMS 算法以同样的思想，基于不同的设计，更为适应这种计数场景
下面介绍该方法的具体实现</li></ul> <h2 id="cms简介"><a href="#cms简介" class="header-anchor">#</a> CMS简介</h2> <p>Count-min Sketch 算法是一个可以用来计数的算法，在数据大小非常大时，一种高效的计数算法，通过牺牲准确性提高的效率。</p> <ul><li>是一个概率数据机构</li></ul> <ul><li>算法效率高</li> <li>提供计数上线</li></ul> <p>其中，重要参数包括</p> <ul><li>Hash 哈希函数的数量： k</li> <li>计数表格列的数量： m</li> <li>内存中用空间： <code>k x m x size of counter</code></li></ul> <h4 id="举个栗子"><a href="#举个栗子" class="header-anchor">#</a> 举个栗子</h4> <p>我们规定一个 m=5，k=3 的Count-min Sketch，用来计数，其中所有hash函数如下</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141337953.png" alt="image-20240914133757906"></p> <p>注意，所有hash函数的结果需 mod m</p> <p>下面开始填表，首先初始状态为</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141338285.webp" alt="img"></p> <p>首先，向里面添加字母B，其ASCII码为66，求hash函数的结果为</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141338670.png" alt="image-20240914133847651"></p> <p>因此，表格变为</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141339026.webp" alt="img"></p> <p>接下来，我们查询字母<strong>A</strong>，其ASCII码为65，求hash函数的结果为</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141339556.png" alt="image-20240914133917531"></p> <p>用这个结果去读表，发现其对应位置均为0，因此字母A最多出现0次，这个值是准确的。</p> <p>然后，我们在查询字母G，其ASCII码为71，求hash函数的结果为</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141339755.png" alt="image-20240914133933732"></p> <p>用这个结果去读表，发现其对应位置均为1，因此字母G最多出现1次；**出错了！**我们从未向里面添加过字母G，这就是一次collision。Count-min Sketch的确会有这种问题，因为这个模型是从Bloom Filter衍生过来的。所以说Count-min Sketch是一个概率模型，返回的结果是一个上限值（upper-bound）。</p> <h2 id="cms-的具体实现"><a href="#cms-的具体实现" class="header-anchor">#</a> CMS 的具体实现</h2> <p>首先第一点，通过 hash 来实现数值空间的转换，通过哈希函数 H 将输入元素 x 映射到一维数组上，通过该 index 的值来判断元素的 Count（是否存在）</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">char</span> x <span class="token operator">:</span> input_element<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	idx <span class="token operator">=</span> <span class="token class-name">Hash</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
	array<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实际上这就是 Bloom Filter 的基础思想，然而无论是定长数组的”有限”还是 Hash 函数本身，都需要考虑冲突问题（两个元素被映射到同一个 index 上），冲突会导致 Count 比真实的大。</p> <p>于是接下来面临的问题就是：**如何降低冲突的概率？**如何提高计数的准确性（实际上也包含在降低冲突的概率中）</p> <p>可以参考 Bloom Filter 的策略，其通过<strong>多个 Hash 函数</strong>来映射同一个数，从而来降低元素的冲突概率（未考虑超大数据场景），进而也能提高计数的准确性，那么我们看一下 bloom filter 方法：</p> <blockquote><p>Bloom Filter 算法解决的是<strong>存在性问题</strong>，因此只需要一个 01 向量，当且仅当所有 Hash 计算出来的 index 的值都为 1 的时候，这个元素才可能存在；</p></blockquote> <p>考虑将该方法向 Count 问题上迁移：</p> <ul><li>计数过程中：使用 n 个 Hash 函数计算 idx{1~n} ，然后 <code>vec[idx[i]] += 1</code> 对count+1</li> <li>查询过程中：使用 n 个 Hash 函数计算 idx{1~n}，然后取 <code>vec[idx[i]]</code> 的最小值，考虑冲突场景可知，这个最小值&gt;=实际的 count。</li></ul> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">int</span> query_count <span class="token operator">=</span> <span class="token constant">INT_MAX</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> function_size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token class-name">Hash</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> tmp_count <span class="token operator">=</span> count_set<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
	query_count <span class="token operator">=</span> <span class="token punctuation">(</span>tmp_count <span class="token operator">&lt;</span> query_count<span class="token punctuation">)</span><span class="token operator">?</span> tmp_count<span class="token operator">:</span> query_count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实际上<strong>取多个 hash 的最小值</strong>就是 Count-Min Sketch 的核心，但如果仅是如此很明显有个问题，就是多个 hash 函数算出的多个 idx 会进一步的“污染”计数，得不偿失，导致 Count 更加不准确。</p> <p>实际上很容易想到，为了通过多个 hash 来减少冲突，并使得多 hash 的索引更加的唯一，最好的办法就是使得每个 hash 对应的计数空间是独立的，也就是将我们的计数空间在拓展成二维数组,其 size 为 <em>depth × width</em> 其中 depth 就代表 hash 函数的个数。</p> <p>那么假设每个 Hash 函数的冲突概率是 p~i~ 那么优化后的冲突概率就从 min(P~i~) 减小到</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141407648.png" alt="image-20240914140713619"></p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>function_size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token class-name">Hash</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span>query<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> tmp_count <span class="token operator">=</span> count_set<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
	query_count <span class="token operator">=</span> <span class="token punctuation">(</span>tmp_count <span class="token operator">&lt;</span> query_count<span class="token punctuation">)</span><span class="token operator">?</span> tmp_count<span class="token operator">:</span> query_count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>结合了这个二维数组就是完整的 CMS 算法了，最终求得的 count 是实际 Count 的近似值（上界）。</p> <h2 id="cms-的参数选择"><a href="#cms-的参数选择" class="header-anchor">#</a> CMS 的参数选择</h2> <p>如果确定使用 CMS，接下来面对的就是计数的精度问题，那么如何选择这个数组的 shape 才能尽可能的减少误差呢？（很明显都是越大越好，那么怎么样是最优/达标的呢）</p> <p>确定一些变量参数：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141408570.png" alt="image-20240914140817544"></p> <p>设定误差范围：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141408107.png" alt="image-20240914140829086"></p> <p>以及结果在这个范围内的概率为:</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141408686.png" alt="image-20240914140839662"></p> <p>那么可以计算出：e 是自然常数</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141408847.png" alt="image-20240914140852823"></p> <p>计算公式来自论文，有效性分析也可以从论文中阅读</p> <blockquote><p>添加一个新哈希函数以指数级别迅速降低超出边界异常数据的概率；当然，增加矩阵的宽度也可以增加减少冲突的概率，但这个只是线性级别。</p></blockquote> <h2 id="count-mean-min-sketch"><a href="#count-mean-min-sketch" class="header-anchor">#</a> Count-Mean-Min-Sketch</h2> <p>由于 Hash 的冲突，<strong>CMS 对于低频的元素误差还是太大了</strong>，引入噪音对于高频元素可以接受（topk）但是对于低频长尾来说太不准确了，因此有了以下的改进：</p> <ul><li>首先按照 CMS 的流程取出 d 个 sketch</li> <li>对于每个 hash 估计出一个噪音，噪音为该行的所有整数（除了被查询元素）的平均值</li> <li>该行的 sketch 减去该行的噪音，作为真正的 sketch</li> <li>返回 d 个 sketch 的中位数</li></ul> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">class</span> <span class="token class-name">CountMeanMinSketch</span> <span class="token punctuation">{</span>
    <span class="token comment">// initialization and addition procedures as in CountMinSketch</span>
    <span class="token comment">// n is total number of added elements</span>
    <span class="token keyword">long</span> <span class="token function">estimateFrequency</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">long</span> e<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">long</span><span class="token punctuation">[</span>d<span class="token punctuation">]</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> d<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sketchCounter <span class="token operator">=</span> estimators<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span> <span class="token function">hash</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">]</span>
            noiseEstimation <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> sketchCounter<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token punctuation">(</span>m <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
            e<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sketchCounter – noiseEstimator
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> <span class="token function">median</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该算法显著改善了在长尾数据上的精确度。</p> <h2 id="参考文献"><a href="#参考文献" class="header-anchor">#</a> 参考文献</h2> <p><a href="https://zhuanlan.zhihu.com/p/369981005" target="_blank" rel="noopener noreferrer">Count-min Sketch 算法 - 知乎 (zhihu.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://aikenh.cn/cn/CountMinSketch/" target="_blank" rel="noopener noreferrer">Count_Min Sketch算法 - AikenH Blogs<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/01.热门算法/01.热门算法/03.Count-Min Sketch.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新于:</span> <span class="time">2024/09/15, 13:32:51</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/1e28a2/" class="prev">Consistent Hashing</a></span> <span class="next"><a href="/pages/87589a/">LRU</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.aaad5302.js" defer></script><script src="/assets/js/2.933750c6.js" defer></script><script src="/assets/js/10.2cc95be8.js" defer></script><script src="/assets/js/7.7eb70372.js" defer></script>
  </body>
</html>
