<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>第五课：Netty 如何高效接收网络数据 | EchoDesign</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="系统设计之「讲解 + 面试指南」，水滴石穿，设计无银弹！">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.c76c3453.css" as="style"><link rel="preload" href="/assets/js/app.bd2af867.js" as="script"><link rel="preload" href="/assets/js/2.933750c6.js" as="script"><link rel="preload" href="/assets/js/55.35c5cbfa.js" as="script"><link rel="preload" href="/assets/js/7.7eb70372.js" as="script"><link rel="prefetch" href="/assets/js/10.2cc95be8.js"><link rel="prefetch" href="/assets/js/100.298ad15f.js"><link rel="prefetch" href="/assets/js/101.99b73fec.js"><link rel="prefetch" href="/assets/js/11.c7521a10.js"><link rel="prefetch" href="/assets/js/12.38d1989d.js"><link rel="prefetch" href="/assets/js/13.65d33f38.js"><link rel="prefetch" href="/assets/js/14.397b7600.js"><link rel="prefetch" href="/assets/js/15.b3c76984.js"><link rel="prefetch" href="/assets/js/16.60cde607.js"><link rel="prefetch" href="/assets/js/17.acb3bf3d.js"><link rel="prefetch" href="/assets/js/18.e491edb6.js"><link rel="prefetch" href="/assets/js/19.daf31819.js"><link rel="prefetch" href="/assets/js/20.cb4a5c13.js"><link rel="prefetch" href="/assets/js/21.049c5e3f.js"><link rel="prefetch" href="/assets/js/22.ff4c8ad5.js"><link rel="prefetch" href="/assets/js/23.4d814163.js"><link rel="prefetch" href="/assets/js/24.615412d4.js"><link rel="prefetch" href="/assets/js/25.1d172890.js"><link rel="prefetch" href="/assets/js/26.96f3c12e.js"><link rel="prefetch" href="/assets/js/27.90323e82.js"><link rel="prefetch" href="/assets/js/28.95a1fb6b.js"><link rel="prefetch" href="/assets/js/29.371a40e1.js"><link rel="prefetch" href="/assets/js/3.5c09ac9d.js"><link rel="prefetch" href="/assets/js/30.ac997df0.js"><link rel="prefetch" href="/assets/js/31.df4cc39d.js"><link rel="prefetch" href="/assets/js/32.13b70e91.js"><link rel="prefetch" href="/assets/js/33.06627774.js"><link rel="prefetch" href="/assets/js/34.6671ead6.js"><link rel="prefetch" href="/assets/js/35.37ae6824.js"><link rel="prefetch" href="/assets/js/36.4602e394.js"><link rel="prefetch" href="/assets/js/37.51145580.js"><link rel="prefetch" href="/assets/js/38.40fe2658.js"><link rel="prefetch" href="/assets/js/39.84b6e82e.js"><link rel="prefetch" href="/assets/js/4.73518a0f.js"><link rel="prefetch" href="/assets/js/40.591baf2a.js"><link rel="prefetch" href="/assets/js/41.f961e422.js"><link rel="prefetch" href="/assets/js/42.b34f1599.js"><link rel="prefetch" href="/assets/js/43.5a509601.js"><link rel="prefetch" href="/assets/js/44.64fd3383.js"><link rel="prefetch" href="/assets/js/45.844e1064.js"><link rel="prefetch" href="/assets/js/46.7c2fa3a4.js"><link rel="prefetch" href="/assets/js/47.9bed4c1b.js"><link rel="prefetch" href="/assets/js/48.16e1233b.js"><link rel="prefetch" href="/assets/js/49.eaa08b9e.js"><link rel="prefetch" href="/assets/js/5.94727770.js"><link rel="prefetch" href="/assets/js/50.4fb0caa1.js"><link rel="prefetch" href="/assets/js/51.ad7a3e32.js"><link rel="prefetch" href="/assets/js/52.18c75eba.js"><link rel="prefetch" href="/assets/js/53.f76e624c.js"><link rel="prefetch" href="/assets/js/54.3098ec9f.js"><link rel="prefetch" href="/assets/js/56.67ae905d.js"><link rel="prefetch" href="/assets/js/57.204f4e75.js"><link rel="prefetch" href="/assets/js/58.7144aef6.js"><link rel="prefetch" href="/assets/js/59.28ca51b4.js"><link rel="prefetch" href="/assets/js/6.0b558b79.js"><link rel="prefetch" href="/assets/js/60.66a7f41d.js"><link rel="prefetch" href="/assets/js/61.08b4acf0.js"><link rel="prefetch" href="/assets/js/62.5cc838f8.js"><link rel="prefetch" href="/assets/js/63.392eea42.js"><link rel="prefetch" href="/assets/js/64.f22c5bcd.js"><link rel="prefetch" href="/assets/js/65.0b2ab47d.js"><link rel="prefetch" href="/assets/js/66.2ae7a107.js"><link rel="prefetch" href="/assets/js/67.79dd6daf.js"><link rel="prefetch" href="/assets/js/68.1b76c178.js"><link rel="prefetch" href="/assets/js/69.7ac52a2f.js"><link rel="prefetch" href="/assets/js/70.7279b1df.js"><link rel="prefetch" href="/assets/js/71.f44644ed.js"><link rel="prefetch" href="/assets/js/72.c8cf2fab.js"><link rel="prefetch" href="/assets/js/73.526febf1.js"><link rel="prefetch" href="/assets/js/74.d9ad1a67.js"><link rel="prefetch" href="/assets/js/75.7c86d41a.js"><link rel="prefetch" href="/assets/js/76.757a0ce9.js"><link rel="prefetch" href="/assets/js/77.7b3f6980.js"><link rel="prefetch" href="/assets/js/78.31a353ef.js"><link rel="prefetch" href="/assets/js/79.173bbc8c.js"><link rel="prefetch" href="/assets/js/8.0ec7f6e8.js"><link rel="prefetch" href="/assets/js/80.d8713e74.js"><link rel="prefetch" href="/assets/js/81.d124398a.js"><link rel="prefetch" href="/assets/js/82.3b90a7cc.js"><link rel="prefetch" href="/assets/js/83.f3a9ee0c.js"><link rel="prefetch" href="/assets/js/84.eeb423e8.js"><link rel="prefetch" href="/assets/js/85.4cd3a775.js"><link rel="prefetch" href="/assets/js/86.931cbb70.js"><link rel="prefetch" href="/assets/js/87.526ca8f2.js"><link rel="prefetch" href="/assets/js/88.93192130.js"><link rel="prefetch" href="/assets/js/89.e6cb2516.js"><link rel="prefetch" href="/assets/js/9.6e274fca.js"><link rel="prefetch" href="/assets/js/90.e90dd5ad.js"><link rel="prefetch" href="/assets/js/91.4150a0c3.js"><link rel="prefetch" href="/assets/js/92.6b777d4b.js"><link rel="prefetch" href="/assets/js/93.f8975bc4.js"><link rel="prefetch" href="/assets/js/94.7dffa77f.js"><link rel="prefetch" href="/assets/js/95.16e48ffc.js"><link rel="prefetch" href="/assets/js/96.5ed2d348.js"><link rel="prefetch" href="/assets/js/97.4d4bfff5.js"><link rel="prefetch" href="/assets/js/98.10f4b27a.js"><link rel="prefetch" href="/assets/js/99.4a895015.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c76c3453.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="EchoDesign" class="logo"> <span class="site-name can-hide">EchoDesign</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 深度剖析</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 深度剖析</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>一、前言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二、基础知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>三、主线任务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>四、深入 Netty 核心</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/65674f/" class="sidebar-link">第一课：透过 Netty 看 IO 模型</a></li><li><a href="/pages/440035/" class="sidebar-link">第二课：Reactor在 Netty 中的实现（创建篇）</a></li><li><a href="/pages/bb668a/" class="sidebar-link">第三课：Netty 核心引擎 Reactor 的运转架构</a></li><li><a href="/pages/be98dc/" class="sidebar-link">第四课：Netty 如何高效接收网络连接</a></li><li><a href="/pages/0938c1/" aria-current="page" class="active sidebar-link">第五课：Netty 如何高效接收网络数据</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/0938c1/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/0938c1/#_1-sub-reactor处理op-read事件流程总览" class="sidebar-link">1. Sub Reactor处理OP_READ事件流程总览</a></li><li class="sidebar-sub-header level2"><a href="/pages/0938c1/#_2-netty接收网络数据流程总览" class="sidebar-link">2. Netty接收网络数据流程总览</a></li><li class="sidebar-sub-header level2"><a href="/pages/0938c1/#_3-源码核心框架总览" class="sidebar-link">3. 源码核心框架总览</a></li><li class="sidebar-sub-header level2"><a href="/pages/0938c1/#_4-bytebuffer动态自适应扩缩容机制" class="sidebar-link">4. ByteBuffer动态自适应扩缩容机制</a></li><li class="sidebar-sub-header level2"><a href="/pages/0938c1/#_5-使用堆外内存为bytebuffer分配内存" class="sidebar-link">5. 使用堆外内存为ByteBuffer分配内存</a></li><li class="sidebar-sub-header level2"><a href="/pages/0938c1/#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level2"><a href="/pages/0938c1/#参考资料" class="sidebar-link">参考资料</a></li></ul></li><li><a href="/pages/a73206/" class="sidebar-link">第六课：Netty 如何高效发送网络数据</a></li><li><a href="/pages/a1b0fe/" class="sidebar-link">第七课：Netty 中IO事件的触发时机和传播流程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>五、深入 Netty 内存管理</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Netty 系统设计</span></li><li data-v-06225672><span data-v-06225672>四、深入 Netty 核心</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-19</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">第五课：Netty 如何高效接收网络数据<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409191130021.png" alt="图片"></p> <h3 id="前文回顾"><a href="#前文回顾" class="header-anchor">#</a> 前文回顾</h3> <p>在前边的系列文章中，我们从内核如何收发网络数据开始以一个 C10K 的问题作为主线详细从内核角度阐述了网络IO模型的演变，最终在此基础上引出了Netty的网络IO模型如下图所示：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409191130408.png" alt="图片"></p> <blockquote><p>详细内容可回看<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247483737&amp;idx=1&amp;sn=7ef3afbb54289c6e839eed724bb8a9d6&amp;chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">?《从内核角度看IO模型的演变》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <p>后续我们又围绕着Netty的主从Reactor网络IO线程模型，在<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247483907&amp;idx=1&amp;sn=084c470a8fe6234c2c9461b5f713ff30&amp;chksm=ce77c444f9004d52e7c6244bee83479070effb0bc59236df071f4d62e91e25f01715fca53696&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">?《Reactor模型在Netty中的实现》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文中详细阐述了Netty的主从Reactor模型的创建，以及介绍了Reactor模型的关键组件。搭建了Netty的核心骨架如下图所示：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409191130297.png" alt="图片"></p> <p>在核心骨架搭建完毕之后，我们随后又在<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247484005&amp;idx=1&amp;sn=52f51269902a58f40d33208421109bc3&amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">?《详细图解Reactor启动全流程》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文中阐述了Reactor启动的全流程，一个非常重要的核心组件NioServerSocketChannel开始在这里初次亮相，承担着一个网络框架最重要的任务--高效接收网络连接。我们介绍了NioServerSocketChannel的创建，初始化，向Main Reactor注册并监听OP_ACCEPT事件的整个流程。在此基础上，Netty得以整装待发，枕戈待旦开始迎接海量的客户端连接。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409191130695.png" alt="图片"></p> <p>随后紧接着我们在<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247484184&amp;idx=1&amp;sn=726877ce28cf6e5d2ac3225fae687f19&amp;chksm=ce77c55ff9004c493b592288819dc4d4664b5949ee97fed977b6558bc517dad0e1f73fab0f46&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">?《Netty如何高效接收网络连接》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文中详细介绍了Netty高效接收客户端网络连接的全流程，在这里Netty的核心重要组件NioServerSocketChannel开始正是登场，在NioServerSocketChannel中我们创建了客户端连接NioSocketChannel，并详细介绍了NioSocketChannel的初始化过程，随后通过在NioServerSocketChannel的pipeline中触发ChannelRead事件，并最终在ServerBootstrapAcceptor中将客户端连接NioSocketChannel注册到Sub Reactor中开始监听客户端连接上的OP_READ事件，准备接收客户端发送的网络数据也就是本文的主题内容。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409191130550.png" alt="图片"></p> <p>自此Netty的核心组件全部就绪并启动完毕，开始起飞~~~</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409191130148.png" alt="图片"></p> <p>之前文章中的主角是Netty中主Reactor组中的Main Reactor以及注册在Main Reactor上边的NioServerSocketChannel，那么从本文开始，我们文章中的主角就切换为Sub Reactor以及注册在SubReactor上的NioSocketChannel了。</p> <p>下面就让我们正式进入今天的主题，看一下Netty是如何处理OP_READ事件以及如何高效接收网络数据的。</p> <h2 id="_1-sub-reactor处理op-read事件流程总览"><a href="#_1-sub-reactor处理op-read事件流程总览" class="header-anchor">#</a> 1. Sub Reactor处理OP_READ事件流程总览</h2> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409191543052.webp" alt="图片"></p> <p>客户端发起系统IO调用向服务端发送数据之后，当网络数据到达服务端的网卡并经过内核协议栈的处理，最终数据到达Socket的接收缓冲区之后，Sub Reactor轮询到NioSocketChannel上的 <code>OP_READ事件</code> 就绪，随后 Sub Reactor 线程就会从 JDK Selector 上的阻塞轮询API<code>selector.select(timeoutMillis)</code>调用中返回。转而去处理NioSocketChannel上的<code>OP_READ事件</code>。</p> <blockquote><p>注意这里的Reactor为负责处理客户端连接的Sub Reactor。连接的类型为NioSocketChannel，处理的事件为OP_READ事件。</p></blockquote> <p>在之前的文章中笔者已经多次强调过了，Reactor在处理Channel上的IO事件入口函数为<code>NioEventLoop#processSelectedKey</code>。</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">NioEventLoop</span> <span class="token keyword">extends</span> <span class="token class-name">SingleThreadEventLoop</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">processSelectedKey</span><span class="token punctuation">(</span><span class="token class-name">SelectionKey</span> k<span class="token punctuation">,</span> <span class="token class-name">AbstractNioChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">AbstractNioChannel<span class="token punctuation">.</span>NioUnsafe</span> unsafe <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> readyOps <span class="token operator">=</span> k<span class="token punctuation">.</span><span class="token function">readyOps</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_CONNECT</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>处理<span class="token constant">OP_CONNECT</span>事件<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span>


            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_WRITE</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>处理<span class="token constant">OP_WRITE</span>事件<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span>


            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>readyOps <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_READ</span> <span class="token operator">|</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_ACCEPT</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">||</span> readyOps <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//本文重点处理OP_ACCEPT事件</span>
                unsafe<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CancelledKeyException</span> ignored<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            unsafe<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span>unsafe<span class="token punctuation">.</span><span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>这里需要重点强调的是，当前的执行线程现在已经变成了 Sub Reactor，而 Sub Reactor 上注册的正是 netty 客户端 NioSocketChannel负责处理连接上的读写事件。</p> <p>所以这里入口函数的参数<code>AbstractNioChannel ch</code>则是IO就绪的客户端连接<code>NioSocketChannel</code>。</p> <p>开头通过<code>ch.unsafe()</code>获取到的NioUnsafe操作类正是NioSocketChannel中对底层JDK NIO SocketChannel的Unsafe底层操作类。实现类型为<code>NioByteUnsafe</code>定义在下图继承结构中的<code>AbstractNioByteChannel</code>父类中。</p> <p>![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)image.png</p> <p>下面我们到<code>NioByteUnsafe#read</code>方法中来看下Netty对<code>OP_READ事件</code>的具体处理过程：</p> <h2 id="_2-netty接收网络数据流程总览"><a href="#_2-netty接收网络数据流程总览" class="header-anchor">#</a> 2. Netty接收网络数据流程总览</h2> <p>我们直接按照老规矩，先从整体上把整个OP_READ事件的逻辑处理框架提取出来，让大家先总体俯视下流程全貌，然后在针对每个核心点位进行各个击破。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409191131609.png" alt="图片"></p> <blockquote><p>流程中相关置灰的步骤为Netty处理连接关闭时的逻辑，和本文主旨无关，我们这里暂时忽略，等后续笔者介绍连接关闭时，会单独开一篇文章详细为大家介绍。</p></blockquote> <p>从上面这张Netty接收网络数据总体流程图可以看出NioSocketChannel在接收网络数据的整个流程和我们在上篇文章<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247484184&amp;idx=1&amp;sn=726877ce28cf6e5d2ac3225fae687f19&amp;chksm=ce77c55ff9004c493b592288819dc4d4664b5949ee97fed977b6558bc517dad0e1f73fab0f46&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">?《Netty如何高效接收网络连接》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中介绍的NioServerSocketChannel在接收客户端连接时的流程在总体框架上是一样的。</p> <p>NioSocketChannel在接收网络数据的过程处理中，也是通过在一个<code>do{....}while(...)</code>循环read loop中不断的循环读取连接NioSocketChannel上的数据。</p> <p>同样在NioSocketChannel读取连接数据的read loop中也是受最大读取次数的限制。默认配置最多只能读取16次，超过16次无论此时NioSocketChannel中是否还有数据可读都不能在进行读取了。</p> <p>这里read loop循环最大读取次数可在启动配置类ServerBootstrap中通过<code>ChannelOption.MAX_MESSAGES_PER_READ</code>选项设置，默认为16。</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token class-name">ServerBootstrap</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServerBootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>bossGroup<span class="token punctuation">,</span> workerGroup<span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioServerSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span><span class="token constant">MAX_MESSAGES_PER_READ</span><span class="token punctuation">,</span> 自定义次数<span class="token punctuation">)</span>
</code></pre></div><p>**Netty这里为什么非得限制read loop的最大读取次数呢？**为什么不在 read loop 中一次性把数据读取完呢？</p> <p>这时候就是考验我们大局观的时候了，在前边的文章介绍中我们提到Netty的IO模型为主从Reactor线程组模型，在Sub Reactor Group中包含了多个Sub Reactor专门用于监听处理客户端连接上的IO事件。</p> <p>为了能够高效有序的处理全量客户端连接上的读写事件，Netty将服务端承载的全量客户端连接分摊到多个Sub Reactor中处理，同时也能保证<code>Channel上IO处理的线程安全性</code>。</p> <p>其中一个Channel只能分配给一个固定的Reactor。一个Reactor负责处理多个Channel上的IO就绪事件，Reactor与Channel之间的对应关系如下图所示：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409191544903.webp" alt="图片"></p> <p>而一个 Sub Reactor上注册了多个NioSocketChannel，Netty 不可能在一个 NioSocketChannel 上无限制的处理下去，要将读取数据的机会均匀分摊给其他 NioSocketChannel，所以需要限定每个 NioSocketChannel 上的最大读取次数。</p> <p>此外，Sub Reactor除了需要监听处理所有注册在它上边的NioSocketChannel中的IO就绪事件之外，还需要腾出事件来处理有用户线程提交过来的异步任务。从这一点看，Netty也不会一直停留在NioSocketChannel的IO处理上。所以限制read loop的最大读取次数是非常必要的。</p> <blockquote><p>关于Reactor的整体运转架构，对细节部分感兴趣的同学可以回看下笔者的<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247484087&amp;idx=1&amp;sn=0c065780e0f05c23c8e6465ede86cba0&amp;chksm=ce77c4f0f9004de63be369a664105708bc5975b52993f4a6df223caed34cc1ef6185a16acd75&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">?《一文聊透Netty核心引擎Reactor的运转架构》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>这篇文章。</p></blockquote> <p>所以基于这个原因，我们需要在read loop循环中，每当通过<code>doReadBytes</code>方法从NioSocketChannel中读取到数据时（方法返回值会大于0，并记录在allocHandle.lastBytesRead中），都需要通过<code>allocHandle.incMessagesRead(1)</code>方法统计已经读取的次数。当达到16次时不管NioSocketChannel是否还有数据可读，都需要在read loop末尾退出循环。转去执行Sub Reactor上的异步任务。以及其他NioSocketChannel上的IO就绪事件。平均分配，雨露均沾！！</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MaxMessageHandle</span> <span class="token keyword">implements</span> <span class="token class-name">ExtendedHandle</span> <span class="token punctuation">{</span>

        <span class="token comment">//read loop总共读取了多少次</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> totalMessages<span class="token punctuation">;</span>

       <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">incMessagesRead</span><span class="token punctuation">(</span><span class="token keyword">int</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            totalMessages <span class="token operator">+=</span> amt<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>本次 read loop 读取到的数据大小会记录在<code>allocHandle.lastBytesRead</code>中</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MaxMessageHandle</span> <span class="token keyword">implements</span> <span class="token class-name">ExtendedHandle</span> <span class="token punctuation">{</span>

         <span class="token comment">//本次read loop读取到的字节数</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> lastBytesRead<span class="token punctuation">;</span>
        <span class="token comment">//整个read loop循环总共读取的字节数</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> totalBytesRead<span class="token punctuation">;</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token keyword">int</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            lastBytesRead <span class="token operator">=</span> bytes<span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                totalBytesRead <span class="token operator">+=</span> bytes<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><code>lastBytesRead &lt; 0</code>：表示客户端主动发起了连接关闭流程，Netty开始连接关闭处理流程。这个和本文的主旨无关，我们先不用管。后面笔者会专门用一篇文章来详解关闭流程。</li> <li><code>lastBytesRead = 0</code>：表示当前NioSocketChannel上的数据已经全部读取完毕，没有数据可读了。本次OP_READ事件圆满处理完毕，可以开开心心的退出read loop。</li> <li>当<code>lastBytesRead &gt; 0</code>：表示在本次read loop中从NioSocketChannel中读取到了数据，会在NioSocketChannel的pipeline中触发ChannelRead事件。进而在pipeline中负责IO处理的ChannelHandelr中响应，处理网络请求。</li></ul> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409191131926.png" alt="图片">fir</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EchoServerHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>处理网络请求，比如解码<span class="token punctuation">,</span>反序列化等操作<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后会在read loop循环的末尾调用<code>allocHandle.continueReading()</code>判断是否结束本次read loop循环。这里的结束循环条件的判断会比我们在介绍NioServerSocketChannel接收连接时的判断条件复杂很多，笔者会将这个判断条件的详细解析放在文章后面细节部分为大家解读，这里大家只需要把握总体核心流程，不需要关注太多细节。</p> <p>总体上在NioSocketChannel中读取网络数据的read loop循环结束条件需要满足以下几点：</p> <ul><li>当前NioSocketChannel中的数据已经全部读取完毕，则退出循环。</li> <li>本轮read loop如果没有读到任何数据，则退出循环。</li> <li>read loop的读取次数达到16次，退出循环。</li></ul> <p>当满足这里的read loop退出条件之后，Sub Reactor线程就会退出循环，随后会调用<code>allocHandle.readComplete()</code>方法根据本轮read loop总共读取到的字节数<code>totalBytesRead</code>来决定是否对用于接收下一轮OP_READ事件数据的ByteBuffer进行扩容或者缩容。</p> <p>最后在NioSocketChannel的pipeline中触发<code>ChannelReadComplete事件</code>，通知ChannelHandler本次OP_READ事件已经处理完毕。</p> <p>![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)fireChannelReadComplete.png</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">EchoServerHandler</span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelRead</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span> <span class="token class-name">Object</span> msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>处理网络请求，比如解码<span class="token punctuation">,</span>反序列化等操作<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">channelReadComplete</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>本次<span class="token constant">OP_READ</span>事件处理完毕<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>决定是否向客户端响应处理结果<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_2-1-channelread与channelreadcomplete事件的区别"><a href="#_2-1-channelread与channelreadcomplete事件的区别" class="header-anchor">#</a> 2.1 ChannelRead与ChannelReadComplete事件的区别</h3> <blockquote><p>有些小伙伴可能对Netty中的一些传播事件触发的时机，或者事件之间的区别理解的不是很清楚，概念容易混淆。在后面的文章中笔者也会从源码的角度出发给大家说清楚Netty中定义的所有异步事件，以及这些事件之间的区别和联系和触发时机，传播机制。</p></blockquote> <p>这里我们主要探讨本文主题中涉及到的两个事件：ChannelRead事件与ChannelReadComplete事件。</p> <p>从上述介绍的Netty接收网络数据流程总览中我们可以看出<code>ChannelRead事件</code>和<code>ChannelReadComplete事件</code>是不一样的，但是对于刚接触Netty的小伙伴来说从命名上乍一看感觉又差不多。</p> <p>下面我们来看这两个事件之间的差别：</p> <p>Netty服务端对于一次OP_READ事件的处理，会在一个<code>do{}while()</code>循环read loop中分多次从客户端NioSocketChannel中读取网络数据。每次读取我们分配的ByteBuffer容量大小，初始容量为2048。</p> <ul><li><code>ChanneRead事件</code>：一次循环读取一次数据，就触发一次<code>ChannelRead事件</code>。本次最多读取在read loop循环开始分配的DirectByteBuffer容量大小。这个容量会动态调整，文章后续笔者会详细介绍。</li> <li><code>ChannelReadComplete事件</code>：当读取不到数据或者不满足<code>continueReading</code>的任意一个条件就会退出read loop，这时就会触发<code>ChannelReadComplete事件</code>。表示本次<code>OP_READ事件</code>处理完毕。</li></ul> <blockquote><p><strong>这里需要特别注意下</strong>触发<code>ChannelReadComplete事件</code>并不代表NioSocketChannel中的数据已经读取完了，只能说明本次<code>OP_READ事件</code>处理完毕。因为有可能是客户端发送的数据太多，Netty读了<code>16次</code>还没读完，那就只能等到下次<code>OP_READ事件</code>到来的时候在进行读取了。</p></blockquote> <hr> <p>以上内容就是Netty在接收客户端发送网络数据的全部核心逻辑。目前为止我们还未涉及到这部分的主干核心源码，笔者想的是先给大家把核心逻辑讲解清楚之后，这样理解起来核心主干源码会更加清晰透彻。</p> <p>经过前边对网络数据接收的核心逻辑介绍，笔者在把这张流程图放出来，大家可以结合这张图在来回想下主干核心逻辑。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409191131609.png" alt="图片"></p> <p>下面笔者会结合这张流程图，给大家把这部分的核心主干源码框架展现出来，大家可以将我们介绍过的核心逻辑与主干源码做个一一对应，还是那句老话，我们要从主干框架层面把握整体处理流程，不需要读懂每一行代码，文章后续笔者会将这个过程中涉及到的核心点位给大家拆开来各个击破！！</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409191131492.png" alt="图片"></p> <h2 id="_3-源码核心框架总览"><a href="#_3-源码核心框架总览" class="header-anchor">#</a> 3. 源码核心框架总览</h2> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">ChannelConfig</span> config <span class="token operator">=</span> <span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>处理半关闭相关代码省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        <span class="token comment">//获取NioSocketChannel的pipeline</span>
        <span class="token keyword">final</span> <span class="token class-name">ChannelPipeline</span> pipeline <span class="token operator">=</span> <span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//PooledByteBufAllocator 具体用于实际分配ByteBuf的分配器</span>
    <span class="token keyword">final</span> <span class="token class-name">ByteBufAllocator</span> allocator <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getAllocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//自适应ByteBuf分配器 AdaptiveRecvByteBufAllocator ,用于动态调节ByteBuf容量</span>
    <span class="token comment">//需要与具体的ByteBuf分配器配合使用 比如这里的PooledByteBufAllocator</span>
    <span class="token keyword">final</span> <span class="token class-name">RecvByteBufAllocator<span class="token punctuation">.</span>Handle</span> allocHandle <span class="token operator">=</span> <span class="token function">recvBufAllocHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//allocHandler用于统计每次读取数据的大小，方便下次分配合适大小的ByteBuf</span>
    <span class="token comment">//重置清除上次的统计指标</span>
    allocHandle<span class="token punctuation">.</span><span class="token function">reset</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token class-name">ByteBuf</span> byteBuf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
    <span class="token keyword">boolean</span> close <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">do</span> <span class="token punctuation">{</span>
            <span class="token comment">//利用PooledByteBufAllocator分配合适大小的byteBuf 初始大小为2048</span>
            byteBuf <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>allocator<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//记录本次读取了多少字节数</span>
            allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token function">doReadBytes</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//如果本次没有读取到任何字节，则退出循环 进行下一轮事件轮询</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// nothing was read. release the buffer.</span>
                byteBuf<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                byteBuf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
                close <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>close<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>表示客户端发起连接关闭<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                <span class="token punctuation">}</span>
                <span class="token keyword">break</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token comment">//read loop读取数据次数+1</span>
            allocHandle<span class="token punctuation">.</span><span class="token function">incMessagesRead</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//客户端NioSocketChannel的pipeline中触发ChannelRead事件</span>
            pipeline<span class="token punctuation">.</span><span class="token function">fireChannelRead</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//解除本次读取数据分配的ByteBuffer引用，方便下一轮read loop分配</span>
            byteBuf <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>allocHandle<span class="token punctuation">.</span><span class="token function">continueReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//判断是否应该继续read loop</span>

        <span class="token comment">//根据本次read loop总共读取的字节数，决定下次是否扩容或者缩容</span>
        allocHandle<span class="token punctuation">.</span><span class="token function">readComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//在NioSocketChannel的pipeline中触发ChannelReadComplete事件，表示一次read事件处理完毕</span>
        <span class="token comment">//但这并不表示 客户端发送来的数据已经全部读完，因为如果数据太多的话，这里只会读取16次，剩下的会等到下次read事件到来后在处理</span>
        pipeline<span class="token punctuation">.</span><span class="token function">fireChannelReadComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略连接关闭流程处理<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>这里再次强调下当前执行线程为Sub Reactor线程，处理连接数据读取逻辑是在NioSocketChannel中。</p></blockquote> <p>首先通过<code>config()</code>获取客户端NioSocketChannel的Channel配置类NioSocketChannelConfig。</p> <p>通过<code>pipeline()</code>获取NioSocketChannel的pipeline。我们在 <a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247484005&amp;idx=1&amp;sn=52f51269902a58f40d33208421109bc3&amp;chksm=ce77c422f9004d340e5b385ef6ba24dfba1f802076ace80ad6390e934173a10401e64e13eaeb&amp;token=1943348780&amp;lang=zh_CN&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">?《详细图解Netty Reactor启动全流程》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文中提到的Netty服务端模板所举的示例中，NioSocketChannelde pipeline中只有一个EchoChannelHandler。</p> <p>![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)客户端channel pipeline结构.png</p> <h3 id="_3-1-分配directbytebuffer接收网络数据"><a href="#_3-1-分配directbytebuffer接收网络数据" class="header-anchor">#</a> 3.1 分配DirectByteBuffer接收网络数据</h3> <p>Sub Reactor 在接收NioSocketChannel上的IO数据时，都会分配一个 ByteBuffer 用来存放接收到的IO数据。</p> <p>这里大家可能觉得比较奇怪，为什么在NioSocketChannel接收数据这里会有两个ByteBuffer分配器呢？一个是ByteBufAllocator，另一个是RecvByteBufAllocator。</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">ByteBufAllocator</span> allocator <span class="token operator">=</span> config<span class="token punctuation">.</span><span class="token function">getAllocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">final</span> <span class="token class-name">RecvByteBufAllocator<span class="token punctuation">.</span>Handle</span> allocHandle <span class="token operator">=</span> <span class="token function">recvBufAllocHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>这两个ByteBuffer又有什么区别和联系呢？</strong></p> <p>在上篇文章<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247484184&amp;idx=1&amp;sn=726877ce28cf6e5d2ac3225fae687f19&amp;chksm=ce77c55ff9004c493b592288819dc4d4664b5949ee97fed977b6558bc517dad0e1f73fab0f46&amp;scene=21&amp;cur_album_id=2217816582418956300#wechat_redirect" target="_blank" rel="noopener noreferrer">?《抓到Netty一个Bug，顺带来透彻地聊一下Netty是如何高效接收网络连接》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中，笔者为了阐述上篇文章中提到的Netty在接收网络连接时的 Bug 时，简单和大家介绍了下这个 RecvByteBufAllocator。</p> <p>在上篇文章提到的NioServerSocketChannelConfig中，这里的RecvByteBufAllocator类型为ServerChannelRecvByteBufAllocator。</p> <p>![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)image.png</p> <blockquote><p>还记得这个ServerChannelRecvByteBufAllocator类型在<strong>4.1.69.final</strong>版本引入是为了解决笔者在上篇文章中提到的那个Bug吗？在<strong>4.1.69.final</strong>版本之前，NioServerSocketChannelConfig中的RecvByteBufAllocator类型为AdaptiveRecvByteBufAllocator。</p></blockquote> <p>而在本文中NioSocketChannelConfig中的RecvByteBufAllocator类型为AdaptiveRecvByteBufAllocator。</p> <p>![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)image.png</p> <p>所以这里<code>recvBufAllocHandle()</code>获得到的RecvByteBufAllocator为AdaptiveRecvByteBufAllocator。顾名思义，这个类型的RecvByteBufAllocator可以根据NioSocketChannel上每次到来的IO数据大小来自适应动态调整ByteBuffer的容量。</p> <p>对于客户端NioSocketChannel来说，它里边包含的IO数据时客户端发送来的网络数据，长度是不定的，所以才会需要这样一个可以根据每次IO数据的大小来自适应动态调整容量的ByteBuffer来接收。</p> <p>如果我们把用于接收数据用的ByteBuffer看做一个桶的话，那么小数据用大桶装或者大数据用小桶装肯定是不合适的，所以我们需要根据接收数据的大小来动态调整桶的容量。而AdaptiveRecvByteBufAllocator的作用正是用来根据每次接收数据的容量大小来动态调整ByteBuffer的容量的。</p> <p>现在RecvByteBufAllocator笔者为大家解释清楚了，接下来我们继续看ByteBufAllocator。</p> <blockquote><p>大家这里需要注意的是AdaptiveRecvByteBufAllocator并不会真正的去分配ByteBuffer，它只是负责动态调整分配ByteBuffer的大小。</p></blockquote> <p>而真正具体执行内存分配动作的是这里的ByteBufAllocator类型为PooledByteBufAllocator。它会根据AdaptiveRecvByteBufAllocator动态调整出来的大小去真正的申请内存分配ByteBuffer。</p> <blockquote><p>PooledByteBufAllocator为Netty中的内存池，用来管理堆外内存DirectByteBuffer。</p></blockquote> <p>AdaptiveRecvByteBufAllocator中的allocHandle在上篇文章中我们也介绍过了，它的实际类型为MaxMessageHandle。</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdaptiveRecvByteBufAllocator</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultMaxMessagesRecvByteBufAllocator</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Handle</span> <span class="token function">newHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HandleImpl</span><span class="token punctuation">(</span>minIndex<span class="token punctuation">,</span> maxIndex<span class="token punctuation">,</span> initial<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HandleImpl</span> <span class="token keyword">extends</span> <span class="token class-name">MaxMessageHandle</span> <span class="token punctuation">{</span>
                  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在MaxMessageHandle中包含了用于动态调整ByteBuffer容量的统计指标。</p> <div class="language-Java extra-class"><pre class="language-java"><code>   <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MaxMessageHandle</span> <span class="token keyword">implements</span> <span class="token class-name">ExtendedHandle</span> <span class="token punctuation">{</span>
        <span class="token keyword">private</span> <span class="token class-name">ChannelConfig</span> config<span class="token punctuation">;</span>

        <span class="token comment">//用于控制每次read loop里最大可以循环读取的次数，默认为16次</span>
        <span class="token comment">//可在启动配置类ServerBootstrap中通过ChannelOption.MAX_MESSAGES_PER_READ选项设置。</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> maxMessagePerRead<span class="token punctuation">;</span>

        <span class="token comment">//用于统计read loop中总共接收的连接个数，NioSocketChannel中表示读取数据的次数</span>
        <span class="token comment">//每次read loop循环后会调用allocHandle.incMessagesRead增加记录接收到的连接个数</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> totalMessages<span class="token punctuation">;</span>

        <span class="token comment">//用于统计在read loop中总共接收到客户端连接上的数据大小</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> totalBytesRead<span class="token punctuation">;</span>

        <span class="token comment">//表示本次read loop 尝试读取多少字节，byteBuffer剩余可写的字节数</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> attemptedBytesRead<span class="token punctuation">;</span>

        <span class="token comment">//本次read loop读取到的字节数</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> lastBytesRead<span class="token punctuation">;</span>
        
        <span class="token comment">//预计下一次分配buffer的容量，初始：2048</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> nextReceiveBufferSize<span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在每轮read loop开始之前，都会调用<code>allocHandle.reset(config)</code>重置清空上一轮read loop的统计指标。</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reset</span><span class="token punctuation">(</span><span class="token class-name">ChannelConfig</span> config<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>config <span class="token operator">=</span> config<span class="token punctuation">;</span>
    <span class="token comment">//默认每次最多读取16次</span>
    maxMessagePerRead <span class="token operator">=</span> <span class="token function">maxMessagesPerRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    totalMessages <span class="token operator">=</span> totalBytesRead <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在每次开始从NioSocketChannel中读取数据之前，需要利用<code>PooledByteBufAllocator</code>在内存池中为ByteBuffer分配内存，默认初始化大小为<code>2048</code>，这个容量由<code>guess()方法</code>决定。</p> <div class="language-Java extra-class"><pre class="language-java"><code>byteBuf <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>allocator<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">ByteBuf</span> <span class="token function">allocate</span><span class="token punctuation">(</span><span class="token class-name">ByteBufAllocator</span> alloc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> alloc<span class="token punctuation">.</span><span class="token function">ioBuffer</span><span class="token punctuation">(</span><span class="token function">guess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">guess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//预计下一次分配buffer的容量，一开始为2048</span>
    <span class="token keyword">return</span> nextReceiveBufferSize<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在每次通过<code>doReadBytes</code>从NioSocketChannel中读取到数据后，都会调用<code>allocHandle.lastBytesRead(doReadBytes(byteBuf))</code>记录本次读取了多少字节数据，并统计本轮read loop目前总共读取了多少字节。</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">lastBytesRead</span><span class="token punctuation">(</span><span class="token keyword">int</span> bytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lastBytesRead <span class="token operator">=</span> bytes<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>bytes <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        totalBytesRead <span class="token operator">+=</span> bytes<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>每次循环从NioSocketChannel中读取数据之后，都会调用<code>allocHandle.incMessagesRead(1)</code>。统计当前已经读取了多少次。如果超过了最大读取限制此时16次，就需要退出read loop。去处理其他NioSocketChannel上的IO事件。</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">incMessagesRead</span><span class="token punctuation">(</span><span class="token keyword">int</span> amt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    totalMessages <span class="token operator">+=</span> amt<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在每次read loop循环的末尾都需要通过调用<code>allocHandle.continueReading()</code>来判断是否继续read loop循环读取NioSocketChannel中的数据。</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">continueReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">continueReading</span><span class="token punctuation">(</span>defaultMaybeMoreSupplier<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">UncheckedBooleanSupplier</span> defaultMaybeMoreSupplier <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UncheckedBooleanSupplier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//判断本次读取byteBuffer是否满载而归</span>
        <span class="token keyword">return</span> attemptedBytesRead <span class="token operator">==</span> lastBytesRead<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">continueReading</span><span class="token punctuation">(</span><span class="token class-name">UncheckedBooleanSupplier</span> maybeMoreDataSupplier<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> config<span class="token punctuation">.</span><span class="token function">isAutoRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span><span class="token operator">!</span>respectMaybeMoreData <span class="token operator">||</span> maybeMoreDataSupplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        totalMessages <span class="token operator">&lt;</span> maxMessagePerRead <span class="token operator">&amp;&amp;</span>
        totalBytesRead <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li><code>attemptedBytesRead :</code>表示当前ByteBuffer预计尝试要写入的字节数。</li> <li><code>lastBytesRead :</code>表示本次read loop真实读取到了多少个字节。</li></ul> <p><code>defaultMaybeMoreSupplier</code>用于判断经过本次read loop读取数据后，ByteBuffer是否满载而归。如果是满载而归的话（attemptedBytesRead == lastBytesRead），表明可能NioSocketChannel里还有数据。如果不是满载而归，表明NioSocketChannel里没有数据了已经。</p> <p>是否继续进行read loop需要<strong>同时</strong>满足以下几个条件：</p> <ul><li><p><code>totalMessages &lt; maxMessagePerRead</code> 当前读取次数是否已经超过<code>16次</code>，如果超过，就退出<code>do(...)while()</code>循环。进行下一轮<code>OP_READ事件</code>的轮询。因为每个Sub Reactor管理了多个NioSocketChannel，不能在一个NioSocketChannel上占用太多时间，要将机会均匀地分配给Sub Reactor所管理的所有NioSocketChannel。</p></li> <li><p><code>totalBytesRead &gt; 0</code> 本次<code>OP_READ事件</code>处理是否读取到了数据，如果已经没有数据可读了，那么就直接退出read loop。</p></li> <li><p><code>!respectMaybeMoreData || maybeMoreDataSupplier.get()</code> 这个条件比较复杂，它其实就是通过<code>respectMaybeMoreData</code>字段来控制NioSocketChannel中可能还有数据可读的情况下该如何处理。</p></li> <li><ul><li><code>maybeMoreDataSupplier.get()</code>：true表示本次读取从NioSocketChannel中读取数据，ByteBuffer满载而归。说明可能NioSocketChannel中还有数据没读完。fasle表示ByteBuffer还没有装满，说明NioSocketChannel中已经没有数据可读了。</li> <li><code>respectMaybeMoreData = true</code>表示要对可能还有更多数据进行处理的这种情况要<code>respect</code>认真对待,如果本次循环读取到的数据已经装满<code>ByteBuffer</code>，表示后面可能还有数据，那么就要进行读取。如果<code>ByteBuffer</code>还没装满表示已经没有数据可读了那么就退出循环。![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)</li> <li><code>respectMaybeMoreData = false</code>表示对可能还有更多数据的这种情况不认真对待 <code>not respect</code>。不管本次循环读取数据<code>ByteBuffer</code>是否满载而归，都要继续进行读取，直到读取不到数据在退出循环，属于无脑读取。</li></ul></li></ul> <p>同时满足以上三个条件，那么read loop继续进行。继续从NioSocketChannel中读取数据，直到读取不到或者不满足三个条件中的任意一个为止。</p> <h3 id="_3-2-从niosocketchannel中读取数据"><a href="#_3-2-从niosocketchannel中读取数据" class="header-anchor">#</a> 3.2 从NioSocketChannel中读取数据</h3> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NioSocketChannel</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractNioByteChannel</span> <span class="token keyword">implements</span> <span class="token class-name"><span class="token namespace">io<span class="token punctuation">.</span>netty<span class="token punctuation">.</span>channel<span class="token punctuation">.</span>socket<span class="token punctuation">.</span></span>SocketChannel</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">doReadBytes</span><span class="token punctuation">(</span><span class="token class-name">ByteBuf</span> byteBuf<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token keyword">final</span> <span class="token class-name">RecvByteBufAllocator<span class="token punctuation">.</span>Handle</span> allocHandle <span class="token operator">=</span> <span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">recvBufAllocHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        allocHandle<span class="token punctuation">.</span><span class="token function">attemptedBytesRead</span><span class="token punctuation">(</span>byteBuf<span class="token punctuation">.</span><span class="token function">writableBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    
        <span class="token keyword">return</span> byteBuf<span class="token punctuation">.</span><span class="token function">writeBytes</span><span class="token punctuation">(</span><span class="token function">javaChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> allocHandle<span class="token punctuation">.</span><span class="token function">attemptedBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里会直接调用底层JDK NIO的<code>SocketChannel#read</code>方法将数据读取到DirectByteBuffer中。读取数据大小为本次分配的DirectByteBuffer容量，初始为2048。</p> <h2 id="_4-bytebuffer动态自适应扩缩容机制"><a href="#_4-bytebuffer动态自适应扩缩容机制" class="header-anchor">#</a> 4. ByteBuffer动态自适应扩缩容机制</h2> <p>由于我们一开始并不知道客户端会发送多大的网络数据，所以这里先利用<code>PooledByteBufAllocator</code>分配一个初始容量为<code>2048</code>的DirectByteBuffer用于接收数据。</p> <div class="language-Java extra-class"><pre class="language-java"><code>byteBuf <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>allocator<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这就好比我们需要拿着一个桶去排队装水，但是第一次去装的时候，我们并不知道管理员会给我们分配多少水，桶拿大了也不合适拿小了也不合适，于是我们就先预估一个差不多容量大小的桶，如果分配的多了，我们下次就拿更大一点的桶，如果分配少了，下次我们就拿一个小点的桶。</p> <p>在这种场景下，我们需要ByteBuffer可以自动根据每次网络数据的大小来动态自适应调整自己的容量。</p> <p>而ByteBuffer动态自适应扩缩容机制依赖于AdaptiveRecvByteBufAllocator类的实现。让我们先回到AdaptiveRecvByteBufAllocator类的创建起点开始说起~~</p> <h3 id="_4-1-adaptiverecvbytebufallocator的创建"><a href="#_4-1-adaptiverecvbytebufallocator的创建" class="header-anchor">#</a> 4.1 AdaptiveRecvByteBufAllocator的创建</h3> <p>在前文<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247484184&amp;idx=1&amp;sn=726877ce28cf6e5d2ac3225fae687f19&amp;chksm=ce77c55ff9004c493b592288819dc4d4664b5949ee97fed977b6558bc517dad0e1f73fab0f46&amp;scene=21&amp;cur_album_id=2217816582418956300#wechat_redirect" target="_blank" rel="noopener noreferrer">?《Netty是如何高效接收网络连接》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中我们提到，当Main Reactor监听到OP_ACCPET事件活跃后，会在NioServerSocketChannel中accept完成三次握手的客户端连接。并创建NioSocketChannel，伴随着NioSocketChannel的创建其对应的配置类NioSocketChannelConfig类也会随之创建。</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">NioSocketChannel</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> parent<span class="token punctuation">,</span> <span class="token class-name">SocketChannel</span> socket<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> socket<span class="token punctuation">)</span><span class="token punctuation">;</span>
    config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioSocketChannelConfig</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> socket<span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最终会在NioSocketChannelConfig的父类<code>DefaultChannelConfig</code>的构造器中创建<code>AdaptiveRecvByteBufAllocator</code>。并保存在<code>RecvByteBufAllocator rcvBufAllocator</code>字段中。</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultChannelConfig</span> <span class="token keyword">implements</span> <span class="token class-name">ChannelConfig</span> <span class="token punctuation">{</span>

    <span class="token comment">//用于Channel接收数据用的buffer分配器  AdaptiveRecvByteBufAllocator</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">RecvByteBufAllocator</span> rcvBufAllocator<span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">DefaultChannelConfig</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">(</span>channel<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">AdaptiveRecvByteBufAllocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>在<code>new AdaptiveRecvByteBufAllocator()</code>创建AdaptiveRecvByteBufAllocator类实例的时候会先触发AdaptiveRecvByteBufAllocator类的初始化。</p> <p>我们先来看下AdaptiveRecvByteBufAllocator类的初始化都做了些什么事情：</p> <h3 id="_4-2-adaptiverecvbytebufallocator类的初始化"><a href="#_4-2-adaptiverecvbytebufallocator类的初始化" class="header-anchor">#</a> 4.2 AdaptiveRecvByteBufAllocator类的初始化</h3> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdaptiveRecvByteBufAllocator</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultMaxMessagesRecvByteBufAllocator</span> <span class="token punctuation">{</span>

    <span class="token comment">//扩容步长</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">INDEX_INCREMENT</span> <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token comment">//缩容步长</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">INDEX_DECREMENT</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment">//RecvBuf分配容量表（扩缩容索引表）按照表中记录的容量大小进行扩缩容</span>
    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">;</span>

   <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token comment">//初始化RecvBuf容量分配表</span>
        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> sizeTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//当分配容量小于512时，扩容单位为16递增</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">512</span><span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">16</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sizeTable<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//当分配容量大于512时，扩容单位为一倍</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">512</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            sizeTable<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//初始化RecbBuf扩缩容索引表</span>
        <span class="token constant">SIZE_TABLE</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>sizeTable<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token constant">SIZE_TABLE</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sizeTable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>AdaptiveRecvByteBufAllocator 主要的作用就是为接收数据的<code>ByteBuffer</code>进行扩容缩容，那么每次怎么扩容？扩容多少？怎么缩容？缩容多少呢？</p> <p>这四个问题将是本小节笔者要为大家解答的内容~~~</p> <p>Netty中定义了一个<code>int型</code>的数组<code>SIZE_TABLE</code>来存储每个扩容单位对应的容量大小。建立起扩缩容的容量索引表。每次扩容多少，缩容多少全部记录在这个容量索引表中。</p> <p>在AdaptiveRecvByteBufAllocatorl类初始化的时候会在<code>static{}</code>静态代码块中对扩缩容索引表<code>SIZE_TABLE</code>进行初始化。</p> <p>从源码中我们可以看出<code>SIZE_TABLE</code>的初始化分为两个部分：</p> <ul><li>当索引容量小于<code>512</code>时，<code>SIZE_TABLE</code>中定义的容量索引是从<code>16开始</code>按<code>16</code>递增。</li></ul> <p>![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)image.png</p> <ul><li>当索引容量大于<code>512</code>时，<code>SIZE_TABLE</code>中定义的容量索引是按前一个索引容量的2倍递增。</li></ul> <p>![图片](data:image/svg+xml,%3C%3Fxml version='1.0' encoding='UTF-8'%3F%3E%3Csvg width='1px' height='1px' viewBox='0 0 1 1' version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink'%3E%3Ctitle%3E%3C/title%3E%3Cg stroke='none' stroke-width='1' fill='none' fill-rule='evenodd' fill-opacity='0'%3E%3Cg transform='translate(-249.000000, -126.000000)' fill='%23FFFFFF'%3E%3Crect x='249' y='126' width='1' height='1'%3E%3C/rect%3E%3C/g%3E%3C/g%3E%3C/svg%3E)image.png</p> <h3 id="_4-3-扩缩容逻辑"><a href="#_4-3-扩缩容逻辑" class="header-anchor">#</a> 4.3 扩缩容逻辑</h3> <p>现在扩缩容索引表<code>SIZE_TABLE</code>已经初始化完毕了，那么当我们需要对<code>ByteBuffer</code>进行扩容或者缩容的时候如何根据<code>SIZE_TABLE</code>决定扩容多少或者缩容多少呢？？</p> <p>这就用到了在AdaptiveRecvByteBufAllocator类中定义的扩容步长<code>INDEX_INCREMENT = 4</code>，缩容步长<code>INDEX_DECREMENT = 1</code>了。</p> <p>我们就以上面两副扩缩容容量索引表<code>SIZE_TABLE</code>中的容量索引展示截图为例，来介绍下扩缩容逻辑，假设我们当前<code>ByteBuffer</code>的容量索引为<code>33</code>，对应的容量为<code>2048</code>。</p> <h4 id="_4-3-1-扩容"><a href="#_4-3-1-扩容" class="header-anchor">#</a> 4.3.1 扩容</h4> <p>当对容量为<code>2048</code>的ByteBuffer进行扩容时，根据当前的容量索引<code>index = 33</code> <strong>加上</strong> 扩容步长<code>INDEX_INCREMENT = 4</code>计算出扩容后的容量索引为<code>37</code>，那么扩缩容索引表<code>SIZE_TABLE</code>下标<code>37</code>对应的容量就是本次ByteBuffer扩容后的容量<code>SIZE_TABLE[37] = 32768</code></p> <h4 id="_4-3-1-缩容"><a href="#_4-3-1-缩容" class="header-anchor">#</a> 4.3.1  缩容</h4> <p>同理对容量为<code>2048</code>的ByteBuffer进行缩容时，我们就需要用当前容量索引<code>index = 33</code> <strong>减去</strong> 缩容步长<code>INDEX_DECREMENT = 1</code>计算出缩容后的容量索引<code>32</code>，那么扩缩容索引表<code>SIZE_TABLE</code>下标<code>32</code>对应的容量就是本次ByteBuffer缩容后的容量<code>SIZE_TABLE[32] = 1024</code></p> <h3 id="_4-4-扩缩容时机"><a href="#_4-4-扩缩容时机" class="header-anchor">#</a> 4.4 扩缩容时机</h3> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractNioByteChannel</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractNioChannel</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token keyword">try</span> <span class="token punctuation">{</span>
                <span class="token keyword">do</span> <span class="token punctuation">{</span>
                      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>allocHandle<span class="token punctuation">.</span><span class="token function">continueReading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">//根据本次read loop总共读取的字节数，决定下次是否扩容或者缩容</span>
                allocHandle<span class="token punctuation">.</span><span class="token function">readComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
               <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在每轮read loop结束之后，我们都会调用<code>allocHandle.readComplete()</code>来根据在allocHandle中统计的在本轮read loop中读取字节总大小，来决定在下一轮read loop中是否对DirectByteBuffer进行扩容或者缩容。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">MaxMessageHandle</span> <span class="token keyword">implements</span> <span class="token class-name">ExtendedHandle</span> <span class="token punctuation">{</span>

       <span class="token annotation punctuation">@Override</span>
       <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">readComplete</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">//是否对recvbuf进行扩容缩容</span>
                <span class="token function">record</span><span class="token punctuation">(</span><span class="token function">totalBytesRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">}</span>

       <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">record</span><span class="token punctuation">(</span><span class="token keyword">int</span> actualReadBytes<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>actualReadBytes <span class="token operator">&lt;=</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">[</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token constant">INDEX_DECREMENT</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>decreaseNow<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    index <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token constant">INDEX_DECREMENT</span><span class="token punctuation">,</span> minIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
                    nextReceiveBufferSize <span class="token operator">=</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
                    decreaseNow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    decreaseNow <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>actualReadBytes <span class="token operator">&gt;=</span> nextReceiveBufferSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                index <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>index <span class="token operator">+</span> <span class="token constant">INDEX_INCREMENT</span><span class="token punctuation">,</span> maxIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
                nextReceiveBufferSize <span class="token operator">=</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
                decreaseNow <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>        
<span class="token punctuation">}</span>
</code></pre></div><p>我们以当前ByteBuffer容量为<code>2048</code>，容量索引<code>index = 33</code>为例，对<code>allocHandle</code>的扩容缩容规则进行说明。</p> <blockquote><p>扩容步长<code>INDEX_INCREMENT = 4</code>，缩容步长<code>INDEX_DECREMENT = 1</code>。</p></blockquote> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409191131842.png" alt="图片">image.png</p> <h4 id="_4-4-1-缩容"><a href="#_4-4-1-缩容" class="header-anchor">#</a> 4.4.1 缩容</h4> <ul><li>如果本次<code>OP_READ事件</code>实际读取到的总字节数<code>actualReadBytes</code>在SIZE_TABLE[index - INDEX_DECREMENT]与SIZE_TABLE[index]之间的话，也就是如果本轮read loop结束之后总共读取的字节数在<code>[1024,2048]</code>之间。说明此时分配的<code>ByteBuffer</code>容量正好，不需要进行缩容也不需要进行扩容。比如本次<code>actualReadBytes = 2000</code>，正好处在<code>1024</code>与<code>2048</code>之间。说明<code>2048</code>的容量正好。</li> <li>如果<code>actualReadBytes</code> 小于等于 SIZE_TABLE[index - INDEX_DECREMENT]，也就是如果本轮read loop结束之后总共读取的字节数小于等于<code>1024</code>。表示本次读取到的字节数比当前ByteBuffer容量的下一级容量还要小，说明当前ByteBuffer的容量分配的有些大了，设置缩容标识<code>decreaseNow = true</code>。当下次<code>OP_READ事件</code>继续满足缩容条件的时候，开始真正的进行缩容。缩容后的容量为SIZE_TABLE[index - INDEX_DECREMENT]，但不能小于SIZE_TABLE[minIndex]。</li></ul> <blockquote><p>注意需要满足两次缩容条件才会进行缩容，且缩容步长为1，缩容比较谨慎</p></blockquote> <h4 id="_4-4-2-扩容"><a href="#_4-4-2-扩容" class="header-anchor">#</a> 4.4.2 扩容</h4> <p>如果本次<code>OP_READ事件</code>处理总共读取的字节数<code>actualReadBytes</code> 大于等于 当前ByteBuffer容量(nextReceiveBufferSize)时，说明ByteBuffer分配的容量有点小了，需要进行扩容。扩容后的容量为SIZE_TABLE[index + INDEX_INCREMENT]，但不能超过SIZE_TABLE[maxIndex]。</p> <blockquote><p>满足一次扩容条件就进行扩容，并且扩容步长为4， 扩容比较奔放</p></blockquote> <h3 id="_4-5-adaptiverecvbytebufallocator类的实例化"><a href="#_4-5-adaptiverecvbytebufallocator类的实例化" class="header-anchor">#</a> 4.5 AdaptiveRecvByteBufAllocator类的实例化</h3> <p>AdaptiveRecvByteBufAllocator类的实例化主要是确定ByteBuffer的初始容量，以及最小容量和最大容量在扩缩容索引表<code>SIZE_TABLE</code>中的下标：<code>minIndex</code>和<code>maxIndex</code>。</p> <p>AdaptiveRecvByteBufAllocator定义了三个关于ByteBuffer容量的字段：</p> <ul><li><code>DEFAULT_MINIMUM</code> ：表示ByteBuffer最小的容量，默认为<code>64</code>，也就是无论ByteBuffer在怎么缩容，容量也不会低于<code>64</code>。</li> <li><code>DEFAULT_INITIAL</code>：表示ByteBuffer的初始化容量。默认为<code>2048</code>。</li> <li><code>DEFAULT_MAXIMUM</code> ：表示ByteBuffer的最大容量，默认为<code>65536</code>，也就是无论ByteBuffer在怎么扩容，容量也不会超过<code>65536</code>。</li></ul> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdaptiveRecvByteBufAllocator</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultMaxMessagesRecvByteBufAllocator</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_MINIMUM</span> <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_INITIAL</span> <span class="token operator">=</span> <span class="token number">2048</span><span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_MAXIMUM</span> <span class="token operator">=</span> <span class="token number">65536</span><span class="token punctuation">;</span>

    <span class="token keyword">public</span> <span class="token class-name">AdaptiveRecvByteBufAllocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_MINIMUM</span><span class="token punctuation">,</span> <span class="token constant">DEFAULT_INITIAL</span><span class="token punctuation">,</span> <span class="token constant">DEFAULT_MAXIMUM</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">public</span> <span class="token class-name">AdaptiveRecvByteBufAllocator</span><span class="token punctuation">(</span><span class="token keyword">int</span> minimum<span class="token punctuation">,</span> <span class="token keyword">int</span> initial<span class="token punctuation">,</span> <span class="token keyword">int</span> maximum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       
         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略异常检查逻辑<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

        <span class="token comment">//计算minIndex maxIndex</span>
        <span class="token comment">//在SIZE_TABLE中二分查找最小 &gt;= minimum的容量索引 ：3</span>
        <span class="token keyword">int</span> minIndex <span class="token operator">=</span> <span class="token function">getSizeTableIndex</span><span class="token punctuation">(</span>minimum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SIZE_TABLE</span><span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minimum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>minIndex <span class="token operator">=</span> minIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>minIndex <span class="token operator">=</span> minIndex<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">//在SIZE_TABLE中二分查找最大 &lt;= maximum的容量索引 ：38</span>
        <span class="token keyword">int</span> maxIndex <span class="token operator">=</span> <span class="token function">getSizeTableIndex</span><span class="token punctuation">(</span>maximum<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">SIZE_TABLE</span><span class="token punctuation">[</span>maxIndex<span class="token punctuation">]</span> <span class="token operator">&gt;</span> maximum<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>maxIndex <span class="token operator">=</span> maxIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>maxIndex <span class="token operator">=</span> maxIndex<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">this</span><span class="token punctuation">.</span>initial <span class="token operator">=</span> initial<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接下来的事情就是确定最小容量DEFAULT_MINIMUM 在SIZE_TABLE中的下标<code>minIndex</code>，以及最大容量DEFAULT_MAXIMUM 在SIZE_TABLE中的下标<code>maxIndex</code>。</p> <p>从AdaptiveRecvByteBufAllocator类初始化的过程中，我们可以看出SIZE_TABLE中存储的数据特征是一个有序的集合。</p> <p>我们可以通过<strong>二分查找</strong>在SIZE_TABLE中找出<code>第一个</code>容量大于等于DEFAULT_MINIMUM的容量索引<code>minIndex</code>。</p> <p>同理通过<strong>二分查找</strong>在SIZE_TABLE中找出<code>最后一个</code>容量小于等于DEFAULT_MAXIMUM的容量索引<code>maxIndex</code>。</p> <p>根据上一小节关于<code>SIZE_TABLE</code>中容量数据分布的截图，我们可以看出<code>minIndex = 3</code>，<code>maxIndex = 38</code></p> <h4 id="_4-5-1-二分查找容量索引下标"><a href="#_4-5-1-二分查找容量索引下标" class="header-anchor">#</a> 4.5.1 二分查找容量索引下标</h4> <div class="language-java extra-class"><pre class="language-java"><code>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getSizeTableIndex</span><span class="token punctuation">(</span><span class="token keyword">final</span> <span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> low <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> high <span class="token operator">=</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>high <span class="token operator">&lt;</span> low<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> low<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>high <span class="token operator">==</span> low<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> high<span class="token punctuation">;</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">int</span> mid <span class="token operator">=</span> low <span class="token operator">+</span> high <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//无符号右移，高位始终补0</span>
            <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">[</span>mid<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">[</span>mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&gt;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                low <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                high <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> mid<span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
</code></pre></div><blockquote><p>经常刷LeetCode的小伙伴肯定一眼就看出这个是<strong>二分查找的模板</strong>了。</p></blockquote> <p>它的目的就是根据给定容量，在扩缩容索引表<code>SIZE_TABLE</code>中，通过<strong>二分查找</strong>找到<code>最贴近</code>给定size的容量的索引下标（第一个大于等于 size的容量）</p> <h3 id="_4-6-recvbytebufallocator-handle"><a href="#_4-6-recvbytebufallocator-handle" class="header-anchor">#</a> 4.6 RecvByteBufAllocator.Handle</h3> <p>前边我们提到最终动态调整ByteBuffer容量的是由AdaptiveRecvByteBufAllocator中的<code>Handler</code>负责的，我们来看下这个<code>allocHandle</code>的创建过程。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractUnsafe</span> <span class="token keyword">implements</span> <span class="token class-name">Unsafe</span> <span class="token punctuation">{</span>

        <span class="token keyword">private</span> <span class="token class-name">RecvByteBufAllocator<span class="token punctuation">.</span>Handle</span> recvHandle<span class="token punctuation">;</span>

        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token class-name">RecvByteBufAllocator<span class="token punctuation">.</span>Handle</span> <span class="token function">recvBufAllocHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>recvHandle <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                recvHandle <span class="token operator">=</span> <span class="token function">config</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getRecvByteBufAllocator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> recvHandle<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>从allocHandle的获取过程我们看到最allocHandle的创建是由<code>AdaptiveRecvByteBufAllocator#newHandle</code>方法执行的。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdaptiveRecvByteBufAllocator</span> <span class="token keyword">extends</span> <span class="token class-name">DefaultMaxMessagesRecvByteBufAllocator</span> <span class="token punctuation">{</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">public</span> <span class="token class-name">Handle</span> <span class="token function">newHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HandleImpl</span><span class="token punctuation">(</span>minIndex<span class="token punctuation">,</span> maxIndex<span class="token punctuation">,</span> initial<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">HandleImpl</span> <span class="token keyword">extends</span> <span class="token class-name">MaxMessageHandle</span> <span class="token punctuation">{</span>
        <span class="token comment">//最小容量在扩缩容索引表中的index</span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> minIndex<span class="token punctuation">;</span>
        <span class="token comment">//最大容量在扩缩容索引表中的index</span>
        <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> maxIndex<span class="token punctuation">;</span>
        <span class="token comment">//当前容量在扩缩容索引表中的index 初始33 对应容量2048</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> index<span class="token punctuation">;</span>
        <span class="token comment">//预计下一次分配buffer的容量，初始：2048</span>
        <span class="token keyword">private</span> <span class="token keyword">int</span> nextReceiveBufferSize<span class="token punctuation">;</span>
        <span class="token comment">//是否缩容</span>
        <span class="token keyword">private</span> <span class="token keyword">boolean</span> decreaseNow<span class="token punctuation">;</span>

        <span class="token class-name">HandleImpl</span><span class="token punctuation">(</span><span class="token keyword">int</span> minIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> maxIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> initial<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>minIndex <span class="token operator">=</span> minIndex<span class="token punctuation">;</span>
            <span class="token keyword">this</span><span class="token punctuation">.</span>maxIndex <span class="token operator">=</span> maxIndex<span class="token punctuation">;</span>

            <span class="token comment">//在扩缩容索引表中二分查找到最小大于等于initial 的容量</span>
            index <span class="token operator">=</span> <span class="token function">getSizeTableIndex</span><span class="token punctuation">(</span>initial<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">//2048</span>
            nextReceiveBufferSize <span class="token operator">=</span> <span class="token constant">SIZE_TABLE</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

<span class="token punctuation">}</span>
</code></pre></div><p>这里我们看到Netty中用于动态调整ByteBuffer容量的<code>allocHandle</code>的实际类型为<code>MaxMessageHandle</code>。</p> <p>下面我们来介绍下<code>HandleImpl</code>中的核心字段，它们都和ByteBuffer的容量有关：</p> <ul><li><code>minIndex</code> ：最小容量在扩缩容索引表<code>SIZE_TABE</code>中的index。默认是<code>3</code>。</li> <li><code>maxIndex</code> ：最大容量在扩缩容索引表<code>SIZE_TABE</code>中的index。默认是<code>38</code>。</li> <li><code>index</code> ：当前容量在扩缩容索引表<code>SIZE_TABE</code>中的index。初始是<code>33</code>。</li> <li><code>nextReceiveBufferSize</code> ：预计下一次分配buffer的容量，初始为<code>2048</code>。在每次申请内存分配ByteBuffer的时候，采用<code>nextReceiveBufferSize</code>的值指定容量。</li> <li><code>decreaseNow ：</code> 是否需要进行缩容。</li></ul> <h2 id="_5-使用堆外内存为bytebuffer分配内存"><a href="#_5-使用堆外内存为bytebuffer分配内存" class="header-anchor">#</a> 5. 使用堆外内存为ByteBuffer分配内存</h2> <p>AdaptiveRecvByteBufAllocator类只是负责动态调整ByteBuffer的容量，而具体为ByteBuffer申请内存空间的是由<code>PooledByteBufAllocator</code>负责。</p> <h3 id="_5-1-类名前缀pooled的来历"><a href="#_5-1-类名前缀pooled的来历" class="header-anchor">#</a> 5.1 类名前缀Pooled的来历</h3> <p>在我们使用Java进行日常开发过程中，在为对象分配内存空间的时候我们都会选择在 JVM 堆中为对象分配内存，这样做对我们 Java 开发者特别的友好，我们只管使用就好而不必过多关心这块申请的内存如何回收，因为 JVM 堆完全受Java虚拟机控制管理，Java 虚拟机会帮助我们回收不再使用的内存。</p> <p>但是 JVM 在进行垃圾回收时候的 <code>stop the world</code> 会对我们应用程序的性能造成一定的影响</p> <p>除此之外我们在<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&amp;mid=2247483737&amp;idx=1&amp;sn=7ef3afbb54289c6e839eed724bb8a9d6&amp;chksm=ce77c71ef9004e08e3d164561e3a2708fc210c05408fa41f7fe338d8e85f39c1ad57519b614e&amp;scene=21#wechat_redirect" target="_blank" rel="noopener noreferrer">?《聊聊Netty那些事儿之从内核角度看IO模型》<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>一文中介绍IO模型的时候提到，当数据达到网卡时，网卡会通过DMA的方式将数据拷贝到内核空间中，这是<code>第一次拷贝</code>。当用户线程在用户空间发起系统IO调用时，CPU会将内核空间的数据再次拷贝到用户空间。这是<code>第二次拷贝</code>。</p> <p>于此不同的是当我们在 JVM 中发起 IO 调用时，比如我们使用JVM堆内存读取 <code>Socket接收缓冲区</code> 中的数据时，<strong>会多一次内存拷贝</strong>，CPU在<code>第二次拷贝</code>中将数据从内核空间拷贝到用户空间时，此时的用户空间站在 JVM 角度是<code>堆外内存</code>，所以还需要将堆外内存中的数据拷贝到 <code>堆内内存</code> 中。这就是 <code>第三次内存拷贝</code></p> <p>同理当我们在JVM中发起IO调用向<code>Socket发送缓冲区</code>写入数据时，JVM会将IO数据先<code>拷贝</code>到<code>堆外内存</code>，然后才能发起系统IO调用。</p> <p><strong>那为什么操作系统不直接使用 JVM 的<code>堆内内存</code>进行<code>IO操作</code>呢？</strong></p> <p>因为 JVM 的内存布局和操作系统分配的内存是不一样的，操作系统不可能按照 JVM 规范来读写数据，所以就需要 <code>第三次拷贝</code> 中间做个转换将堆外内存中的数据拷贝到JVM堆中。</p> <hr> <p>所以基于上述内容，在使用JVM堆内内存时会产生以下两点性能影响：</p> <ol><li>JVM 在垃圾回收堆内内存时，会发生 <code>stop the world</code> 导致应用程序卡顿。</li> <li>在进行 IO 操作的时候，会多产生一次由堆外内存到堆内内存的拷贝。</li></ol> <p><strong>基于以上两点使用<code>JVM堆内内存</code>对性能造成的影响</strong>，于是对性能有卓越追求的Netty采用<code>堆外内存</code>也就是<code>DirectBuffer</code>来为ByteBuffer分配内存空间。</p> <p>采用堆外内存为 ByteBuffer 分配内存的好处就是：</p> <ul><li>堆外内存直接受操作系统的管理，不会受JVM的管理，所以JVM垃圾回收对应用程序的性能影响就没有了。</li> <li>网络数据到达之后直接在<code>堆外内存</code>上接收，进程读取网络数据时直接在堆外内存中读取，所以就避免了<code>第三次内存拷贝</code>。</li></ul> <p>所以 Netty 在进行 I/O 操作时都是使用的堆外内存，可以避免数据从 JVM 堆内存到堆外内存的拷贝。但是由于堆外内存不受JVM的管理，所以就需要额外关注对内存的使用和释放，稍有不慎就会造成内存泄露，于是Netty就引入了<strong>内存池</strong>对<code>堆外内存</code>进行统一管理。</p> <p><strong>PooledByteBufAllocator类的这个前缀<code>Pooled</code>就是<code>内存池</code>的意思，这个类会使用Netty的内存池为ByteBuffer分配<code>堆外内存</code>。</strong></p> <h3 id="_5-2-pooledbytebufallocator的创建"><a href="#_5-2-pooledbytebufallocator的创建" class="header-anchor">#</a> 5.2 PooledByteBufAllocator的创建</h3> <h4 id="创建时机"><a href="#创建时机" class="header-anchor">#</a> 创建时机</h4> <p>在服务端NioServerSocketChannel的配置类NioServerSocketChannelConfig以及客户端NioSocketChannel的配置类NioSocketChannelConfig<strong>实例化的时候会触发</strong>PooledByteBufAllocator的创建。</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DefaultChannelConfig</span> <span class="token keyword">implements</span> <span class="token class-name">ChannelConfig</span> <span class="token punctuation">{</span>
    <span class="token comment">//PooledByteBufAllocator</span>
    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token class-name">ByteBufAllocator</span> allocator <span class="token operator">=</span> <span class="token class-name">ByteBufAllocator</span><span class="token punctuation">.</span><span class="token constant">DEFAULT</span><span class="token punctuation">;</span>

    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>创建出来的PooledByteBufAllocator实例保存在<code>DefaultChannelConfig类</code>中的<code>ByteBufAllocator allocator</code>字段中。</p> <h4 id="创建过程"><a href="#创建过程" class="header-anchor">#</a> 创建过程</h4> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">ByteBufAllocator</span> <span class="token punctuation">{</span>

    <span class="token class-name">ByteBufAllocator</span> <span class="token constant">DEFAULT</span> <span class="token operator">=</span> <span class="token class-name">ByteBufUtil</span><span class="token punctuation">.</span><span class="token constant">DEFAULT_ALLOCATOR</span><span class="token punctuation">;</span>
    
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ByteBufUtil</span> <span class="token punctuation">{</span>

    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">ByteBufAllocator</span> <span class="token constant">DEFAULT_ALLOCATOR</span><span class="token punctuation">;</span>

    <span class="token keyword">static</span> <span class="token punctuation">{</span>
        <span class="token class-name">String</span> allocType <span class="token operator">=</span> <span class="token class-name">SystemPropertyUtil</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>
                <span class="token string">&quot;io.netty.allocator.type&quot;</span><span class="token punctuation">,</span> <span class="token class-name">PlatformDependent</span><span class="token punctuation">.</span><span class="token function">isAndroid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token string">&quot;unpooled&quot;</span> <span class="token operator">:</span> <span class="token string">&quot;pooled&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        allocType <span class="token operator">=</span> allocType<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token class-name">Locale</span><span class="token punctuation">.</span><span class="token constant">US</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token class-name">ByteBufAllocator</span> alloc<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;unpooled&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>allocType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            alloc <span class="token operator">=</span> <span class="token class-name">UnpooledByteBufAllocator</span><span class="token punctuation">.</span><span class="token constant">DEFAULT</span><span class="token punctuation">;</span>
            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;-Dio.netty.allocator.type: {}&quot;</span><span class="token punctuation">,</span> allocType<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">&quot;pooled&quot;</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>allocType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            alloc <span class="token operator">=</span> <span class="token class-name">PooledByteBufAllocator</span><span class="token punctuation">.</span><span class="token constant">DEFAULT</span><span class="token punctuation">;</span>
            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;-Dio.netty.allocator.type: {}&quot;</span><span class="token punctuation">,</span> allocType<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            alloc <span class="token operator">=</span> <span class="token class-name">PooledByteBufAllocator</span><span class="token punctuation">.</span><span class="token constant">DEFAULT</span><span class="token punctuation">;</span>
            logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">&quot;-Dio.netty.allocator.type: pooled (unknown: {})&quot;</span><span class="token punctuation">,</span> allocType<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token constant">DEFAULT_ALLOCATOR</span> <span class="token operator">=</span> alloc<span class="token punctuation">;</span>
        
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>省略<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从ByteBufUtil类的初始化过程我们可以看出，在为ByteBuffer分配内存的时候是否使用内存池在Netty中是可以配置的。</p> <ul><li>通过系统变量<code>-D io.netty.allocator.type</code> 可以配置是否使用内存池为ByteBuffer分配内存。默认情况下是需要使用内存池的。但是在安卓系统中默认是不使用内存池的。</li> <li>通过<code>PooledByteBufAllocator.DEFAULT</code>获取<strong>内存池ByteBuffer分配器</strong>。</li></ul> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">PooledByteBufAllocator</span> <span class="token constant">DEFAULT</span> <span class="token operator">=</span>
    <span class="token keyword">new</span> <span class="token class-name">PooledByteBufAllocator</span><span class="token punctuation">(</span><span class="token class-name">PlatformDependent</span><span class="token punctuation">.</span><span class="token function">directBufferPreferred</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><blockquote><p>由于本文的主线是介绍Sub Reactor处理<code>OP_READ事件</code>的完整过程，所以这里只介绍主线相关的内容，这里只是简单介绍下在接收数据的时候为什么会用<code>PooledByteBufAllocator</code>来为<code>ByteBuffer</code>分配内存。而内存池的架构设计比较复杂，所以笔者后面会单独写一篇关于Netty内存管理的文章。</p></blockquote> <hr> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>本文介绍了Sub Reactor线程在处理OP_READ事件的整个过程。并深入剖析了AdaptiveRecvByteBufAllocator类动态调整ByteBuffer容量的原理。</p> <p>同时也介绍了Netty为什么会使用堆外内存来为ByteBuffer分配内存，并由此引出了Netty的内存池分配器PooledByteBufAllocator 。</p> <p>在介绍AdaptiveRecvByteBufAllocator类和PooledByteBufAllocator一起组合实现动态地为ByteBuffer分配容量的时候，笔者不禁想起了多年前看过的《Effective Java》中第16条 <code>复合优先于继承</code>。</p> <p>Netty在这里也遵循了这条军规，首先两个类设计的都是单一的功能。</p> <ul><li>AdaptiveRecvByteBufAllocator 类只负责动态的调整ByteBuffer容量，并不管具体的内存分配。</li> <li>PooledByteBufAllocator 类负责具体的内存分配，用内存池的方式。</li></ul> <p>这样设计的就比较灵活，具体内存分配的工作交给具体的<code>ByteBufAllocator</code>,可以使用内存池的分配方式<code>PooledByteBufAllocator</code>，也可以不使用内存池的分配方式<code>UnpooledByteBufAllocator</code>。具体的内存可以采用JVM堆内内存（HeapBuffer），也可以使用堆外内存（DirectBuffer）。</p> <p>而<code>AdaptiveRecvByteBufAllocator</code>只需要关注调整它们的容量工作就可以了，而并不需要关注它们具体的内存分配方式。</p> <p>最后通过<code>io.netty.channel.RecvByteBufAllocator.Handle#allocate</code>方法灵活组合不同的内存分配方式。这也是<code>装饰模式</code>的一种应用。</p> <div class="language-java extra-class"><pre class="language-java"><code>byteBuf <span class="token operator">=</span> allocHandle<span class="token punctuation">.</span><span class="token function">allocate</span><span class="token punctuation">(</span>allocator<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>好了，今天的内容就到这里，我们下篇文章见~~~~</p> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <p><a href="https://mp.weixin.qq.com/s/KhpNjA8vDQSBipoDMILvOQ" target="_blank" rel="noopener noreferrer">Netty如何高效接收网络数据？一文聊透ByteBuffer动态自适应扩缩容机制 (qq.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/Netty 系统设计/25.四、深入 Netty 核心/18.第五课：Netty 如何高效接收网络数据.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新于:</span> <span class="time">2024/09/19, 08:16:36</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/be98dc/" class="prev">第四课：Netty 如何高效接收网络连接</a></span> <span class="next"><a href="/pages/a73206/">第六课：Netty 如何高效发送网络数据</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.bd2af867.js" defer></script><script src="/assets/js/2.933750c6.js" defer></script><script src="/assets/js/55.35c5cbfa.js" defer></script><script src="/assets/js/7.7eb70372.js" defer></script>
  </body>
</html>
