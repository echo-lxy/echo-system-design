<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Bootstrap（client）源码解析 | EchoDesign</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="系统设计之「讲解 + 面试指南」，水滴石穿，设计无银弹！">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.c76c3453.css" as="style"><link rel="preload" href="/assets/js/app.f229a648.js" as="script"><link rel="preload" href="/assets/js/2.933750c6.js" as="script"><link rel="preload" href="/assets/js/44.3252b240.js" as="script"><link rel="preload" href="/assets/js/7.7eb70372.js" as="script"><link rel="prefetch" href="/assets/js/10.2cc95be8.js"><link rel="prefetch" href="/assets/js/100.152e23f6.js"><link rel="prefetch" href="/assets/js/101.09d5e594.js"><link rel="prefetch" href="/assets/js/11.c7521a10.js"><link rel="prefetch" href="/assets/js/12.38d1989d.js"><link rel="prefetch" href="/assets/js/13.850793b0.js"><link rel="prefetch" href="/assets/js/14.1141ec27.js"><link rel="prefetch" href="/assets/js/15.8f1b4081.js"><link rel="prefetch" href="/assets/js/16.831e5a24.js"><link rel="prefetch" href="/assets/js/17.acb3bf3d.js"><link rel="prefetch" href="/assets/js/18.baad837c.js"><link rel="prefetch" href="/assets/js/19.571eaed1.js"><link rel="prefetch" href="/assets/js/20.cb4a5c13.js"><link rel="prefetch" href="/assets/js/21.24c0f101.js"><link rel="prefetch" href="/assets/js/22.dd779f94.js"><link rel="prefetch" href="/assets/js/23.4f896de4.js"><link rel="prefetch" href="/assets/js/24.6ba53300.js"><link rel="prefetch" href="/assets/js/25.1fb855d9.js"><link rel="prefetch" href="/assets/js/26.0146252c.js"><link rel="prefetch" href="/assets/js/27.eeee1d20.js"><link rel="prefetch" href="/assets/js/28.6fa848cf.js"><link rel="prefetch" href="/assets/js/29.371a40e1.js"><link rel="prefetch" href="/assets/js/3.5c09ac9d.js"><link rel="prefetch" href="/assets/js/30.ac997df0.js"><link rel="prefetch" href="/assets/js/31.df4cc39d.js"><link rel="prefetch" href="/assets/js/32.fb8340ca.js"><link rel="prefetch" href="/assets/js/33.85e30f9d.js"><link rel="prefetch" href="/assets/js/34.405ab364.js"><link rel="prefetch" href="/assets/js/35.fe9374ba.js"><link rel="prefetch" href="/assets/js/36.b5f133ca.js"><link rel="prefetch" href="/assets/js/37.51145580.js"><link rel="prefetch" href="/assets/js/38.9f396b5a.js"><link rel="prefetch" href="/assets/js/39.9b34b9f9.js"><link rel="prefetch" href="/assets/js/4.73518a0f.js"><link rel="prefetch" href="/assets/js/40.0ada49bd.js"><link rel="prefetch" href="/assets/js/41.fcee3e0f.js"><link rel="prefetch" href="/assets/js/42.f5fdb401.js"><link rel="prefetch" href="/assets/js/43.f868dd1d.js"><link rel="prefetch" href="/assets/js/45.685623ac.js"><link rel="prefetch" href="/assets/js/46.844682b8.js"><link rel="prefetch" href="/assets/js/47.5646b068.js"><link rel="prefetch" href="/assets/js/48.a1b270df.js"><link rel="prefetch" href="/assets/js/49.451cf9ab.js"><link rel="prefetch" href="/assets/js/5.94727770.js"><link rel="prefetch" href="/assets/js/50.1cc0bc70.js"><link rel="prefetch" href="/assets/js/51.7d7cc754.js"><link rel="prefetch" href="/assets/js/52.18c75eba.js"><link rel="prefetch" href="/assets/js/53.04079421.js"><link rel="prefetch" href="/assets/js/54.8604fc24.js"><link rel="prefetch" href="/assets/js/55.653b34bd.js"><link rel="prefetch" href="/assets/js/56.67ae905d.js"><link rel="prefetch" href="/assets/js/57.36581a94.js"><link rel="prefetch" href="/assets/js/58.641ba81b.js"><link rel="prefetch" href="/assets/js/59.28ca51b4.js"><link rel="prefetch" href="/assets/js/6.0b558b79.js"><link rel="prefetch" href="/assets/js/60.96815912.js"><link rel="prefetch" href="/assets/js/61.11238a6f.js"><link rel="prefetch" href="/assets/js/62.82fff0c9.js"><link rel="prefetch" href="/assets/js/63.392eea42.js"><link rel="prefetch" href="/assets/js/64.b2ff808f.js"><link rel="prefetch" href="/assets/js/65.1d3875f8.js"><link rel="prefetch" href="/assets/js/66.e67fcc68.js"><link rel="prefetch" href="/assets/js/67.7ad17063.js"><link rel="prefetch" href="/assets/js/68.4a1d45de.js"><link rel="prefetch" href="/assets/js/69.577af289.js"><link rel="prefetch" href="/assets/js/70.6c868f8f.js"><link rel="prefetch" href="/assets/js/71.805b9749.js"><link rel="prefetch" href="/assets/js/72.c8cf2fab.js"><link rel="prefetch" href="/assets/js/73.f5f13c12.js"><link rel="prefetch" href="/assets/js/74.0b988887.js"><link rel="prefetch" href="/assets/js/75.b0e6ed0a.js"><link rel="prefetch" href="/assets/js/76.15d5bea9.js"><link rel="prefetch" href="/assets/js/77.c89b4964.js"><link rel="prefetch" href="/assets/js/78.13bde471.js"><link rel="prefetch" href="/assets/js/79.173bbc8c.js"><link rel="prefetch" href="/assets/js/8.0ec7f6e8.js"><link rel="prefetch" href="/assets/js/80.ddcb5191.js"><link rel="prefetch" href="/assets/js/81.d124398a.js"><link rel="prefetch" href="/assets/js/82.6d0d2919.js"><link rel="prefetch" href="/assets/js/83.65db62ac.js"><link rel="prefetch" href="/assets/js/84.eeb423e8.js"><link rel="prefetch" href="/assets/js/85.4cd3a775.js"><link rel="prefetch" href="/assets/js/86.931cbb70.js"><link rel="prefetch" href="/assets/js/87.78b2eebd.js"><link rel="prefetch" href="/assets/js/88.605444aa.js"><link rel="prefetch" href="/assets/js/89.b5690031.js"><link rel="prefetch" href="/assets/js/9.6e274fca.js"><link rel="prefetch" href="/assets/js/90.cdc8eb8f.js"><link rel="prefetch" href="/assets/js/91.8ad18b18.js"><link rel="prefetch" href="/assets/js/92.da14d456.js"><link rel="prefetch" href="/assets/js/93.f8975bc4.js"><link rel="prefetch" href="/assets/js/94.0b55855d.js"><link rel="prefetch" href="/assets/js/95.96f5db04.js"><link rel="prefetch" href="/assets/js/96.fc68b295.js"><link rel="prefetch" href="/assets/js/97.0a9a6187.js"><link rel="prefetch" href="/assets/js/98.4adb167d.js"><link rel="prefetch" href="/assets/js/99.7d84cc97.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c76c3453.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="EchoDesign" class="logo"> <span class="site-name can-hide">EchoDesign</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 深度剖析</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 深度剖析</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>一、前言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二、基础知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>三、主线任务</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b0bc66/" class="sidebar-link">Netty 框架概述</a></li><li><a href="/pages/9582d0/" aria-current="page" class="active sidebar-link">Bootstrap（client）源码解析</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/9582d0/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/9582d0/#bootstrap" class="sidebar-link">Bootstrap</a></li><li class="sidebar-sub-header level2"><a href="/pages/9582d0/#客户端部分" class="sidebar-link">客户端部分</a></li><li class="sidebar-sub-header level2"><a href="/pages/9582d0/#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level2"><a href="/pages/9582d0/#参考资料" class="sidebar-link">参考资料</a></li></ul></li><li><a href="/pages/b2a14a/" class="sidebar-link">Bootstrap（server）源码解析</a></li><li><a href="/pages/8d1ba9/Channel/" class="sidebar-link">Channel 源码解析</a></li><li><a href="/pages/397456/" class="sidebar-link">EventLoop 源码解析</a></li><li><a href="/pages/ce1f78/" class="sidebar-link">ChannelHandler 源码解析</a></li><li><a href="/pages/4234c0/" class="sidebar-link">ChannelPipeline 源码解析</a></li><li><a href="/pages/43eb30/" class="sidebar-link">ByteBuf 源码解析</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>四、深入 Netty 核心</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>五、深入 Netty 内存管理</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Netty 系统设计</span></li><li data-v-06225672><span data-v-06225672>三、主线任务</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-18</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">Bootstrap（client）源码解析<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>这一章是 Netty 源码分析系列的第一章, 我打算在这一章中, 展示一下 Netty 的客户端和服务端的初始化和启动的流程, 给读者一个对 Netty 源码有一个大致的框架上的认识, 而不会深入每个功能模块. 本章会从 Bootstrap/ServerBootstrap 类 入手, 分析 Netty 程序的初始化和启动的流程.</p> <h2 id="bootstrap"><a href="#bootstrap" class="header-anchor">#</a> Bootstrap</h2> <p>Bootstrap 是 Netty 提供的一个便利的工厂类, 我们可以通过它来完成 Netty 的客户端或服务器端的 Netty 初始化. 下面我以 Netty 源码例子中的 Echo 服务器作为例子, 从客户端和服务器端分别分析一下 Netty 的程序是如何启动的.</p> <h2 id="客户端部分"><a href="#客户端部分" class="header-anchor">#</a> 客户端部分</h2> <h3 id="连接源码"><a href="#连接源码" class="header-anchor">#</a> 连接源码</h3> <p>首先, 让我们从客户端方面的代码开始 下面是源码 <em>example/src/main/java/io/netty/example/echo/EchoClient.java</em> 的客户端部分的启动代码:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token class-name">EventLoopGroup</span> group <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoopGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token class-name">Bootstrap</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Bootstrap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    b<span class="token punctuation">.</span><span class="token function">group</span><span class="token punctuation">(</span>group<span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">NioSocketChannel</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">option</span><span class="token punctuation">(</span><span class="token class-name">ChannelOption</span><span class="token punctuation">.</span><span class="token constant">TCP_NODELAY</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>
     <span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token annotation punctuation">@Override</span>
         <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
             <span class="token class-name">ChannelPipeline</span> p <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
             p<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EchoClientHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Start the client.</span>
    <span class="token class-name">ChannelFuture</span> f <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token constant">HOST</span><span class="token punctuation">,</span> <span class="token constant">PORT</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Wait until the connection is closed.</span>
    f<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">closeFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sync</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
    <span class="token comment">// Shut down the event loop to terminate all threads.</span>
    group<span class="token punctuation">.</span><span class="token function">shutdownGracefully</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从上面的客户端代码虽然简单, 但是却展示了 Netty 客户端初始化时所需的所有内容：</p> <ol><li><code>EventLoopGroup</code>：不论是服务器端还是客户端, 都必须指定 EventLoopGroup. 在这个例子中, 指定了 NioEventLoopGroup, 表示一个 NIO 的 EventLoopGroup</li> <li><code>ChannelType</code>: 指定 Channel 的类型。因为是客户端, 因此使用了 NioSocketChannel.</li> <li><code>Handler</code>: 设置数据的处理器</li></ol> <p>下面我们深入代码，看一下客户端通过 Bootstrap 启动后，都做了哪些工作.</p> <h3 id="niosocketchannel-的初始化过程"><a href="#niosocketchannel-的初始化过程" class="header-anchor">#</a> NioSocketChannel 的初始化过程</h3> <p>在 Netty 中, Channel 是一个 Socket 的抽象, 它为用户提供了关于 Socket 状态(是否是连接还是断开) 以及对 Socket 的读写等操作. 每当 Netty 建立了一个连接后, 都会有一个对应的 Channel 实例。NioSocketChannel 的类层次结构如下：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409182123746.png" alt="NioSocketChannel 类层次结构.png"></p> <p>这一小节我们着重分析一下 Channel 的初始化过程.</p> <h4 id="channelfactory-和-channel-类型的确定"><a href="#channelfactory-和-channel-类型的确定" class="header-anchor">#</a> ChannelFactory 和 Channel 类型的确定</h4> <p>除了 TCP 协议以外, Netty 还支持很多其他的连接协议, 并且每种协议还有 NIO(异步 IO) 和 OIO(Old-IO, 即传统的阻塞 IO) 版本的区别. 不同协议不同的阻塞类型的连接都有不同的 Channel 类型与之对应下面是一些常用的 Channel 类型:</p> <ul><li>NioSocketChannel, 代表异步的客户端 TCP Socket 连接</li> <li>NioServerSocketChannel, 异步的服务器端 TCP Socket 连接</li> <li>NioDatagramChannel, 异步的 UDP 连接</li> <li>NioSctpChannel, 异步的客户端 Sctp 连接</li> <li>NioSctpServerChannel, 异步的 Sctp 服务器端连接</li> <li>OioSocketChannel, 同步的客户端 TCP Socket 连接</li> <li>OioServerSocketChannel, 同步的服务器端 TCP Socket 连接</li> <li>OioDatagramChannel, 同步的 UDP 连接</li> <li>OioSctpChannel, 同步的 Sctp 服务器端连接</li> <li>OioSctpServerChannel, 同步的客户端 TCP Socket 连接</li></ul> <p>那么我们是如何设置所需要的 Channel 的类型的呢? 答案是 channel() 方法的调用. 回想一下我们在客户端连接代码的初始化 Bootstrap 中, 会调用 channel() 方法, 传入 NioSocketChannel.class, 这个方法其实就是初始化了一个 BootstrapChannelFactory：</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">B</span> <span class="token function">channel</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">C</span><span class="token punctuation">&gt;</span></span> channelClass<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>channelClass <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">&quot;channelClass&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">channelFactory</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BootstrapChannelFactory</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">C</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>channelClass<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而 BootstrapChannelFactory 实现了 ChannelFactory 接口, 它提供了唯一的方法, 即 <strong>newChannel</strong>. ChannelFactory, 顾名思义, 就是产生 Channel 的工厂类. 进入到 BootstrapChannelFactory.newChannel 中, 我们看到其实现代码如下:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">T</span> <span class="token function">newChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 删除 try 块</span>
    <span class="token keyword">return</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>根据上面代码的提示, 我们就可以确定:</p> <ul><li>Bootstrap 中的 ChannelFactory 的实现是 BootstrapChannelFactory</li> <li>生成的 Channel 的具体类型是 NioSocketChannel. Channel 的实例化过程, 其实就是调用的 ChannelFactory#newChannel 方法, 而实例化的 Channel 的具体的类型又是和在初始化 Bootstrap 时传入的 channel() 方法的参数相关. 因此对于我们这个例子中的客户端的 Bootstrap 而言, 生成的的 Channel 实例就是 NioSocketChannel</li></ul> <h4 id="channel-实例化"><a href="#channel-实例化" class="header-anchor">#</a> Channel 实例化</h4> <p>前面我们已经知道了如何确定一个 Channel 的类型, 并且了解到 Channel 是通过工厂方法 ChannelFactory.newChannel() 来实例化的, 那么 ChannelFactory.newChannel() 方法在哪里调用呢？继续跟踪, 我们发现其调用链是:</p> <div class="language-c extra-class"><pre class="language-c"><code>Bootstrap<span class="token punctuation">.</span>connect <span class="token operator">-&gt;</span> Bootstrap<span class="token punctuation">.</span>doConnect <span class="token operator">-&gt;</span> AbstractBootstrap<span class="token punctuation">.</span>initAndRegister
</code></pre></div><p>在 AbstractBootstrap.initAndRegister 中就调用了 <strong>channelFactory().newChannel()</strong> 来获取一个新的 NioSocketChannel 实例, 其源码如下:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">ChannelFuture</span> <span class="token function">initAndRegister</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 去掉非关键代码</span>
    <span class="token keyword">final</span> <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token function">channelFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ChannelFuture</span> regFuture <span class="token operator">=</span> <span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 <strong>newChannel</strong> 中, 通过类对象的 newInstance 来获取一个新 Channel 实例, 因而会调用 NioSocketChannel 的默认构造器. NioSocketChannel 默认构造器代码如下:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">NioSocketChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">(</span><span class="token function">newSocket</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_SELECTOR_PROVIDER</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>这里的代码比较关键</code>, 我们看到, 在这个构造器中, 会调用 <strong>newSocket</strong> 来打开一个新的 Java NIO SocketChannel:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">SocketChannel</span> <span class="token function">newSocket</span><span class="token punctuation">(</span><span class="token class-name">SelectorProvider</span> provider<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">return</span> provider<span class="token punctuation">.</span><span class="token function">openSocketChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接着会调用父类, 即 AbstractNioByteChannel 的构造器:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token class-name">AbstractNioByteChannel</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> parent<span class="token punctuation">,</span> <span class="token class-name">SelectableChannel</span> ch<span class="token punctuation">)</span>
</code></pre></div><p>并传入参数 parent 为 null, ch 为刚才使用 newSocket 创建的 Java NIO SocketChannel, 因此生成的 NioSocketChannel 的 parent channel 是空的.</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">AbstractNioByteChannel</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> parent<span class="token punctuation">,</span> <span class="token class-name">SelectableChannel</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">,</span> ch<span class="token punctuation">,</span> <span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_READ</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接着会继续调用父类 AbstractNioChannel 的构造器, 并传入了参数 <strong>readInterestOp = SelectionKey.OP_READ</strong>:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">AbstractNioChannel</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> parent<span class="token punctuation">,</span> <span class="token class-name">SelectableChannel</span> ch<span class="token punctuation">,</span> <span class="token keyword">int</span> readInterestOp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>ch <span class="token operator">=</span> ch<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>readInterestOp <span class="token operator">=</span> readInterestOp<span class="token punctuation">;</span>
    <span class="token comment">// 省略 try 块</span>
    <span class="token comment">// 配置 Java NIO SocketChannel 为非阻塞的.</span>
    ch<span class="token punctuation">.</span><span class="token function">configureBlocking</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>然后继续调用父类 AbstractChannel 的构造器:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">AbstractChannel</span><span class="token punctuation">(</span><span class="token class-name">Channel</span> parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> parent<span class="token punctuation">;</span>
    unsafe <span class="token operator">=</span> <span class="token function">newUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pipeline <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultChannelPipeline</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>到这里, 一个完整的 NioSocketChannel 就初始化完成了, 我们可以稍微总结一下构造一个 NioSocketChannel 所需要做的工作:</p> <ul><li>调用 NioSocketChannel.newSocket(DEFAULT_SELECTOR_PROVIDER) 打开一个新的 Java NIO SocketChannel</li> <li>AbstractChannel(Channel parent) 中初始化 AbstractChannel 的属性:</li> <li>parent 属性置为 null</li> <li>unsafe 通过 newUnsafe() 实例化一个 unsafe 对象, 它的类型是 AbstractNioByteChannel.NioByteUnsafe 内部类</li> <li>pipeline 是 new DefaultChannelPipeline(this) 新创建的实例. <code>这里体现了:Each channel has its own pipeline and it is created automatically when a new channel is created.</code></li> <li>AbstractNioChannel 中的属性:</li> <li>SelectableChannel ch 被设置为 Java SocketChannel, 即 NioSocketChannel#newSocket 返回的 Java NIO SocketChannel.</li> <li>readInterestOp 被设置为 SelectionKey.OP_READ</li> <li>SelectableChannel ch 被配置为非阻塞的 <strong>ch.configureBlocking(false)</strong></li> <li>NioSocketChannel 中的属性:</li> <li>SocketChannelConfig config = new NioSocketChannelConfig(this, socket.socket())</li></ul> <h3 id="关于-unsafe-字段的初始化"><a href="#关于-unsafe-字段的初始化" class="header-anchor">#</a> 关于 unsafe 字段的初始化</h3> <p>我们简单地提到了, 在实例化 NioSocketChannel 的过程中, 会在父类 AbstractChannel 的构造器中, 调用 newUnsafe() 来获取一个 unsafe 实例. 那么 unsafe 是怎么初始化的呢? 它的作用是什么? 其实 unsafe 特别关键, 它封装了对 Java 底层 Socket 的操作, 因此实际上是沟通 Netty 上层和 Java 底层的重要的桥梁.</p> <p>那么我们就来看一下 Unsafe 接口所提供的方法吧:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">interface</span> <span class="token class-name">Unsafe</span> <span class="token punctuation">{</span>
    <span class="token class-name">SocketAddress</span> <span class="token function">localAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">SocketAddress</span> <span class="token function">remoteAddress</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">EventLoop</span> eventLoop<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token class-name">SocketAddress</span> localAddress<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">SocketAddress</span> remoteAddress<span class="token punctuation">,</span> <span class="token class-name">SocketAddress</span> localAddress<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">disconnect</span><span class="token punctuation">(</span><span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">closeForcibly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">deregister</span><span class="token punctuation">(</span><span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">beginRead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token class-name">Object</span> msg<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ChannelPromise</span> <span class="token function">voidPromise</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ChannelOutboundBuffer</span> <span class="token function">outboundBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一看便知, 这些方法其实都会对应到相关的 Java 底层的 Socket 的操作. 回到 AbstractChannel 的构造方法中, 在这里调用了 newUnsafe() 获取一个新的 unsafe 对象, 而 newUnsafe 方法在 NioSocketChannel 中被重写了:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token class-name">AbstractNioUnsafe</span> <span class="token function">newUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NioSocketChannelUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>NioSocketChannel.newUnsafe 方法会返回一个 NioSocketChannelUnsafe 实例. 从这里我们就可以确定了, 在实例化的 NioSocketChannel 中的 unsafe 字段, 其实是一个 NioSocketChannelUnsafe 的实例.</p> <h3 id="关于-pipeline-的初始化"><a href="#关于-pipeline-的初始化" class="header-anchor">#</a> 关于 pipeline 的初始化</h3> <p>上面我们分析了一个 Channel (在这个例子中是 NioSocketChannel) 的大体初始化过程, 但是我们漏掉了一个关键的部分, 即 ChannelPipeline 的初始化. 根据 <code>Each channel has its own pipeline and it is created automatically when a new channel is created.</code>, 我们知道, 在实例化一个 Channel 时, 必然伴随着实例化一个 ChannelPipeline. 而我们确实在 AbstractChannel 的构造器看到了 pipeline 字段被初始化为 DefaultChannelPipeline 的实例. 那么我们就来看一下, DefaultChannelPipeline 构造器做了哪些工作吧:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">DefaultChannelPipeline</span><span class="token punctuation">(</span><span class="token class-name">AbstractChannel</span> channel<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>channel <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token string">&quot;channel&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>channel <span class="token operator">=</span> channel<span class="token punctuation">;</span>

    tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TailContext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HeadContext</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>
    tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们调用 DefaultChannelPipeline 的构造器, 传入了一个 channel, 而这个 channel 其实就是我们实例化的 NioSocketChannel, DefaultChannelPipeline 会将这个 NioSocketChannel 对象保存在 channel 字段中. DefaultChannelPipeline 中, 还有两个特殊的字段, 即 head 和 tail, 而这两个字段是一个双向链表的头和尾. 其实在 DefaultChannelPipeline 中, 维护了一个以 AbstractChannelHandlerContext 为节点的双向链表, 这个链表是 Netty 实现 Pipeline 机制的关键. 关于 DefaultChannelPipeline 中的双向链表以及它所起的作用, 我在这里暂时不表, 在 <strong>Netty 源码分析之 二 贯穿 Netty 的大动脉 ── ChannelPipeline</strong> 中会有详细的分析.</p> <p>HeadContext 的继承层次结构如下所示: [<img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409182120262.png" alt="Alt text">](https://github.com/yongshun/learn_netty_source_code/blob/master/Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (客户端)/HeadContext.png) TailContext 的继承层次结构如下所示: [<img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409182120334.png" alt="Alt text">](https://github.com/yongshun/learn_netty_source_code/blob/master/Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (客户端)/TailContext.png)</p> <p>我们可以看到, 链表中 head 是一个 <strong>ChannelOutboundHandler</strong>, 而 tail 则是一个 <strong>ChannelInboundHandler</strong>. 接着看一下 HeadContext 的构造器:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token class-name">HeadContext</span><span class="token punctuation">(</span><span class="token class-name">DefaultChannelPipeline</span> pipeline<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>pipeline<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token constant">HEAD_NAME</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    unsafe <span class="token operator">=</span> pipeline<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它调用了父类 AbstractChannelHandlerContext 的构造器, 并传入参数 inbound = false, outbound = true. TailContext 的构造器与 HeadContext 的相反, 它调用了父类 AbstractChannelHandlerContext 的构造器, 并传入参数 inbound = true, outbound = false. 即 header 是一个 outboundHandler, 而 tail 是一个 inboundHandler, 关于这一点, 大家要特别注意, 因为在分析到 Netty Pipeline 时, 我们会反复用到 inbound 和 outbound 这两个属性.</p> <h3 id="关于-eventloop-初始化"><a href="#关于-eventloop-初始化" class="header-anchor">#</a> 关于 EventLoop 初始化</h3> <p>回到最开始的 EchoClient.java 代码中, 我们在一开始就实例化了一个 NioEventLoopGroup 对象, 因此我们就从它的构造器中追踪一下 EventLoop 的初始化过程. 首先来看一下 NioEventLoopGroup 的类继承层次: <img src="NioEventLoopGroup%20%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png" alt="Alt text"></p> <p>NioEventLoop 有几个重载的构造器, 不过内容都没有什么区别, 最终都是调用的父类 MultithreadEventLoopGroup 构造器:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">MultithreadEventLoopGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">super</span><span class="token punctuation">(</span>nThreads <span class="token operator">==</span> <span class="token number">0</span><span class="token operator">?</span> <span class="token constant">DEFAULT_EVENT_LOOP_THREADS</span> <span class="token operator">:</span> nThreads<span class="token punctuation">,</span> threadFactory<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其中有一点有意思的地方是, 如果我们传入的线程数 nThreads 是 0, 那么 Netty 会为我们设置默认的线程数 DEFAULT_EVENT_LOOP_THREADS, 而这个默认的线程数是怎么确定的呢? 其实很简单, 在静态代码块中, 会首先确定 DEFAULT_EVENT_LOOP_THREADS 的值:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token punctuation">{</span>
    <span class="token constant">DEFAULT_EVENT_LOOP_THREADS</span> <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">SystemPropertyUtil</span><span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span>
            <span class="token string">&quot;io.netty.eventLoopThreads&quot;</span><span class="token punctuation">,</span> <span class="token class-name">Runtime</span><span class="token punctuation">.</span><span class="token function">getRuntime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">availableProcessors</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Netty 会首先从系统属性中获取 &quot;io.netty.eventLoopThreads&quot; 的值, 如果我们没有设置它的话, 那么就返回默认值: 处理器核心数 * 2.</p> <p>回到 MultithreadEventLoopGroup 构造器中, 这个构造器会继续调用父类 MultithreadEventExecutorGroup 的构造器:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">protected</span> <span class="token class-name">MultithreadEventExecutorGroup</span><span class="token punctuation">(</span><span class="token keyword">int</span> nThreads<span class="token punctuation">,</span> <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 去掉了参数检查, 异常处理 等代码.</span>
    children <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleThreadEventExecutor</span><span class="token punctuation">[</span>nThreads<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>children<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        chooser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">PowerOfTwoEventExecutorChooser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        chooser <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericEventExecutorChooser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nThreads<span class="token punctuation">;</span> i <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        children<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newChild</span><span class="token punctuation">(</span>threadFactory<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>根据代码, 我们就很清楚 MultithreadEventExecutorGroup 中的处理逻辑了:</p> <ul><li>创建一个大小为 nThreads 的 SingleThreadEventExecutor 数组</li> <li>根据 nThreads 的大小, 创建不同的 Chooser, 即如果 nThreads 是 2 的幂, 则使用 PowerOfTwoEventExecutorChooser, 反之使用 GenericEventExecutorChooser. 不论使用哪个 Chooser, 它们的功能都是一样的, 即从 children 数组中选出一个合适的 EventExecutor 实例.</li> <li>调用 newChhild 方法初始化 children 数组.</li></ul> <p>根据上面的代码, 我们知道, MultithreadEventExecutorGroup 内部维护了一个 EventExecutor 数组, Netty 的 EventLoopGroup 的实现机制其实就建立在 MultithreadEventExecutorGroup 之上. 每当 Netty 需要一个 EventLoop 时, 会调用 next() 方法获取一个可用的 EventLoop. 上面代码的最后一部分是 newChild 方法, 这个是一个抽象方法, 它的任务是实例化 EventLoop 对象. 我们跟踪一下它的代码, 可以发现, 这个方法在 NioEventLoopGroup 类中实现了, 其内容很简单:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token class-name">EventExecutor</span> <span class="token function">newChild</span><span class="token punctuation">(</span>
        <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">NioEventLoop</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> threadFactory<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token class-name">SelectorProvider</span><span class="token punctuation">)</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实就是实例化一个 NioEventLoop 对象, 然后返回它.</p> <p>最后总结一下整个 EventLoopGroup 的初始化过程吧:</p> <ul><li>EventLoopGroup(其实是 MultithreadEventExecutorGroup) 内部维护一个类型为 EventExecutor children 数组, 其大小是 nThreads, 这样就构成了一个线程池</li> <li>如果我们在实例化 NioEventLoopGroup 时, 如果指定线程池大小, 则 nThreads 就是指定的值, 反之是处理器核心数 * 2</li> <li>MultithreadEventExecutorGroup 中会调用 newChild 抽象方法来初始化 children 数组</li> <li>抽象方法 newChild 是在 NioEventLoopGroup 中实现的, 它返回一个 NioEventLoop 实例.</li> <li>NioEventLoop 属性:</li> <li>SelectorProvider provider 属性: NioEventLoopGroup 构造器中通过 SelectorProvider.provider() 获取一个 SelectorProvider</li> <li>Selector selector 属性: NioEventLoop 构造器中通过调用通过 selector = provider.openSelector() 获取一个 selector 对象.</li></ul> <h3 id="channel-的注册过程"><a href="#channel-的注册过程" class="header-anchor">#</a> channel 的注册过程</h3> <p>在前面的分析中, 我们提到, channel 会在 Bootstrap.initAndRegister 中进行初始化, 但是这个方法还会将初始化好的 Channel 注册到 EventGroup 中. 接下来我们就来分析一下 Channel 注册的过程. 回顾一下 AbstractBootstrap.initAndRegister 方法:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">ChannelFuture</span> <span class="token function">initAndRegister</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 去掉非关键代码</span>
    <span class="token keyword">final</span> <span class="token class-name">Channel</span> channel <span class="token operator">=</span> <span class="token function">channelFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">init</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">ChannelFuture</span> regFuture <span class="token operator">=</span> <span class="token function">group</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>channel<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当 Channel 初始化后, 会紧接着调用 group().register() 方法来注册 Channel, 我们继续跟踪的话, 会发现其调用链如下: AbstractBootstrap.initAndRegister -&gt; MultithreadEventLoopGroup.register -&gt; SingleThreadEventLoop.register -&gt; AbstractUnsafe.register 通过跟踪调用链, 最终我们发现是调用到了 unsafe 的 register 方法, 那么接下来我们就仔细看一下 AbstractUnsafe.register 方法中到底做了什么:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">EventLoop</span> eventLoop<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token comment">// 省略条件判断和错误处理</span>
    <span class="token class-name">AbstractChannel</span><span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">.</span>eventLoop <span class="token operator">=</span> eventLoop<span class="token punctuation">;</span>
    <span class="token function">register0</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>首先, 将 eventLoop 赋值给 Channel 的 eventLoop 属性, 而我们知道这个 eventLoop 对象其实是 MultithreadEventLoopGroup.next() 方法获取的, 根据我们前面 <strong>关于 EventLoop 初始化</strong> 小节中, 我们可以确定 next() 方法返回的 eventLoop 对象是 NioEventLoop 实例. register 方法接着调用了 register0 方法:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">register0</span><span class="token punctuation">(</span><span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> firstRegistration <span class="token operator">=</span> neverRegistered<span class="token punctuation">;</span>
    <span class="token function">doRegister</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    neverRegistered <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    registered <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token function">safeSetSuccess</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    pipeline<span class="token punctuation">.</span><span class="token function">fireChannelRegistered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span>
    <span class="token comment">// multiple channel actives if the channel is deregistered and re-registered.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>firstRegistration <span class="token operator">&amp;&amp;</span> <span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        pipeline<span class="token punctuation">.</span><span class="token function">fireChannelActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>register0 又调用了 AbstractNioChannel.doRegister:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">doRegister</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
	<span class="token comment">// 省略错误处理</span>
    selectionKey <span class="token operator">=</span> <span class="token function">javaChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>selector<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>javaChannel() 这个方法在前面我们已经知道了, 它返回的是一个 Java NIO SocketChannel, 这里我们将这个 SocketChannel 注册到与 eventLoop 关联的 selector 上了.</p> <p>我们总结一下 Channel 的注册过程:</p> <ul><li>首先在 AbstractBootstrap.initAndRegister 中, 通过 group().register(channel), 调用 MultithreadEventLoopGroup.register 方法</li> <li>在 MultithreadEventLoopGroup.register 中, 通过 next() 获取一个可用的 SingleThreadEventLoop, 然后调用它的 register</li> <li>在 SingleThreadEventLoop.register 中, 通过 channel.unsafe().register(this, promise) 来获取 channel 的 unsafe() 底层操作对象, 然后调用它的 register.</li> <li>在 AbstractUnsafe.register 方法中, 调用 register0 方法注册 Channel</li> <li>在 AbstractUnsafe.register0 中, 调用 AbstractNioChannel.doRegister 方法</li> <li>AbstractNioChannel.doRegister 方法通过 javaChannel().register(eventLoop().selector, 0, this) 将 Channel 对应的 Java NIO SockerChannel 注册到一个 eventLoop 的 Selector 中, 并且将当前 Channel 作为 attachment.</li></ul> <p>总的来说, Channel 注册过程所做的工作就是将 Channel 与对应的 EventLoop 关联, 因此这也体现了, 在 Netty 中, 每个 Channel 都会关联一个特定的 EventLoop, 并且这个 Channel 中的所有 IO 操作都是在这个 EventLoop 中执行的; 当关联好 Channel 和 EventLoop 后, 会继续调用底层的 Java NIO SocketChannel 的 register 方法, 将底层的 Java NIO SocketChannel 注册到指定的 selector 中. 通过这两步, 就完成了 Netty Channel 的注册过程.</p> <h3 id="handler-的添加过程"><a href="#handler-的添加过程" class="header-anchor">#</a> handler 的添加过程</h3> <p>Netty 的一个强大和灵活之处就是基于 Pipeline 的自定义 handler 机制. 基于此, 我们可以像添加插件一样自由组合各种各样的 handler 来完成业务逻辑. 例如我们需要处理 HTTP 数据, 那么就可以在 pipeline 前添加一个 Http 的编解码的 Handler, 然后接着添加我们自己的业务逻辑的 handler, 这样网络上的数据流就向通过一个管道一样, 从不同的 handler 中流过并进行编解码, 最终在到达我们自定义的 handler 中. 既然说到这里, 有些读者朋友肯定会好奇, 既然这个 pipeline 机制是这么的强大, 那么它是怎么实现的呢? 不过我这里不打算详细展开 Netty 的 ChannelPipeline 的实现机制(具体的细节会在后续的章节中展示), 我在这一小节中, 从简单的入手, 展示一下我们自定义的 handler 是如何以及何时添加到 ChannelPipeline 中的. 首先让我们看一下如下的代码片段:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">.</span><span class="token function">handler</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SocketChannel</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
     <span class="token annotation punctuation">@Override</span>
     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">SocketChannel</span> ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
         <span class="token class-name">ChannelPipeline</span> p <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>sslCtx <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
             p<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span>sslCtx<span class="token punctuation">.</span><span class="token function">newHandler</span><span class="token punctuation">(</span>ch<span class="token punctuation">.</span><span class="token function">alloc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">HOST</span><span class="token punctuation">,</span> <span class="token constant">PORT</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
         <span class="token punctuation">}</span>
         <span class="token comment">//p.addLast(new LoggingHandler(LogLevel.INFO));</span>
         p<span class="token punctuation">.</span><span class="token function">addLast</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">EchoClientHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
     <span class="token punctuation">}</span>
 <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>这个代码片段就是实现了 handler 的添加功能. 我们看到, Bootstrap.handler 方法接收一个 ChannelHandler, 而我们传递的是一个 派生于 ChannelInitializer 的匿名类, 它正好也实现了 ChannelHandler 接口. 我们来看一下, ChannelInitializer 类内到底有什么玄机:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Sharable</span>
<span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ChannelInitializer</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">C</span> <span class="token keyword">extends</span> <span class="token class-name">Channel</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">ChannelInboundHandlerAdapter</span> <span class="token punctuation">{</span>

    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">InternalLogger</span> logger <span class="token operator">=</span> <span class="token class-name">InternalLoggerFactory</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token class-name">ChannelInitializer</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">protected</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token class-name">C</span> ch<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span><span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Override</span>
    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">channelRegistered</span><span class="token punctuation">(</span><span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        <span class="token function">initChannel</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">C</span><span class="token punctuation">)</span> ctx<span class="token punctuation">.</span><span class="token function">channel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ctx<span class="token punctuation">.</span><span class="token function">pipeline</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        ctx<span class="token punctuation">.</span><span class="token function">fireChannelRegistered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>ChannelInitializer 是一个抽象类, 它有一个抽象的方法 initChannel, 我们正是实现了这个方法, 并在这个方法中添加的自定义的 handler 的. 那么 initChannel 是哪里被调用的呢? 答案是 ChannelInitializer.channelRegistered 方法中. 我们来关注一下 channelRegistered 方法. 从上面的源码中, 我们可以看到, 在 channelRegistered 方法中, 会调用 initChannel 方法, 将自定义的 handler 添加到 ChannelPipeline 中, 然后调用 ctx.pipeline().remove(this) 将自己从 ChannelPipeline 中删除. 上面的分析过程, 可以用如下图片展示: 一开始, ChannelPipeline 中只有三个 handler, head, tail 和我们添加的 ChannelInitializer. [<img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409182120865.png" alt="Alt text">](https://github.com/yongshun/learn_netty_source_code/blob/master/Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (客户端)/1477130291691.png) 接着 initChannel 方法调用后, 添加了自定义的 handler: [<img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409182120573.png" alt="Alt text">](https://github.com/yongshun/learn_netty_source_code/blob/master/Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (客户端)/1477130295919.png) 最后将 ChannelInitializer 删除: [<img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409182120629.png" alt="Alt text">](https://github.com/yongshun/learn_netty_source_code/blob/master/Netty 源码分析之 一 揭开 Bootstrap 神秘的红盖头 (客户端)/1477130299722.png)</p> <p>分析到这里, 我们已经简单了解了自定义的 handler 是如何添加到 ChannelPipeline 中的, 不过限于主题与篇幅的原因, 我没有在这里详细展开 ChannelPipeline 的底层机制, 我打算在下一篇 <strong>Netty 源码分析之 二 贯穿 Netty 的大动脉 ── ChannelPipeline</strong> 中对这个问题进行深入的探讨.</p> <h3 id="客户端连接分析"><a href="#客户端连接分析" class="header-anchor">#</a> 客户端连接分析</h3> <p>经过上面的各种分析后, 我们大致了解了 Netty 初始化时, 所做的工作, 那么接下来我们就直奔主题, 分析一下客户端是如何发起 TCP 连接的.</p> <p>首先, 客户端通过调用 <strong>Bootstrap</strong> 的 <strong>connect</strong> 方法进行连接. 在 connect 中, 会进行一些参数检查后, 最终调用的是 <strong>doConnect0</strong> 方法, 其实现如下:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">doConnect0</span><span class="token punctuation">(</span>
        <span class="token keyword">final</span> <span class="token class-name">ChannelFuture</span> regFuture<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">Channel</span> channel<span class="token punctuation">,</span>
        <span class="token keyword">final</span> <span class="token class-name">SocketAddress</span> remoteAddress<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">SocketAddress</span> localAddress<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// This method is invoked before channelRegistered() is triggered.  Give user handlers a chance to set up</span>
    <span class="token comment">// the pipeline in its channelRegistered() implementation.</span>
    channel<span class="token punctuation">.</span><span class="token function">eventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token annotation punctuation">@Override</span>
        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>regFuture<span class="token punctuation">.</span><span class="token function">isSuccess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">if</span> <span class="token punctuation">(</span>localAddress <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    channel<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>remoteAddress<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    channel<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>remoteAddress<span class="token punctuation">,</span> localAddress<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                promise<span class="token punctuation">.</span><span class="token function">addListener</span><span class="token punctuation">(</span><span class="token class-name">ChannelFutureListener</span><span class="token punctuation">.</span><span class="token constant">CLOSE_ON_FAILURE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                promise<span class="token punctuation">.</span><span class="token function">setFailure</span><span class="token punctuation">(</span>regFuture<span class="token punctuation">.</span><span class="token function">cause</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在 doConnect0 中, 会在 eventloop 线程中调用 Channel 的 connect 方法, 而这个 Channel 的具体类型是什么呢? 我们在 Channel 初始化这一小节中已经分析过了, 这里 channel 的类型就是 <strong>NioSocketChannel</strong>. 进行跟踪到 channel.connect 中, 我们发现它调用的是 DefaultChannelPipeline#connect, 而, pipeline 的 connect 代码如下:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">ChannelFuture</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token class-name">SocketAddress</span> remoteAddress<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> tail<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>remoteAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而 tail 字段, 我们已经分析过了, 是一个 TailContext 的实例, 而 TailContext 又是 AbstractChannelHandlerContext 的子类, 并且没有实现 connect 方法, 因此这里调用的其实是 AbstractChannelHandlerContext.connect, 我们看一下这个方法的实现:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token class-name">ChannelFuture</span> <span class="token function">connect</span><span class="token punctuation">(</span>
        <span class="token keyword">final</span> <span class="token class-name">SocketAddress</span> remoteAddress<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">SocketAddress</span> localAddress<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>

	<span class="token comment">// 删除的参数检查的代码</span>
    <span class="token keyword">final</span> <span class="token class-name">AbstractChannelHandlerContext</span> next <span class="token operator">=</span> <span class="token function">findContextOutbound</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">EventExecutor</span> executor <span class="token operator">=</span> next<span class="token punctuation">.</span><span class="token function">executor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>executor<span class="token punctuation">.</span><span class="token function">inEventLoop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        next<span class="token punctuation">.</span><span class="token function">invokeConnect</span><span class="token punctuation">(</span>remoteAddress<span class="token punctuation">,</span> localAddress<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token function">safeExecute</span><span class="token punctuation">(</span>executor<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">OneTimeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token annotation punctuation">@Override</span>
            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                next<span class="token punctuation">.</span><span class="token function">invokeConnect</span><span class="token punctuation">(</span>remoteAddress<span class="token punctuation">,</span> localAddress<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> promise<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> promise<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上面的代码中有一个关键的地方, 即 <strong>final AbstractChannelHandlerContext next = findContextOutbound()</strong>, 这里调用 <strong>findContextOutbound</strong> 方法, 从 DefaultChannelPipeline 内的双向链表的 tail 开始, 不断向前寻找第一个 outbound 为 true 的 AbstractChannelHandlerContext, 然后调用它的 invokeConnect 方法, 其代码如下:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">invokeConnect</span><span class="token punctuation">(</span><span class="token class-name">SocketAddress</span> remoteAddress<span class="token punctuation">,</span> <span class="token class-name">SocketAddress</span> localAddress<span class="token punctuation">,</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 忽略 try 块</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">ChannelOutboundHandler</span><span class="token punctuation">)</span> <span class="token function">handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> remoteAddress<span class="token punctuation">,</span> localAddress<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>还记得我们在 &quot;关于 pipeline 的初始化&quot; 这一小节分析的的内容吗? 我们提到, 在 DefaultChannelPipeline 的构造器中, 会实例化两个对象: head 和 tail, 并形成了双向链表的头和尾. head 是 HeadContext 的实例, 它实现了 ChannelOutboundHandler 接口, 并且它的 outbound 字段为 true. 因此在 findContextOutbound 中, 找到的 AbstractChannelHandlerContext 对象其实就是 head. 进而在 invokeConnect 方法中, 我们向上转换为 ChannelOutboundHandler 就是没问题的了. 而又因为 HeadContext 重写了 connect 方法, 因此实际上调用的是 HeadContext.connect. 我们接着跟踪到 HeadContext.connect, 其代码如下:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">connect</span><span class="token punctuation">(</span>
        <span class="token class-name">ChannelHandlerContext</span> ctx<span class="token punctuation">,</span>
        <span class="token class-name">SocketAddress</span> remoteAddress<span class="token punctuation">,</span> <span class="token class-name">SocketAddress</span> localAddress<span class="token punctuation">,</span>
        <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    unsafe<span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>remoteAddress<span class="token punctuation">,</span> localAddress<span class="token punctuation">,</span> promise<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这个 connect 方法很简单, 仅仅调用了 unsafe 的 connect 方法. 而 unsafe 又是什么呢? 回顾一下 HeadContext 的构造器, 我们发现 unsafe 是 pipeline.channel().unsafe() 返回的, 而 Channel 的 unsafe 字段, 在这个例子中, 我们已经知道了, 其实是 AbstractNioByteChannel.NioByteUnsafe 内部类. 兜兜转转了一大圈, 我们找到了创建 Socket 连接的关键代码. 进行跟踪 NioByteUnsafe -&gt; AbstractNioUnsafe.connect:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">connect</span><span class="token punctuation">(</span>
        <span class="token keyword">final</span> <span class="token class-name">SocketAddress</span> remoteAddress<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">SocketAddress</span> localAddress<span class="token punctuation">,</span> <span class="token keyword">final</span> <span class="token class-name">ChannelPromise</span> promise<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">boolean</span> wasActive <span class="token operator">=</span> <span class="token function">isActive</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">doConnect</span><span class="token punctuation">(</span>remoteAddress<span class="token punctuation">,</span> localAddress<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fulfillConnectPromise</span><span class="token punctuation">(</span>promise<span class="token punctuation">,</span> wasActive<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>AbstractNioUnsafe.connect 的实现如上代码所示, 在这个 connect 方法中, 调用了 doConnect 方法, <code>注意, 这个方法并不是 AbstractNioUnsafe 的方法, 而是 AbstractNioChannel 的抽象方法.</code> doConnect 方法是在 NioSocketChannel 中实现的, 因此进入到 <strong>NioSocketChannel.doConnect</strong> 中:</p> <div class="language-Java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Override</span>
<span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">doConnect</span><span class="token punctuation">(</span><span class="token class-name">SocketAddress</span> remoteAddress<span class="token punctuation">,</span> <span class="token class-name">SocketAddress</span> localAddress<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>localAddress <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">javaChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>localAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">boolean</span> success <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">boolean</span> connected <span class="token operator">=</span> <span class="token function">javaChannel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>remoteAddress<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>connected<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">selectionKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">interestOps</span><span class="token punctuation">(</span><span class="token class-name">SelectionKey</span><span class="token punctuation">.</span><span class="token constant">OP_CONNECT</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        success <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> connected<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">doClose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们终于看到的最关键的部分了, 庆祝一下! 上面的代码不用多说, 首先是获取 Java NIO SocketChannel, 即我们已经分析过的, 从 NioSocketChannel.newSocket 返回的 SocketChannel 对象; 然后是调用 SocketChannel.connect 方法完成 Java NIO 层面上的 Socket 的连接. 最后, 上面的代码流程可以用如下时序图直观地展示:</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409182122486.png" alt="image-20240918212211407"></p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li>https://github.com/yongshun/learn_netty_source_code</li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/Netty 系统设计/20.三、主线任务/02.Bootstrap（client）源码解析.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新于:</span> <span class="time">2024/09/18, 16:19:18</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/b0bc66/" class="prev">Netty 框架概述</a></span> <span class="next"><a href="/pages/b2a14a/">Bootstrap（server）源码解析</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.f229a648.js" defer></script><script src="/assets/js/2.933750c6.js" defer></script><script src="/assets/js/44.3252b240.js" defer></script><script src="/assets/js/7.7eb70372.js" defer></script>
  </body>
</html>
