<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>深入 Redis 事件驱动框架 | Echo 系统设计之美</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="水滴石穿，设计无银弹">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.473bdd25.css" as="style"><link rel="preload" href="/assets/js/app.f1bdf1ca.js" as="script"><link rel="preload" href="/assets/js/2.933750c6.js" as="script"><link rel="preload" href="/assets/js/47.f3a2643a.js" as="script"><link rel="preload" href="/assets/js/7.7eb70372.js" as="script"><link rel="prefetch" href="/assets/js/10.b313d17c.js"><link rel="prefetch" href="/assets/js/11.c7521a10.js"><link rel="prefetch" href="/assets/js/12.38d1989d.js"><link rel="prefetch" href="/assets/js/13.850793b0.js"><link rel="prefetch" href="/assets/js/14.1141ec27.js"><link rel="prefetch" href="/assets/js/15.13af8159.js"><link rel="prefetch" href="/assets/js/16.9c3f8295.js"><link rel="prefetch" href="/assets/js/17.1bd2c772.js"><link rel="prefetch" href="/assets/js/18.e689f555.js"><link rel="prefetch" href="/assets/js/19.68db5844.js"><link rel="prefetch" href="/assets/js/20.b5e0fdf1.js"><link rel="prefetch" href="/assets/js/21.af1069aa.js"><link rel="prefetch" href="/assets/js/22.98d9538a.js"><link rel="prefetch" href="/assets/js/23.80625400.js"><link rel="prefetch" href="/assets/js/24.88b84218.js"><link rel="prefetch" href="/assets/js/25.db0f299d.js"><link rel="prefetch" href="/assets/js/26.dc5ac22f.js"><link rel="prefetch" href="/assets/js/27.e82ff876.js"><link rel="prefetch" href="/assets/js/28.6b737928.js"><link rel="prefetch" href="/assets/js/29.ebd14054.js"><link rel="prefetch" href="/assets/js/3.aa815192.js"><link rel="prefetch" href="/assets/js/30.8e70b90d.js"><link rel="prefetch" href="/assets/js/31.833f9b33.js"><link rel="prefetch" href="/assets/js/32.f1016cda.js"><link rel="prefetch" href="/assets/js/33.39471dd3.js"><link rel="prefetch" href="/assets/js/34.9740832c.js"><link rel="prefetch" href="/assets/js/35.ac8dd46f.js"><link rel="prefetch" href="/assets/js/36.8aa375d9.js"><link rel="prefetch" href="/assets/js/37.07cad209.js"><link rel="prefetch" href="/assets/js/38.42e2eab6.js"><link rel="prefetch" href="/assets/js/39.ccf686b4.js"><link rel="prefetch" href="/assets/js/4.73518a0f.js"><link rel="prefetch" href="/assets/js/40.38653c0f.js"><link rel="prefetch" href="/assets/js/41.5525b2c4.js"><link rel="prefetch" href="/assets/js/42.825c6423.js"><link rel="prefetch" href="/assets/js/43.ba91706f.js"><link rel="prefetch" href="/assets/js/44.f4a3c564.js"><link rel="prefetch" href="/assets/js/45.4dc327b0.js"><link rel="prefetch" href="/assets/js/46.7ddc3ffa.js"><link rel="prefetch" href="/assets/js/48.0fdc5aae.js"><link rel="prefetch" href="/assets/js/49.449593cb.js"><link rel="prefetch" href="/assets/js/5.1875cdb3.js"><link rel="prefetch" href="/assets/js/50.009e4919.js"><link rel="prefetch" href="/assets/js/51.88874359.js"><link rel="prefetch" href="/assets/js/52.a2af2e28.js"><link rel="prefetch" href="/assets/js/53.c391ee9d.js"><link rel="prefetch" href="/assets/js/54.89dcf983.js"><link rel="prefetch" href="/assets/js/55.2f20af86.js"><link rel="prefetch" href="/assets/js/56.bee4259d.js"><link rel="prefetch" href="/assets/js/57.b6ba41a5.js"><link rel="prefetch" href="/assets/js/6.0b558b79.js"><link rel="prefetch" href="/assets/js/8.0ec7f6e8.js"><link rel="prefetch" href="/assets/js/9.b55932ba.js">
    <link rel="stylesheet" href="/assets/css/0.styles.473bdd25.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Echo 系统设计之美" class="logo"> <span class="site-name can-hide">Echo 系统设计之美</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧑‍💻实战系统设计" class="dropdown-title"><!----> <span class="title" style="display:;">🧑‍💻实战系统设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/84cb49/" class="nav-link">设计基础设施</a></li><li class="dropdown-item"><!----> <a href="/pages/a95d7d/" class="nav-link">设计热门应用</a></li><li class="dropdown-item"><!----> <a href="/pages/def08a/" class="nav-link">场景设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🧑‍💻实战系统设计" class="dropdown-title"><!----> <span class="title" style="display:;">🧑‍💻实战系统设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/84cb49/" class="nav-link">设计基础设施</a></li><li class="dropdown-item"><!----> <a href="/pages/a95d7d/" class="nav-link">设计热门应用</a></li><li class="dropdown-item"><!----> <a href="/pages/def08a/" class="nav-link">场景设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>指南</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>基础</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>主线</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/34fa27/" class="sidebar-link">Linux 中的 IO 多路复用</a></li><li><a href="/pages/d4ecb9/" class="sidebar-link">Redis Server 初始化</a></li><li><a href="/pages/d6b00d/" class="sidebar-link">Redis 的 Reactor 模型</a></li><li><a href="/pages/264b06/" aria-current="page" class="active sidebar-link">深入 Redis 事件驱动框架</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/264b06/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/264b06/#事件概述" class="sidebar-link">事件概述</a></li><li class="sidebar-sub-header level2"><a href="/pages/264b06/#事件驱动框架循环流程的初始化" class="sidebar-link">事件驱动框架循环流程的初始化</a></li><li class="sidebar-sub-header level2"><a href="/pages/264b06/#io-事件处理" class="sidebar-link">IO 事件处理</a></li><li class="sidebar-sub-header level2"><a href="/pages/264b06/#时间事件处理" class="sidebar-link">时间事件处理</a></li><li class="sidebar-sub-header level2"><a href="/pages/264b06/#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level2"><a href="/pages/264b06/#参考文献" class="sidebar-link">参考文献</a></li></ul></li><li><a href="/pages/e6d8ef/" class="sidebar-link">Redis 的执行模式</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>支线</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>集群</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Redis 系统设计</span></li><li data-v-06225672><span data-v-06225672>主线</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-15</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">深入 Redis 事件驱动框架<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><div class="custom-block danger"><p class="custom-block-title">提出问题是一切智慧的开端</p> <ul><li>Redis 事件驱动框架有哪些事件？</li> <li>这些事件的创建和处理又分别对应了 Redis 源码中的哪些具体操作？</li> <li>如何在一个框架中，同时处理 IO 事件 和 时间事件？</li> <li>Redis 事件驱动框架有哪些核心函数？struct？</li></ul></div> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>前置知识</p> <ul><li>Linux 提供的三种 IO 多路复用机制</li> <li>Redis 事件驱动框架的基本工作机制</li></ul> <p>事件驱动框架是 Redis server 运行后的核心循环流程，了解它何时用什么函数处理哪种事件，对我们排查 server 运行过程中遇到的问题，是很有帮助的</p> <h2 id="事件概述"><a href="#事件概述" class="header-anchor">#</a> 事件概述</h2> <ul><li><p>文件事件「也叫 IO 事件」：Redis 服务器通过套接字与客户端进行连接，而<strong>文件事件就是服务器对套接字操作的抽象</strong>。服务器与客户端的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</p></li> <li><p>时间事件：Redis 服务器中的一些操作「比如 servercron 函数」需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</p></li></ul> <h3 id="文件事件处理"><a href="#文件事件处理" class="header-anchor">#</a> 文件事件处理</h3> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151551218.png" alt="image-20240915155140145"></p> <p>文件事件处理器有四个组成部分：</p> <ul><li><strong>套接字</strong>：文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件</li> <li><strong>IO 多路复用</strong>：IO 多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。</li> <li><strong>文件事件分派器</strong>：尽管多个文件事件可能会并发地出现，但 IO 多路复用程序总是会将所有产生事件的套接字都放到<strong>一个队列</strong>里面，然后通过这个队列，以有序(sequentially)、同步(synchronously)、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后(该套接字为事件所关联的事件处理器执行完毕)，I/O 多路复用程序才会继续向文件事件分派器传送下一个套接字</li> <li><strong>事件处理器</strong>：文件事件分派器接收 I/O 多路复用程序传来的套接字，并根据套接字产生的事件的类调用相应的事件处理器。服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数它们定义了某个事件发生时，服务器应该执行的动作</li></ul> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151556794.png" alt="image-20240915155600717"></p> <h3 id="时间事件处理器"><a href="#时间事件处理器" class="header-anchor">#</a> 时间事件处理器</h3> <p>时间事件分为两类：</p> <ul><li>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序 X 在当前时间的 30 毫秒之后执行一次。</li> <li>周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序 Y 每隔 30 毫秒就执行一次。</li></ul> <p>一个时间事件主要由以下三个属性组成</p> <ul><li><strong>id</strong>：服务器为时间事件创建的全局唯一 ID(标识号)。ID 号按从小到大的顺序递增新事件的 ID 号比旧事件的 ID 号要大。</li> <li><strong>when</strong>：毫秒精度的 UNIX 时间戳，记录了时间事件的到达(arrive)时间。</li> <li><strong>timeProc</strong>：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul> <blockquote><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:如果事件处理器返回 ae.h/AENOMORE，那么这个事件为定时事件:该事件在达到一次之后就会被删除，之后不再到达。如果事件处理器返回一个非 AENOMORE 的整数值，那么这个事件为周期性时间:当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的 when 属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。</p></blockquote> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151603657.png" alt="image-20240915160321589"></p> <p>redis 中的所有时间事件都放在一个无序链表中，服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>我们说保存时间事件的链表为无序链表，指的不是链表不按 ID 排序，而是说该链表不按 when 属性的大小排序。正因为链表没有按 when 属性进行排序，所以当时间事件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到达的时间事件都会被处理。</p> <p>正常模式下的 Redis 服务器只使用 serverCron 一个时间事件，而在 benchmark 模式下，服务器也只使用两个时间事件。在这种情况下，服务器几乎是将无序链表退化成一个指针来使用，<strong>所以使用无序链表来保存时间事件，并不影响事件执行的性能。</strong></p></div> <blockquote><p>serverCron</p> <p>持续运行的 Redis 服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由 redis.c/serverCron 函数负责执行，它的主要工作包括:</p> <ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li> <li>清理数据库中的过期键值对。关闭和清理连接失效的客户端。</li> <li>尝试进行 AOF 或 RDB 持久化操作。</li> <li>如果服务器是主服务器，那么对从服务器进行定期同步。</li> <li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul></blockquote> <h3 id="核心源码的伪代码-自顶向下"><a href="#核心源码的伪代码-自顶向下" class="header-anchor">#</a> 核心源码的伪代码（自顶向下）</h3> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151620132.png" alt="image-20240915162014063"></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment">#初始化服务器</span>
    init server<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">#一直处理事件，直到服务器关闭为止</span>
    <span class="token keyword">while</span> server_is_not_shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    	aeProcessEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">#服务器关闭，执行清理操作</span>
    clean server<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment">#获取到达时间离当前时间最接近的时间事件</span>
    time_event<span class="token operator">=</span>aeSearchNearestTimer<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">#计算最接近的时间事件距离到达还有多少毫秒</span>
    remaind_ms<span class="token operator">=</span>time_event<span class="token punctuation">.</span>when <span class="token operator">-</span> unix_ts_now<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">#如果事件已到达，那么remaind ms的值可能为负数，将它设定为0</span>
    <span class="token keyword">if</span> remaind_ms <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
    	remaind_ms <span class="token operator">=</span> <span class="token number">0</span>

    <span class="token comment">#根据remaind_ms的值，创建timeval结构</span>
    timeval<span class="token operator">=</span>create_timeval_with_ms<span class="token punctuation">(</span>remaind_ms<span class="token punctuation">)</span>

    <span class="token comment">#阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定#如果remaind_ms的值为0，那么aeApiPo1l调用之后马上返回，不阻塞</span>
    aeApiPoll<span class="token punctuation">(</span>timeval<span class="token punctuation">)</span>

    <span class="token comment">#处理所有已产生的文件事件</span>
    processFileEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment">#处理所有已到达的时间事件</span>
    processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token comment">#遍历服务器中的所有时间事件</span>
	<span class="token keyword">for</span> time_event <span class="token keyword">in</span> all_time_event<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token comment">#检查事件是否已经到达</span>
		<span class="token keyword">if</span> time_event<span class="token punctuation">.</span>when <span class="token operator">&lt;=</span> unix_ts_now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token comment">#事件已到达</span>
			<span class="token comment">#执行事件处理器，并获取返回值</span>
			retval<span class="token operator">=</span>time_event<span class="token punctuation">.</span>timeProc<span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token comment">#如果这是一个定时事件</span>
			<span class="token keyword">if</span> retval<span class="token operator">==</span>AE_NOMORE<span class="token punctuation">:</span>
				<span class="token comment">#那么将该事件从服务器中删除</span>
				delete_time_event_from_server<span class="token punctuation">(</span>time event<span class="token punctuation">)</span>
			<span class="token comment">#如果这是一个周期性事件</span>
			<span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment">#那么按照事件处理器的返回值更新时间事件的when 属性</span>
            <span class="token comment">#让这个事件在指定的时间之后再次到达</span>
            	update_when<span class="token punctuation">(</span>time_event<span class="token punctuation">,</span>retval<span class="token punctuation">)</span>
</code></pre></div><h2 id="事件驱动框架循环流程的初始化"><a href="#事件驱动框架循环流程的初始化" class="header-anchor">#</a> 事件驱动框架循环流程的初始化</h2> <p>为了对这两类事件有个相对全面的了解，接下来，我们先从事件驱动框架循环流程的数据结构及其初始化开始学起，因为这里面就包含了针对<strong>这两类事件的数据结构定义和初始化操作</strong>。</p> <h3 id="aeeventloop-结构体与初始化"><a href="#aeeventloop-结构体与初始化" class="header-anchor">#</a> aeEventLoop 结构体与初始化</h3> <p>首先，我们来看下 Redis 事件驱动框架循环流程对应的数据结构 aeEventLoop。</p> <p>这个结构体是在事件驱动框架代码 <a href="https://github.com/redis/redis/tree/5.0/src/ae.h" target="_blank" rel="noopener noreferrer">ae.h <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中定义的，记录了框架循环运行过程中的信息，其中，就包含了记录两类事件的变量，分别是：</p> <ul><li><strong>aeFileEvent 类型的指针 *events，表示 IO 事件</strong>。之所以类型名称为 aeFileEvent，是因为所有的 IO 事件都会用文件描述符进行标识</li> <li><strong>aeTimeEvent 类型的指针 *timeEventHead，表示时间事件</strong>，即按一定时间周期触发的事件</li></ul> <p>此外，aeEventLoop 结构体中还有一个<strong>aeFiredEvent 类型的指针 *fired</strong>，这个并不是一类专门的事件类型，它只是用来记录<strong>已触发</strong>事件对应的文件描述符信息</p> <p>下面的代码显示了 Redis 中事件循环的结构体定义，你可以看下</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token punctuation">{</span>
    …
    aeFileEvent <span class="token operator">*</span>events<span class="token punctuation">;</span> <span class="token comment">//IO事件数组</span>
    aeFiredEvent <span class="token operator">*</span>fired<span class="token punctuation">;</span> <span class="token comment">//已触发事件数组</span>
    aeTimeEvent <span class="token operator">*</span>timeEventHead<span class="token punctuation">;</span> <span class="token comment">//记录时间事件的链表头</span>
    …
    <span class="token keyword">void</span> <span class="token operator">*</span>apidata<span class="token punctuation">;</span> <span class="token comment">//和API调用接口相关的数据</span>
    aeBeforeSleepProc <span class="token operator">*</span>beforesleep<span class="token punctuation">;</span> <span class="token comment">//进入事件循环流程前执行的函数</span>
    aeBeforeSleepProc <span class="token operator">*</span>aftersleep<span class="token punctuation">;</span>  <span class="token comment">//退出事件循环流程后执行的函数</span>
    
<span class="token punctuation">}</span> aeEventLoop<span class="token punctuation">;</span>
</code></pre></div><p>了解了 aeEventLoop 结构体后，我们再来看下，这个结构体是如何初始化的，这其中就包括了 IO 事件数组和时间事件链表的初始化。</p> <h3 id="aecreateeventloop-函数的初始化操作"><a href="#aecreateeventloop-函数的初始化操作" class="header-anchor">#</a> aeCreateEventLoop 函数的初始化操作</h3> <p>因为 Redis server 在完成初始化后，就要开始运行事件驱动框架的循环流程，所以，aeEventLoop 结构体在<a href="http://github.com/redis/redis/tree/5.0/src/server.c" target="_blank" rel="noopener noreferrer">server.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的 initServer 函数中，就通过调用 **aeCreateEventLoop 函数 **进行初始化了。这个函数的参数只有一个，是 setsize</p> <p>下面的代码展示了 initServer 函数中对 aeCreateEventLoop 函数的调用。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
    <span class="token comment">//调用 aeCreateEventLoop 函数创建 aeEventLoop 结构体，并赋值给 server 结构的 el 变量</span>
    server<span class="token punctuation">.</span>el <span class="token operator">=</span> <span class="token function">aeCreateEventLoop</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxclients<span class="token operator">+</span>CONFIG_FDSET_INCR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    …
<span class="token punctuation">}</span>
</code></pre></div><p>从这里我们可以看到 <strong>参数 setsize</strong> 的大小，其实是由 server 结构的 maxclients 变量和宏定义 CONFIG_FDSET_INCR 共同决定的。其中，maxclients 变量的值大小，可以在 Redis 的配置文件 redis.conf 中进行定义，默认值是 1000。而宏定义 CONFIG_FDSET_INCR 的大小，等于宏定义 CONFIG_MIN_RESERVED_FDS 的值再加上 96，如下所示，这里的两个宏定义都是在<a href="https://github.com/redis/redis/blob/5.0/src/server.h" target="_blank" rel="noopener noreferrer">server.h<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文件中定义的。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CONFIG_MIN_RESERVED_FDS</span> <span class="token expression"><span class="token number">32</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CONFIG_FDSET_INCR</span> <span class="token expression"><span class="token punctuation">(</span>CONFIG_MIN_RESERVED_FDS<span class="token operator">+</span><span class="token number">96</span><span class="token punctuation">)</span></span></span>
</code></pre></div><p>好了，到这里，你可能有疑问了：aeCreateEventLoop 函数的参数 setsize，设置为最大客户端数量加上一个宏定义值，可是<strong>这个参数有什么用呢</strong>？这就和 aeCreateEventLoop 函数具体执行的初始化操作有关了。</p> <p>接下来，我们就来看下 aeCreateEventLoop 函数执行的操作，大致可以分成以下三个步骤。</p> <p><strong>第一步，aeCreateEventLoop 函数会创建一个 aeEventLoop 结构体类型的变量 eventLoop</strong>。然后，该函数会给 eventLoop 的成员变量分配内存空间，比如，按照传入的参数 setsize，给 IO 事件数组和已触发事件数组分配相应的内存空间。此外，该函数还会给 eventLoop 的成员变量赋初始值</p> <p><strong>第二步，aeCreateEventLoop 函数会调用 aeApiCreate 函数</strong>。aeApiCreate 函数封装了操作系统提供的 IO 多路复用函数，假设 Redis 运行在 Linux 操作系统上，并且 IO 多路复用机制是 epoll，那么此时，aeApiCreate 函数就会调用 epoll_create 创建 epoll 实例，同时会创建 epoll_event 结构的数组，数组大小等于参数 setsize</p> <p>这里你需要注意，aeApiCreate 函数是把创建的 epoll 实例描述符和 epoll_event 数组，保存在了 aeApiState 结构体类型的变量 state，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeApiState</span> <span class="token punctuation">{</span>  <span class="token comment">//aeApiState结构体定义</span>
    <span class="token keyword">int</span> epfd<span class="token punctuation">;</span>   <span class="token comment">//epoll实例的描述符</span>
    <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">;</span>   <span class="token comment">//epoll_event结构体数组，记录监听事件</span>
<span class="token punctuation">}</span> aeApiState<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiCreate</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    aeApiState <span class="token operator">*</span>state <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeApiState<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//将epoll_event数组保存在aeApiState结构体变量state中</span>
    state<span class="token operator">-&gt;</span>events <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span><span class="token punctuation">)</span><span class="token operator">*</span>eventLoop<span class="token operator">-&gt;</span>setsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//将epoll实例描述符保存在aeApiState结构体变量state中</span>
    state<span class="token operator">-&gt;</span>epfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    ···
<span class="token punctuation">}</span>
</code></pre></div><p>紧接着，aeApiCreate 函数把 state 变量赋值给 eventLoop 中的 apidata 。这样一来，eventLoop 结构体中就有了 epoll 实例和 epoll_event 数组的信息，这样就可以用来基于 epoll 创建和处理事件了。我一会儿还会给你具体介绍。</p> <div class="language-c extra-class"><pre class="language-c"><code>eventLoop<span class="token operator">-&gt;</span>apidata <span class="token operator">=</span> state<span class="token punctuation">;</span>
</code></pre></div><p><strong>第三步，aeCreateEventLoop 函数会把所有网络 IO 事件对应文件描述符的掩码，初始化为 AE_NONE，表示暂时不对任何事件进行监听</strong></p> <p>我把 aeCreateEventLoop 函数的主要部分代码放在这里，你可以看下。</p> <div class="language-v extra-class"><pre class="language-v"><code>aeEventLoop <span class="token operator">*</span><span class="token function">aeCreateEventLoop</span><span class="token punctuation">(</span><span class="token builtin">int</span> setsize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">;</span>
    <span class="token builtin">int</span> i<span class="token punctuation">;</span>

    <span class="token comment">//给eventLoop变量分配内存空间</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eventLoop <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> NULL<span class="token punctuation">)</span> <span class="token keyword">goto</span> err<span class="token punctuation">;</span>

	<span class="token comment">//给IO事件、已触发事件分配内存空间</span>
    eventLoop<span class="token operator">-</span><span class="token operator">&gt;</span>events <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeFileEvent<span class="token punctuation">)</span><span class="token operator">*</span>setsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    eventLoop<span class="token operator">-</span><span class="token operator">&gt;</span>fired <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeFiredEvent<span class="token punctuation">)</span><span class="token operator">*</span>setsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    …
    eventLoop<span class="token operator">-</span><span class="token operator">&gt;</span>setsize <span class="token operator">=</span> setsize<span class="token punctuation">;</span>
    eventLoop<span class="token operator">-</span><span class="token operator">&gt;</span>lastTime <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span>NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">//设置时间事件的链表头为NULL</span>
    eventLoop<span class="token operator">-</span><span class="token operator">&gt;</span>timeEventHead <span class="token operator">=</span> NULL<span class="token punctuation">;</span>
	…
	<span class="token comment">//调用aeApiCreate函数，去实际调用操作系统提供的IO多路复用函数</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeApiCreate</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> err<span class="token punctuation">;</span>

    <span class="token comment">//将所有网络IO事件对应文件描述符的掩码设置为AE_NONE</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> setsize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        eventLoop<span class="token operator">-</span><span class="token operator">&gt;</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">=</span> AE_NONE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> eventLoop<span class="token punctuation">;</span>

    <span class="token comment">//初始化失败后的处理逻辑，</span>
    err<span class="token punctuation">:</span>
    …
<span class="token punctuation">}</span>
</code></pre></div><p>好，那么从 aeCreateEventLoop 函数的执行流程中，我们其实可以看到以下<strong>两个关键点</strong>：</p> <ul><li>事件驱动框架监听的 IO 事件数组大小就等于参数 setsize，这样决定了和 Redis server 连接的客户端数量。所以，当你遇到客户端连接 Redis 时报错“max number of clients reached”，你就可以去 redis.conf 文件修改 maxclients 配置项，以扩充框架能监听的客户端数量。</li> <li>当使用 Linux 系统的 epoll 机制时，框架循环流程初始化操作，会通过 aeApiCreate 函数创建 epoll_event 结构数组，并调用 epoll_create 函数创建 epoll 实例，这都是使用 epoll 机制的准备工作要求</li></ul> <p>到这里，框架就可以创建和处理具体的 IO 事件和时间事件了。所以接下来，我们就先来了解下 IO 事件及其处理机制。</p> <h2 id="io-事件处理"><a href="#io-事件处理" class="header-anchor">#</a> IO 事件处理</h2> <p>Redis 的 IO 事件主要包括三类，分别是</p> <ul><li>可读事件</li> <li>可写事件</li> <li>屏障事件</li></ul> <p>其中，可读事件和可写事件其实比较好理解，也就是对应于 Redis 实例，我们可以<strong>从客户端读取数据或是向客户端写入数据</strong>。</p> <p>而屏障事件的主要作用是用来<strong>反转事件的处理顺序</strong>。比如在默认情况下，Redis 会先给客户端返回结果，但是如果面临需要把数据尽快写入磁盘的情况，Redis 就会用到屏障事件，把写数据和回复客户端的顺序做下调整，先把数据落盘，再给客户端回复。</p> <p>echo 之前说过，在 Redis 源码中，IO 事件的数据结构是 aeFileEvent 结构体，IO 事件的创建是通过 aeCreateFileEvent 函数来完成的。下面的代码展示了 aeFileEvent 结构体的定义，你可以再回顾下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeFileEvent</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> mask<span class="token punctuation">;</span> <span class="token comment">//掩码标记，包括可读事件、可写事件和屏障事件</span>
    aeFileProc <span class="token operator">*</span>rfileProc<span class="token punctuation">;</span>   <span class="token comment">//处理可读事件的回调函数</span>
    aeFileProc <span class="token operator">*</span>wfileProc<span class="token punctuation">;</span>   <span class="token comment">//处理可写事件的回调函数</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span>  <span class="token comment">//私有数据</span>
<span class="token punctuation">}</span> aeFileEvent<span class="token punctuation">;</span>
</code></pre></div><p>而对于 aeCreateFileEvent 函数来说，在上节课我们已经了解了它是通过 aeApiAddEvent 函数来完成事件注册的。那么接下来，我们再从代码级别看下它是如何执行的，这可以帮助我们更加透彻地理解，事件驱动框架对 IO 事件监听是如何基于 epoll 机制对应封装的。</p> <h3 id="io-事件创建"><a href="#io-事件创建" class="header-anchor">#</a> IO 事件创建</h3> <p>首先，我们来看 aeCreateFileEvent 函数的原型定义，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span> aeFileProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span>
</code></pre></div><p>这个函数的参数有 5 个，分别是</p> <ul><li>循环流程结构体<code>*eventLoop</code></li> <li>IO 事件对应的文件描述符 fd</li> <li>事件类型掩码 mask</li> <li>事件处理回调函数<code>*proc</code></li> <li>事件私有数据<code>*clientData</code>。</li></ul> <p>因为循环流程结构体<code>*eventLoop</code>中有 IO 事件数组，这个数组的元素是 aeFileEvent 类型，所以，每个数组元素都对应记录了一个文件描述符（比如一个套接字）相关联的监听事件类型和回调函数。</p> <p>aeCreateFileEvent 函数会先根据传入的文件描述符 fd，在 eventLoop 的 IO 事件数组中，获取该描述符关联的 IO 事件指针变量<code>*fe</code>，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code>aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>紧接着，aeCreateFileEvent 函数会调用 aeApiAddEvent 函数，添加要监听的事件：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
   <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span>
</code></pre></div><p>aeApiAddEvent 函数实际上会调用操作系统提供的 IO 多路复用函数，来完成事件的添加。我们还是假设 Redis 实例运行在使用 epoll 机制的 Linux 上，那么 aeApiAddEvent 函数就会调用 epoll_ctl 函数，添加要监听的事件。我在第 9 讲中其实已经给你介绍过 epoll_ctl 函数，这个函数会接收 4 个参数，分别是：</p> <ul><li>epoll 实例；</li> <li>要执行的操作类型（是添加还是修改）；</li> <li>要监听的文件描述符；</li> <li>epoll_event 类型变量</li></ul> <p>那么，<strong>这个调用过程是如何准备 epoll_ctl 函数需要的参数，从而完成执行的呢？</strong></p> <p>首先，epoll 实例是我刚才给你介绍的 aeCreateEventLoop 函数，它是通过调用 aeApiCreate 函数来创建的，保存在了 eventLoop 结构体的 apidata 变量中，类型是 aeApiState。所以，aeApiAddEvent 函数会先获取该变量，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//从eventLoop结构体中获取aeApiState变量，里面保存了epoll实例</span>
	aeApiState <span class="token operator">*</span>state <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>apidata<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
 <span class="token punctuation">}</span>
</code></pre></div><p>其次，对于要执行的操作类型的设置，aeApiAddEvent 函数会根据传入的文件描述符 fd，在 eventLoop 结构体中 IO 事件数组中查找该 fd。因为 IO 事件数组的每个元素，都对应了一个文件描述符，而该数组初始化时，每个元素的值都设置为了 AE_NONE。</p> <p>所以，如果要监听的文件描述符 fd 在数组中的类型不是 AE_NONE，则表明该描述符已做过设置，那么操作类型就是修改操作，对应 epoll 机制中的宏定义 EPOLL_CTL_MOD。否则，操作类型就是添加操作，对应 epoll 机制中的宏定义 EPOLL_CTL_ADD。这部分代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//如果文件描述符fd对应的IO事件已存在，则操作类型为修改，否则为添加</span>
 <span class="token keyword">int</span> op <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">==</span> AE_NONE <span class="token operator">?</span>
            EPOLL_CTL_ADD <span class="token operator">:</span> EPOLL_CTL_MOD<span class="token punctuation">;</span>
</code></pre></div><p>第三，epoll_ctl 函数需要的监听文件描述符，就是 aeApiAddEvent 函数接收到的参数 fd。</p> <p>最后，epoll_ctl 函数还需要一个 epoll_event 类型变量，因此 aeApiAddEvent 函数在调用 epoll_ctl 函数前，会新创建 epoll_event 类型**变量 ee。**然后，aeApiAddEvent 函数会设置变量 ee 中的监听事件类型和监听文件描述符。</p> <p>aeApiAddEvent 函数的参数 mask，表示的是要监听的事件类型掩码。所以，aeApiAddEvent 函数会根据掩码值是可读（AE_READABLE）或可写（AE_WRITABLE）事件，来设置 ee 监听的事件类型是 EPOLLIN 还是 EPOLLOUT。这样一来，Redis 事件驱动框架中的读写事件就能够和 epoll 机制中的读写事件对应上来。下面的代码展示了这部分逻辑，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code>…
<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> ee <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//创建epoll_event类型变量</span>
…
<span class="token comment">//将可读或可写IO事件类型转换为epoll监听的类型EPOLLIN或EPOLLOUT</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> ee<span class="token punctuation">.</span>events <span class="token operator">|=</span> EPOLLIN<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> ee<span class="token punctuation">.</span>events <span class="token operator">|=</span> EPOLLOUT<span class="token punctuation">;</span>
ee<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> fd<span class="token punctuation">;</span>  <span class="token comment">//将要监听的文件描述符赋值给ee</span>
…
</code></pre></div><p>好了，到这里，aeApiAddEvent 函数就准备好了 epoll 实例、操作类型、监听文件描述符以及 epoll_event 类型变量，然后，它就会调用 epoll_ctl 开始实际创建监听事件了，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">//调用epoll_ctl实际创建监听事件</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">epoll_ctl</span><span class="token punctuation">(</span>state<span class="token operator">-&gt;</span>epfd<span class="token punctuation">,</span>op<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>ee<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>了解了这些代码后，我们可以学习到事件驱动框架是如何基于 epoll，封装实现了 IO 事件的创建。那么，在 Redis server 启动运行后，最开始监听的 IO 事件是可读事件，对应于客户端的连接请求。具体是 initServer 函数调用了 aeCreateFileEvent 函数，创建可读事件，并设置回调函数为 acceptTcpHandler，用来处理客户端连接</p> <p>接下来，我们再来看下一旦有了客户端连接请求后，IO 事件具体是如何处理的呢？</p> <h3 id="读事件处理"><a href="#读事件处理" class="header-anchor">#</a> 读事件处理</h3> <p>当 Redis server 接收到客户端的连接请求时，就会使用注册好的 <strong>acceptTcpHandler 函数</strong> 进行处理。</p> <p>acceptTcpHandler 函数会接受客户端连接，并创建已连接套接字 cfd。然后，acceptCommonHandler 函数会被调用，同时，刚刚创建的已连接套接字 cfd 会作为参数，传递给 acceptCommonHandler 函数。</p> <p>acceptCommonHandler 函数会调用 createClient 函数创建客户端。而在 createClient 函数中，我们就会看到，aeCreateFileEvent 函数被再次调用了</p> <p>此时，aeCreateFileEvent 函数会针对已连接套接字上，创建监听事件，类型为 AE_READABLE，回调函数是 readQueryFromClient</p> <p>好了，到这里，事件驱动框架就<strong>增加</strong>了对一个客户端已连接套接字的监听。一旦客户端有请求发送到 server，框架就会回调 readQueryFromClient 函数处理请求。这样一来，客户端请求就能通过事件驱动框架进行处理了。</p> <p>下面代码展示了 createClient 函数调用 aeCreateFileEvent 的过程，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code>client <span class="token operator">*</span><span class="token function">createClient</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
…
<span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        …
        <span class="token comment">//调用aeCreateFileEvent，监听读事件，对应客户端读写请求，使用readQueryFromclient回调函数处理</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>AE_READABLE<span class="token punctuation">,</span>
            readQueryFromClient<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">zfree</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token punctuation">}</span>
…
<span class="token punctuation">}</span>
</code></pre></div><p>为了便于你掌握从监听客户端连接请求到监听客户端常规读写请求的事件创建过程，我画了下面这张图，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151358214.png" alt="image-20240915135841109"></p> <h3 id="写事件处理"><a href="#写事件处理" class="header-anchor">#</a> 写事件处理</h3> <p>Redis 实例在收到客户端请求后，会在处理客户端命令后，将要返回的数据写入客户端输出缓冲区。下图就展示了这个过程的函数调用逻辑：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151359441.png" alt="image-20240915135959373"></p> <p>而在 Redis 事件驱动框架每次循环进入事件处理函数前，也就是在框架主函数 aeMain 中调用 aeProcessEvents，来处理监听到的已触发事件或是到时的时间事件之前，都会调用 server.c 文件中的<strong>beforeSleep 函数</strong>，进行一些任务处理，这其中就包括了调用 handleClientsWithPendingWrites 函数，它会将 Redis sever 客户端缓冲区中的数据写回客户端。</p> <p>下面给出的代码是事件驱动框架的主函数 aeMain。在该函数每次调用 aeProcessEvents 函数前，就会调用 beforeSleep 函数，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    eventLoop<span class="token operator">-&gt;</span>stop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>eventLoop<span class="token operator">-&gt;</span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token comment">//如果beforeSleep函数不为空，则调用beforeSleep函数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            eventLoop<span class="token operator">-&gt;</span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//调用完beforeSleep函数，再处理事件</span>
        <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> AE_ALL_EVENTS<span class="token operator">|</span>AE_CALL_AFTER_SLEEP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里你要知道，beforeSleep 函数调用的 handleClientsWithPendingWrites 函数，会遍历每一个待写回数据的客户端，然后调用 writeToClient 函数，将客户端输出缓冲区中的数据写回。下面这张图展示了这个流程，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151400521.png" alt="image-20240915140035435"></p> <p>不过，如果输出缓冲区的数据还没有写完，此时，handleClientsWithPendingWrites 函数就会<strong>调用 aeCreateFileEvent 函数，创建可写事件</strong>，并设置回调函数 sendReplyToClient。sendReplyToClient 函数里面会调用 writeToClient 函数写回数据。</p> <blockquote><p>aeCreateFileEvent 是 Redis 中的一个底层函数，用于向事件循环中注册一个新的文件事件。文件事件可以是“可读事件”（数据到来时触发）或“可写事件”（缓冲区空闲时触发）。在上述场景中，<code>aeCreateFileEvent</code> 创建的是一个“可写事件”。</p> <p>当客户端的输出缓冲区还未完全发送完数据时，Redis 不会立刻阻塞，而是通过创建“可写事件”来处理这个情况。这个可写事件表示，当 Redis 发现客户端可以继续接收数据时（输出缓冲区空闲），它就会自动触发这个事件。</p> <p>当可写事件触发时，Redis 会调用 <code>sendReplyToClient</code> 函数。这个函数负责将剩余的数据从输出缓冲区发送给客户端。具体来说，它内部会调用 <code>writeToClient</code> 函数来真正执行数据发送的操作。</p></blockquote> <p>echo 认为</p> <blockquote><ol><li><strong>输出缓冲区</strong>：当 Redis 需要将数据返回给客户端时，数据会先存放在一个输出缓冲区中，然后再通过网络传输给客户端。</li> <li><strong>缓冲区未写完</strong>：这个情况可能发生在以下几种情况下：
<ul><li><strong>客户端网络不畅</strong>：客户端处理速度较慢，或者网络带宽不足，导致一次只能从缓冲区接收一部分数据，剩余的数据暂时无法发送。(可能是 TCP 的滑动窗口中的接收方的接收窗口跟不上)</li> <li><strong>大数据量传输</strong>：如果 Redis 需要发送的数据量很大，比如一个大的查询结果，Redis 可能无法在一次 write 操作中将所有数据写入客户端的网络套接字，只能先写入一部分，剩下的放在缓冲区里等待下一次写入。</li></ul></li> <li><strong>处理机制</strong>：
<ul><li>当 Redis 发现缓冲区中的数据没有写完（例如，<code>writeToClient</code> 函数尝试发送数据时只能写入一部分），它不会等待或阻塞主线程。</li> <li>此时 Redis 会调用 <code>aeCreateFileEvent</code>，创建一个<strong>可写事件</strong>，表示客户端还未完全接收数据。当客户端准备好接收更多数据时，这个可写事件会触发，回调函数 <code>sendReplyToClient</code> 会再次被调用，尝试将剩下的数据发送给客户端。</li></ul></li></ol> <ul><li><strong>避免阻塞主线程</strong>：Redis 是单线程的，如果由于网络问题或客户端处理能力限制，主线程被阻塞在一个客户端的发送过程中，其他客户端的请求就无法得到及时处理。</li> <li><strong>提高性能和吞吐量</strong>：通过异步的方式处理缓冲区的剩余数据发送，Redis 能在高并发的情况下更高效地处理多个客户端的请求。</li></ul></blockquote> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    listIter li<span class="token punctuation">;</span>
	listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>
	…
    <span class="token comment">//获取待写回的客户端列表</span>
	<span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//遍历每一个待写回的客户端</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	   client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
	   …
	   <span class="token comment">//调用writeToClient将当前客户端的输出缓冲区数据写回</span>
	   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>fd<span class="token punctuation">,</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
	   <span class="token comment">//如果还有待写回数据</span>
	   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	            <span class="token keyword">int</span> ae_flags <span class="token operator">=</span> AE_WRITABLE<span class="token punctuation">;</span>
	            <span class="token comment">//创建可写事件的监听，以及设置回调函数</span>
	             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> c<span class="token operator">-&gt;</span>fd<span class="token punctuation">,</span> ae_flags<span class="token punctuation">,</span>
	                sendReplyToClient<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span>
	            <span class="token punctuation">{</span>
	                   …
	            <span class="token punctuation">}</span>
	  <span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好了，我们刚才了解的是读写事件对应的回调处理函数。实际上，为了能及时处理这些事件，Redis 事件驱动框架的 aeMain 函数还会循环<strong>调用 aeProcessEvents 函数，来检测已触发的事件，并调用相应的回调函数进行处理。</strong></p> <p>从 aeProcessEvents 函数的代码中，我们可以看到该函数会调用 aeApiPoll 函数，查询监听的文件描述符中，有哪些已经就绪。一旦有描述符就绪，aeProcessEvents 函数就会根据事件的可读或可写类型，调用相应的回调函数进行处理。aeProcessEvents 函数调用的基本流程如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>
…
<span class="token comment">//调用aeApiPoll获取就绪的描述符</span>
numevents <span class="token operator">=</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> tvp<span class="token punctuation">)</span><span class="token punctuation">;</span>
…
<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numevents<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>
	…
    <span class="token comment">//如果触发的是可读事件，调用事件注册时设置的读事件回调处理函数</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>invert <span class="token operator">&amp;&amp;</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	      fe<span class="token operator">-&gt;</span><span class="token function">rfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                fired<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

    <span class="token comment">//如果触发的是可写事件，调用事件注册时设置的写事件回调处理函数</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fired <span class="token operator">||</span> fe<span class="token operator">-&gt;</span>wfileProc <span class="token operator">!=</span> fe<span class="token operator">-&gt;</span>rfileProc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	                    fe<span class="token operator">-&gt;</span><span class="token function">wfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                    fired<span class="token operator">++</span><span class="token punctuation">;</span>
	                <span class="token punctuation">}</span>
	            <span class="token punctuation">}</span>
	…
	<span class="token punctuation">}</span> <span class="token punctuation">}</span>
	…
<span class="token punctuation">}</span>
</code></pre></div><p>到这里，我们就了解了 IO 事件的创建函数 aeCreateFileEvent，以及在处理客户端请求时对应的读写事件和它们的处理函数。那么接下来，我们再来看看事件驱动框架中的时间事件是怎么创建和处理的。</p> <h2 id="时间事件处理"><a href="#时间事件处理" class="header-anchor">#</a> 时间事件处理</h2> <p>其实，相比于 IO 事件有可读、可写、屏障类型，以及不同类型 IO 事件有不同回调函数来说，时间事件的处理就比较简单了。下面，我们就来分别学习下它的定义、创建、回调函数和触发处理。</p> <h3 id="时间事件定义"><a href="#时间事件定义" class="header-anchor">#</a> 时间事件定义</h3> <p>首先，我们来看下时间事件的结构体定义，代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span> <span class="token comment">//时间事件ID</span>
    <span class="token keyword">long</span> when_sec<span class="token punctuation">;</span> <span class="token comment">//事件到达的秒级时间戳</span>
    <span class="token keyword">long</span> when_ms<span class="token punctuation">;</span> <span class="token comment">//事件到达的毫秒级时间戳</span>
    aeTimeProc <span class="token operator">*</span>timeProc<span class="token punctuation">;</span> <span class="token comment">//时间事件触发后的处理函数</span>
    aeEventFinalizerProc <span class="token operator">*</span>finalizerProc<span class="token punctuation">;</span>  <span class="token comment">//事件结束后的处理函数</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span> <span class="token comment">//事件相关的私有数据</span>
    <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>  <span class="token comment">//时间事件链表的前向指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">//时间事件链表的后向指针</span>
<span class="token punctuation">}</span> aeTimeEvent<span class="token punctuation">;</span>
</code></pre></div><p>时间事件结构体中主要的变量，包括以秒记录和以毫秒记录的时间事件触发时的时间戳 when_sec 和 when_ms，以及时间事件触发后的处理函数<code>*timeProc</code>。另外，在时间事件的结构体中，还包含了前向和后向指针<code>*prev</code>和<code>*next</code>，这表明<strong>时间事件是以链表的形式组织起来的</strong>。</p> <p>在了解了时间事件结构体的定义以后，我们接着来看下，时间事件是如何创建的。</p> <h3 id="时间事件创建"><a href="#时间事件创建" class="header-anchor">#</a> 时间事件创建</h3> <p>与 IO 事件创建使用 aeCreateFileEvent 函数类似，<strong>时间事件的创建函数是 aeCreateTimeEvent 函数</strong>。这个函数的原型定义如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">aeCreateTimeEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> milliseconds<span class="token punctuation">,</span> aeTimeProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">,</span> aeEventFinalizerProc <span class="token operator">*</span>finalizerProc<span class="token punctuation">)</span>
</code></pre></div><p>在它的参数中，有两个需要我们重点了解下，以便于我们理解时间事件的处理。</p> <ul><li>一个是<strong>milliseconds</strong>，这是所创建时间事件的触发时间距离当前时间的时长，是用毫秒表示的。</li> <li>另一个是***proc**，这是所创建时间事件触发后的<strong>回调函数</strong>。</li></ul> <p>aeCreateTimeEvent 函数的执行逻辑不复杂，主要就是创建一个时间事件的<strong>变量 te</strong>，对它进行初始化，并把它插入到框架循环流程结构体 eventLoop 中的时间事件链表中。在这个过程中，aeCreateTimeEvent 函数会<strong>调用 aeAddMillisecondsToNow 函数</strong>，根据传入的 milliseconds 参数，计算所创建时间事件具体的触发时间戳，并赋值给 te。</p> <p>实际上，Redis server 在初始化时，除了创建监听的 IO 事件外，也会调用 aeCreateTimeEvent 函数创建时间事件。下面代码显示了 initServer 函数对 aeCreateTimeEvent 函数的调用：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
    <span class="token comment">//创建时间事件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateTimeEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> serverCron<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span><span class="token punctuation">{</span>
    … <span class="token comment">//报错信息</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从代码中，我们可以看到，<strong>时间事件触发后的回调函数是 serverCron</strong>。所以接下来，我们就来了解下 serverCron 函数。</p> <h3 id="时间事件回调函数"><a href="#时间事件回调函数" class="header-anchor">#</a> 时间事件回调函数</h3> <p>serverCron 函数是在 server.c 文件中实现的。<strong>一方面</strong>，它会顺序调用一些函数，来实现时间事件被触发后，执行一些后台任务。比如，serverCron 函数会检查是否有进程结束信号，若有就执行 server 关闭操作。serverCron 会调用 databaseCron 函数，处理过期 key 或进行 rehash 等。你可以参考下面给出的代码：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//如果收到进程结束信号，则执行server关闭操作</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>shutdown_asap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">prepareForShutdown</span><span class="token punctuation">(</span>SHUTDOWN_NOFLAGS<span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token function">clientCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//执行客户端的异步操作</span>
<span class="token function">databaseCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//执行数据库的后台操作</span>
</code></pre></div><p><strong>另一方面</strong>，serverCron 函数还会以不同的频率周期性执行一些任务，这是通过执行宏 run_with_period 来实现的。</p> <p>run<em>with_period 宏定义如下，该宏定义会根据 Redis 实例配置文件 redis.conf 中定义的 hz 值，来判断参数_ms</em>表示的时间戳是否到达。一旦到达，serverCron 就可以执行相应的任务了。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">run_with_period</span><span class="token expression"><span class="token punctuation">(</span>_ms_<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>_ms_ <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token operator">/</span>server<span class="token punctuation">.</span>hz<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cronloops<span class="token operator">%</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_ms_<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token operator">/</span>server<span class="token punctuation">.</span>hz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre></div><p>比如，serverCron 函数中会以 1 秒 1 次的频率，检查 AOF 文件是否有写错误。如果有的话，serverCron 就会调用 flushAppendOnlyFile 函数，再次刷回 AOF 文件的缓存数据。下面的代码展示了这一周期性任务：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   …
   <span class="token comment">//每1秒执行1次，检查AOF是否有写错误</span>
   <span class="token function">run_with_period</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_last_write_status <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span>
            <span class="token function">flushAppendOnlyFile</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   …
<span class="token punctuation">}</span>
</code></pre></div><p>如果你想了解更多的周期性任务，可以再详细阅读下 serverCron 函数中，以 run_with_period 宏定义包含的代码块。</p> <p>好了，了解了时间事件触发后的回调函数 serverCron，我们最后来看下，时间事件是如何触发处理的。</p> <h3 id="时间事件的触发处理"><a href="#时间事件的触发处理" class="header-anchor">#</a> 时间事件的触发处理</h3> <p>其实，时间事件的检测触发比较简单，事件驱动框架的 aeMain 函数会循环调用 aeProcessEvents 函数，来处理各种事件。而 aeProcessEvents 函数在执行流程的最后，会<strong>调用 processTimeEvents 函数处理相应到时的任务</strong>。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">aeProcessEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    …
    <span class="token comment">//检测时间事件是否触发</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span>
            processed <span class="token operator">+=</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    …
<span class="token punctuation">}</span>
</code></pre></div><p>那么，具体到 proecessTimeEvent 函数来说，它的基本流程就是从时间事件链表上逐一取出每一个事件，然后根据当前时间判断该事件的触发时间戳是否已满足。如果已满足，那么就调用该事件对应的回调函数进行处理。这样一来，周期性任务就能在不断循环执行的 aeProcessEvents 函数中，得到执行了。</p> <p>下面的代码显示了 processTimeEvents 函数的基本流程，你可以再看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    te <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span>  <span class="token comment">//从时间事件链表中取出事件</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      <span class="token function">aeGetTime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>now_sec<span class="token punctuation">,</span> <span class="token operator">&amp;</span>now_ms<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//获取当前时间</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>now_sec <span class="token operator">&gt;</span> te<span class="token operator">-&gt;</span>when_sec <span class="token operator">||</span> <span class="token punctuation">(</span>now_sec <span class="token operator">==</span> te<span class="token operator">-&gt;</span>when_sec <span class="token operator">&amp;&amp;</span> now_ms <span class="token operator">&gt;=</span> te<span class="token operator">-&gt;</span>when_ms<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">//如果当前时间已经满足当前事件的触发时间戳</span>
      <span class="token punctuation">{</span>
         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        retval <span class="token operator">=</span> te<span class="token operator">-&gt;</span><span class="token function">timeProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> id<span class="token punctuation">,</span> te<span class="token operator">-&gt;</span>clientData<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用注册的回调函数处理</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      <span class="token punctuation">}</span>
      te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>   <span class="token comment">//获取下一个时间事件</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>对于 IO 事件来说，它可以进一步分成可读、可写和屏障事件。因为可读、可写事件在 Redis 和客户端通信处理请求过程中使用广泛，所以本节我们重点学习了这两种 IO 事件。当 Redis server 创建 Socket 后，就会注册可读事件，并使用 acceptTCPHandler 回调函数处理客户端的连接请求。</p> <p>当 server 和客户端完成连接建立后，server 会在已连接套接字上监听可读事件，并使用 readQueryFromClient 函数处理客户端读写请求。这里，你需要再注意下，<strong>无论客户端发送的请求是读或写操作，对于 server 来说，都是要读取客户端的请求并解析处理</strong>。所以，server 在客户端的已连接套接字上注册的是可读事件。</p> <p>而当实例需要向客户端写回数据时，实例会在事件驱动框架中注册可写事件，并使用 sendReplyToClient 作为回调函数，将缓冲区中数据写回客户端。我总结了一张表格，以便你再回顾下 IO 事件和相应套接字、回调函数的对应关系。</p> <p>然后，对于时间事件来说，它主要是用于在事件驱动框架中注册一些周期性执行的任务，以便 Redis server 进行后台处理。时间事件的回调函数是 serverCron 函数，你可以做进一步阅读了解其中的具体任务。</p> <p>好了，从第 9 讲开始，我用了 3 节课，向你介绍 Redis 事件驱动框架的运行机制，本质上来说，事件驱动框架是基于操作系统提供的 IO 多路复用机制进行了封装，并加上了时间事件的处理。这是一个非常经典的事件框架实现，我希望你可以学习并掌握好它，然后用在你自己的系统开发中。</p> <h2 id="参考文献"><a href="#参考文献" class="header-anchor">#</a> 参考文献</h2> <p><a href="https://time.geekbang.org/column/intro/100084301?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noopener noreferrer">Redis 源码剖析与实战<em>Redis_Redis 源码</em>数据结构<em>主从复制</em>缓存<em>集群</em>分布式数据库<em>键值数据库</em>事件驱动框架-极客时间 (geekbang.org)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener noreferrer">Redis 设计与实现 (豆瓣) (douban.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/Redis 系统设计/03.主线/08.深入 Redis 事件驱动框架.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新于:</span> <span class="time">2024/09/16, 13:27:00</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/d6b00d/" class="prev">Redis 的 Reactor 模型</a></span> <span class="next"><a href="/pages/e6d8ef/">Redis 的执行模式</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.f1bdf1ca.js" defer></script><script src="/assets/js/2.933750c6.js" defer></script><script src="/assets/js/47.f3a2643a.js" defer></script><script src="/assets/js/7.7eb70372.js" defer></script>
  </body>
</html>
