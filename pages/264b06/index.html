<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis 事件驱动框架之 IO 多路复用 | Echo 系统设计之美</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="将系统设计技能提升到一个新水平所需的一切">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.cdf6edd4.css" as="style"><link rel="preload" href="/assets/js/app.e2123772.js" as="script"><link rel="preload" href="/assets/js/2.81691b95.js" as="script"><link rel="preload" href="/assets/js/35.c5c7cc6d.js" as="script"><link rel="prefetch" href="/assets/js/10.10f57c8c.js"><link rel="prefetch" href="/assets/js/11.0011448e.js"><link rel="prefetch" href="/assets/js/12.eb7cd9a4.js"><link rel="prefetch" href="/assets/js/13.e0f459fb.js"><link rel="prefetch" href="/assets/js/14.317c830e.js"><link rel="prefetch" href="/assets/js/15.f5267ca5.js"><link rel="prefetch" href="/assets/js/16.b9004d69.js"><link rel="prefetch" href="/assets/js/17.ed780ee9.js"><link rel="prefetch" href="/assets/js/18.1395f633.js"><link rel="prefetch" href="/assets/js/19.86872914.js"><link rel="prefetch" href="/assets/js/20.2bd2a513.js"><link rel="prefetch" href="/assets/js/21.d18d7dbd.js"><link rel="prefetch" href="/assets/js/22.bc7e0113.js"><link rel="prefetch" href="/assets/js/23.4e5ae27b.js"><link rel="prefetch" href="/assets/js/24.5daaf2a7.js"><link rel="prefetch" href="/assets/js/25.aea2d76d.js"><link rel="prefetch" href="/assets/js/26.e5c2c30b.js"><link rel="prefetch" href="/assets/js/27.1a0c5834.js"><link rel="prefetch" href="/assets/js/28.a6254791.js"><link rel="prefetch" href="/assets/js/29.87731f46.js"><link rel="prefetch" href="/assets/js/3.9d64ee0b.js"><link rel="prefetch" href="/assets/js/30.f7506f68.js"><link rel="prefetch" href="/assets/js/31.d80c18a2.js"><link rel="prefetch" href="/assets/js/32.a0718230.js"><link rel="prefetch" href="/assets/js/33.05697a0c.js"><link rel="prefetch" href="/assets/js/34.61dc7ef2.js"><link rel="prefetch" href="/assets/js/36.3490806f.js"><link rel="prefetch" href="/assets/js/37.c3415129.js"><link rel="prefetch" href="/assets/js/4.d012670c.js"><link rel="prefetch" href="/assets/js/5.ae7e13e5.js"><link rel="prefetch" href="/assets/js/6.f85123d8.js"><link rel="prefetch" href="/assets/js/7.8848b60d.js"><link rel="prefetch" href="/assets/js/8.fcd31aa9.js"><link rel="prefetch" href="/assets/js/9.17d970ac.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cdf6edd4.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="Echo 系统设计之美" class="logo"> <span class="site-name can-hide">Echo 系统设计之美</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/bd2edd/" class="nav-link">系统设计概述</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">经典设计算法</a></div><div class="nav-item"><a href="/pages/264b06/" aria-current="page" class="nav-link router-link-exact-active router-link-active">系统设计鉴赏</a></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">设计实战</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">问答归档</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">我的动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><a href="/pages/bd2edd/" class="nav-link">系统设计概述</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">经典设计算法</a></div><div class="nav-item"><a href="/pages/264b06/" aria-current="page" class="nav-link router-link-exact-active router-link-active">系统设计鉴赏</a></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">设计实战</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">问答归档</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">我的动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Redis</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/264b06/" aria-current="page" class="active sidebar-link">Redis 事件驱动框架之 IO 多路复用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/264b06/#前言" class="sidebar-link">前言</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/264b06/#简述传统-socket-模型" class="sidebar-link">简述传统 Socket 模型</a></li><li class="sidebar-sub-header level3"><a href="/pages/264b06/#展望-io-多路复用" class="sidebar-link">展望 IO 多路复用</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/264b06/#linux-如何实现-io-多路复用" class="sidebar-link">Linux 如何实现 IO 多路复用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/264b06/#select-机制-多路复用的基本实现" class="sidebar-link">select 机制：多路复用的基本实现</a></li><li class="sidebar-sub-header level3"><a href="/pages/264b06/#poll-机制-不受限的文件描述符数量" class="sidebar-link">poll 机制：不受限的文件描述符数量</a></li><li class="sidebar-sub-header level3"><a href="/pages/264b06/#epoll-机制-避免遍历每个描述符" class="sidebar-link">epoll 机制：避免遍历每个描述符</a></li><li class="sidebar-sub-header level3"><a href="/pages/264b06/#总结" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/264b06/#redis-的-reactor-模型" class="sidebar-link">Redis 的 Reactor 模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/264b06/#reactor-模型的工作机制" class="sidebar-link">Reactor 模型的工作机制</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#事件类型" class="sidebar-link">事件类型</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#关键角色" class="sidebar-link">关键角色</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#事件驱动框架" class="sidebar-link">事件驱动框架</a></li><li class="sidebar-sub-header level3"><a href="/pages/264b06/#redis对reactor模型的实现" class="sidebar-link">Redis对Reactor模型的实现</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#事件的数据结构定义-以aefileevent为例" class="sidebar-link">事件的数据结构定义：以aeFileEvent为例</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#主循环-aemain-函数" class="sidebar-link">主循环：aeMain 函数</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#事件捕获与分发-aeprocessevents-函数" class="sidebar-link">事件捕获与分发：aeProcessEvents 函数</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#事件注册-aecreatefileevent-函数" class="sidebar-link">事件注册：aeCreateFileEvent 函数</a></li><li class="sidebar-sub-header level3"><a href="/pages/264b06/#总结-2" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/264b06/#redis-中的事件" class="sidebar-link">Redis 中的事件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/pages/264b06/#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#文件事件处理器" class="sidebar-link">文件事件处理器</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#时间事件处理器" class="sidebar-link">时间事件处理器</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#核心源码的伪码-自顶向下" class="sidebar-link">核心源码的伪码（自顶向下）</a></li><li class="sidebar-sub-header level3"><a href="/pages/264b06/#事件驱动框架循环流程的数据结构及其初始化" class="sidebar-link">事件驱动框架循环流程的数据结构及其初始化</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#aeeventloop-结构体与初始化" class="sidebar-link">aeEventLoop 结构体与初始化</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#aecreateeventloop-函数的初始化操作" class="sidebar-link">aeCreateEventLoop 函数的初始化操作</a></li><li class="sidebar-sub-header level3"><a href="/pages/264b06/#io-事件处理" class="sidebar-link">IO 事件处理</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#io-事件创建" class="sidebar-link">IO 事件创建</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#读事件处理" class="sidebar-link">读事件处理</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#写事件处理" class="sidebar-link">写事件处理</a></li><li class="sidebar-sub-header level3"><a href="/pages/264b06/#时间事件处理" class="sidebar-link">时间事件处理</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#时间事件定义" class="sidebar-link">时间事件定义</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#时间事件创建" class="sidebar-link">时间事件创建</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#时间事件回调函数" class="sidebar-link">时间事件回调函数</a></li><li class="sidebar-sub-header level4"><a href="/pages/264b06/#时间事件的触发处理" class="sidebar-link">时间事件的触发处理</a></li><li class="sidebar-sub-header level3"><a href="/pages/264b06/#总结-3" class="sidebar-link">总结</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/pages/264b06/#参考文献" class="sidebar-link">参考文献</a></li></ul></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>系统设计鉴赏</span></li><li data-v-06225672><span data-v-06225672>Redis</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-15</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Redis 事件驱动框架之 IO 多路复用<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><p>我在这里大量引用了<a href="https://time.geekbang.org/column/intro/100084301?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noopener noreferrer">Redis源码剖析与实战_Redis_Redis源码_数据结构_主从复制_缓存_集群_分布式数据库_键值数据库_事件驱动框架-极客时间 (geekbang.org)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、<a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener noreferrer">Redis设计与实现 (豆瓣) (douban.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中的内容，只为粗略介绍redis的事件驱动框架设计</p> <p>我觉得看完本文之后，最好是结合 Redis 事件驱动的核心源码进行深入学习</p> <p><a href="https://github.com/redis/redis/blob/5.0/src/ae.c" target="_blank" rel="noopener noreferrer">redis/src/ae.c at 5.0 · redis/redis (github.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151547840.png" alt="image-20240915154721774"></p> <p>redis 源码中ae开头的 都是事件驱动框架的核心源码</p> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>Redis 作为一个 Client-Server 架构的数据库，其源码中少不了用来实现网络通信的部分。通常系统实现网络通信的基本方法是 <strong>使用Socket编程模型</strong>，但是，由于基本的 Socket 编程模型一次只能处理一个客户端连接上的请求，所以当要处理高并发请求时</p> <ul><li>一种方案就是使用多线程，让每个线程负责处理一个客户端的请求。而Redis负责客户端请求解析和处理的线程只有一个，那么如果直接采用基本 Socket 模型，就会影响Redis支持高并发的客户端访问。</li> <li>另外一种方案就是IO多路复用，因此，为了实现高并发的网络通信，我们常用的Linux操作系统，就提供了select、poll和epoll三种编程模型，而在Linux上运行的Redis，通常就会采用其中的<strong>epoll模型</strong>来进行网络通信。</li></ul> <p>请你带着问题看文章</p> <ul><li><strong>为啥Redis通常会选择epoll模型呢？</strong></li> <li><strong>这三种编程模型之间有什么区别？</strong></li> <li>如果我们自己要开发高并发的服务器处理程序时，应该如何选择使用呢？</li></ul> <h3 id="简述传统-socket-模型"><a href="#简述传统-socket-模型" class="header-anchor">#</a> 简述传统 Socket 模型</h3> <p>刚刚我们说过，使用Socket模型实现网络通信时，需要经过创建 Socket、监听端口、处理连接和读写请求等多个步骤，现在我们就来具体了解下这些步骤中的关键操作，以此帮助我们分析 Socket 模型中的不足。</p> <p>首先，当我们需要让服务器端和客户端进行通信时，可以在服务器端通过以下三步，来创建监听客户端连接的监听套接字（Listening Socket）：</p> <ol><li>调用socket函数，创建一个套接字。我们通常把这个套接字称为主动套接字（Active Socket）；</li> <li>调用bind函数，将主动套接字和当前服务器的IP和监听端口进行绑定；</li> <li>调用listen函数，将主动套接字转换为监听套接字，开始监听客户端的连接。</li></ol> <p>在完成上述三步之后，服务器端就可以接收客户端的连接请求了。为了能及时地收到客户端的连接请求，我们可以运行一个循环流程，在该流程中调用accept函数，用于接收客户端连接请求。</p> <p>这里你需要注意的是，accept函数是阻塞函数，也就是说，如果此时一直没有客户端连接请求，那么，服务器端的执行流程会一直阻塞在accept函数。一旦有客户端连接请求到达，accept将不再阻塞，而是处理连接请求，和客户端建立连接，并返回已连接套接字（Connected Socket）。</p> <p>最后，服务器端可以通过调用recv或send函数，在刚才返回的已连接套接字上，接收并处理读写请求，或是将数据发送给客户端。</p> <p>下面的代码展示了这一过程，你可以看下。</p> <div class="language-Java extra-class"><pre class="language-java"><code>listenSocket <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用socket系统调用创建一个主动套接字</span>
<span class="token function">bind</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//绑定地址和端口</span>
<span class="token function">listen</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将默认的主动套接字转换为服务器使用的被动套接字，也就是监听套接字</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//循环监听是否有客户端连接请求到来</span>
   connSocket <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//接受客户端连接</span>
   <span class="token function">recv</span><span class="token punctuation">(</span>connsocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//从客户端读取数据，只能同时处理一个客户端</span>
   <span class="token function">send</span><span class="token punctuation">(</span>connsocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//给客户端返回数据，只能同时处理一个客户端</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不过，从上述代码中，你可能会发现，虽然它能够实现服务器端和客户端之间的通信，但是程序每调用一次 accept 函数，只能处理一个客户端连接。因此，如果想要处理多个并发客户端的请求，我们就需要使用<strong>多线程</strong>的方法，来处理通过 accept 函数建立的多个客户端连接上的请求。</p> <p>使用这种方法后，我们需要在 accept 函数返回已连接套接字后，创建一个线程，并将已连接套接字传递给创建的线程，由该线程负责这个连接套接字上后续的数据读写。同时，服务器端的执行流程会再次调用 accept 函数，等待下一个客户端连接。</p> <p>以下给出的示例代码，就展示了使用多线程来提升服务器端的并发客户端处理能力：</p> <div class="language-Java extra-class"><pre class="language-java"><code>listenSocket <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用socket系统调用创建一个主动套接字</span>
<span class="token function">bind</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//绑定地址和端口</span>
<span class="token function">listen</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//将默认的主动套接字转换为服务器使用的被动套接字，即监听套接字</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//循环监听是否有客户端连接到来</span>
   connSocket <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>listenSocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//接受客户端连接，返回已连接套接字</span>
   <span class="token function">pthread_create</span><span class="token punctuation">(</span>processData<span class="token punctuation">,</span> connSocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建新线程对已连接套接字进行处理</span>
   
<span class="token punctuation">}</span>

<span class="token comment">//处理已连接套接字上的读写请求</span>
<span class="token function">processData</span><span class="token punctuation">(</span>connSocket<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token function">recv</span><span class="token punctuation">(</span>connsocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//从客户端读取数据，只能同时处理一个客户端</span>
   <span class="token function">send</span><span class="token punctuation">(</span>connsocket<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//给客户端返回数据，只能同时处理一个客户端</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="展望-io-多路复用"><a href="#展望-io-多路复用" class="header-anchor">#</a> 展望 IO 多路复用</h3> <p>不过，虽然上述方法能提升服务器端的并发处理能力，遗憾的是</p> <p><strong>Redis的主执行流程是由一个线程在执行，无法使用多线程的方式来提升并发处理能力。</strong></p> <p>所以，该方法对Redis并不起作用。那么，还有没有什么其他方法，能帮助Redis提升并发客户端的处理能力呢？</p> <p>这就要用到操作系统提供的<strong>IO多路复用功能</strong>了。在基本的Socket编程模型中，accept函数只能在一个监听套接字上监听客户端的连接，recv函数也只能在一个已连接套接字上，等待客户端发送的请求。</p> <p>而IO多路复用机制，可以让程序通过调用多路复用函数，同时监听多个套接字上的请求。这里既可以包括监听套接字上的连接请求，也可以包括已连接套接字上的读写请求。这样当有一个或多个套接字上有请求时，多路复用函数就会返回。此时，程序就可以处理这些就绪套接字上的请求，比如读取就绪的已连接套接字上的请求内容。</p> <p>因为Linux操作系统在实际应用中比较广泛，所以 讲解 Linux上的IO多路复用机制。</p> <p>Linux提供的IO多路复用机制主要有三种，分别是</p> <ul><li>select</li> <li>poll</li> <li>epoll</li></ul> <p>下面，我们就分别来学习下这三种机制的实现思路和使用方法。然后，我们再来看看，为什么Redis通常是选择使用epoll这种机制来实现网络通信。</p> <h2 id="linux-如何实现-io-多路复用"><a href="#linux-如何实现-io-多路复用" class="header-anchor">#</a> Linux 如何实现 IO 多路复用</h2> <p>首先，我们来了解下 select 机制的编程模型。</p> <p>课前提问：</p> <ul><li>第一，多路复用机制会监听套接字上的<strong>哪些</strong>事件？</li> <li>第二，多路复用机制可以监听<strong>多少个</strong>套接字？</li> <li>第三，当有套接字就绪时，多路复用机制要<strong>如何找到就绪的套接字</strong>？</li></ul> <h3 id="select-机制-多路复用的基本实现"><a href="#select-机制-多路复用的基本实现" class="header-anchor">#</a> select 机制：多路复用的基本实现</h3> <p>select机制中的一个重要函数就是select函数。</p> <p>对于select函数来说，它的参数包括</p> <ul><li>监听的文件描述符数量<code>__nfds</code></li> <li>被监听描述符的三个集合<code>*__readfds</code>、<code>*__writefds</code>和<code>*__exceptfds</code></li> <li>监听时阻塞等待的超时时长<code>*__timeout</code></li></ul> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">select</span> <span class="token punctuation">(</span><span class="token keyword">int</span> __nfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>__readfds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>__writefds<span class="token punctuation">,</span> fd_set <span class="token operator">*</span>__exceptfds<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>__timeout<span class="token punctuation">)</span>
</code></pre></div><p>这里你需要注意的是，<strong>Linux 针对每一个套接字都会有一个文件描述符，也就是一个非负整数，用来唯一标识该套接字</strong>。</p> <p>所以，<strong>在多路复用机制的函数中，Linux 通常会用文件描述符作为参数</strong>。有了文件描述符，函数也就能找到对应的套接字，进而进行监听、读写等操作。</p> <p>所以，select函数的参数<code>__readfds</code>、<code>__writefds</code>和<code>__exceptfds</code>表示的是，被监听描述符的集合，其实就是被监听套接字的集合。那么，为什么会有三个集合呢？</p> <p>这就和我刚才提出的第一个问题相关，也就是<strong>多路复用机制会监听哪些事件</strong>。select 函数使用三个集合，表示监听的三类事件，分别是</p> <ul><li>读数据事件（对应<code>__readfds</code>集合）</li> <li>写数据事件（对应<code>__writefds</code>集合）</li> <li>异常事件（对应<code>__exceptfds</code>集合）。</li></ul> <p>我们进一步可以看到，参数__readfds、__writefds 和 __exceptfds的类型是fd_set结构体，它主要定义部分如下所示。其中，<code>__fd_mask</code>类型是long int类型的别名，__FD_SETSIZE和__NFDBITS这两个宏定义的大小默认为1024和32。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
   …
   __fd_mask  __fds_bits<span class="token punctuation">[</span>__FD_SETSIZE <span class="token operator">/</span> __NFDBITS<span class="token punctuation">]</span><span class="token punctuation">;</span>
   …
<span class="token punctuation">}</span> fd_set
</code></pre></div><p>所以，fd_set结构体的定义，其实就是一个long int类型的数组，该数组中一共有32个元素（1024/32=32），每个元素是32位（long int类型的大小），而每一位可以用来表示一个文件描述符的状态。</p> <p>好了，了解了 fd_set 结构体的定义，我们就可以回答刚才提出的第二个问题了。<strong>select 函数对每一个描述符集合，都可以监听1024个描述符</strong>。</p> <p>接下来，我们再来了解下 <strong>如何使用select机制来实现网络通信</strong>。</p> <ol><li>首先，我们<strong>在调用select函数前，可以先创建好传递给select函数的描述符集合，然后再创建监听套接字</strong>。而为了让创建的监听套接字能被select函数监控，我们需要把这个套接字的描述符加入到创建好的描述符集合中。</li> <li>然后，我们就可以<strong>调用select函数，并把创建好的描述符集合作为参数传递给select函数</strong>。程序在调用select函数后，会发生<strong>阻塞</strong>。而当select函数检测到有描述符<strong>就绪</strong>后，就会<strong>结束阻塞</strong>，并返回就绪的文件描述符个数。</li> <li>此时，我们就可以在描述符集合中查找哪些描述符就绪了。然后，我们对已就绪描述符对应的套接字进行处理。比如，如果是__readfds 集合中有描述符就绪，这就表明这些就绪描述符对应的套接字上，有读事件发生，此时，我们就在该套接字上读取数据</li></ol> <p>而因为select函数一次可以监听1024个文件描述符的状态，所以select函数在返回时，也可能会一次返回多个就绪的文件描述符。这样一来，我们就可以使用一个循环流程，依次对就绪描述符对应的套接字进行读写或异常处理操作。</p> <p>我也画了张图，展示了使用select函数进行网络通信的基本流程，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151159828.png" alt="image-20240915115933746"></p> <p>下面的代码展示的是使用select函数，进行并发客户端处理的关键步骤和主要函数调用：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> sock_fd<span class="token punctuation">,</span>conn_fd<span class="token punctuation">;</span> <span class="token comment">//监听套接字和已连接套接字的变量</span>
sock_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//创建套接字</span>
<span class="token function">bind</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span>   <span class="token comment">//绑定套接字</span>
<span class="token function">listen</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span> <span class="token comment">//在套接字上进行监听，将套接字转为监听套接字</span>

fd_set rset<span class="token punctuation">;</span>  <span class="token comment">//被监听的描述符集合，关注描述符上的读事件</span>
 
<span class="token keyword">int</span> max_fd <span class="token operator">=</span> sock_fd

<span class="token comment">//初始化rset数组，使用FD_ZERO宏设置每个元素为0 </span>
<span class="token function">FD_ZERO</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//使用FD_SET宏设置rset数组中位置为sock_fd的文件描述符为1，表示需要监听该文件描述符</span>
<span class="token function">FD_SET</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//设置超时时间 </span>
<span class="token keyword">struct</span> <span class="token class-name">timeval</span> timeout<span class="token punctuation">;</span>
timeout<span class="token punctuation">.</span>tv_sec <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
timeout<span class="token punctuation">.</span>tv_usec <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
 
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">//调用select函数，检测rset数组保存的文件描述符是否已有读事件就绪，返回就绪的文件描述符个数</span>
   n <span class="token operator">=</span> <span class="token function">select</span><span class="token punctuation">(</span>max_fd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
 
   <span class="token comment">//调用FD_ISSET宏，在rset数组中检测sock_fd对应的文件描述符是否就绪</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//如果sock_fd已经就绪，表明已有客户端连接；调用accept函数建立连接</span>
       conn_fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token comment">//设置rset数组中位置为conn_fd的文件描述符为1，表示需要监听该文件描述符</span>
       <span class="token function">FD_SET</span><span class="token punctuation">(</span>conn_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token punctuation">}</span>

   <span class="token comment">//依次检查已连接套接字的文件描述符</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxfd<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">//调用FD_ISSET宏，在rset数组中检测文件描述符是否就绪</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">FD_ISSET</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token operator">&amp;</span>rset<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">//有数据可读，进行读数据处理</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>不过，你或许会发现select函数存在 <strong>两个设计上的不足</strong>：</p> <ul><li>select函数对单个进程能监听的文件描述符数量是<strong>有限制</strong>的，它能监听的文件描述符个数由__FD_SETSIZE决定，默认值是1024。</li> <li>当select函数返回后，我们需要<strong>遍历</strong>描述符集合，才能找到具体是哪些描述符就绪了。这个遍历过程会产生一定开销，从而降低程序的性能。</li></ul> <p>所以，为了解决select函数受限于1024个文件描述符的不足，poll函数对此做了改进</p> <h3 id="poll-机制-不受限的文件描述符数量"><a href="#poll-机制-不受限的文件描述符数量" class="header-anchor">#</a> poll 机制：不受限的文件描述符数量</h3> <p>poll机制的主要函数是poll函数，我们先来看下它的原型定义，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">poll</span> <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token operator">*</span>__fds<span class="token punctuation">,</span> <span class="token class-name">nfds_t</span> __nfds<span class="token punctuation">,</span> <span class="token keyword">int</span> __timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>其中，参数*__fds是pollfd结构体数组，参数__nfds表示的是*__fds数组的元素个数，而__timeout表示poll函数阻塞的超时时间。</p> <p>pollfd 结构体里包含了要监听的描述符，以及该描述符上要监听的事件类型。这个我们可以从pollfd结构体的定义中看出来，如下所示。pollfd 结构体中包含了三个成员变量fd、events和revents，分别表示要监听的文件描述符、要监听的事件类型和实际发生的事件类型。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">pollfd</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">;</span>         <span class="token comment">//进行监听的文件描述符</span>
    <span class="token keyword">short</span> <span class="token keyword">int</span> events<span class="token punctuation">;</span>       <span class="token comment">//要监听的事件类型</span>
    <span class="token keyword">short</span> <span class="token keyword">int</span> revents<span class="token punctuation">;</span>      <span class="token comment">//实际发生的事件类型</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>pollfd结构体中要监听和实际发生的事件类型，是通过以下三个宏定义来表示的，分别是POLLRDNORM、POLLWRNORM和POLLERR，它们分别表示可读、可写和错误事件。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLRDNORM</span>  <span class="token expression"><span class="token number">0x040</span>       </span><span class="token comment">//可读事件</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLWRNORM</span>  <span class="token expression"><span class="token number">0x100</span>       </span><span class="token comment">//可写事件</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">POLLERR</span>     <span class="token expression"><span class="token number">0x008</span>       </span><span class="token comment">//错误事件</span></span>
</code></pre></div><p>好了，了解了poll函数的参数后，我们来看下如何使用poll函数完成网络通信。这个流程主要可以分成三步：</p> <ol><li>创建pollfd数组和监听套接字，并进行绑定；</li> <li>将监听套接字加入pollfd数组，并设置其监听读事件，也就是客户端的连接请求；</li> <li>循环调用poll函数，检测pollfd数组中是否有就绪的文件描述符。</li></ol> <p>而在第三步的循环过程中，其处理逻辑又分成了两种情况：</p> <ul><li>如果是连接套接字就绪，这表明是有客户端连接，我们可以调用accept接受连接，并创建已连接套接字，并将其加入pollfd数组，并监听读事件；</li> <li>如果是已连接套接字就绪，这表明客户端有读写请求，我们可以调用recv/send函数处理读写请求。</li></ul> <p>我画了下面这张图，展示了使用poll函数的流程，你可以学习掌握下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151201716.png" alt="image-20240915120127664"></p> <p>另外，为了便于你掌握在代码中使用poll函数，我也写了一份示例代码，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> sock_fd<span class="token punctuation">,</span>conn_fd<span class="token punctuation">;</span> <span class="token comment">//监听套接字和已连接套接字的变量</span>
sock_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//创建套接字</span>
<span class="token function">bind</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span>   <span class="token comment">//绑定套接字</span>
<span class="token function">listen</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span> <span class="token comment">//在套接字上进行监听，将套接字转为监听套接字</span>

<span class="token comment">//poll函数可以监听的文件描述符数量，可以大于1024</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_OPEN</span> <span class="token expression"><span class="token operator">=</span> <span class="token number">2048</span></span></span>

<span class="token comment">//pollfd结构体数组，对应文件描述符</span>
<span class="token keyword">struct</span> <span class="token class-name">pollfd</span> client<span class="token punctuation">[</span>MAX_OPEN<span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">//将创建的监听套接字加入pollfd数组，并监听其可读事件</span>
client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> sock_fd<span class="token punctuation">;</span>
client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLRDNORM<span class="token punctuation">;</span> 
maxfd <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

<span class="token comment">//初始化client数组其他元素为-1</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_OPEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
    client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> 

<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">//调用poll函数，检测client数组里的文件描述符是否有就绪的，返回就绪的文件描述符个数</span>
   n <span class="token operator">=</span> <span class="token function">poll</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> maxfd<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment">//如果监听套件字的文件描述符有可读事件，则进行处理</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> POLLRDNORM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//有客户端连接；调用accept函数建立连接</span>
       conn_fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

       <span class="token comment">//保存已建立连接套接字</span>
       <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_OPEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
         <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
           client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>fd <span class="token operator">=</span> conn_fd<span class="token punctuation">;</span> <span class="token comment">//将已建立连接的文件描述符保存到client数组</span>
           client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>events <span class="token operator">=</span> POLLRDNORM<span class="token punctuation">;</span> <span class="token comment">//设置该文件描述符监听可读事件</span>
           <span class="token keyword">break</span><span class="token punctuation">;</span>
          <span class="token punctuation">}</span>
       <span class="token punctuation">}</span>
       maxfd <span class="token operator">=</span> i<span class="token punctuation">;</span> 
   <span class="token punctuation">}</span>
   
   <span class="token comment">//依次检查已连接套接字的文件描述符</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> MAX_OPEN<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>client<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>revents <span class="token operator">&amp;</span> <span class="token punctuation">(</span>POLLRDNORM <span class="token operator">|</span> POLLERR<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token comment">//有数据可读或发生错误，进行读数据处理或错误处理</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>其实，和select函数相比，poll函数的改进之处主要就在于，<strong>它允许一次监听超过1024个文件描述符</strong>。但是当调用了poll函数后，我们仍然需要遍历每个文件描述符，检测该描述符是否就绪，然后再进行处理。</p> <p>**那么，有没有办法可以避免遍历每个描述符呢？**这就是我接下来向你介绍的epoll机制</p> <h3 id="epoll-机制-避免遍历每个描述符"><a href="#epoll-机制-避免遍历每个描述符" class="header-anchor">#</a> epoll 机制：避免遍历每个描述符</h3> <p>首先，epoll机制是使用epoll_event结构体，来记录待监听的文件描述符及其监听的事件类型的，这和poll机制中使用pollfd结构体比较类似。</p> <p>那么，对于epoll_event结构体来说，其中包含了epoll_data_t联合体变量，以及整数类型的events变量。epoll_data_t联合体中有记录文件描述符的成员变量fd，而events变量会取值使用不同的宏定义值，来表示epoll_data_t变量中的文件描述符所关注的事件类型，比如一些常见的事件类型包括以下这几种。</p> <ul><li>EPOLLIN：读事件，表示文件描述符对应套接字有数据可读。</li> <li>EPOLLOUT：写事件，表示文件描述符对应套接字有数据要写。</li> <li>EPOLLERR：错误事件，表示文件描述符对于套接字出错。</li></ul> <p>下面的代码展示了epoll_event结构体以及epoll_data联合体的定义，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">union</span> epoll_data
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">int</span> fd<span class="token punctuation">;</span>  <span class="token comment">//记录文件描述符</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> <span class="token class-name">epoll_data_t</span><span class="token punctuation">;</span>


<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span>
<span class="token punctuation">{</span>
  <span class="token class-name">uint32_t</span> events<span class="token punctuation">;</span>  <span class="token comment">//epoll监听的事件类型</span>
  <span class="token class-name">epoll_data_t</span> data<span class="token punctuation">;</span> <span class="token comment">//应用程序数据</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>好了，现在我们知道，在使用select或poll函数的时候，创建好文件描述符集合或pollfd数组后，就可以往数组中添加我们需要监听的文件描述符。</p> <p>但是对于epoll机制来说，我们则需要先调用epoll_create函数，创建一个epoll实例。这个epoll实例内部维护了两个结构，分别是<strong>记录要监听的文件描述符</strong>和<strong>已经就绪的文件描述符</strong>，而对于已经就绪的文件描述符来说，它们会被返回给用户程序进行处理。</p> <p>所以，我们在使用epoll机制时，就不用像使用select和poll一样，遍历查询哪些文件描述符已经就绪了。这样一来， epoll的效率就比select和poll有了更高的提升。</p> <p>在创建了epoll实例后，我们需要再使用epoll_ctl函数，给被监听的文件描述符添加监听事件类型，以及使用epoll_wait函数获取就绪的文件描述符。</p> <p>我画了一张图，展示了使用epoll进行网络通信的流程，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151202271.png" alt="image-20240915120259208"></p> <p>下面的代码展示了使用epoll函数的流程，你也可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> sock_fd<span class="token punctuation">,</span>conn_fd<span class="token punctuation">;</span> <span class="token comment">//监听套接字和已连接套接字的变量</span>
sock_fd <span class="token operator">=</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//创建套接字</span>
<span class="token function">bind</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span>   <span class="token comment">//绑定套接字</span>
<span class="token function">listen</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span> <span class="token comment">//在套接字上进行监听，将套接字转为监听套接字</span>
    
epfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span>EPOLL_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//创建epoll实例，</span>
<span class="token comment">//创建epoll_event结构体数组，保存套接字对应文件描述符和监听事件类型    </span>
ep_events <span class="token operator">=</span> <span class="token punctuation">(</span>epoll_event<span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>epoll_event<span class="token punctuation">)</span> <span class="token operator">*</span> EPOLL_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//创建epoll_event变量</span>
<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> ee
<span class="token comment">//监听读事件</span>
ee<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN<span class="token punctuation">;</span>
<span class="token comment">//监听的文件描述符是刚创建的监听套接字</span>
ee<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> sock_fd<span class="token punctuation">;</span>

<span class="token comment">//将监听套接字加入到监听列表中    </span>
<span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> sock_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ee<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">//等待返回已经就绪的描述符 </span>
   n <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> ep_events<span class="token punctuation">,</span> EPOLL_SIZE<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
   <span class="token comment">//遍历所有就绪的描述符     </span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token comment">//如果是监听套接字描述符就绪，表明有一个新客户端连接到来 </span>
       <span class="token keyword">if</span> <span class="token punctuation">(</span>ep_events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">==</span> sock_fd<span class="token punctuation">)</span> <span class="token punctuation">{</span> 
          conn_fd <span class="token operator">=</span> <span class="token function">accept</span><span class="token punctuation">(</span>sock_fd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用accept()建立连接</span>
          ee<span class="token punctuation">.</span>events <span class="token operator">=</span> EPOLLIN<span class="token punctuation">;</span>  
          ee<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> conn_fd<span class="token punctuation">;</span>
          <span class="token comment">//添加对新创建的已连接套接字描述符的监听，监听后续在已连接套接字上的读事件      </span>
          <span class="token function">epoll_ctl</span><span class="token punctuation">(</span>epfd<span class="token punctuation">,</span> EPOLL_CTL_ADD<span class="token punctuation">,</span> conn_fd<span class="token punctuation">,</span> <span class="token operator">&amp;</span>ee<span class="token punctuation">)</span><span class="token punctuation">;</span> 
                
       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">//如果是已连接套接字描述符就绪，则可以读数据</span>
           <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">//读取数据并处理</span>
       <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好了，到这里，你就了解了 epoll 函数的使用方法了。实际上，也正是因为 epoll 能自定义监听的描述符数量，以及可以直接返回就绪的描述符，Redis 在设计和实现网络通信框架时，就基于 epoll 机制中的 epoll_create、epoll_ctl 和 epoll_wait 等函数和读写事件，进行了封装开发，实现了用于网络通信的事件驱动框架，从而使得Redis虽然是单线程运行，但是仍然能高效应对高并发的客户端访问。</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <p>echo 给你介绍了Redis网络通信依赖的操作系统底层机制，也就是IO多路复用机制</p> <p>由于Redis是单线程程序，如果使用基本的 Socket 编程模型的话，只能对一个监听套接字或一个已连接套接字进行监听。而当Redis实例面临很多并发的客户端时，这种处理方式的效率就会很低。</p> <p>所以，和基本的Socket通信相比，使用IO多路复用机制，就可以一次性获得就绪的多个套接字，从而避免了逐个检测套接字的开销。</p> <p>这节课，我是以最常用的Linux操作系统为例，给你具体介绍了Linux系统提供的三种IO多路复用机制，分别是select、poll和epoll。这三种机制在能监听的描述符数量和查找就绪描述符的方法上是不一样的</p> <table><thead><tr><th>多路复用机制</th> <th>监听的文件描述符数量</th> <th>查找就绪的文件描述符</th></tr></thead> <tbody><tr><td>select</td> <td>最多1024</td> <td>遍历所有描述符</td></tr> <tr><td>poll</td> <td>不受限</td> <td>遍历所有描述符</td></tr> <tr><td>epoll</td> <td>与使用</td> <td>epoll_wait自动返回就绪的描述符，未就绪的描述符不返回</td></tr></tbody></table> <h2 id="redis-的-reactor-模型"><a href="#redis-的-reactor-模型" class="header-anchor">#</a> Redis 的 Reactor 模型</h2> <p><strong>Redis的网络框架是实现了Reactor模型吗？</strong></p> <p>建议分为两部分来回答：</p> <ul><li>介绍Reactor模型是什么</li> <li>说明Redis代码实现是如何与Reactor模型相对应的</li></ul> <p>Reactor 模型是高性能网络系统实现高并发请求处理的一个重要技术方案。掌握Reactor模型的设计思想与实现方法，可以指导你设计和实现自己的高并发系统。当你要处理成千上万的网络连接时，就不会一筹莫展了。</p> <h3 id="reactor-模型的工作机制"><a href="#reactor-模型的工作机制" class="header-anchor">#</a> Reactor 模型的工作机制</h3> <p>实际上，<strong>Reactor模型就是网络服务器端用来处理高并发网络IO请求的一种编程模型</strong>。我把这个模型的特征用两个“三”来总结，也就是：</p> <ul><li>三类处理事件 连接事件、写事件、读事件；</li> <li>三个关键角色，即 reactor、acceptor、handler。</li></ul> <p>那么，Reactor模型是如何基于这三类事件和三个角色来处理高并发请求的呢？下面我们就来具体了解下。</p> <h4 id="事件类型"><a href="#事件类型" class="header-anchor">#</a> 事件类型</h4> <p>我们先来看看这三类事件和Reactor模型的关系。</p> <p>其实，Reactor 模型处理的是客户端和服务器端的<strong>交互过程</strong>，而这三类事件正好对应了客户端和服务器端交互过程中，不同类请求在服务器端引发的待处理事件：</p> <ul><li>连接事件
<ul><li>当一个客户端要和服务器端进行交互时，客户端会向服务器端发送连接请求，以建立连接，这就对应了服务器端的一个<strong>连接事件</strong></li></ul></li> <li>写事件
<ul><li>一旦连接建立后，客户端会给服务器端发送读请求，以便读取数据。服务器端在处理读请求时，需要向客户端写回数据，这对应了服务器端的<strong>写事件</strong></li></ul></li> <li>读事件
<ul><li>无论客户端给服务器端发送读或写请求，服务器端都需要从客户端读取请求内容，所以在这里，读或写请求的读取就对应了服务器端的<strong>读事件</strong></li></ul></li></ul> <p>如下所示的图例中，就展示了客户端和服务器端在交互过程中，不同类请求和Reactor模型事件的对应关系，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151209488.png" alt="image-20240915120925427"></p> <p>好，在了解了Reactor模型的三类事件后，你现在可能还有一个疑问：这三类事件是由谁来处理的呢？</p> <h4 id="关键角色"><a href="#关键角色" class="header-anchor">#</a> 关键角色</h4> <p>这其实就是模型中<strong>三个关键角色</strong>的作用了：</p> <ul><li>acceptor ：连接事件由 acceptor 来处理，负责接收连接；acceptor 在接收连接后，会创建 handler，用于网络连接上对后续读写事件的处理；</li> <li>handler：读写事件由 handler 处理；</li> <li>reactor：在高并发场景中，连接事件、读写事件会同时发生，所以，我们需要有一个角色专门监听和分配事件，这就是 reactor 角色。当有连接请求时，reactor 将产生的连接事件交由 acceptor 处理；当有读写请求时，reactor 将读写事件交由 handler 处理。</li></ul> <p>下图就展示了这三个角色之间的关系，以及它们和事件的关系，你可以看下</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151209413.png" alt="image-20240915120823439"></p> <p>事实上，这三个角色都是Reactor模型中要实现的功能的抽象。</p> <p><strong>当我们遵循Reactor模型开发服务器端的网络框架时，就需要在编程的时候，在代码功能模块中实现reactor、acceptor和handler 的逻辑</strong></p> <p>那么，现在我们已经知道，这三个角色是围绕事件的监听、转发和处理来进行交互的，那么在编程时，我们又该如何实现这三者的<strong>交互</strong>呢？这就离不开 <strong>事件驱动框架</strong>了</p> <h4 id="事件驱动框架"><a href="#事件驱动框架" class="header-anchor">#</a> 事件驱动框架</h4> <p>所谓的事件驱动框架，就是在实现 Reactor 模型时，需要实现的代码整体控制逻辑。</p> <p>简单来说，事件驱动框架包括了两部分</p> <ul><li>一是<strong>事件初始化</strong></li> <li>二是<strong>事件捕获、分发和处理主循环</strong>。</li></ul> <p>事件初始化是在服务器程序启动时就执行的，它的作用主要是 <strong>创建需要监听的事件类型，以及该类事件对应的handler</strong>。</p> <p>而一旦服务器完成初始化后，事件初始化也就相应完成了，服务器程序就需要进入到事件捕获、分发和处理的主循环中。</p> <p>在开发代码时，我们通常会用一个<strong>while循环</strong>来作为这个主循环。</p> <p>然后在这个主循环中，我们需要</p> <ol><li>捕获发生的事件</li> <li>判断事件类型</li> <li>根据事件类型，调用在初始化时创建好的事件handler来实际处理事件</li></ol> <p>比如说，当有连接事件发生时，服务器程序需要调用acceptor处理函数，创建和客户端的连接。而当有读事件发生时，就表明有读或写请求发送到了服务器端，服务器程序就要调用具体的请求处理函数，从客户端连接中读取请求内容，进而就完成了读事件的处理。这里你可以参考下面给出的图例，其中显示了事件驱动框架的基本执行过程：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151210395.png" alt="image-20240915121009334"></p> <p>那么到这里，你应该就已经了解了<strong>Reactor模型的基本工作机制</strong>：客户端的不同类请求会在服务器端触发连接、读、写三类事件，这三类事件的监听、分发和处理又是由reactor、acceptor、handler三类角色来完成的，然后这三类角色会通过事件驱动框架来实现交互和事件处理。</p> <p>所以可见，实现一个Reactor模型的<strong>关键</strong>，就是要实现事件驱动框架。那么，如何开发实现一个事件驱动框架呢？</p> <p>Redis 提供了一个简洁但有效的参考实现，非常值得我们学习，而且也可以用于自己的网络系统开发。下面，我们就一起来学习下Redis中对 Reactor 模型的实现。</p> <h3 id="redis对reactor模型的实现"><a href="#redis对reactor模型的实现" class="header-anchor">#</a> Redis对Reactor模型的实现</h3> <p>首先我们要知道的是，Redis 的网络框架实现了 Reactor 模型，并且自行开发实现了一个事件驱动框架。这个框架对应的Redis代码实现文件是<a href="https://github.com/redis/redis/blob/5.0/src/ae.c" target="_blank" rel="noopener noreferrer">ae.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，对应的头文件是<a href="https://github.com/redis/redis/blob/5.0/src/ae.h" target="_blank" rel="noopener noreferrer">ae.h<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p>前面我们已经知道，事件驱动框架的实现离不开事件的定义，以及事件注册、捕获、分发和处理等一系列操作。当然，对于整个框架来说，还需要能一直运行，持续地响应发生的事件。</p> <p>那么由此，我们从ae.h头文件中就可以看到，Redis为了实现事件驱动框架，相应地定义了</p> <ul><li><strong>事件的数据结构</strong></li> <li><strong>框架主循环函数</strong></li> <li><strong>事件捕获分发函数</strong></li> <li><strong>事件</strong></li> <li><strong>handler注册函数</strong></li></ul> <p>所以接下来，我们就依次来了解学习下。</p> <h4 id="事件的数据结构定义-以aefileevent为例"><a href="#事件的数据结构定义-以aefileevent为例" class="header-anchor">#</a> 事件的数据结构定义：以aeFileEvent为例</h4> <p>首先，我们要明确一点，就是在Redis事件驱动框架的实现当中，<strong>事件的数据结构是关联事件类型和事件处理函数的关键要素</strong>。而Redis的事件驱动框架定义了两类事件：</p> <ul><li><strong>IO事件</strong>：对应 客户端发送的 网络请求</li> <li><strong>时间事件</strong>：对应 Redis 自身的周期性操作</li></ul> <p>这也就是说，<strong>不同类型事件的数据结构定义是不一样的</strong>。不过，当前我们主要关注的是事件框架的整体设计与实现，所以对于不同类型事件的差异和具体处理，echo 后面再介绍。</p> <p>那么为了让你能够理解事件数据结构对框架的作用，我就以 IO 事件aeFileEvent为例，给你介绍下它的数据结构定义</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeFileEvent</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> mask<span class="token punctuation">;</span> <span class="token comment">/* one of AE_(READABLE|WRITABLE|BARRIER) */</span>
    aeFileProc <span class="token operator">*</span>rfileProc<span class="token punctuation">;</span>
    aeFileProc <span class="token operator">*</span>wfileProc<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span>
<span class="token punctuation">}</span> aeFileEvent<span class="token punctuation">;</span>
</code></pre></div><ul><li><strong>mask <strong>是用来</strong>表示事件类型</strong>的掩码。对于网络通信的事件来说，主要有 AE_READABLE、AE_WRITABLE 和 AE_BARRIER 三种类型事件。框架在分发事件时，依赖的就是结构体中的事件类型；</li> <li><strong>rfileProc 和 wfileProce</strong> 分别是指向AE_READABLE和AE_WRITABLE这两类事件的<strong>处理函数</strong>，也就是Reactor模型中的handler。框架在分发事件后，就需要调用结构体中定义的函数进行事件处理</li> <li>最后一个成员变量 <strong>clientData</strong> 是用来指向客户端私有数据的指针</li></ul> <p>除了事件的数据结构以外，前面我还提到 Redis 在 ae.h 文件中，定义了支撑框架运行的主要函数，包括框架主循环的aeMain函数、负责事件捕获与分发的 aeProcessEvents 函数，以及负责事件和 handler 注册的 aeCreateFileEvent 函数，它们的原型定义如下</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span> aeFileProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>而这三个函数的实现，都是在对应的 ae.c 文件中，那么接下来，我就给你具体介绍下这三个函数的主体逻辑和关键流程</p> <h4 id="主循环-aemain-函数"><a href="#主循环-aemain-函数" class="header-anchor">#</a> 主循环：aeMain 函数</h4> <p>我们先来看下 aeMain 函数。</p> <p>aeMain 函数的逻辑很简单，就是<strong>用一个循环不停地判断事件循环的停止标记</strong>。如果事件循环的停止标记被设置为true，那么针对事件捕获、分发和处理的整个主循环就停止了；否则，主循环会一直执行。aeMain 函数的主体代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    eventLoop<span class="token operator">-&gt;</span>stop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>eventLoop<span class="token operator">-&gt;</span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        …
        <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> AE_ALL_EVENTS<span class="token operator">|</span>AE_CALL_AFTER_SLEEP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么这里你可能要问了，<strong>aeMain 函数是在哪里被调用的呢？</strong></p> <p>按照事件驱动框架的编程规范来说，<strong>框架主循环是在服务器程序初始化完成后，就会开始执行</strong>。因此，如果我们把目光转向 Redis 服务器初始化的函数，就会发现服务器程序的 main 函数在完成 Redis server 的初始化后，会调用 aeMain 函数开始执行事件驱动框架。如果你想具体查看main函数，main函数在<a href="https://github.com/redis/redis/blob/5.0/src/server.c" target="_blank" rel="noopener noreferrer">server.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文件中，我们在<a href="https://time.geekbang.org/column/article/406556" target="_blank" rel="noopener noreferrer">第8讲<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中介绍过该文件，server.c主要用于初始化服务器和执行服务器整体控制流程，你可以回顾下。</p> <p>不过，既然aeMain函数包含了事件框架的主循环，**那么在主循环中，事件又是如何被捕获、分发和处理呢？**这就是由aeProcessEvents函数来完成的了。</p> <h4 id="事件捕获与分发-aeprocessevents-函数"><a href="#事件捕获与分发-aeprocessevents-函数" class="header-anchor">#</a> 事件捕获与分发：aeProcessEvents 函数</h4> <p>aeProcessEvents 函数实现的主要功能，包括</p> <ul><li>捕获事件</li> <li>判断事件类型</li> <li>调用具体的事件处理函数，从而实现事件的处理</li></ul> <p>从 aeProcessEvents 函数的主体结构中，我们可以看到主要有三个 if 条件分支，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> numevents<span class="token punctuation">;</span>
 
    <span class="token comment">/* 若没有事件处理，则立刻返回*/</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_FILE_EVENTS<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    
    <span class="token comment">/*如果有IO事件发生，或者紧急的时间事件发生，则开始处理*/</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       …
    <span class="token punctuation">}</span>
    
    <span class="token comment">/* 检查是否有时间事件，若有，则调用processTimeEvents函数处理 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span>
        processed <span class="token operator">+=</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">/* 返回已经处理的文件或时间*/</span>
    <span class="token keyword">return</span> processed<span class="token punctuation">;</span> 
<span class="token punctuation">}</span>
</code></pre></div><p>这三个分支分别对应了以下三种情况：</p> <ul><li>情况一：既没有时间事件，也没有网络事件；</li> <li>情况二：有IO事件或者有需要紧急处理的时间事件；</li> <li>情况三：只有普通的时间事件。</li></ul> <p>那么对于第一种情况来说，因为没有任何事件需要处理，aeProcessEvents函数就会直接返回到aeMain的主循环，开始下一轮的循环；而对于第三种情况来说，该情况发生时只有普通时间事件发生，所以aeMain函数会调用专门处理时间事件的函数processTimeEvents，对时间事件进行处理。</p> <p>现在，我们再来看看第二种情况。</p> <p>首先，当该情况发生时，Redis需要捕获发生的网络事件，并进行相应的处理。那么从Redis源码中我们可以分析得到，在这种情况下，<strong>aeApiPoll 函数会被调用，用来捕获事件</strong>，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>maxfd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_DONT_WAIT<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
       <span class="token comment">//调用 aeApiPoll 函数捕获事件</span>
       numevents <span class="token operator">=</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> tvp<span class="token punctuation">)</span><span class="token punctuation">;</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
」
</code></pre></div><p><strong>那么，aeApiPoll是如何捕获事件呢？</strong></p> <p>实际上，Redis是依赖于操作系统底层提供的 <strong>IO多路复用机制</strong>，来实现事件捕获，检查是否有新的连接、读写事件发生。为了适配不同的操作系统，Redis对不同操作系统实现的网络IO多路复用函数，都进行了统一的封装，封装后的代码分别通过以下四个文件中实现：</p> <ul><li>ae_epoll.c，对应Linux上的IO复用函数epoll；</li> <li>ae_evport.c，对应Solaris上的IO复用函数evport；</li> <li>ae_kqueue.c，对应macOS或FreeBSD上的IO复用函数kqueue；</li> <li>ae_select.c，对应Linux（或Windows）的IO复用函数select。</li></ul> <p>这样，在有了这些封装代码后，Redis在不同的操作系统上调用IO多路复用API时，就可以通过统一的接口来进行调用了。</p> <p>不过看到这里，你可能还是不太明白Redis封装的具体操作，所以这里，我就以在服务器端最常用的Linux操作系统为例，给你介绍下Redis是如何封装Linux上提供的IO复用API的。</p> <p>首先，Linux上提供了<strong>epoll_wait API</strong>，用于检测内核中发生的网络IO事件。在<a href="https://github.com/redis/redis/blob/5.0/src/ae_epoll.c" target="_blank" rel="noopener noreferrer">ae_epoll.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文件中，<strong>aeApiPoll函数</strong>就是封装了对epoll_wait的调用。</p> <p>这个封装程序如下所示，其中你可以看到，在aeApiPoll函数中直接调用了epoll_wait函数，并将epoll返回的事件信息保存起来的逻辑：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">timeval</span> <span class="token operator">*</span>tvp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
    <span class="token comment">//调用epoll_wait获取监听到的事件</span>
    retval <span class="token operator">=</span> <span class="token function">epoll_wait</span><span class="token punctuation">(</span>state<span class="token operator">-&gt;</span>epfd<span class="token punctuation">,</span>state<span class="token operator">-&gt;</span>events<span class="token punctuation">,</span>eventLoop<span class="token operator">-&gt;</span>setsize<span class="token punctuation">,</span>
            tvp <span class="token operator">?</span> <span class="token punctuation">(</span>tvp<span class="token operator">-&gt;</span>tv_sec<span class="token operator">*</span><span class="token number">1000</span> <span class="token operator">+</span> tvp<span class="token operator">-&gt;</span>tv_usec<span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>retval <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">int</span> j<span class="token punctuation">;</span>
        <span class="token comment">//获得监听到的事件数量</span>
        numevents <span class="token operator">=</span> retval<span class="token punctuation">;</span>
        <span class="token comment">//针对每一个事件，进行处理</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numevents<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
             #保存事件信息
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> numevents<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为了让你更加清晰地理解，事件驱动框架是如何实现最终对epoll_wait的调用，这里我也放了一张示意图，你可以看看整个调用链是如何工作和实现的。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151446771.png" alt="image-20240915144649696"></p> <p>OK，现在我们就已经在 aeMain 函数中，看到了 aeProcessEvents 函数被调用，并用于捕获和分发事件的基本处理逻辑。</p> <p>**那么，事件具体是由哪个函数来处理的呢？**这就和框架中的 aeCreateFileEvents 函数有关了。</p> <h4 id="事件注册-aecreatefileevent-函数"><a href="#事件注册-aecreatefileevent-函数" class="header-anchor">#</a> 事件注册：aeCreateFileEvent 函数</h4> <p>我们知道，当Redis启动后，服务器程序的 main 函数会调用 initSever 函数来进行初始化，而在初始化的过程中，aeCreateFileEvent 就会被 initServer 函数调用，用于注册要监听的事件，以及相应的事件处理函数。</p> <p>具体来说，在 initServer 函数的执行过程中，initServer 函数会根据启用的IP端口个数，为每个 IP 端口上的网络事件，调用aeCreateFileEvent，创建对 AE_READABLE 事件的监听，并且注册 AE_READABLE 事件的处理 handler，也就是 acceptTcpHandler 函数。这一过程如下图所示：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151448913.png" alt="image-20240915144801833"></p> <p>所以这里我们可以看到，<strong>AE_READABLE 事件就是客户端的网络连接事件，而对应的处理函数就是接收TCP连接请求</strong>。下面的示例代码中，显示了initServer中调用aeCreateFileEvent的部分片段，你可以看下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">initServer</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>ipfd_count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> server<span class="token punctuation">.</span>ipfd<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> AE_READABLE<span class="token punctuation">,</span>
            acceptTcpHandler<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span>
            <span class="token punctuation">{</span>
                <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">&quot;Unrecoverable error creating server.ipfd file event.&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
	<span class="token punctuation">}</span>
	…
<span class="token punctuation">}</span>
</code></pre></div><p>**那么，aeCreateFileEvent 如何实现事件和处理函数的注册呢？ **这就和刚才我介绍的Redis对底层IO多路复用函数封装有关了，下面我仍然以Linux系统为例，来给你说明一下。</p> <p>首先，Linux提供了<strong>epoll_ctl API</strong>，用于增加新的观察事件。而 Redis 在此基础上，封装了 aeApiAddEvent 函数，对epoll_ctl进行调用。</p> <p>所以这样一来，aeCreateFileEvent 就会调用aeApiAddEvent，然后 aeApiAddEvent 再通过调用 epoll_ctl，来注册希望监听的事件和相应的处理函数。等到 aeProceeEvents 函数捕获到实际事件时，它就会调用注册的函数对事件进行处理了。</p> <p>好了，到这里，我们就已经全部了解了Redis中实现事件驱动框架的三个关键函数：aeMain、aeProcessEvents，以及aeCreateFileEvent。当你要去实现一个事件驱动框架时，Redis的设计思想就具有很好的参考意义。</p> <p>最后我再带你来简单地回顾下，在实现事件驱动框架的时候，你需要先实现一个主循环函数（对应aeMain），负责一直运行框架。其次，你需要编写事件注册函数（对应aeCreateFileEvent），用来注册监听的事件和事件对应的处理函数。<strong>只有对事件和处理函数进行了注册，才能在事件发生时调用相应的函数进行处理。</strong></p> <p>最后，你需要编写事件监听、分发函数（对应aeProcessEvents），负责调用操作系统底层函数来捕获网络连接、读、写事件，并分发给不同处理函数进一步处理。</p> <h3 id="总结-2"><a href="#总结-2" class="header-anchor">#</a> 总结</h3> <p>Redis一直被称为单线程架构，按照我们通常的理解，单个线程只能处理单个客户端的请求，但是在实际使用时，我们会看到Redis能同时和成百上千个客户端进行交互，这就是因为Redis基于Reactor模型，实现了高性能的网络框架，<strong>通过事件驱动框架，Redis可以使用一个循环来不断捕获、分发和处理客户端产生的网络连接、数据读写事件。</strong></p> <p>为了方便你从代码层面掌握Redis事件驱动框架的实现，我总结了一个表格，其中列出了Redis事件驱动框架的主要函数和功能、它们所属的C文件，以及这些函数本身是在Redis代码结构中的哪里被调用。你可以使用这张表格，来巩固今天这节课学习的事件驱动框架。</p> <p>我也再强调下，这节课我们主要关注的是，事件驱动框架的基本运行流程，并以客户端连接事件为例，将框架主循环、事件捕获分发和事件注册的关键步骤串起来，给你做了介绍。Redis事件驱动框架监听处理的事件，还包括客户端请求、服务器端写数据以及周期性操作等，这也是我下一节课要和你一起学习的主要内容。</p> <h2 id="redis-中的事件"><a href="#redis-中的事件" class="header-anchor">#</a> Redis 中的事件</h2> <p>前置知识</p> <ul><li>Linux 提供的三种 IO 多路复用机制</li> <li>Redis 事件驱动框架的基本工作机制</li></ul> <p>到这里，你或许仍然存有一些疑问，比如说：</p> <ul><li>Redis 事件驱动框架监听的 IO 事件，除了上节课介绍的客户端连接以外，还有没有其他事件？而除了IO事件以外，框架还会监听其他事件么</li> <li>这些事件的创建和处理又分别对应了Redis源码中的哪些具体操作？</li></ul> <p>稍等片刻，echo 来给你介绍下Redis事件驱动框架中的两大类事件类型：<strong>IO事件 和 时间事件，以及它们相应的处理机制。</strong></p> <p>请先问自己几个问题：</p> <ul><li><strong>Redis 事件驱动框架是如何以事件形式，处理 server 运行过程中面临的请求操作和多种任务的</strong>。
<ul><li>正常的客户端读写请求是以什么事件、由哪个函数进行处理</li> <li>后台快照任务又是如何及时启动的</li></ul></li> <li><strong>如何在一个框架中，同时处理 IO事件 和 时间事件</strong>。</li></ul> <p>因为事件驱动框架是 Redis server 运行后的核心循环流程，了解它何时用什么函数处理哪种事件，对我们排查server运行过程中遇到的问题，是很有帮助的</p> <p>然后我们平时开发服务器端程序，经常需要处理周期性任务，而Redis关于两类事件的处理实现，就给了我们一个不错的参考</p> <h3 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h3> <ul><li><p>文件事件(file event)：Redis 服务器通过套接字与客户端(或者其他Redis服务器)进行连接，而文件事件就是服务器对套接字操作的抽象。服务器与客户端(或者其他服务器)的通信会产生相应的文件事件，而服务器则通过监听并处理这些事件来完成一系列网络通信操作。</p></li> <li><p>时间事件(time event)：Redis 服务器中的一些操作(比如servercron函数)需要在给定的时间点执行，而时间事件就是服务器对这类定时操作的抽象。</p></li></ul> <h4 id="文件事件处理器"><a href="#文件事件处理器" class="header-anchor">#</a> 文件事件处理器</h4> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151551218.png" alt="image-20240915155140145"></p> <p>文件事件处理器有四个组成部分：</p> <ul><li><strong>套接字</strong>：文件事件是对套接字操作的抽象，每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件</li> <li><strong>IO 多路复用</strong>：IO 多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。</li> <li><strong>文件事件分派器</strong>：尽管多个文件事件可能会并发地出现，但IO多路复用程序总是会将所有产生事件的套接字都放到<strong>一个队列</strong>里面，然后通过这个队列，以有序(sequentially)、同步(synchronously)、每次一个套接字的方式向文件事件分派器传送套接字。当上一个套接字产生的事件被处理完毕之后(该套接字为事件所关联的事件处理器执行完毕)，I/O多路复用程序才会继续向文件事件分派器传送下一个套接字</li> <li><strong>事件处理器</strong>：文件事件分派器接收I/O多路复用程序传来的套接字，并根据套接字产生的事件的类调用相应的事件处理器。服务器会为执行不同任务的套接字关联不同的事件处理器，这些处理器是一个个函数它们定义了某个事件发生时，服务器应该执行的动作</li></ul> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151556794.png" alt="image-20240915155600717"></p> <h4 id="时间事件处理器"><a href="#时间事件处理器" class="header-anchor">#</a> 时间事件处理器</h4> <p>时间事件分为两类：</p> <ul><li>定时事件：让一段程序在指定的时间之后执行一次。比如说，让程序 X 在当前时间的 30 毫秒之后执行一次。</li> <li>周期性事件：让一段程序每隔指定时间就执行一次。比如说，让程序 Y 每隔30毫秒就执行一次。</li></ul> <p>一个时间事件主要由以下三个属性组成</p> <ul><li>id：服务器为时间事件创建的全局唯一ID(标识号)。ID号按从小到大的顺序递增新事件的ID号比旧事件的ID号要大。</li> <li>when：毫秒精度的 UNIX时间戳，记录了时间事件的到达(arrive)时间。</li> <li>timeProc：时间事件处理器，一个函数。当时间事件到达时，服务器就会调用相应的处理器来处理事件。</li></ul> <blockquote><p>一个时间事件是定时事件还是周期性事件取决于时间事件处理器的返回值:如果事件处理器返回ae.h/AENOMORE，那么这个事件为定时事件:该事件在达到一次之后就会被删除，之后不再到达。如果事件处理器返回一个非AENOMORE的整数值，那么这个事件为周期性时间:当一个时间事件到达之后，服务器会根据事件处理器返回的值，对时间事件的when属性进行更新，让这个事件在一段时间之后再次到达，并以这种方式一直更新并运行下去。</p></blockquote> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151603657.png" alt="image-20240915160321589"></p> <p>redis中的所有时间事件都放在一个无序链表中，服务器将所有时间事件都放在一个无序链表中，每当时间事件执行器运行时，它就遍历整个链表，查找所有已到达的时间事件，并调用相应的事件处理器。</p> <blockquote><p>注意，我们说保存时间事件的链表为无序链表，指的不是链表不按ID排序，而是说该链表不按 when属性的大小排序。正因为链表没有按when属性进行排序，所以当时间事件执行器运行的时候，它必须遍历链表中的所有时间事件，这样才能确保服务器中所有已到达的时间事件都会被处理。</p></blockquote> <p>正常模式下的Redis服务器只使用 serverCron 一个时间事件，而在 benchmark 模式下，服务器也只使用两个时间事件。在这种情况下，服务器几乎是将无序链表退化成一个指针来使用，<strong>所以使用无序链表来保存时间事件，并不影响事件执行的性能。</strong></p> <blockquote><p>serverCron</p> <p>持续运行的Redis服务器需要定期对自身的资源和状态进行检查和调整，从而确保服务器可以长期、稳定地运行，这些定期操作由redis.c/serverCron函数负责执行，它的主要工作包括:</p> <ul><li>更新服务器的各类统计信息，比如时间、内存占用、数据库占用情况等。</li> <li>清理数据库中的过期键值对。关闭和清理连接失效的客户端。</li> <li>尝试进行 AOF或RDB持久化操作。</li> <li>如果服务器是主服务器，那么对从服务器进行定期同步。</li> <li>如果处于集群模式，对集群进行定期同步和连接测试。</li></ul></blockquote> <h4 id="核心源码的伪码-自顶向下"><a href="#核心源码的伪码-自顶向下" class="header-anchor">#</a> 核心源码的伪码（自顶向下）</h4> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151620132.png" alt="image-20240915162014063"></p> <div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment">#初始化服务器</span>
    init server<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">#一直处理事件，直到服务器关闭为止</span>
    <span class="token keyword">while</span> server_is_not_shutdown<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    	aeProcessEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token comment">#服务器关闭，执行清理操作</span>
    clean server<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
    <span class="token comment">#获取到达时间离当前时间最接近的时间事件</span>
    time_event<span class="token operator">=</span>aeSearchNearestTimer<span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token comment">#计算最接近的时间事件距离到达还有多少毫秒</span>
    remaind_ms<span class="token operator">=</span>time_event<span class="token punctuation">.</span>when <span class="token operator">-</span> unix_ts_now<span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token comment">#如果事件已到达，那么remaind ms的值可能为负数，将它设定为0</span>
    <span class="token keyword">if</span> remaind_ms <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
    	remaind_ms <span class="token operator">=</span> <span class="token number">0</span>
    
    <span class="token comment">#根据remaind_ms的值，创建timeval结构</span>
    timeval<span class="token operator">=</span>create_timeval_with_ms<span class="token punctuation">(</span>remaind_ms<span class="token punctuation">)</span>
    
    <span class="token comment">#阻塞并等待文件事件产生，最大阻塞时间由传入的timeval结构决定#如果remaind_ms的值为0，那么aeApiPo1l调用之后马上返回，不阻塞</span>
    aeApiPoll<span class="token punctuation">(</span>timeval<span class="token punctuation">)</span>

    <span class="token comment">#处理所有已产生的文件事件</span>
    processFileEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
    
    <span class="token comment">#处理所有已到达的时间事件</span>
    processTimeEvents<span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-python extra-class"><pre class="language-python"><code><span class="token keyword">def</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token comment">#遍历服务器中的所有时间事件</span>
	<span class="token keyword">for</span> time_event <span class="token keyword">in</span> all_time_event<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
	<span class="token comment">#检查事件是否已经到达</span>
		<span class="token keyword">if</span> time_event<span class="token punctuation">.</span>when <span class="token operator">&lt;=</span> unix_ts_now<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
			<span class="token comment">#事件已到达</span>
			<span class="token comment">#执行事件处理器，并获取返回值</span>
			retval<span class="token operator">=</span>time_event<span class="token punctuation">.</span>timeProc<span class="token punctuation">(</span><span class="token punctuation">)</span>
			<span class="token comment">#如果这是一个定时事件</span>
			<span class="token keyword">if</span> retval<span class="token operator">==</span>AE_NOMORE<span class="token punctuation">:</span>
				<span class="token comment">#那么将该事件从服务器中删除</span>
				delete_time_event_from_server<span class="token punctuation">(</span>time event<span class="token punctuation">)</span>
			<span class="token comment">#如果这是一个周期性事件</span>
			<span class="token keyword">else</span><span class="token punctuation">:</span>
            <span class="token comment">#那么按照事件处理器的返回值更新时间事件的when 属性</span>
            <span class="token comment">#让这个事件在指定的时间之后再次到达</span>
            	update_when<span class="token punctuation">(</span>time_event<span class="token punctuation">,</span>retval<span class="token punctuation">)</span>
</code></pre></div><h3 id="事件驱动框架循环流程的数据结构及其初始化"><a href="#事件驱动框架循环流程的数据结构及其初始化" class="header-anchor">#</a> 事件驱动框架循环流程的数据结构及其初始化</h3> <p>为了对这两类事件有个相对全面的了解，接下来，我们先从事件驱动框架循环流程的数据结构及其初始化开始学起，因为这里面就包含了针对这两类事件的数据结构定义和初始化操作。</p> <h4 id="aeeventloop-结构体与初始化"><a href="#aeeventloop-结构体与初始化" class="header-anchor">#</a> aeEventLoop 结构体与初始化</h4> <p>首先，我们来看下 Redis 事件驱动框架循环流程对应的数据结构 aeEventLoop。</p> <p>这个结构体是在事件驱动框架代码 <a href="https://github.com/redis/redis/tree/5.0/src/ae.h" target="_blank" rel="noopener noreferrer">ae.h <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>中定义的，记录了框架循环运行过程中的信息，其中，就包含了记录两类事件的变量，分别是：</p> <ul><li><strong>aeFileEvent类型的指针 *events，表示IO事件</strong>。之所以类型名称为aeFileEvent，是因为所有的IO事件都会用文件描述符进行标识；</li> <li><strong>aeTimeEvent类型的指针 *timeEventHead，表示时间事件</strong>，即按一定时间周期触发的事件。</li></ul> <p>此外，aeEventLoop结构体中还有一个<strong>aeFiredEvent类型的指针*fired</strong>，这个并不是一类专门的事件类型，它只是用来记录已触发事件对应的文件描述符信息。</p> <p>下面的代码显示了Redis中事件循环的结构体定义，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token punctuation">{</span>
    …
    aeFileEvent <span class="token operator">*</span>events<span class="token punctuation">;</span> <span class="token comment">//IO事件数组</span>
    aeFiredEvent <span class="token operator">*</span>fired<span class="token punctuation">;</span> <span class="token comment">//已触发事件数组</span>
    aeTimeEvent <span class="token operator">*</span>timeEventHead<span class="token punctuation">;</span> <span class="token comment">//记录时间事件的链表头</span>
    …
    <span class="token keyword">void</span> <span class="token operator">*</span>apidata<span class="token punctuation">;</span> <span class="token comment">//和API调用接口相关的数据</span>
    aeBeforeSleepProc <span class="token operator">*</span>beforesleep<span class="token punctuation">;</span> <span class="token comment">//进入事件循环流程前执行的函数</span>
    aeBeforeSleepProc <span class="token operator">*</span>aftersleep<span class="token punctuation">;</span>  <span class="token comment">//退出事件循环流程后执行的函数</span>
<span class="token punctuation">}</span> aeEventLoop<span class="token punctuation">;</span>
</code></pre></div><p>了解了 aeEventLoop 结构体后，我们再来看下，这个结构体是如何初始化的，这其中就包括了IO事件数组和时间事件链表的初始化。</p> <h4 id="aecreateeventloop-函数的初始化操作"><a href="#aecreateeventloop-函数的初始化操作" class="header-anchor">#</a> aeCreateEventLoop 函数的初始化操作</h4> <p>因为 Redis server 在完成初始化后，就要开始运行事件驱动框架的循环流程，所以，aeEventLoop 结构体在<a href="http://github.com/redis/redis/tree/5.0/src/server.c" target="_blank" rel="noopener noreferrer">server.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>的 initServer 函数中，就通过调用 **aeCreateEventLoop 函数 **进行初始化了。这个函数的参数只有一个，是setsize</p> <p>下面的代码展示了 initServer 函数中对 aeCreateEventLoop 函数的调用。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
    <span class="token comment">//调用 aeCreateEventLoop 函数创建 aeEventLoop 结构体，并赋值给 server 结构的 el 变量</span>
    server<span class="token punctuation">.</span>el <span class="token operator">=</span> <span class="token function">aeCreateEventLoop</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxclients<span class="token operator">+</span>CONFIG_FDSET_INCR<span class="token punctuation">)</span><span class="token punctuation">;</span>
    …
<span class="token punctuation">}</span>
</code></pre></div><p>从这里我们可以看到 <strong>参数 setsize</strong> 的大小，其实是由 server 结构的 maxclients 变量和宏定义 CONFIG_FDSET_INCR 共同决定的。其中，maxclients变量的值大小，可以在Redis的配置文件 redis.conf 中进行定义，默认值是 1000。而宏定义CONFIG_FDSET_INCR的大小，等于宏定义 CONFIG_MIN_RESERVED_FDS 的值再加上96，如下所示，这里的两个宏定义都是在<a href="https://github.com/redis/redis/blob/5.0/src/server.h" target="_blank" rel="noopener noreferrer">server.h<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文件中定义的。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CONFIG_MIN_RESERVED_FDS</span> <span class="token expression"><span class="token number">32</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">CONFIG_FDSET_INCR</span> <span class="token expression"><span class="token punctuation">(</span>CONFIG_MIN_RESERVED_FDS<span class="token operator">+</span><span class="token number">96</span><span class="token punctuation">)</span></span></span>
</code></pre></div><p>好了，到这里，你可能有疑问了：aeCreateEventLoop 函数的参数setsize，设置为最大客户端数量加上一个宏定义值，可是<strong>这个参数有什么用呢</strong>？这就和aeCreateEventLoop函数具体执行的初始化操作有关了。</p> <p>接下来，我们就来看下 aeCreateEventLoop 函数执行的操作，大致可以分成以下三个步骤。</p> <p><strong>第一步，aeCreateEventLoop 函数会创建一个 aeEventLoop 结构体类型的变量 eventLoop</strong>。然后，该函数会给 eventLoop 的成员变量分配内存空间，比如，按照传入的参数setsize，给 IO 事件数组和已触发事件数组分配相应的内存空间。此外，该函数还会给eventLoop 的成员变量赋初始值。</p> <p><strong>第二步，aeCreateEventLoop 函数会调用 aeApiCreate 函数</strong>。aeApiCreate 函数封装了操作系统提供的 IO 多路复用函数，假设 Redis 运行在 Linux 操作系统上，并且 IO 多路复用机制是 epoll，那么此时，aeApiCreate 函数就会调用 epoll_create 创建 epoll 实例，同时会创建 epoll_event 结构的数组，数组大小等于参数 setsize。</p> <p>这里你需要注意，aeApiCreate 函数是把创建的 epoll 实例描述符和 epoll_event 数组，保存在了 aeApiState 结构体类型的变量 state，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeApiState</span> <span class="token punctuation">{</span>  <span class="token comment">//aeApiState结构体定义</span>
    <span class="token keyword">int</span> epfd<span class="token punctuation">;</span>   <span class="token comment">//epoll实例的描述符</span>
    <span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> <span class="token operator">*</span>events<span class="token punctuation">;</span>   <span class="token comment">//epoll_event结构体数组，记录监听事件</span>
<span class="token punctuation">}</span> aeApiState<span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiCreate</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    aeApiState <span class="token operator">*</span>state <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeApiState<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//将epoll_event数组保存在aeApiState结构体变量state中</span>
    state<span class="token operator">-&gt;</span>events <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">epoll_event</span><span class="token punctuation">)</span><span class="token operator">*</span>eventLoop<span class="token operator">-&gt;</span>setsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//将epoll实例描述符保存在aeApiState结构体变量state中</span>
    state<span class="token operator">-&gt;</span>epfd <span class="token operator">=</span> <span class="token function">epoll_create</span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    ···
<span class="token punctuation">}</span>
</code></pre></div><p>紧接着，aeApiCreate 函数把 state 变量赋值给 eventLoop 中的 apidata 。这样一来，eventLoop 结构体中就有了 epoll 实例和epoll_event数组的信息，这样就可以用来基于epoll创建和处理事件了。我一会儿还会给你具体介绍。</p> <div class="language-c extra-class"><pre class="language-c"><code>eventLoop<span class="token operator">-&gt;</span>apidata <span class="token operator">=</span> state<span class="token punctuation">;</span>
</code></pre></div><p><strong>第三步，aeCreateEventLoop 函数会把所有网络 IO 事件对应文件描述符的掩码，初始化为 AE_NONE，表示暂时不对任何事件进行监听。</strong></p> <p>我把 aeCreateEventLoop 函数的主要部分代码放在这里，你可以看下。</p> <div class="language-v extra-class"><pre class="language-v"><code>aeEventLoop <span class="token operator">*</span><span class="token function">aeCreateEventLoop</span><span class="token punctuation">(</span><span class="token builtin">int</span> setsize<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">;</span>
    <span class="token builtin">int</span> i<span class="token punctuation">;</span>
   
    <span class="token comment">//给eventLoop变量分配内存空间</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>eventLoop <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> NULL<span class="token punctuation">)</span> <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
    
	<span class="token comment">//给IO事件、已触发事件分配内存空间</span>
    eventLoop<span class="token operator">-</span><span class="token operator">&gt;</span>events <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeFileEvent<span class="token punctuation">)</span><span class="token operator">*</span>setsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    eventLoop<span class="token operator">-</span><span class="token operator">&gt;</span>fired <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span>aeFiredEvent<span class="token punctuation">)</span><span class="token operator">*</span>setsize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    …
    eventLoop<span class="token operator">-</span><span class="token operator">&gt;</span>setsize <span class="token operator">=</span> setsize<span class="token punctuation">;</span>
    eventLoop<span class="token operator">-</span><span class="token operator">&gt;</span>lastTime <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span>NULL<span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//设置时间事件的链表头为NULL</span>
    eventLoop<span class="token operator">-</span><span class="token operator">&gt;</span>timeEventHead <span class="token operator">=</span> NULL<span class="token punctuation">;</span>
	…
	<span class="token comment">//调用aeApiCreate函数，去实际调用操作系统提供的IO多路复用函数</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeApiCreate</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">goto</span> err<span class="token punctuation">;</span>
	 
    <span class="token comment">//将所有网络IO事件对应文件描述符的掩码设置为AE_NONE</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> setsize<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        eventLoop<span class="token operator">-</span><span class="token operator">&gt;</span>events<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">=</span> AE_NONE<span class="token punctuation">;</span>
    <span class="token keyword">return</span> eventLoop<span class="token punctuation">;</span>
 
    <span class="token comment">//初始化失败后的处理逻辑，</span>
    err<span class="token punctuation">:</span>
    …
<span class="token punctuation">}</span>
</code></pre></div><p>好，那么从 aeCreateEventLoop 函数的执行流程中，我们其实可以看到以下<strong>两个关键点</strong>：</p> <ul><li>事件驱动框架监听的 IO 事件数组大小就等于参数 setsize，这样决定了和 Redis server 连接的客户端数量。所以，当你遇到客户端连接Redis时报错“max number of clients reached”，你就可以去 redis.conf 文件修改 maxclients 配置项，以扩充框架能监听的客户端数量。</li> <li>当使用 Linux 系统的 epoll 机制时，框架循环流程初始化操作，会通过 aeApiCreate 函数创建 epoll_event 结构数组，并调用epoll_create 函数创建 epoll 实例，这都是使用 epoll 机制的准备工作要求，你也可以再回顾下第9讲中对 epoll 使用的介绍。</li></ul> <p>到这里，框架就可以创建和处理具体的 IO 事件和时间事件了。所以接下来，我们就先来了解下 IO 事件及其处理机制。</p> <h3 id="io-事件处理"><a href="#io-事件处理" class="header-anchor">#</a> IO 事件处理</h3> <p>Redis的 IO事件主要包括三类，分别是</p> <ul><li>可读事件</li> <li>可写事件</li> <li>屏障事件</li></ul> <p>其中，可读事件和可写事件其实比较好理解，也就是对应于Redis实例，我们可以<strong>从客户端读取数据或是向客户端写入数据</strong>。</p> <p>而屏障事件的主要作用是用来<strong>反转事件的处理顺序</strong>。比如在默认情况下，Redis 会先给客户端返回结果，但是如果面临需要把数据尽快写入磁盘的情况，Redis就会用到屏障事件，把写数据和回复客户端的顺序做下调整，先把数据落盘，再给客户端回复。</p> <p>echo 之前说过，在 Redis 源码中，IO 事件的数据结构是 aeFileEvent 结构体，IO 事件的创建是通过 aeCreateFileEvent 函数来完成的。下面的代码展示了 aeFileEvent 结构体的定义，你可以再回顾下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeFileEvent</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> mask<span class="token punctuation">;</span> <span class="token comment">//掩码标记，包括可读事件、可写事件和屏障事件</span>
    aeFileProc <span class="token operator">*</span>rfileProc<span class="token punctuation">;</span>   <span class="token comment">//处理可读事件的回调函数</span>
    aeFileProc <span class="token operator">*</span>wfileProc<span class="token punctuation">;</span>   <span class="token comment">//处理可写事件的回调函数</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span>  <span class="token comment">//私有数据</span>
<span class="token punctuation">}</span> aeFileEvent<span class="token punctuation">;</span>
</code></pre></div><p>而对于 aeCreateFileEvent 函数来说，在上节课我们已经了解了它是通过 aeApiAddEvent 函数来完成事件注册的。那么接下来，我们再从代码级别看下它是如何执行的，这可以帮助我们更加透彻地理解，事件驱动框架对 IO 事件监听是如何基于 epoll 机制对应封装的。</p> <h4 id="io-事件创建"><a href="#io-事件创建" class="header-anchor">#</a> IO 事件创建</h4> <p>首先，我们来看 aeCreateFileEvent 函数的原型定义，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">,</span> aeFileProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span>
</code></pre></div><p>这个函数的参数有 5 个，分别是</p> <ul><li>循环流程结构体<code>*eventLoop</code></li> <li>IO事件对应的文件描述符fd</li> <li>事件类型掩码mask</li> <li>事件处理回调函数<code>*proc</code></li> <li>事件私有数据<code>*clientData</code>。</li></ul> <p>因为循环流程结构体<code>*eventLoop</code>中有IO事件数组，这个数组的元素是 aeFileEvent 类型，所以，每个数组元素都对应记录了一个文件描述符（比如一个套接字）相关联的监听事件类型和回调函数。</p> <p>aeCreateFileEvent函数会先根据传入的文件描述符fd，在 eventLoop 的IO事件数组中，获取该描述符关联的IO事件指针变量<code>*fe</code>，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code>aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>紧接着，aeCreateFileEvent函数会调用aeApiAddEvent函数，添加要监听的事件：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> mask<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
   <span class="token keyword">return</span> AE_ERR<span class="token punctuation">;</span>
</code></pre></div><p>aeApiAddEvent 函数实际上会调用操作系统提供的 IO 多路复用函数，来完成事件的添加。我们还是假设Redis实例运行在使用epoll机制的Linux上，那么aeApiAddEvent函数就会调用 epoll_ctl 函数，添加要监听的事件。我在第9讲中其实已经给你介绍过 epoll_ctl 函数，这个函数会接收 4 个参数，分别是：</p> <ul><li>epoll实例；</li> <li>要执行的操作类型（是添加还是修改）；</li> <li>要监听的文件描述符；</li> <li>epoll_event类型变量</li></ul> <p>那么，<strong>这个调用过程是如何准备 epoll_ctl 函数需要的参数，从而完成执行的呢？</strong></p> <p>首先，epoll 实例是我刚才给你介绍的 aeCreateEventLoop 函数，它是通过调用aeApiCreate函数来创建的，保存在了eventLoop结构体的apidata变量中，类型是aeApiState。所以，aeApiAddEvent函数会先获取该变量，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">//从eventLoop结构体中获取aeApiState变量，里面保存了epoll实例</span>
	aeApiState <span class="token operator">*</span>state <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>apidata<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
 <span class="token punctuation">}</span>
</code></pre></div><p>其次，对于要执行的操作类型的设置，aeApiAddEvent函数会根据传入的文件描述符fd，在eventLoop结构体中IO事件数组中查找该fd。因为IO事件数组的每个元素，都对应了一个文件描述符，而该数组初始化时，每个元素的值都设置为了AE_NONE。</p> <p>所以，如果要监听的文件描述符fd在数组中的类型不是AE_NONE，则表明该描述符已做过设置，那么操作类型就是修改操作，对应epoll机制中的宏定义EPOLL_CTL_MOD。否则，操作类型就是添加操作，对应epoll机制中的宏定义EPOLL_CTL_ADD。这部分代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//如果文件描述符fd对应的IO事件已存在，则操作类型为修改，否则为添加</span>
 <span class="token keyword">int</span> op <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>fd<span class="token punctuation">]</span><span class="token punctuation">.</span>mask <span class="token operator">==</span> AE_NONE <span class="token operator">?</span>
            EPOLL_CTL_ADD <span class="token operator">:</span> EPOLL_CTL_MOD<span class="token punctuation">;</span>
</code></pre></div><p>第三，epoll_ctl函数需要的监听文件描述符，就是aeApiAddEvent函数接收到的参数fd。</p> <p>最后，epoll_ctl函数还需要一个epoll_event类型变量，因此aeApiAddEvent函数在调用epoll_ctl函数前，会新创建epoll_event类型**变量ee。**然后，aeApiAddEvent函数会设置变量ee中的监听事件类型和监听文件描述符。</p> <p>aeApiAddEvent函数的参数mask，表示的是要监听的事件类型掩码。所以，aeApiAddEvent函数会根据掩码值是可读（AE_READABLE）或可写（AE_WRITABLE）事件，来设置ee监听的事件类型是EPOLLIN还是EPOLLOUT。这样一来，Redis事件驱动框架中的读写事件就能够和epoll机制中的读写事件对应上来。下面的代码展示了这部分逻辑，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code>…
<span class="token keyword">struct</span> <span class="token class-name">epoll_event</span> ee <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//创建epoll_event类型变量</span>
…
<span class="token comment">//将可读或可写IO事件类型转换为epoll监听的类型EPOLLIN或EPOLLOUT</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> ee<span class="token punctuation">.</span>events <span class="token operator">|=</span> EPOLLIN<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> ee<span class="token punctuation">.</span>events <span class="token operator">|=</span> EPOLLOUT<span class="token punctuation">;</span>
ee<span class="token punctuation">.</span>data<span class="token punctuation">.</span>fd <span class="token operator">=</span> fd<span class="token punctuation">;</span>  <span class="token comment">//将要监听的文件描述符赋值给ee</span>
…	
</code></pre></div><p>好了，到这里，aeApiAddEvent函数就准备好了epoll实例、操作类型、监听文件描述符以及epoll_event类型变量，然后，它就会调用epoll_ctl开始实际创建监听事件了，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">aeApiAddEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> mask<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">//调用epoll_ctl实际创建监听事件</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">epoll_ctl</span><span class="token punctuation">(</span>state<span class="token operator">-&gt;</span>epfd<span class="token punctuation">,</span>op<span class="token punctuation">,</span>fd<span class="token punctuation">,</span><span class="token operator">&amp;</span>ee<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>了解了这些代码后，我们可以学习到事件驱动框架是如何基于 epoll，封装实现了IO事件的创建。那么，在Redis server启动运行后，最开始监听的 IO 事件是可读事件，对应于客户端的连接请求。具体是 initServer 函数调用了 aeCreateFileEvent 函数，创建可读事件，并设置回调函数为acceptTcpHandler，用来处理客户端连接</p> <p>接下来，我们再来看下一旦有了客户端连接请求后，IO 事件具体是如何处理的呢？</p> <h4 id="读事件处理"><a href="#读事件处理" class="header-anchor">#</a> 读事件处理</h4> <p>当 Redis server 接收到客户端的连接请求时，就会使用注册好的 <strong>acceptTcpHandler函数</strong> 进行处理。</p> <p>acceptTcpHandler 函数会接受客户端连接，并创建已连接套接字 cfd。然后，acceptCommonHandler 函数会被调用，同时，刚刚创建的已连接套接字 cfd 会作为参数，传递给 acceptCommonHandler 函数。</p> <p>acceptCommonHandler 函数会调用 createClient 函数创建客户端。而在createClient函数中，我们就会看到，aeCreateFileEvent函数被再次调用了</p> <p>此时，aeCreateFileEvent函数会针对已连接套接字上，创建监听事件，类型为 AE_READABLE，回调函数是 readQueryFromClient</p> <p>好了，到这里，事件驱动框架就<strong>增加</strong>了对一个客户端已连接套接字的监听。一旦客户端有请求发送到server，框架就会回调readQueryFromClient 函数处理请求。这样一来，客户端请求就能通过事件驱动框架进行处理了。</p> <p>下面代码展示了 createClient 函数调用 aeCreateFileEvent 的过程，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code>client <span class="token operator">*</span><span class="token function">createClient</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
…
<span class="token keyword">if</span> <span class="token punctuation">(</span>fd <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        …
        <span class="token comment">//调用aeCreateFileEvent，监听读事件，对应客户端读写请求，使用readQueryFromclient回调函数处理</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>AE_READABLE<span class="token punctuation">,</span>
            readQueryFromClient<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">zfree</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token punctuation">}</span>
…
<span class="token punctuation">}</span>
</code></pre></div><p>为了便于你掌握从监听客户端连接请求到监听客户端常规读写请求的事件创建过程，我画了下面这张图，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151358214.png" alt="image-20240915135841109"></p> <h4 id="写事件处理"><a href="#写事件处理" class="header-anchor">#</a> 写事件处理</h4> <p>Redis实例在收到客户端请求后，会在处理客户端命令后，将要返回的数据写入客户端输出缓冲区。下图就展示了这个过程的函数调用逻辑：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151359441.png" alt="image-20240915135959373"></p> <p>而在Redis事件驱动框架每次循环进入事件处理函数前，也就是在框架主函数aeMain中调用aeProcessEvents，来处理监听到的已触发事件或是到时的时间事件之前，都会调用server.c文件中的<strong>beforeSleep函数</strong>，进行一些任务处理，这其中就包括了调用handleClientsWithPendingWrites函数，它会将Redis sever客户端缓冲区中的数据写回客户端。</p> <p>下面给出的代码是事件驱动框架的主函数aeMain。在该函数每次调用aeProcessEvents函数前，就会调用beforeSleep函数，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">aeMain</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    eventLoop<span class="token operator">-&gt;</span>stop <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>eventLoop<span class="token operator">-&gt;</span>stop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	    <span class="token comment">//如果beforeSleep函数不为空，则调用beforeSleep函数</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventLoop<span class="token operator">-&gt;</span>beforesleep <span class="token operator">!=</span> <span class="token constant">NULL</span><span class="token punctuation">)</span>
            eventLoop<span class="token operator">-&gt;</span><span class="token function">beforesleep</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//调用完beforeSleep函数，再处理事件</span>
        <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> AE_ALL_EVENTS<span class="token operator">|</span>AE_CALL_AFTER_SLEEP<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里你要知道，beforeSleep函数调用的handleClientsWithPendingWrites函数，会遍历每一个待写回数据的客户端，然后调用writeToClient函数，将客户端输出缓冲区中的数据写回。下面这张图展示了这个流程，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409151400521.png" alt="image-20240915140035435"></p> <p>不过，如果输出缓冲区的数据还没有写完，此时，handleClientsWithPendingWrites函数就会<strong>调用aeCreateFileEvent函数，创建可写事件</strong>，并设置回调函数sendReplyToClient。sendReplyToClient函数里面会调用writeToClient函数写回数据。</p> <blockquote><p>aeCreateFileEvent 是 Redis 中的一个底层函数，用于向事件循环中注册一个新的文件事件。文件事件可以是“可读事件”（数据到来时触发）或“可写事件”（缓冲区空闲时触发）。在上述场景中，<code>aeCreateFileEvent</code> 创建的是一个“可写事件”。</p> <p>当客户端的输出缓冲区还未完全发送完数据时，Redis 不会立刻阻塞，而是通过创建“可写事件”来处理这个情况。这个可写事件表示，当 Redis 发现客户端可以继续接收数据时（输出缓冲区空闲），它就会自动触发这个事件。</p> <p>当可写事件触发时，Redis 会调用 <code>sendReplyToClient</code> 函数。这个函数负责将剩余的数据从输出缓冲区发送给客户端。具体来说，它内部会调用 <code>writeToClient</code> 函数来真正执行数据发送的操作。</p></blockquote> <p>echo 认为</p> <blockquote><ol><li><strong>输出缓冲区</strong>：当 Redis 需要将数据返回给客户端时，数据会先存放在一个输出缓冲区中，然后再通过网络传输给客户端。</li> <li><strong>缓冲区未写完</strong>：这个情况可能发生在以下几种情况下：
<ul><li><strong>客户端网络不畅</strong>：客户端处理速度较慢，或者网络带宽不足，导致一次只能从缓冲区接收一部分数据，剩余的数据暂时无法发送。(可能是TCP的滑动窗口中的接收方的接收窗口跟不上)</li> <li><strong>大数据量传输</strong>：如果 Redis 需要发送的数据量很大，比如一个大的查询结果，Redis 可能无法在一次 write 操作中将所有数据写入客户端的网络套接字，只能先写入一部分，剩下的放在缓冲区里等待下一次写入。</li></ul></li> <li><strong>处理机制</strong>：
<ul><li>当 Redis 发现缓冲区中的数据没有写完（例如，<code>writeToClient</code> 函数尝试发送数据时只能写入一部分），它不会等待或阻塞主线程。</li> <li>此时 Redis 会调用 <code>aeCreateFileEvent</code>，创建一个<strong>可写事件</strong>，表示客户端还未完全接收数据。当客户端准备好接收更多数据时，这个可写事件会触发，回调函数 <code>sendReplyToClient</code> 会再次被调用，尝试将剩下的数据发送给客户端。</li></ul></li></ol> <ul><li><strong>避免阻塞主线程</strong>：Redis 是单线程的，如果由于网络问题或客户端处理能力限制，主线程被阻塞在一个客户端的发送过程中，其他客户端的请求就无法得到及时处理。</li> <li><strong>提高性能和吞吐量</strong>：通过异步的方式处理缓冲区的剩余数据发送，Redis 能在高并发的情况下更高效地处理多个客户端的请求。</li></ul></blockquote> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    listIter li<span class="token punctuation">;</span>
	listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>
	…
    <span class="token comment">//获取待写回的客户端列表</span>
	<span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//遍历每一个待写回的客户端</span>
	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	   client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
	   …
	   <span class="token comment">//调用writeToClient将当前客户端的输出缓冲区数据写回</span>
	   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>fd<span class="token punctuation">,</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
	   <span class="token comment">//如果还有待写回数据</span>
	   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	            <span class="token keyword">int</span> ae_flags <span class="token operator">=</span> AE_WRITABLE<span class="token punctuation">;</span>
	            <span class="token comment">//创建可写事件的监听，以及设置回调函数</span>
	             <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateFileEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> c<span class="token operator">-&gt;</span>fd<span class="token punctuation">,</span> ae_flags<span class="token punctuation">,</span>
	                sendReplyToClient<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span>
	            <span class="token punctuation">{</span>
	                   …
	            <span class="token punctuation">}</span>
	  <span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好了，我们刚才了解的是读写事件对应的回调处理函数。实际上，为了能及时处理这些事件，Redis事件驱动框架的aeMain函数还会循环<strong>调用aeProcessEvents函数，来检测已触发的事件，并调用相应的回调函数进行处理。</strong></p> <p>从aeProcessEvents函数的代码中，我们可以看到该函数会调用aeApiPoll函数，查询监听的文件描述符中，有哪些已经就绪。一旦有描述符就绪，aeProcessEvents函数就会根据事件的可读或可写类型，调用相应的回调函数进行处理。aeProcessEvents函数调用的基本流程如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">aeProcessEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span><span class="token punctuation">{</span>
…
<span class="token comment">//调用aeApiPoll获取就绪的描述符</span>
numevents <span class="token operator">=</span> <span class="token function">aeApiPoll</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> tvp<span class="token punctuation">)</span><span class="token punctuation">;</span>
…
<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> numevents<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	aeFileEvent <span class="token operator">*</span>fe <span class="token operator">=</span> <span class="token operator">&amp;</span>eventLoop<span class="token operator">-&gt;</span>events<span class="token punctuation">[</span>eventLoop<span class="token operator">-&gt;</span>fired<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>fd<span class="token punctuation">]</span><span class="token punctuation">;</span>
	…
    <span class="token comment">//如果触发的是可读事件，调用事件注册时设置的读事件回调处理函数</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>invert <span class="token operator">&amp;&amp;</span> fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_READABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	      fe<span class="token operator">-&gt;</span><span class="token function">rfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                fired<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
    
    <span class="token comment">//如果触发的是可写事件，调用事件注册时设置的写事件回调处理函数</span>
	<span class="token keyword">if</span> <span class="token punctuation">(</span>fe<span class="token operator">-&gt;</span>mask <span class="token operator">&amp;</span> mask <span class="token operator">&amp;</span> AE_WRITABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fired <span class="token operator">||</span> fe<span class="token operator">-&gt;</span>wfileProc <span class="token operator">!=</span> fe<span class="token operator">-&gt;</span>rfileProc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	                    fe<span class="token operator">-&gt;</span><span class="token function">wfileProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span>fd<span class="token punctuation">,</span>fe<span class="token operator">-&gt;</span>clientData<span class="token punctuation">,</span>mask<span class="token punctuation">)</span><span class="token punctuation">;</span>
	                    fired<span class="token operator">++</span><span class="token punctuation">;</span>
	                <span class="token punctuation">}</span>
	            <span class="token punctuation">}</span>
	…
	<span class="token punctuation">}</span> <span class="token punctuation">}</span>
	…
<span class="token punctuation">}</span>
</code></pre></div><p>到这里，我们就了解了IO事件的创建函数aeCreateFileEvent，以及在处理客户端请求时对应的读写事件和它们的处理函数。那么接下来，我们再来看看事件驱动框架中的时间事件是怎么创建和处理的。</p> <h3 id="时间事件处理"><a href="#时间事件处理" class="header-anchor">#</a> 时间事件处理</h3> <p>其实，相比于 IO 事件有可读、可写、屏障类型，以及不同类型IO事件有不同回调函数来说，时间事件的处理就比较简单了。下面，我们就来分别学习下它的定义、创建、回调函数和触发处理。</p> <h4 id="时间事件定义"><a href="#时间事件定义" class="header-anchor">#</a> 时间事件定义</h4> <p>首先，我们来看下时间事件的结构体定义，代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token punctuation">{</span>
    <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">;</span> <span class="token comment">//时间事件ID</span>
    <span class="token keyword">long</span> when_sec<span class="token punctuation">;</span> <span class="token comment">//事件到达的秒级时间戳</span>
    <span class="token keyword">long</span> when_ms<span class="token punctuation">;</span> <span class="token comment">//事件到达的毫秒级时间戳</span>
    aeTimeProc <span class="token operator">*</span>timeProc<span class="token punctuation">;</span> <span class="token comment">//时间事件触发后的处理函数</span>
    aeEventFinalizerProc <span class="token operator">*</span>finalizerProc<span class="token punctuation">;</span>  <span class="token comment">//事件结束后的处理函数</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">;</span> <span class="token comment">//事件相关的私有数据</span>
    <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>prev<span class="token punctuation">;</span>  <span class="token comment">//时间事件链表的前向指针</span>
    <span class="token keyword">struct</span> <span class="token class-name">aeTimeEvent</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>  <span class="token comment">//时间事件链表的后向指针</span>
<span class="token punctuation">}</span> aeTimeEvent<span class="token punctuation">;</span>
</code></pre></div><p>时间事件结构体中主要的变量，包括以秒记录和以毫秒记录的时间事件触发时的时间戳when_sec和when_ms，以及时间事件触发后的处理函数<code>*timeProc</code>。另外，在时间事件的结构体中，还包含了前向和后向指针<code>*prev</code>和<code>*next</code>，这表明<strong>时间事件是以链表的形式组织起来的</strong>。</p> <p>在了解了时间事件结构体的定义以后，我们接着来看下，时间事件是如何创建的。</p> <h4 id="时间事件创建"><a href="#时间事件创建" class="header-anchor">#</a> 时间事件创建</h4> <p>与IO事件创建使用aeCreateFileEvent函数类似，<strong>时间事件的创建函数是 aeCreateTimeEvent 函数</strong>。这个函数的原型定义如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token function">aeCreateTimeEvent</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> milliseconds<span class="token punctuation">,</span> aeTimeProc <span class="token operator">*</span>proc<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">,</span> aeEventFinalizerProc <span class="token operator">*</span>finalizerProc<span class="token punctuation">)</span>
</code></pre></div><p>在它的参数中，有两个需要我们重点了解下，以便于我们理解时间事件的处理。</p> <ul><li>一个是<strong>milliseconds</strong>，这是所创建时间事件的触发时间距离当前时间的时长，是用毫秒表示的。</li> <li>另一个是<em><strong>proc</strong>，这是所创建时间事件触发后的</em><em>回调函数</em>*。</li></ul> <p>aeCreateTimeEvent函数的执行逻辑不复杂，主要就是创建一个时间事件的<strong>变量te</strong>，对它进行初始化，并把它插入到框架循环流程结构体eventLoop中的时间事件链表中。在这个过程中，aeCreateTimeEvent函数会<strong>调用aeAddMillisecondsToNow函数</strong>，根据传入的milliseconds参数，计算所创建时间事件具体的触发时间戳，并赋值给te。</p> <p>实际上，Redis server在初始化时，除了创建监听的IO事件外，也会调用aeCreateTimeEvent函数创建时间事件。下面代码显示了initServer函数对aeCreateTimeEvent函数的调用：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">initServer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
    <span class="token comment">//创建时间事件</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">aeCreateTimeEvent</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>el<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> serverCron<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> AE_ERR<span class="token punctuation">)</span><span class="token punctuation">{</span>
    … <span class="token comment">//报错信息</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从代码中，我们可以看到，<strong>时间事件触发后的回调函数是 serverCron</strong>。所以接下来，我们就来了解下serverCron函数。</p> <h4 id="时间事件回调函数"><a href="#时间事件回调函数" class="header-anchor">#</a> 时间事件回调函数</h4> <p>serverCron函数是在server.c文件中实现的。<strong>一方面</strong>，它会顺序调用一些函数，来实现时间事件被触发后，执行一些后台任务。比如，serverCron函数会检查是否有进程结束信号，若有就执行server关闭操作。serverCron会调用databaseCron函数，处理过期key或进行rehash等。你可以参考下面给出的代码：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//如果收到进程结束信号，则执行server关闭操作</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>shutdown_asap<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">prepareForShutdown</span><span class="token punctuation">(</span>SHUTDOWN_NOFLAGS<span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span> <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token function">clientCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//执行客户端的异步操作</span>
<span class="token function">databaseCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//执行数据库的后台操作</span>
</code></pre></div><p><strong>另一方面</strong>，serverCron函数还会以不同的频率周期性执行一些任务，这是通过执行宏run_with_period来实现的。</p> <p>run_with_period宏定义如下，该宏定义会根据Redis实例配置文件redis.conf中定义的hz值，来判断参数_ms_表示的时间戳是否到达。一旦到达，serverCron就可以执行相应的任务了。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">run_with_period</span><span class="token expression"><span class="token punctuation">(</span>_ms_<span class="token punctuation">)</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>_ms_ <span class="token operator">&lt;=</span> <span class="token number">1000</span><span class="token operator">/</span>server<span class="token punctuation">.</span>hz<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>cronloops<span class="token operator">%</span><span class="token punctuation">(</span><span class="token punctuation">(</span>_ms_<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token operator">/</span>server<span class="token punctuation">.</span>hz<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
</code></pre></div><p>比如，serverCron函数中会以1秒1次的频率，检查AOF文件是否有写错误。如果有的话，serverCron就会调用flushAppendOnlyFile函数，再次刷回AOF文件的缓存数据。下面的代码展示了这一周期性任务：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   …
   <span class="token comment">//每1秒执行1次，检查AOF是否有写错误</span>
   <span class="token function">run_with_period</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>aof_last_write_status <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span>
            <span class="token function">flushAppendOnlyFile</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
   …
<span class="token punctuation">}</span>
</code></pre></div><p>如果你想了解更多的周期性任务，可以再详细阅读下 serverCron 函数中，以 run_with_period 宏定义包含的代码块。</p> <p>好了，了解了时间事件触发后的回调函数 serverCron，我们最后来看下，时间事件是如何触发处理的。</p> <h4 id="时间事件的触发处理"><a href="#时间事件的触发处理" class="header-anchor">#</a> 时间事件的触发处理</h4> <p>其实，时间事件的检测触发比较简单，事件驱动框架的aeMain函数会循环调用aeProcessEvents函数，来处理各种事件。而aeProcessEvents函数在执行流程的最后，会<strong>调用processTimeEvents函数处理相应到时的任务</strong>。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">aeProcessEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    …
    <span class="token comment">//检测时间事件是否触发</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> AE_TIME_EVENTS<span class="token punctuation">)</span>
            processed <span class="token operator">+=</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">)</span><span class="token punctuation">;</span>
    …
<span class="token punctuation">}</span>
</code></pre></div><p>那么，具体到 proecessTimeEvent 函数来说，它的基本流程就是从时间事件链表上逐一取出每一个事件，然后根据当前时间判断该事件的触发时间戳是否已满足。如果已满足，那么就调用该事件对应的回调函数进行处理。这样一来，周期性任务就能在不断循环执行的aeProcessEvents函数中，得到执行了。</p> <p>下面的代码显示了 processTimeEvents 函数的基本流程，你可以再看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">processTimeEvents</span><span class="token punctuation">(</span>aeEventLoop <span class="token operator">*</span>eventLoop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    te <span class="token operator">=</span> eventLoop<span class="token operator">-&gt;</span>timeEventHead<span class="token punctuation">;</span>  <span class="token comment">//从时间事件链表中取出事件</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>te<span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      <span class="token function">aeGetTime</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>now_sec<span class="token punctuation">,</span> <span class="token operator">&amp;</span>now_ms<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//获取当前时间</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>now_sec <span class="token operator">&gt;</span> te<span class="token operator">-&gt;</span>when_sec <span class="token operator">||</span> <span class="token punctuation">(</span>now_sec <span class="token operator">==</span> te<span class="token operator">-&gt;</span>when_sec <span class="token operator">&amp;&amp;</span> now_ms <span class="token operator">&gt;=</span> te<span class="token operator">-&gt;</span>when_ms<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">//如果当前时间已经满足当前事件的触发时间戳</span>
      <span class="token punctuation">{</span>
         <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        retval <span class="token operator">=</span> te<span class="token operator">-&gt;</span><span class="token function">timeProc</span><span class="token punctuation">(</span>eventLoop<span class="token punctuation">,</span> id<span class="token punctuation">,</span> te<span class="token operator">-&gt;</span>clientData<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//调用注册的回调函数处理</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      <span class="token punctuation">}</span>
      te <span class="token operator">=</span> te<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>   <span class="token comment">//获取下一个时间事件</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="总结-3"><a href="#总结-3" class="header-anchor">#</a> 总结</h3> <p>对于IO事件来说，它可以进一步分成可读、可写和屏障事件。因为可读、可写事件在Redis和客户端通信处理请求过程中使用广泛，所以本节我们重点学习了这两种IO事件。当Redis server创建Socket后，就会注册可读事件，并使用 acceptTCPHandler 回调函数处理客户端的连接请求。</p> <p>当server和客户端完成连接建立后，server 会在已连接套接字上监听可读事件，并使用 readQueryFromClient 函数处理客户端读写请求。这里，你需要再注意下，<strong>无论客户端发送的请求是读或写操作，对于server来说，都是要读取客户端的请求并解析处理</strong>。所以，server在客户端的已连接套接字上注册的是可读事件。</p> <p>而当实例需要向客户端写回数据时，实例会在事件驱动框架中注册可写事件，并使用 sendReplyToClient 作为回调函数，将缓冲区中数据写回客户端。我总结了一张表格，以便你再回顾下IO事件和相应套接字、回调函数的对应关系。</p> <p>然后，对于时间事件来说，它主要是用于在事件驱动框架中注册一些周期性执行的任务，以便 Redis server 进行后台处理。时间事件的回调函数是 serverCron 函数，你可以做进一步阅读了解其中的具体任务。</p> <p>好了，从第9讲开始，我用了3节课，向你介绍Redis事件驱动框架的运行机制，本质上来说，事件驱动框架是基于操作系统提供的IO多路复用机制进行了封装，并加上了时间事件的处理。这是一个非常经典的事件框架实现，我希望你可以学习并掌握好它，然后用在你自己的系统开发中。</p> <h2 id="参考文献"><a href="#参考文献" class="header-anchor">#</a> 参考文献</h2> <p><a href="https://time.geekbang.org/column/intro/100084301?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noopener noreferrer">Redis源码剖析与实战_Redis_Redis源码_数据结构_主从复制_缓存_集群_分布式数据库_键值数据库_事件驱动框架-极客时间 (geekbang.org)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener noreferrer">Redis设计与实现 (豆瓣) (douban.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/09.系统设计鉴赏/01.Redis/01.Redis 事件驱动框架.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2024/09/15, 09:11:59</span></div></div> <div class="page-nav-wapper"><!----> <!----></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.e2123772.js" defer></script><script src="/assets/js/2.81691b95.js" defer></script><script src="/assets/js/35.c5c7cc6d.js" defer></script>
  </body>
</html>
