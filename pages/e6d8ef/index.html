<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis 的执行模式 | EchoDesign</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="系统设计之「讲解 + 面试指南」，水滴石穿，设计无银弹！">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.c76c3453.css" as="style"><link rel="preload" href="/assets/js/app.9830b779.js" as="script"><link rel="preload" href="/assets/js/2.933750c6.js" as="script"><link rel="preload" href="/assets/js/69.7ac52a2f.js" as="script"><link rel="preload" href="/assets/js/7.7eb70372.js" as="script"><link rel="prefetch" href="/assets/js/10.2cc95be8.js"><link rel="prefetch" href="/assets/js/100.2b21dce5.js"><link rel="prefetch" href="/assets/js/101.96ca71f6.js"><link rel="prefetch" href="/assets/js/11.c7521a10.js"><link rel="prefetch" href="/assets/js/12.38d1989d.js"><link rel="prefetch" href="/assets/js/13.850793b0.js"><link rel="prefetch" href="/assets/js/14.1141ec27.js"><link rel="prefetch" href="/assets/js/15.12d1dea8.js"><link rel="prefetch" href="/assets/js/16.60cde607.js"><link rel="prefetch" href="/assets/js/17.acb3bf3d.js"><link rel="prefetch" href="/assets/js/18.e491edb6.js"><link rel="prefetch" href="/assets/js/19.daf31819.js"><link rel="prefetch" href="/assets/js/20.cb4a5c13.js"><link rel="prefetch" href="/assets/js/21.24c0f101.js"><link rel="prefetch" href="/assets/js/22.dd779f94.js"><link rel="prefetch" href="/assets/js/23.4d814163.js"><link rel="prefetch" href="/assets/js/24.891fe6fb.js"><link rel="prefetch" href="/assets/js/25.41dca26b.js"><link rel="prefetch" href="/assets/js/26.6337eac0.js"><link rel="prefetch" href="/assets/js/27.de80589e.js"><link rel="prefetch" href="/assets/js/28.95a1fb6b.js"><link rel="prefetch" href="/assets/js/29.371a40e1.js"><link rel="prefetch" href="/assets/js/3.e62a71e4.js"><link rel="prefetch" href="/assets/js/30.e32f6b31.js"><link rel="prefetch" href="/assets/js/31.a532917f.js"><link rel="prefetch" href="/assets/js/32.13b70e91.js"><link rel="prefetch" href="/assets/js/33.64ab8d0c.js"><link rel="prefetch" href="/assets/js/34.6d3cc288.js"><link rel="prefetch" href="/assets/js/35.2760ed8d.js"><link rel="prefetch" href="/assets/js/36.be98cc35.js"><link rel="prefetch" href="/assets/js/37.82be3556.js"><link rel="prefetch" href="/assets/js/38.40fe2658.js"><link rel="prefetch" href="/assets/js/39.84b6e82e.js"><link rel="prefetch" href="/assets/js/4.73518a0f.js"><link rel="prefetch" href="/assets/js/40.591baf2a.js"><link rel="prefetch" href="/assets/js/41.f961e422.js"><link rel="prefetch" href="/assets/js/42.b34f1599.js"><link rel="prefetch" href="/assets/js/43.5a509601.js"><link rel="prefetch" href="/assets/js/44.64fd3383.js"><link rel="prefetch" href="/assets/js/45.685623ac.js"><link rel="prefetch" href="/assets/js/46.7624d38c.js"><link rel="prefetch" href="/assets/js/47.5646b068.js"><link rel="prefetch" href="/assets/js/48.a1b270df.js"><link rel="prefetch" href="/assets/js/49.ee9681bc.js"><link rel="prefetch" href="/assets/js/5.94727770.js"><link rel="prefetch" href="/assets/js/50.b424b2c0.js"><link rel="prefetch" href="/assets/js/51.ef213b56.js"><link rel="prefetch" href="/assets/js/52.18c75eba.js"><link rel="prefetch" href="/assets/js/53.f76e624c.js"><link rel="prefetch" href="/assets/js/54.3098ec9f.js"><link rel="prefetch" href="/assets/js/55.4c46841d.js"><link rel="prefetch" href="/assets/js/56.10e3f10b.js"><link rel="prefetch" href="/assets/js/57.36581a94.js"><link rel="prefetch" href="/assets/js/58.e5a83b70.js"><link rel="prefetch" href="/assets/js/59.7b7e3faf.js"><link rel="prefetch" href="/assets/js/6.0b558b79.js"><link rel="prefetch" href="/assets/js/60.66a7f41d.js"><link rel="prefetch" href="/assets/js/61.52ab8e4e.js"><link rel="prefetch" href="/assets/js/62.cc8fdced.js"><link rel="prefetch" href="/assets/js/63.41ff19e4.js"><link rel="prefetch" href="/assets/js/64.9b3def35.js"><link rel="prefetch" href="/assets/js/65.0b2ab47d.js"><link rel="prefetch" href="/assets/js/66.2ae7a107.js"><link rel="prefetch" href="/assets/js/67.79dd6daf.js"><link rel="prefetch" href="/assets/js/68.1b76c178.js"><link rel="prefetch" href="/assets/js/70.7279b1df.js"><link rel="prefetch" href="/assets/js/71.4f744076.js"><link rel="prefetch" href="/assets/js/72.44c999da.js"><link rel="prefetch" href="/assets/js/73.526febf1.js"><link rel="prefetch" href="/assets/js/74.26f8d9a5.js"><link rel="prefetch" href="/assets/js/75.dc7fdd0f.js"><link rel="prefetch" href="/assets/js/76.32858593.js"><link rel="prefetch" href="/assets/js/77.7b3f6980.js"><link rel="prefetch" href="/assets/js/78.31a353ef.js"><link rel="prefetch" href="/assets/js/79.173bbc8c.js"><link rel="prefetch" href="/assets/js/8.0ec7f6e8.js"><link rel="prefetch" href="/assets/js/80.78a31e84.js"><link rel="prefetch" href="/assets/js/81.8d6c43d2.js"><link rel="prefetch" href="/assets/js/82.3b90a7cc.js"><link rel="prefetch" href="/assets/js/83.f3a9ee0c.js"><link rel="prefetch" href="/assets/js/84.eeb423e8.js"><link rel="prefetch" href="/assets/js/85.4cd3a775.js"><link rel="prefetch" href="/assets/js/86.931cbb70.js"><link rel="prefetch" href="/assets/js/87.78b2eebd.js"><link rel="prefetch" href="/assets/js/88.605444aa.js"><link rel="prefetch" href="/assets/js/89.b5690031.js"><link rel="prefetch" href="/assets/js/9.6e274fca.js"><link rel="prefetch" href="/assets/js/90.cdc8eb8f.js"><link rel="prefetch" href="/assets/js/91.8ad18b18.js"><link rel="prefetch" href="/assets/js/92.b554f1c7.js"><link rel="prefetch" href="/assets/js/93.fb2397b7.js"><link rel="prefetch" href="/assets/js/94.1eade7f0.js"><link rel="prefetch" href="/assets/js/95.96f5db04.js"><link rel="prefetch" href="/assets/js/96.5ed2d348.js"><link rel="prefetch" href="/assets/js/97.4d4bfff5.js"><link rel="prefetch" href="/assets/js/98.10f4b27a.js"><link rel="prefetch" href="/assets/js/99.4a895015.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c76c3453.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="EchoDesign" class="logo"> <span class="site-name can-hide">EchoDesign</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 深度剖析</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 深度剖析</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>一、前言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二、基础知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>三、主线任务</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/34fa27/" class="sidebar-link">Linux 中的 IO 多路复用</a></li><li><a href="/pages/d4ecb9/" class="sidebar-link">Redis Server 初始化</a></li><li><a href="/pages/d6b00d/" class="sidebar-link">Redis 的 Reactor 模型</a></li><li><a href="/pages/264b06/" class="sidebar-link">深入 Redis 事件驱动框架</a></li><li><a href="/pages/e6d8ef/" aria-current="page" class="active sidebar-link">Redis 的执行模式</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/e6d8ef/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/e6d8ef/#从-bio-c-文件学习-redis-的后台线程" class="sidebar-link">从 bio.c 文件学习 Redis 的后台线程</a></li><li class="sidebar-sub-header level2"><a href="/pages/e6d8ef/#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level2"><a href="/pages/e6d8ef/#参考资料" class="sidebar-link">参考资料</a></li></ul></li><li><a href="/pages/0850b6/" class="sidebar-link">Redis 多IO线程</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>四、支线任务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>五、集群</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Redis 系统设计</span></li><li data-v-06225672><span data-v-06225672>三、主线任务</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-15</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">Redis 的执行模式<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><div class="custom-block note"><p class="custom-block-title">提出问题是一切智慧的开端</p> <ul><li>为什么 Redis 的核心流程采用单线程 IO 架构，而不是多线程？</li> <li>哪些操作可能导致 Redis 主线程阻塞？如何用后台线程避免？</li> <li>Redis 后台线程如何启动、管理，并与主线程协同？</li> <li>Redis 的惰性删除机制是如何工作的？对性能有何影响？</li> <li>生产环境中如何根据 Redis 模型优化性能？</li> <li>Redis 后台线程的创建机制及其与任务队列的交互？</li> <li>如果 Redis 的后台任务队列满了，会发生什么？</li> <li>Redis 如何通过任务优先级或类型优化资源管理？</li></ul></div> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p><strong>所谓的执行模型，就是指 Redis 运行时使用的进程、子进程和线程的个数，以及它们各自负责的工作任务</strong></p> <p>你在实际使用 Redis 的时候，可能经常会听到类似“Redis 是单线程”、“Redis 的主 IO 线程”、“Redis 包含多线程”等不同说法。我也听到不少同学提出困惑和疑问：<strong>Redis 到底是不是一个单线程的程序？</strong></p> <p>其实，彻底理解这个问题，有助于指导我们保持 Redis 高性能、低延迟的特性。如果说 Redis 就是单线程程序，那么，我们就需要避免所有容易引起线程阻塞的操作；而如果说 Redis 不只是单线程，还有其他线程在工作，那么，我们就需要了解多线程各自负责什么任务，负责请求解析和数据读写的线程有几个，有哪些操作是后台线程在完成，而不会影响请求解析和数据读写的。</p> <h2 id="从-bio-c-文件学习-redis-的后台线程"><a href="#从-bio-c-文件学习-redis-的后台线程" class="header-anchor">#</a> 从 bio.c 文件学习 Redis 的后台线程</h2> <p>我们先来看下 main 函数在初始化过程最后调用的 InitServerLast 函数。InitServerLast 函数的作用是进一步调用 bioInit 函数，来创建后台线程，让 Redis 把部分任务交给后台线程处理。这个过程如下所示。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">InitServerLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">bioInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    …
<span class="token punctuation">}</span>
</code></pre></div><p><code>bioInit</code>函数是在<a href="https://github.com/redis/redis/tree/5.0/src/bio.c" target="_blank" rel="noopener noreferrer">bio.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文件中实现的，它的主要作用调用<code>pthread_create</code>函数创建多个后台线程。不过在具体了解<code>bioInit</code>函数之前，我们先来看下 bio.c 文件中定义的主要数组，这也是在<code>bioInit</code>函数中要进行初始化的。</p> <p>bio.c 文件针对要创建的线程，定义了<code>pthread_t</code>类型的数组<code>bio_threads</code>，用来保存创建的线程描述符。此外，bio.c 文件还创建了一个保存互斥锁的数组<code>bio_mutex</code>，以及两个保存条件变量的数组<code>bio_newjob_cond</code>和<code>bio_step_cond</code>。以下代码展示了这些数组的创建逻辑，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">//保存线程描述符的数组</span>
<span class="token keyword">static</span> <span class="token class-name">pthread_t</span> bio_threads<span class="token punctuation">[</span>BIO_NUM_OPS<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//保存互斥锁的数组</span>
<span class="token keyword">static</span> <span class="token class-name">pthread_mutex_t</span> bio_mutex<span class="token punctuation">[</span>BIO_NUM_OPS<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//保存条件变量的两个数组</span>
<span class="token keyword">static</span> <span class="token class-name">pthread_cond_t</span> bio_newjob_cond<span class="token punctuation">[</span>BIO_NUM_OPS<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">static</span> <span class="token class-name">pthread_cond_t</span> bio_step_cond<span class="token punctuation">[</span>BIO_NUM_OPS<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>从中你可以注意到，这些数组的大小都是宏定义 BIO_NUM_OPS，这个宏定义是在<a href="https://github.com/redis/redis/tree/5.0/src/bio.h" target="_blank" rel="noopener noreferrer">bio.h<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>文件中定义的，默认值为 3。</p> <p>同时在 bio.h 文件中，你还可以看到另外三个宏定义，分别是 BIO_CLOSE_FILE、BIO_AOF_FSYNC 和 BIO_LAZY_FREE。它们的代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIO_CLOSE_FILE</span>    <span class="token expression"><span class="token number">0</span> </span><span class="token comment">/* Deferred close(2) syscall. */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIO_AOF_FSYNC</span>    <span class="token expression"><span class="token number">1</span> </span><span class="token comment">/* Deferred AOF fsync. */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIO_LAZY_FREE</span>     <span class="token expression"><span class="token number">2</span> </span><span class="token comment">/* Deferred objects freeing. */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">BIO_NUM_OPS</span>       <span class="token expression"><span class="token number">3</span></span></span>
</code></pre></div><p>其中，BIO_NUM_OPS 表示的是 Redis 后台任务的类型有三种。而 BIO_CLOSE_FILE、BIO_AOF_FSYNC 和 BIO_LAZY_FREE，它们分别表示三种后台任务的操作码，这些操作码可以用来标识不同的任务。</p> <ul><li><strong>BIO_CLOSE_FILE</strong>：文件关闭后台任务</li> <li><strong>BIO_AOF_FSYNC</strong>：AOF 日志同步写回后台任务</li> <li><strong>BIO_LAZY_FREE</strong>：惰性删除后台任务</li></ul> <p>实际上，bio.c 文件创建的线程数组、互斥锁数组和条件变量数组，大小都是包含三个元素，也正是对应了这三种任务。</p> <h3 id="bioinit-函数-初始化数组"><a href="#bioinit-函数-初始化数组" class="header-anchor">#</a> bioInit 函数：初始化数组</h3> <p>接下来，我们再来了解下 bio.c 文件中的初始化和线程创建函数<code>bioInit</code>。我刚才也给你介绍过这个函数，它是<code>main</code>函数执行完<code>server</code>初始化后，通过<code>InitServerLast</code>函数调用的。也就是说，Redis 在完成 server 初始化后，就会创建线程来执行后台任务。</p> <p>所以，<strong>Redis 在运行时其实已经不止是单个线程（也就是主 IO 线程）在运行了，还会有后台线程在运行</strong>。</p> <p><code>bioInit</code>函数首先会初始化互斥锁数组和条件变量数组。然后，该函数会调用<code>listCreate</code>函数，给<code>bio_jobs</code>这个数组的每个元素创建一个列表，同时给<code>bio_pending</code>数组的每个元素赋值为 0。这部分代码如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> BIO_NUM_OPS<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bio_mutex<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bio_newjob_cond<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_cond_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bio_step_cond<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bio_jobs<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">listCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    bio_pending<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么，要想了解给<code>bio_jobs</code>数组和<code>bio_pending</code>数组元素赋值的作用，我们就需要先搞清楚这两个数组的含义：</p> <ul><li><strong>bio_jobs 数组</strong>的元素是<code>bio_jobs</code>结构体类型，用来表示后台任务。该结构体的成员变量包括了后台任务的创建时间 time，以及任务的参数。为该数组的每个元素创建一个列表，其实就是为每个后台线程创建一个要处理的任务列表。</li> <li><strong>bio_pending 数组</strong>的元素类型是<code>unsigned long long</code>，用来表示每种任务中，处于等待状态的任务个数。将该数组每个元素初始化为 0，其实就是表示初始时，每种任务都没有待处理的具体任务。</li></ul> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">bio_job</span> <span class="token punctuation">{</span>
    <span class="token class-name">time_t</span> time<span class="token punctuation">;</span> <span class="token comment">//任务创建时间</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>arg1<span class="token punctuation">,</span> <span class="token operator">*</span>arg2<span class="token punctuation">,</span> <span class="token operator">*</span>arg3<span class="token punctuation">;</span>  <span class="token comment">//任务参数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//以后台线程方式运行的任务列表</span>
<span class="token keyword">static</span> list <span class="token operator">*</span>bio_jobs<span class="token punctuation">[</span>BIO_NUM_OPS<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token comment">//被阻塞的后台任务数组</span>
<span class="token keyword">static</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> bio_pending<span class="token punctuation">[</span>BIO_NUM_OPS<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>好了，到这里，你就了解了<code>bioInit</code>函数执行时，会把线程互斥锁、条件变量对应数组初始化为 NULL，同时会给每个后台线程创建一个任务列表（对应<code>bio_jobs</code>数组的元素），以及会设置每种任务的待处理个数为 0（对应 bio_pending 数组的元素）。</p> <h3 id="bioinit-函数-设置线程属性并创建线程"><a href="#bioinit-函数-设置线程属性并创建线程" class="header-anchor">#</a> bioInit 函数：设置线程属性并创建线程</h3> <p>在完成了初始化之后，接下来，bioInit 函数会先通过 pthread_attr_t 类型的变量，给线程设置属性。然后，bioInit 函数会调用前面我提到的 pthread_create 函数来创建线程。</p> <p>不过，为了能更好地理解 bioInit 函数设置线程属性和创建线程的过程，我们需要先对 pthread_create 函数本身有所了解，该函数的原型如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span>  <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token class-name">pthread_t</span> <span class="token operator">*</span>tidp<span class="token punctuation">,</span> <span class="token keyword">const</span>  <span class="token class-name">pthread_attr_t</span> <span class="token operator">*</span>attr<span class="token punctuation">,</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">*</span>start_routine<span class="token punctuation">)</span><span class="token punctuation">(</span> <span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">void</span>  <span class="token operator">*</span>arg<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>可以看到，pthread_create 函数一共有 4 个参数，分别是：</p> <ul><li><strong>*tidp</strong>，指向线程数据结构 pthread_t 的指针；</li> <li><strong>*attr</strong>，指向线程属性结构 pthread_attr_t 的指针；</li> <li><strong>*start_routine</strong>，线程所要运行的函数的起始地址，也是指向函数的指针；</li> <li><strong>*arg</strong>，传给运行函数的参数。</li></ul> <p>了解了<code>pthread_create</code>函数之后，我们来看下<code>bioInit</code>函数的具体操作。</p> <p>首先，<code>bioInit</code>函数会调用<code>pthread_attr_init</code>函数，初始化线程属性变量<code>attr</code>，然后调用<code>pthread_attr_getstacksize</code>函数，获取线程的栈大小这一属性的当前值，并根据当前栈大小和<code>REDIS_THREAD_STACK_SIZE</code>宏定义的大小（默认值为 4MB），来计算最终的栈大小属性值。紧接着，<code>bioInit</code>函数会调用<code>pthread_attr_setstacksize</code>函数，来设置栈大小这一属性值。</p> <p>下面的代码展示了线程属性的获取、计算和设置逻辑，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">pthread_attr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">pthread_attr_getstacksize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">,</span><span class="token operator">&amp;</span>stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>stacksize<span class="token punctuation">)</span> stacksize <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">/</span>针对Solaris系统做处理
    <span class="token keyword">while</span> <span class="token punctuation">(</span>stacksize <span class="token operator">&lt;</span> REDIS_THREAD_STACK_SIZE<span class="token punctuation">)</span> stacksize <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token function">pthread_attr_setstacksize</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>attr<span class="token punctuation">,</span> stacksize<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>我也画了一张图，展示了线程属性的这一操作过程，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409171542553.png" alt="image-20240917154255497"></p> <p>在完成线程属性的设置后，接下来，<code>bioInit</code>函数会通过一个 for 循环，来依次为每种后台任务创建一个线程。循环的次数是由<code>BIO_NUM_OPS</code>宏定义决定的，也就是 3 次。相应的，<code>bioInit</code>函数就会调用 3 次<code>pthread_create</code>函数，并创建 3 个线程。bioInit 函数让这 3 个线程执行的函数都是**<code>bioProcessBackgroundJobs</code>**。</p> <p>不过这里要注意一点，就是在这三次线程的创建过程中，传给这个函数的参数分别是 0、1、2。这个创建过程如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> BIO_NUM_OPS<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>arg <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> j<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>thread<span class="token punctuation">,</span><span class="token operator">&amp;</span>attr<span class="token punctuation">,</span>bioProcessBackgroundJobs<span class="token punctuation">,</span>arg<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	… <span class="token comment">//报错信息</span>
    <span class="token punctuation">}</span>
    bio_threads<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> thread<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>你看了这个代码，可能会有一个小疑问：<strong>为什么创建的 3 个线程，它们所运行的 bioProcessBackgroundJobs 函数接收的参数分别是 0、1、2 呢？</strong></p> <p>这就和 bioProcessBackgroundJobs 函数的实现有关了，我们来具体看下。</p> <h3 id="bioprocessbackgroundjobs-函数-处理后台任务"><a href="#bioprocessbackgroundjobs-函数-处理后台任务" class="header-anchor">#</a> bioProcessBackgroundJobs 函数：处理后台任务</h3> <p>首先，<code>bioProcessBackgroundJobs</code>函数会把接收到的参数 arg，转成<code>unsigned long</code>类型，并赋值给 type 变量，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">bioProcessBackgroundJobs</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    …
	<span class="token keyword">unsigned</span> <span class="token keyword">long</span> type <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span> arg<span class="token punctuation">;</span>
	…
<span class="token punctuation">}</span>
</code></pre></div><p>而<strong>type 变量表示的就是后台任务的操作码</strong>。这也是我刚才给你介绍的三种后台任务类型 BIO_CLOSE_FILE、BIO_AOF_FSYNC 和 BIO_LAZY_FREE 对应的操作码，它们的取值分别为 0、1、2。</p> <p>bioProcessBackgroundJobs 函数的主要执行逻辑是一个 while(1)的循环。在这个循环中，bioProcessBackgroundJobs 函数会从 bio_jobs 这个数组中取出相应任务，并根据任务类型，调用具体的函数来执行。</p> <p>我刚才已经介绍过，<code>bio_jobs</code>数组的每一个元素是一个队列。而因为<code>bio_jobs</code>数组的元素个数，等于后台任务的类型个数（也就是 BIO_NUM_OPS），<strong>所以，<code>bio_jobs</code>数组的每个元素，实际上是对应了某一种后台任务的任务队列。</strong></p> <p>在了解了这一点后，我们就容易理解<code>bioProcessBackgroundJobs</code>函数中的 while 循环了。因为传给<code>bioProcessBackgroundJobs</code>函数的参数，分别是 0、1、2，对应了三种任务类型，所以在这个循环中，<code>bioProcessBackgroundJobs</code>函数会一直不停地从某一种任务队列中，取出一个任务来执行。</p> <p>同时，bioProcessBackgroundJobs 函数会根据传入的任务操作类型调用相应函数，具体来说：</p> <ul><li>任务类型是 BIO_CLOSE_FILE，则调用 close 函数；</li> <li>任务类型是 BIO_AOF_FSYNC，则调用 redis_fsync 函数；</li> <li>任务类型是 BIO_LAZY_FREE，则再根据参数个数等情况，分别调用 lazyfreeFreeObjectFromBioThread、lazyfreeFreeDatabaseFromBioThread 和 lazyfreeFreeSlotsMapFromBioThread 这三个函数。</li></ul> <p>最后，当某个任务执行完成后，bioProcessBackgroundJobs 函数会从任务队列中，把这个任务对应的数据结构删除。我把这部分代码放在这里，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>

        …
        <span class="token comment">//从类型为type的任务队列中获取第一个任务</span>
        ln <span class="token operator">=</span> <span class="token function">listFirst</span><span class="token punctuation">(</span>bio_jobs<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        job <span class="token operator">=</span> ln<span class="token operator">-&gt;</span>value<span class="token punctuation">;</span>

        …
        <span class="token comment">//判断当前处理的后台任务类型是哪一种</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> BIO_CLOSE_FILE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>job<span class="token operator">-&gt;</span>arg1<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//如果是关闭文件任务，那就调用close函数</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> BIO_AOF_FSYNC<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">redis_fsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>job<span class="token operator">-&gt;</span>arg1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//如果是AOF同步写任务，那就调用redis_fsync函数</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> BIO_LAZY_FREE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">//如果是惰性删除任务，那根据任务的参数分别调用不同的惰性删除函数执行</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>job<span class="token operator">-&gt;</span>arg1<span class="token punctuation">)</span>
                <span class="token function">lazyfreeFreeObjectFromBioThread</span><span class="token punctuation">(</span>job<span class="token operator">-&gt;</span>arg1<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>job<span class="token operator">-&gt;</span>arg2 <span class="token operator">&amp;&amp;</span> job<span class="token operator">-&gt;</span>arg3<span class="token punctuation">)</span>
                <span class="token function">lazyfreeFreeDatabaseFromBioThread</span><span class="token punctuation">(</span>job<span class="token operator">-&gt;</span>arg2<span class="token punctuation">,</span>job<span class="token operator">-&gt;</span>arg3<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>job<span class="token operator">-&gt;</span>arg3<span class="token punctuation">)</span>
                <span class="token function">lazyfreeFreeSlotsMapFromBioThread</span><span class="token punctuation">(</span>job<span class="token operator">-&gt;</span>arg3<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">&quot;Wrong job type in bioProcessBackgroundJobs().&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        …
        <span class="token comment">//任务执行完成后，调用 listDelNode 在任务队列中删除该任务</span>
        <span class="token function">listDelNode</span><span class="token punctuation">(</span>bio_jobs<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">,</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//将对应的等待任务个数减一。</span>
        bio_pending<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>
        …
<span class="token punctuation">}</span>
</code></pre></div><p>所以说，bioInit 函数其实就是创建了 3 个线程，每个线程不停地去查看任务队列中是否有任务，如果有任务，就调用具体函数执行。</p> <p>你可以再参考回顾下图所展示的<code>bioInit</code>函数和<code>bioProcessBackgroundJobs</code>函数的基本处理流程。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409171543650.png" alt="image-20240917154318564"></p> <p>不过接下来你或许还会疑惑：既然 bioProcessBackgroundJobs 函数是负责执行任务的，<strong>那么哪个函数负责生成任务呢？</strong></p> <p>这就是下面，我要给你介绍的 <strong>后台任务创建函数 bioCreateBackgroundJob</strong></p> <h3 id="biocreatebackgroundjob-函数-创建后台任务"><a href="#biocreatebackgroundjob-函数-创建后台任务" class="header-anchor">#</a> bioCreateBackgroundJob 函数：创建后台任务</h3> <p><code>bioCreateBackgroundJob</code>函数的原型如下，它会接收 4 个参数，其中，参数 type 表示该后台任务的类型，剩下来的 3 个参数，则对应了后台任务函数的参数，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">bioCreateBackgroundJob</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg1<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg2<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>arg3<span class="token punctuation">)</span>
</code></pre></div><p><code>bioCreateBackgroundJob</code>函数在执行时，会先创建<code>bio_job</code>，这是后台任务对应的数据结构。然后，后台任务数据结构中的参数，会被设置为<code>bioCreateBackgroundJob</code>函数传入的参数 arg1、arg2 和 arg3。</p> <p>最后，<code>bioCreateBackgroundJob</code>函数调用<code>listAddNodeTail</code>函数，将刚才创建的任务加入到对应的<code>bio_jobs</code>队列中，同时，将<code>bio_pending</code>数组的对应值加 1，表示有个任务在等待执行。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token punctuation">{</span>
    <span class="token comment">//创建新的任务</span>
    <span class="token keyword">struct</span> <span class="token class-name">bio_job</span> <span class="token operator">*</span>job <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>job<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//设置任务数据结构中的参数</span>
    job<span class="token operator">-&gt;</span>time <span class="token operator">=</span> <span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    job<span class="token operator">-&gt;</span>arg1 <span class="token operator">=</span> arg1<span class="token punctuation">;</span>
    job<span class="token operator">-&gt;</span>arg2 <span class="token operator">=</span> arg2<span class="token punctuation">;</span>
    job<span class="token operator">-&gt;</span>arg3 <span class="token operator">=</span> arg3<span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bio_mutex<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">listAddNodeTail</span><span class="token punctuation">(</span>bio_jobs<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">,</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将任务加到bio_jobs数组的对应任务列表中</span>
    bio_pending<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//将对应任务列表上等待处理的任务个数加1</span>
    <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bio_newjob_cond<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>bio_mutex<span class="token punctuation">[</span>type<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好了，这样一来，当 Redis 进程想要启动一个后台任务时，只要调用<code>bioCreateBackgroundJob</code>函数，并设置好该任务对应的类型和参数即可。然后，<code>bioCreateBackgroundJob</code>函数就会把创建好的任务数据结构，放到后台任务对应的队列中。另一方面，<code>bioInit</code>函数在 Redis server 启动时，创建的线程会不断地轮询后台任务队列，一旦发现有任务可以执行，就会将该任务取出并执行。</p> <p>其实，这种设计方式是典型的<strong>生产者-消费者模型</strong>。<code>bioCreateBackgroundJob</code>函数是生产者，负责往每种任务队列中加入要执行的后台任务，而<code>bioProcessBackgroundJobs</code>函数是消费者，负责从每种任务队列中取出任务来执行。然后 Redis 创建的后台线程，会调用<code>bioProcessBackgroundJobs</code>函数，从而实现一直循环检查任务队列。</p> <p>下图展示的就是<code>bioCreateBackgroundJob</code>和<code>bioProcessBackgroundJobs</code>两者间的生产者-消费者模型，你可以看下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409171543295.png" alt="image-20240917154355237"></p> <p>好了，到这里，我们就学习了 Redis 后台线程的创建和运行机制。简单来说，主要是以下三个关键点：</p> <ul><li>Redis 是先通过 <code>bioInit</code> 函数初始化和创建后台线程</li> <li>后台线程运行的是 <code>bioProcessBackgroundJobs</code> 函数，这个函数会轮询任务队列，并根据要处理的任务类型，调用相应函数进行处理</li> <li>后台线程要处理的任务是由 <code>bioCreateBackgroundJob</code>函数来创建的，这些任务创建后会被放到任务队列中，等待<code>bioProcessBackgroundJobs</code> 函数处理</li></ul> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>echo 你介绍了 Redis 的执行模型，并且也从源码的角度出发，通过分析代码，带你了解了 Redis 进程创建、以子进程方式创建的守护进程、以及后台线程和它们负责的工作任务。同时，这也解答了你在面试中可能经常会被问到的问题：<strong>Redis 是单线程程序吗？</strong></p> <p>事实上，Redis server 启动后，它的主要工作包括接收客户端请求、解析请求和进行数据读写等操作，是由单线程来执行的，这也是我们常说 Redis 是单线程程序的原因。</p> <p>但是，学完这节课你应该也知道，Redis 还启动了 3 个线程来执行文件关闭、AOF 同步写和惰性删除等操作，从这个角度来说，Redis 又不能算单线程程序，它还是有多线程的。</p> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li><p><a href="https://time.geekbang.org/column/intro/100084301?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noopener noreferrer">极客时间：Redis源码剖析与实战<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener noreferrer">Redis设计与实现 <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://github.com/redis/redis/blob/5.0/src/ae.c" target="_blank" rel="noopener noreferrer">Github：redis 源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/Redis 系统设计/03.三、主线任务/09.Redis 的执行模式.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新于:</span> <span class="time">2024/09/18, 11:29:27</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/264b06/" class="prev">深入 Redis 事件驱动框架</a></span> <span class="next"><a href="/pages/0850b6/">Redis 多IO线程</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.9830b779.js" defer></script><script src="/assets/js/2.933750c6.js" defer></script><script src="/assets/js/69.7ac52a2f.js" defer></script><script src="/assets/js/7.7eb70372.js" defer></script>
  </body>
</html>
