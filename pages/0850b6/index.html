<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis 多IO线程 | EchoDesign</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="系统设计之「讲解 + 面试指南」，水滴石穿，设计无银弹！">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.c76c3453.css" as="style"><link rel="preload" href="/assets/js/app.bdcc6820.js" as="script"><link rel="preload" href="/assets/js/2.933750c6.js" as="script"><link rel="preload" href="/assets/js/70.b920a5f7.js" as="script"><link rel="preload" href="/assets/js/7.7eb70372.js" as="script"><link rel="prefetch" href="/assets/js/10.2cc95be8.js"><link rel="prefetch" href="/assets/js/100.152e23f6.js"><link rel="prefetch" href="/assets/js/101.99b73fec.js"><link rel="prefetch" href="/assets/js/11.c7521a10.js"><link rel="prefetch" href="/assets/js/12.38d1989d.js"><link rel="prefetch" href="/assets/js/13.850793b0.js"><link rel="prefetch" href="/assets/js/14.1141ec27.js"><link rel="prefetch" href="/assets/js/15.8f1b4081.js"><link rel="prefetch" href="/assets/js/16.e52ba8b4.js"><link rel="prefetch" href="/assets/js/17.acb3bf3d.js"><link rel="prefetch" href="/assets/js/18.5df2a013.js"><link rel="prefetch" href="/assets/js/19.571eaed1.js"><link rel="prefetch" href="/assets/js/20.fe7d08c7.js"><link rel="prefetch" href="/assets/js/21.0e0ed140.js"><link rel="prefetch" href="/assets/js/22.dd779f94.js"><link rel="prefetch" href="/assets/js/23.4d814163.js"><link rel="prefetch" href="/assets/js/24.e94253bb.js"><link rel="prefetch" href="/assets/js/25.1d172890.js"><link rel="prefetch" href="/assets/js/26.6337eac0.js"><link rel="prefetch" href="/assets/js/27.eeee1d20.js"><link rel="prefetch" href="/assets/js/28.6fa848cf.js"><link rel="prefetch" href="/assets/js/29.4ff6fa35.js"><link rel="prefetch" href="/assets/js/3.08ee786a.js"><link rel="prefetch" href="/assets/js/30.892b2994.js"><link rel="prefetch" href="/assets/js/31.df4cc39d.js"><link rel="prefetch" href="/assets/js/32.f1174703.js"><link rel="prefetch" href="/assets/js/33.64ab8d0c.js"><link rel="prefetch" href="/assets/js/34.405ab364.js"><link rel="prefetch" href="/assets/js/35.8287c9dc.js"><link rel="prefetch" href="/assets/js/36.be98cc35.js"><link rel="prefetch" href="/assets/js/37.82be3556.js"><link rel="prefetch" href="/assets/js/38.40fe2658.js"><link rel="prefetch" href="/assets/js/39.6e2f31a6.js"><link rel="prefetch" href="/assets/js/4.73518a0f.js"><link rel="prefetch" href="/assets/js/40.0ada49bd.js"><link rel="prefetch" href="/assets/js/41.fcee3e0f.js"><link rel="prefetch" href="/assets/js/42.f5fdb401.js"><link rel="prefetch" href="/assets/js/43.5a509601.js"><link rel="prefetch" href="/assets/js/44.64fd3383.js"><link rel="prefetch" href="/assets/js/45.685623ac.js"><link rel="prefetch" href="/assets/js/46.7624d38c.js"><link rel="prefetch" href="/assets/js/47.cc86aae6.js"><link rel="prefetch" href="/assets/js/48.ba7dfd47.js"><link rel="prefetch" href="/assets/js/49.15d8e916.js"><link rel="prefetch" href="/assets/js/5.94727770.js"><link rel="prefetch" href="/assets/js/50.b424b2c0.js"><link rel="prefetch" href="/assets/js/51.ef213b56.js"><link rel="prefetch" href="/assets/js/52.24cc5c91.js"><link rel="prefetch" href="/assets/js/53.16def11d.js"><link rel="prefetch" href="/assets/js/54.8604fc24.js"><link rel="prefetch" href="/assets/js/55.78a9171b.js"><link rel="prefetch" href="/assets/js/56.94e28708.js"><link rel="prefetch" href="/assets/js/57.9f8a974b.js"><link rel="prefetch" href="/assets/js/58.24008d78.js"><link rel="prefetch" href="/assets/js/59.28ca51b4.js"><link rel="prefetch" href="/assets/js/6.0b558b79.js"><link rel="prefetch" href="/assets/js/60.1714dba8.js"><link rel="prefetch" href="/assets/js/61.08b4acf0.js"><link rel="prefetch" href="/assets/js/62.cc8fdced.js"><link rel="prefetch" href="/assets/js/63.41ff19e4.js"><link rel="prefetch" href="/assets/js/64.9b3def35.js"><link rel="prefetch" href="/assets/js/65.0b2ab47d.js"><link rel="prefetch" href="/assets/js/66.2ae7a107.js"><link rel="prefetch" href="/assets/js/67.79dd6daf.js"><link rel="prefetch" href="/assets/js/68.c27f5109.js"><link rel="prefetch" href="/assets/js/69.5f61d937.js"><link rel="prefetch" href="/assets/js/71.f44644ed.js"><link rel="prefetch" href="/assets/js/72.9a370df8.js"><link rel="prefetch" href="/assets/js/73.bc16a468.js"><link rel="prefetch" href="/assets/js/74.d9ad1a67.js"><link rel="prefetch" href="/assets/js/75.7c86d41a.js"><link rel="prefetch" href="/assets/js/76.15a7bb60.js"><link rel="prefetch" href="/assets/js/77.c89b4964.js"><link rel="prefetch" href="/assets/js/78.c0a4ffae.js"><link rel="prefetch" href="/assets/js/79.0906d2fb.js"><link rel="prefetch" href="/assets/js/8.0ec7f6e8.js"><link rel="prefetch" href="/assets/js/80.fdcb5fa1.js"><link rel="prefetch" href="/assets/js/81.711911b1.js"><link rel="prefetch" href="/assets/js/82.e54c087e.js"><link rel="prefetch" href="/assets/js/83.65db62ac.js"><link rel="prefetch" href="/assets/js/84.e5207e82.js"><link rel="prefetch" href="/assets/js/85.4cd3a775.js"><link rel="prefetch" href="/assets/js/86.931cbb70.js"><link rel="prefetch" href="/assets/js/87.47ba635a.js"><link rel="prefetch" href="/assets/js/88.93192130.js"><link rel="prefetch" href="/assets/js/89.e05e3a70.js"><link rel="prefetch" href="/assets/js/9.6e274fca.js"><link rel="prefetch" href="/assets/js/90.ca1ff100.js"><link rel="prefetch" href="/assets/js/91.8ad18b18.js"><link rel="prefetch" href="/assets/js/92.ec3a28ed.js"><link rel="prefetch" href="/assets/js/93.f8975bc4.js"><link rel="prefetch" href="/assets/js/94.1eade7f0.js"><link rel="prefetch" href="/assets/js/95.96f5db04.js"><link rel="prefetch" href="/assets/js/96.5ed2d348.js"><link rel="prefetch" href="/assets/js/97.4d4bfff5.js"><link rel="prefetch" href="/assets/js/98.18f62eb7.js"><link rel="prefetch" href="/assets/js/99.7d84cc97.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c76c3453.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="EchoDesign" class="logo"> <span class="site-name can-hide">EchoDesign</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 系统设计</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 系统设计</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>一、前言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二、基础知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>三、主线任务</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/34fa27/" class="sidebar-link">Linux 中的 IO 多路复用</a></li><li><a href="/pages/d4ecb9/" class="sidebar-link">Redis Server 初始化</a></li><li><a href="/pages/d6b00d/" class="sidebar-link">Redis 的 Reactor 模型</a></li><li><a href="/pages/264b06/" class="sidebar-link">深入 Redis 事件驱动框架</a></li><li><a href="/pages/e6d8ef/" class="sidebar-link">Redis 的执行模式</a></li><li><a href="/pages/0850b6/" aria-current="page" class="active sidebar-link">Redis 多IO线程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/0850b6/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/0850b6/#单线程-io-及其缺陷" class="sidebar-link">单线程 IO 及其缺陷</a></li><li class="sidebar-sub-header level2"><a href="/pages/0850b6/#redis-多线程-io-的工作原理" class="sidebar-link">Redis 多线程 IO 的工作原理</a></li><li class="sidebar-sub-header level2"><a href="/pages/0850b6/#redis-多线程-io-核心源码解析" class="sidebar-link">Redis 多线程 IO 核心源码解析</a></li><li class="sidebar-sub-header level2"><a href="/pages/0850b6/#redis-多线程-io-的性能调优与实际问题" class="sidebar-link">Redis 多线程 IO 的性能调优与实际问题</a></li><li class="sidebar-sub-header level2"><a href="/pages/0850b6/#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level2"><a href="/pages/0850b6/#参考文献" class="sidebar-link">参考文献</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>四、支线任务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>五、集群</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Redis 系统设计</span></li><li data-v-06225672><span data-v-06225672>三、主线任务</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-17</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABKFJREFUSA3tVl1oFVcQnrMbrak3QUgkya1akpJYcrUtIqW1JvFBE9LiQ5v6JmJpolbMg32rVrhgoYK0QiMY6i9Y6EMaW5D+xFJaTYItIuK2Kr3+BJNwkxBj05sQY3b3nM6cs2dv9t7NT/vQJw/sndk5M/PNzJkzewGerP+pAmy+ON8lLzUJgA8ZYxYIYZmGYRnctDaWvJJAmTtfP1pvXsBCCPP8QFcCaRkZYACgDZFO4stNIcBCajEOlmmC9XpJ9bAGCaPaPmzPl32dvLSVu3BWCTQs0XQQ6g0DYgwLIoAZbBCdW/i+781o1VVlm/410mw4h06Y7bIPHNyWDyL4FHkX03Q8SrzNhZTZriieckWt7cL6MM85YcLpsi/7O9/iXFT6MswI0DmmpkSaJ0qLxFIm3+i1THHB3zmBH3PYx9CcykcLOeQVVa7QtdxTgQgEleX2AjHYfwA+2ddV77ruGoJUbhGDI09YSNXyMpUt5ylOzxgbUmtOp7NmbNt8v3arjTBfYELmLUV+M+nSawNNAUqpT3ClJWg5I3BLT+cGW/DXNGCa6tx1aakCGEigArTn4TDIPdrXXYKCZNrHLMCOEPvHBlLQ99s9eHB7EB6NTki73CVPQ2F5MSx/uRQixfmq7rK0wYD8w8E905bnPDfwoWs/rfv93NWN/ZfvwsLIU7A09gxECyISeGJkHAau98L97tuw7NXnoPyNF8FcYGLGKsOs0mN3OEyec9esGW/ZEl945dTP34wlR2FZVQWU1q0Cw8Tr7p+hgLLNL0FPxx/Q35mA8aEUrH6nCgwEl0tn7wUiZYJnNRh6DK4UH/k0lfyrsBKdPVv/AriGIQcEDQZ65LBAGe2Rzui9Ybjz7XUppz1/uKBbyVPGkN3ZAeC6hr0x7Nr38N5+EqkoOm17xpoqR9ohQF55ERSvr4Dkr3chNfC3DMzGJlNBElW8w9nsGQvhNGIzDkXzCg8cLK951xHsFBlTJspJNi3ZFIMF2AeDV3q8DNOB+YHi6QTrChDIWDBRi5U5f+ZMfJLu3ccrqxtdxk4SKH336LFxSmkqefwU5T8fhdSdQf9IVKD6aNiwI/hnmcAZ91isYMJIaCUCx9W098+LgruikeTqzqqxKPUwqJyCPJiyemVVZBOijDGjD38Os0jOiSPL1z3SPjXNANbiNPXAdzTfukjjuknNBbyz3nwgTd3AVFqUJ5hpHlq9MveLnWwttUfoygBmvVjuikxND3znrhsELnZk7k+OjIGxeNEkomyLVta0xxn+HZhjBc4YZ/AFjHjz9u3xRZl2BN4aq9nFwWh16IrQ1aHHEd3j1+4/dB9OtH4e29A2H1DyHQRmOSfQZ1Fy7MHBTGB6J/Djq6p3OxyO2cB+4Car7v/o3GXgfAkj23+x9ID1Teoamo/SXcbvSf2PX7Vc8DdCmE1vN9di+32P9/5YR3vLnhCVGUWBjEkr3yh4H8v9CzmsbdhzOKzsJKM90iFdaTMjRPhGVsakRvOaRidljo6H6G7j+ctrJpsP+4COhDIl0La2+FS4+5mlocBaXY5QnGZysIBYoeSsl5qQzrSj/cgNrfuEzlWBfwA+EjrZyWUvpAAAAABJRU5ErkJggg==">Redis 多IO线程<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><div class="custom-block note"><p class="custom-block-title">提出问题是一切智慧的开端</p> <ol><li>为什么 Redis 从单线程演变到多线程？单线程模式的瓶颈在哪里？</li> <li>Redis 6.0 引入多线程 IO 的主要原理是什么？它如何提升性能？</li> <li>多线程 IO 是如何在 Redis 中分担读写任务的？与单线程 IO 有哪些关键区别？</li> <li>在 Redis 6.0 中，哪些情况下适合启用多线程 IO，线程数该如何配置？</li> <li>Redis 如何利用多线程机制分配和处理客户端请求？具体流程是怎样的？</li> <li>多线程 IO 如何解决单线程模式下的性能瓶颈？有哪些场景下效果最显著？</li> <li>什么是 Redis 多线程 IO 的主要性能优化点？如何避免潜在的问题？</li> <li>多 IO 线程对 Redis 命令执行的影响有哪些？是否会带来新的并发挑战？</li></ol></div> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>复杂的架构系统通常是逐渐演进的，从单线程到多线程，从单体应用到复杂功能的分布式系统，Redis 也经历了类似的发展历程。</p> <p>在单线程模式下，Redis 能够实现极高的吞吐量，但在某些情况下，处理时间可能会显著增加，导致性能下降。为了解决这些问题，Redis 引入了后台线程来处理一些耗时的操作。随着对更高吞吐量的需求增加，网络模块也成为瓶颈，因此 Redis 在 6.0 版本中引入了多线程来解决这个问题——这也是本文主要探讨的内容。</p> <p>本文内容包括：</p> <ol><li>早期单线程 IO 处理过程及其缺点</li> <li>Redis 多线程 IO 的工作原理</li> <li>Redis 多线程 IO 核心源码解析</li></ol> <div class="custom-block warning"><p class="custom-block-title">注意</p> <p>请下载 <a href="https://github.com/redis/redis/tree/6.0" target="_blank" rel="noopener noreferrer">Redis 6.0.15<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 的源码，以便查看与多 IO 线程机制相关的代码。</p></div> <h2 id="单线程-io-及其缺陷"><a href="#单线程-io-及其缺陷" class="header-anchor">#</a> 单线程 IO 及其缺陷</h2> <h3 id="异步处理"><a href="#异步处理" class="header-anchor">#</a> 异步处理</h3> <p>Redis 的核心负载由单线程处理，但为何其性能仍能如此优异？</p> <ul><li><strong>纯内存操作</strong>：Redis 的操作大多在内存中完成。</li> <li><strong>非阻塞 IO</strong>：Redis 使用非阻塞的 IO 机制。</li> <li><strong>异步 IO 处理</strong>：每个命令在接收、处理和返回的过程中，经过多个“不连续”的步骤。</li></ul> <blockquote><p>需要特别指出的是，此处的“异步处理”并非指同步/异步 IO，而是指 IO 处理过程的异步化，即各个处理步骤之间不是同步执行的，而是通过事件循环机制和非阻塞 IO，使 Redis 能在单线程环境下高效处理多个请求。</p></blockquote> <p>假设客户端发送以下命令：</p> <div class="language-c extra-class"><pre class="language-c"><code>GET key<span class="token operator">-</span>how<span class="token operator">-</span>to<span class="token operator">-</span>be<span class="token operator">-</span>a<span class="token operator">-</span>better<span class="token operator">-</span>man
</code></pre></div><p>Redis 的回应是：</p> <div class="language-c extra-class"><pre class="language-c"><code>努力加把劲把文章写完
</code></pre></div><p>处理这个命令的过程包括以下几个步骤：</p> <ul><li><strong>接收</strong>：通过 TCP 接收命令，可能经历多次 TCP 包、确认应答 (ack) 和 IO 操作。</li> <li><strong>解析</strong>：从接收到的数据中提取命令。</li> <li><strong>执行</strong>：读取指定位置的值。</li> <li><strong>返回</strong>：通过 TCP 返回值给客户端。如果值较大，IO 负载也更重。</li></ul> <p>其中，解析和执行步骤主要是 CPU 和内存操作，而接收和返回主要涉及 IO 操作，这是我们关注的重点。以接收为例，Redis 采用了两种策略：</p> <ul><li><strong>同步处理</strong>：在接收完整命令之前，始终保持等待状态，接收到完整命令后才进行处理，然后返回结果。在网络状况不佳时，这种方法可能会导致较长的等待时间。</li> <li><strong>异步处理</strong>：通过非阻塞 IO 和事件循环机制，在处理一个请求时，Redis 可以继续处理其他请求，从而避免了阻塞等待。Redis 使用高效的事件驱动机制（如 epoll）来监控 IO 事件，从而提高单线程下的并发处理能力。</li></ul> <p>以下是对异步处理的类比：</p> <ul><li><strong>同步</strong>：当聊天框显示“正在输入”时，你需要等对方输入完成后，才能回答对方的问题。完成回答后，才会转向其他人。</li> <li><strong>异步</strong>：当聊天框显示“正在输入”时，你可以回答其他已完成输入的问题，而不必等对方输入完成，待对方输入完成后再继续回答其他问题。</li></ul> <p>显然，异步处理的效率更高，因为同步处理在等待上浪费了时间。异步处理策略总结如下：</p> <ul><li>在网络包到达时立即读取并放入缓冲区，读取完成后立即进行其他操作，而不等待下一个包。</li> <li>解析缓冲区中的数据是否完整。若数据完整，则执行命令；若不完整，则继续处理其他任务。</li> <li>数据完整后立即执行命令，将结果放入缓冲区。</li> <li>将数据返回给客户端。如果一次不能全部发送，则等到可以发送时再继续发送，直到全部发送完毕。</li></ul> <h3 id="事件驱动"><a href="#事件驱动" class="header-anchor">#</a> 事件驱动</h3> <p>尽管异步处理避免了零散的等待时间，但如何得知“网络包有数据”或“下次可以发送数据”呢？如果通过轮询检查这些时机，效率会很低。Redis 使用事件驱动机制来解决这一问题。</p> <p>事件驱动框架能够高效地通知 Redis 在何时需要处理事件。Redis 通过事件驱动机制（如 epoll）来监听和处理事件。Linux 中的 epoll 机制专为高效通知而设计。Redis 基于 epoll 等机制抽象出了一套事件驱动框架，整个服务器由事件驱动，当事件发生时进行处理，无事件时则处于空闲状态。</p> <ul><li><strong><code>可读</code>事件</strong>：表示对应的 socket 中有新的 TCP 数据包到达。</li> <li><strong><code>可写</code>事件</strong>：表示对应的 socket 的写缓冲区已经空了（数据已通过网络发送给客户端）。</li></ul> <p>处理流程如下：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409172227893.webp" alt="img"></p> <ul><li><code>aeMain()</code> 内部为一个死循环，在 <code>epoll_wait</code> 处短暂休眠。</li> <li><code>epoll_wait</code> 返回当前可读、可写的 socket 列表。</li> <li><code>beforeSleep</code> 是进入休眠前执行的逻辑，主要是将数据回写到 socket。</li> <li>核心逻辑由 IO 事件触发，可能是可读事件，也可能是可写事件，否则执行定时任务。</li> <li>第一次的 IO 可读事件是监听 socket（如监听 6379 端口），当有握手请求时，执行 <code>accept</code> 调用，获取一个连接 socket，并注册可读回调 <code>createClient</code>，此后客户端与 Redis 的数据通过该 socket 进行传输。</li> <li>一个完整的命令可能通过多次 <code>readQueryFromClient</code> 读取完毕，意味着会有多次可读 IO 事件。</li> <li>命令执行结果也可能需要通过多次写操作完成。</li> <li>命令执行完毕后，对应的连接会被加入 <code>clients_pending_write</code>，<code>beforeSleep</code> 会尝试回写到 socket，若写不完则注册可写事件，下次继续写。</li> <li>整个过程中的 IO 全部是同步非阻塞的，没有时间浪费。</li></ul> <h3 id="单线程-io-的瓶颈"><a href="#单线程-io-的瓶颈" class="header-anchor">#</a> 单线程 IO 的瓶颈</h3> <p>尽管单线程 IO 处理过程避免了等待时间的浪费，并能实现较高的 QPS，但仍然存在一些瓶颈：</p> <ul><li><strong>仅使用一个 CPU 核心</strong>（忽略后台线程）。</li> <li>当数据量较大时，Redis 的 QPS 可能会显著下降，有时一个大的 key 会拖垮整个系统。</li> <li>难以进一步提升 QPS。</li></ul> <p>Redis 主线程的时间消耗主要集中在以下两个方面：</p> <ul><li><strong>逻辑计算消耗</strong></li> <li><strong>同步 IO 读写消耗</strong>，包括数据拷贝的消耗。</li></ul> <p>当数据量较大时，瓶颈主要出现在同步 IO 上（假设带宽和内存充足）。主要的消耗包括：</p> <ul><li>从 socket 中读取请求数据时，会将数据从内核态拷贝到用户态（<code>read</code> 调用）。</li> <li>将数据回写到 socket 时，会将数据从用户态拷贝到内核态（<code>write</code> 调用）。</li></ul> <p>这些数据读写操作会占用大量 CPU 时间，并直接导致性能瓶颈。如果能通过多线程来分担这些消耗，Redis 的吞吐量有望得到显著提升，这也是 Redis 引入多线程 IO 的主要目的。</p> <h2 id="redis-多线程-io-的工作原理"><a href="#redis-多线程-io-的工作原理" class="header-anchor">#</a> Redis 多线程 IO 的工作原理</h2> <p>接下来将目光放到： 如何用多线程分担IO的负荷。其做法用简单的话来说就是：</p> <ul><li>用一组单独的线程专门进行 read/write socket读写调用 （同步IO）</li> <li>读回调函数中不再读数据，而是将对应的连接追加到可读 clients_pending_read 的链表</li> <li>主线程在 beforeSleep 中将IO读任务分给IO线程组</li> <li>主线程自己也处理一个 IO 读任务，并自旋式等 IO 线程组处理完，再继续往下</li> <li>主线程在 beforeSleep 中将 IO 写任务分给IO线程组</li> <li>主线程自己也处理一个 IO 写任务，并自旋式等 IO 线程组处理完，再继续往下</li> <li>IO线程组要么同时在读，要么同时在写</li> <li>命令的执行由主线程串行执行（保持单线程）</li> <li>IO线程数量可配置</li></ul> <p>完整流程图如下：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409172051604.webp" alt="img"></p> <p>beforesleep 中，先让 IO 线程读数据，然后再让 IO 线程写数据。 读写时，多线程能并发执行，利用多核。</p> <ol><li>将读任务均匀分发到各个IO线程的任务链表 io_threads_list[i]，将 io_threads_pending[i] 设置为对应的任务数，此时 IO 线程将从死循环中被激活，开始执行任务，执行完毕后，会将 io_threads_pending[i] 清零。 函数名为： handleClientsWithPendingReadsUsingThreads</li> <li>将写任务均匀分发到各个IO线程的任务链表 io_threads_list[i]，将io_threads_pending[i] 设置为对应的任务数，此时IO线程将从死循环中被激活，开始执行任务，执行完毕后，会将 io_threads_pending[i]清零。 函数名为： handleClientsWithPendingWritesUsingThreads</li> <li>beforeSleep中主线程也会执行其中一个任务，执行完后自旋等待 IO 线程处理完。</li> <li>读任务要么在 beforeSleep 中被执行，要么在 IO 线程被执行，不会再在读回调中执行</li> <li>写任务会分散到 beforeSleep、IO线程、写回调中执行</li> <li>主线程和 IO 线程交互是无锁的，通过标志位设置进行，不会同时写任务链表</li></ol> <h2 id="redis-多线程-io-核心源码解析"><a href="#redis-多线程-io-核心源码解析" class="header-anchor">#</a> Redis 多线程 IO 核心源码解析</h2> <h3 id="_1、初始化-io-线程"><a href="#_1、初始化-io-线程" class="header-anchor">#</a> 1、初始化 IO 线程</h3> <p>在 <a href="">Redis 的执行模式</a> 中提到：Redis 5.0 版本中的三个后台线程是在 <code>server.c</code> 文件的 <code>main</code> 函数启动的最后阶段调用 <code>InitServerLast</code> 函数来初始化的，而 <code>InitServerLast</code> 函数则进一步调用 <code>bioInit</code> 函数来完成初始化。</p> <p>在 Redis 6.0 中，<code>InitServerLast</code> 函数在调用 <code>bioInit</code> 后，新增了对 <code>initThreadedIO</code> 函数的调用，以初始化多线程 IO 机制。</p> <p><code>initThreadedIO</code> 函数用于初始化多 IO 线程，其代码实现如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// server.c#InitServerLast</span>
<span class="token keyword">void</span> <span class="token function">InitServerLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">bioInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">initThreadedIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">set_jemalloc_bg_thread</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>jemalloc_bg_thread<span class="token punctuation">)</span><span class="token punctuation">;</span>
    server<span class="token punctuation">.</span>initial_memory_usage <span class="token operator">=</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p><code>bioInit</code> 函数用于初始化 Redis 的后台 IO 线程，处理如 RDB/AOF 持久化等耗时操作。而 <code>initThreadedIO</code> 函数在此基础上进一步初始化多线程 IO 机制，以支持更高效的客户端请求处理。</p></blockquote> <p><code>initThreadedIO</code> 函数的主要任务是初始化 IO 线程，其代码实现如下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// networking.c#initThreadedIO</span>
<span class="token keyword">void</span> <span class="token function">initThreadedIO</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    server<span class="token punctuation">.</span>io_threads_active <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* 初始化时线程未激活。 */</span>

    <span class="token comment">/* 如果用户选择了单线程，则不创建额外线程：
     * 所有 I/O 操作将由主线程处理。 */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_num <span class="token operator">&gt;</span> IO_THREADS_MAX_NUM<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">&quot;致命错误：配置了过多的 I/O 线程。&quot;</span>
                             <span class="token string">&quot;最大允许数量为 %d。&quot;</span><span class="token punctuation">,</span> IO_THREADS_MAX_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* 创建并初始化 I/O 线程。 */</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 对所有线程（包括主线程）执行的操作。 */</span>
        io_threads_list<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">listCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span> <span class="token comment">/* 线程 0 是主线程。 */</span>

        <span class="token comment">/* 对额外线程执行的操作。 */</span>
        <span class="token class-name">pthread_t</span> tid<span class="token punctuation">;</span>
        <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>io_threads_mutex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setIOPendingCount</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>io_threads_mutex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 线程将被暂停。 */</span>
        <span class="token comment">// 创建线程，并指定处理方法 IOThreadMain</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span>IOThreadMain<span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">serverLog</span><span class="token punctuation">(</span>LL_WARNING<span class="token punctuation">,</span><span class="token string">&quot;致命错误：无法初始化 IO 线程。&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        io_threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tid<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ol><li>首先，<code>initThreadedIO</code> 函数会设置 IO 线程的激活标志。</li> <li>随后，<code>initThreadedIO</code> 函数对设置的 IO 线程数量进行检查：
<ol><li>如果 IO 线程数量为 1，则表示只有一个主线程，<code>initThreadedIO</code> 函数将直接返回。在这种情况下，Redis server 的 IO 线程配置与 Redis 6.0 之前的版本相同。</li> <li>如果 IO 线程数量超过宏定义 <code>IO_THREADS_MAX_NUM</code>（默认值为 128），<code>initThreadedIO</code> 函数会报错并退出程序。</li> <li>如果 IO 线程数量在 1 和 <code>IO_THREADS_MAX_NUM</code> 之间，<code>initThreadedIO</code> 函数会执行一个循环，该循环次数等于设置的 IO 线程数量（<strong>注意</strong>，<code>i == 0</code> 表示主线程）。</li></ol></li></ol> <blockquote><p><code>IO_THREADS_MAX_NUM</code> 是一个宏定义，表示 Redis 支持的最大 IO 线程数量，默认值为 128。这一限制旨在防止过多线程对系统性能造成负担。</p></blockquote> <p>在该循环中，<code>initThreadedIO</code> 函数会对以下四个数组进行初始化：</p> <ul><li><strong>io_threads_list 数组</strong>：保存每个 IO 线程要处理的客户端列表，数组的每个元素初始化为一个 <code>List</code> 类型的列表。</li> <li><strong>io_threads_pending 数组</strong>：保存等待每个 IO 线程处理的客户端数量。</li> <li><strong>io_threads_mutex 数组</strong>：保存线程的互斥锁。</li> <li><strong>io_threads 数组</strong>：保存每个 IO 线程的描述符。</li></ul> <p>这些数组的定义都在 <code>networking.c</code> 文件中，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token class-name">pthread_t</span> io_threads<span class="token punctuation">[</span>IO_THREADS_MAX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment">// 记录线程描述符的数组</span>
<span class="token class-name">pthread_mutex_t</span> io_threads_mutex<span class="token punctuation">[</span>IO_THREADS_MAX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 记录线程互斥锁的数组</span>
<span class="token keyword">_Atomic</span> <span class="token keyword">unsigned</span> <span class="token keyword">long</span> io_threads_pending<span class="token punctuation">[</span>IO_THREADS_MAX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 记录线程待处理的客户端数量</span>
list <span class="token operator">*</span>io_threads_list<span class="token punctuation">[</span>IO_THREADS_MAX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 记录线程对应处理的客户端列表</span>
</code></pre></div><p>在对这些数组进行初始化的同时，<code>initThreadedIO</code> 函数还会根据 IO 线程数量，<strong>调用 <code>pthread_create</code> 函数创建相应数量的线程</strong>。</p> <p>在 <code>for</code> 循环中，<code>pthread_create</code> 函数用于创建线程。每个线程执行 <code>IOThreadMain</code> 函数来处理客户端请求。如果 <code>pthread_create</code> 返回非零值，则说明线程创建失败，此时 Redis 会记录错误并退出。</p> <p>因此，<code>initThreadedIO</code> 函数创建的线程运行的函数是 <strong>IOThreadMain</strong>，参数为当前创建线程的编号。需要注意的是，该编号从 1 开始，而编号为 0 的线程实际上是运行 Redis server 主流程的主线程。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">IOThreadMain</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>myid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ID 是线程编号（从 0 到 server.iothreads_num-1） */</span>
    <span class="token keyword">long</span> id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span><span class="token punctuation">)</span>myid<span class="token punctuation">;</span>
    <span class="token keyword">char</span> thdname<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

    <span class="token function">snprintf</span><span class="token punctuation">(</span>thdname<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>thdname<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">&quot;io_thd_%ld&quot;</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">redis_set_thread_title</span><span class="token punctuation">(</span>thdname<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">redisSetCpuAffinity</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>server_cpulist<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">makeThreadKillable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">/* 等待开始 */</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> <span class="token number">1000000</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getIOPendingCount</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token comment">/* 给主线程一个机会来停止此线程。 */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getIOPendingCount</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>io_threads_mutex<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>io_threads_mutex<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token function">serverAssert</span><span class="token punctuation">(</span><span class="token function">getIOPendingCount</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>tio_debug<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;[%ld] %d to handle\n&quot;</span><span class="token punctuation">,</span> id<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token function">listLength</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* 处理：注意主线程不会在我们将待处理数量减少到 0 之前触碰我们的列表 */</span>
        listIter li<span class="token punctuation">;</span>
        listNode <span class="token operator">*</span>ln<span class="token punctuation">;</span>
        <span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>io_threads_op <span class="token operator">==</span> IO_THREADS_OP_WRITE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">writeToClient</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>io_threads_op <span class="token operator">==</span> IO_THREADS_OP_READ<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                <span class="token function">serverPanic</span><span class="token punctuation">(</span><span class="token string">&quot;io_threads_op 值未知&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token function">listEmpty</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>id<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setIOPendingCount</span><span class="token punctuation">(</span>id<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">if</span> <span class="token punctuation">(</span>tio_debug<span class="token punctuation">)</span> <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;[%ld] Done\n&quot;</span><span class="token punctuation">,</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>IOThreadMain</code> 函数也在 <code>networking.c</code> 文件中定义，其主要逻辑为一个 <strong>while(1) 循环</strong>。</p> <p><code>IOThreadMain</code> 函数在循环中处理 <code>io_threads_list</code> 数组中每个线程的客户端请求。</p> <p>正如之前所述，<code>io_threads_list</code> 数组中为每个 IO 线程使用一个列表记录待处理的客户端。因此，<code>IOThreadMain</code> 函数会从每个 IO 线程对应的列表中取出待处理的客户端，并根据操作类型执行相应操作。操作类型由变量 <code>io_threads_op</code> 表示，其值有两种：</p> <ul><li><strong><code>io_threads_op</code> 的值为宏定义 <code>IO_THREADS_OP_WRITE</code></strong>：表示该 IO 线程进行写操作，将数据从 Redis 写回客户端，线程会调用 <code>writeToClient</code> 函数。</li> <li><strong><code>io_threads_op</code> 的值为宏定义 <code>IO_THREADS_OP_READ</code></strong>：表示该 IO 线程进行读操作，从客户端读取数据，线程会调用 <code>readQueryFromClient</code> 函数。</li></ul> <div class="custom-block note"><p class="custom-block-title">笔记</p> <p>如果您对 Java 编程熟悉，可以将 <code>IOThreadMain</code> 函数视为 <code>Runnable</code> 的具体实现。其核心逻辑在于 <code>while(1)</code> 无限循环中。根据源码，IO 线程从 <code>io_threads_list</code> 队列（或列表）中获取待处理的客户端，并根据操作类型选择具体的执行逻辑。这是一种典型的 <code>生产者-消费者模型</code>，主线程负责投递事件，IO 线程负责消费事件（主线程也参与）。</p></div> <p>我绘制了下图，以展示 <code>IOThreadMain</code> 函数的基本流程，请参考：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409172237429.png" alt="image-20240917144454718"></p> <p>如上所示，每个 IO 线程在运行过程中，会不断检查是否有待处理的客户端请求。如果存在待处理的客户端，线程会根据操作类型，从客户端读取数据或将数据写回客户端。这些操作涉及 Redis 与客户端之间的 I/O 交互，因此这些线程被称为 IO 线程。</p> <p>在此，您可能会产生一些疑问：<strong>IO 线程如何将客户端添加到 <code>io_threads_list</code> 数组中？</strong></p> <p>这涉及 Redis server 的全局变量 <code>server</code>。<code>server</code> 变量中包含两个 <code>List</code> 类型的成员变量：<code>clients_pending_write</code> 和 <code>clients_pending_read</code>，分别记录待写回数据的客户端和待读取数据的客户端，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// 待写回数据的客户端</span>
    list <span class="token operator">*</span>clients_pending_write<span class="token punctuation">;</span>  
    <span class="token comment">// 待读取数据的客户端</span>
    list <span class="token operator">*</span>clients_pending_read<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Redis server 在接收客户端请求和返回数据的过程中，会根据特定条件推迟客户端的读写操作，并将这些客户端分别保存到这两个列表中。随后，在每次进入事件循环前，Redis server 会将列表中的客户端添加到 <code>io_threads_list</code> 数组中，由 IO 线程进行处理。</p> <p>接下来，我们将探讨 Redis 如何推迟客户端的读写操作，并将这些客户端添加到 <code>clients_pending_write</code> 和 <code>clients_pending_read</code> 列表中。</p> <h3 id="_2-多线程读"><a href="#_2-多线程读" class="header-anchor">#</a> 2. 多线程读</h3> <p>在早期的单线程版本中，当多路复用检测到客户端数据准备就绪时，主事件循环会轮询处理这些就绪的客户端，步骤如下：</p> <ol><li>读取数据</li> <li>解析数据</li> <li>执行命令</li> <li>将数据写回客户端缓冲区</li> <li>等待下一轮主事件循环</li> <li>将客户端缓冲数据写回客户端</li></ol> <p>在多线程模式下（假设配置了多线程读），上述流程有所变化：数据读取和解析操作将被分配给多个 IO 线程（包括主线程）。</p> <p>所有就绪客户端将暂存至队列中：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">redisServer</span> <span class="token punctuation">{</span>  
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   list <span class="token operator">*</span>clients_pending_read<span class="token punctuation">;</span>
   <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>处理流程如下：</p> <ol><li>主线程开始监听 IO 事件</li> <li>主线程调用 <code>readQueryFromClient</code></li> <li><code>postponeClientRead</code> 将客户端添加至 <code>clients_pending_read</code></li> <li><code>handleClientsWithPendingReadsUsingThreads</code> 将 <code>clients_pending_read</code> 列表中的客户端分配给所有 IO 线程</li> <li>主线程阻塞并等待所有 IO 线程完成读取</li> <li>主线程循环遍历并处理所有读取到的数据</li></ol> <h4 id="入队-如何推迟客户端读操作"><a href="#入队-如何推迟客户端读操作" class="header-anchor">#</a> 入队：如何推迟客户端读操作？</h4> <p>Redis server 在与客户端建立连接后，会开始监听客户端的可读事件。处理可读事件的回调函数是 <code>readQueryFromClient</code>。我在某处已介绍了这一过程，您可以再次回顾。</p> <p>在 Redis 6.0 版本中，<code>readQueryFromClient</code> 函数首先从传入的参数 <code>conn</code> 中获取客户端 <code>c</code>，然后调用 <code>postponeClientRead</code> 函数来判断是否推迟从客户端读取数据。执行逻辑如下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>connection <span class="token operator">*</span>conn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">connGetPrivateData</span><span class="token punctuation">(</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 从连接数据结构中获取客户端</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">postponeClientRead</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token comment">// 判断是否推迟从客户端读取数据</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接下来，我们将分析 <code>postponeClientRead</code> 函数的执行逻辑。该函数会根据以下四个条件判断是否可以推迟从客户端读取数据：</p> <p><strong>条件一：全局变量 <code>server</code> 的 <code>io_threads_active</code> 值为 1</strong></p> <p>这表示多 IO 线程已激活。正如前述，该变量在 <code>initThreadedIO</code> 函数中初始化为 0，表明多 IO 线程初始化后默认未激活（后文将详细介绍何时将该变量值设置为 1）。</p> <p><strong>条件二：全局变量 <code>server</code> 的 <code>io_threads_do_read</code> 值为 1</strong></p> <p>这表示多 IO 线程可以处理延后执行的客户端读操作。该变量在 Redis 配置文件 <code>redis.conf</code> 中通过 <code>io-threads-do-reads</code> 配置项设置，默认为 <code>no</code>，即多 IO 线程机制默认不用于客户端读操作。若要启用多 IO 线程处理客户端读操作，需将 <code>io-threads-do-reads</code> 配置项设为 <code>yes</code>。</p> <p><strong>条件三：<code>ProcessingEventsWhileBlocked</code> 变量值为 0</strong></p> <p>这表示 <code>processEventsWhileBlocked</code> 函数未在执行中。<code>ProcessingEventsWhileBlocked</code> 是一个全局变量，当 <code>processEventsWhileBlocked</code> 函数执行时，该变量值为 1，函数执行完成后值为 0。<code>processEventsWhileBlocked</code> 函数在 <code>networking.c</code> 文件中实现，主要用于在 Redis 读取 RDB 或 AOF 文件时处理事件，避免因读取文件阻塞 Redis 导致事件处理延迟。因此，当 <code>processEventsWhileBlocked</code> 函数处理客户端可读事件时，这些客户端读操作不会被推迟。</p> <p><strong>条件四：客户端当前标识不能包含 <code>CLIENT_MASTER</code>、<code>CLIENT_SLAVE</code> 和 <code>CLIENT_PENDING_READ</code></strong></p> <p>其中，<code>CLIENT_MASTER</code> 和 <code>CLIENT_SLAVE</code> 标识表示客户端用于主从复制，这些客户端的读操作不会被推迟。<code>CLIENT_PENDING_READ</code> 标识表示客户端已设置为推迟读操作，因此，对于已带有 <code>CLIENT_PENDING_READ</code> 标识的客户端，<code>postponeClientRead</code> 函数不会再次推迟其读操作。</p> <p>只有当上述四个条件均满足时，<code>postponeClientRead</code> 函数才会推迟当前客户端的读操作。具体来说，<code>postponeClientRead</code> 函数会为该客户端设置 <code>CLIENT_PENDING_READ</code> 标识，并调用 <code>listAddNodeHead</code> 函数，将客户端添加到全局变量 <code>server</code> 的 <code>clients_pending_read</code> 列表中。</p> <p>以下是 <code>postponeClientRead</code> 函数的代码：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">postponeClientRead</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 判断 IO 线程是否激活</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_active <span class="token operator">&amp;&amp;</span> server<span class="token punctuation">.</span>io_threads_do_reads <span class="token operator">&amp;&amp;</span>      
         <span class="token operator">!</span>ProcessingEventsWhileBlocked <span class="token operator">&amp;&amp;</span>
        <span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> <span class="token punctuation">(</span>CLIENT_MASTER<span class="token operator">|</span>CLIENT_SLAVE<span class="token operator">|</span>CLIENT_PENDING_READ<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        c<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> CLIENT_PENDING_READ<span class="token punctuation">;</span> <span class="token comment">// 设置客户端标识为 CLIENT_PENDING_READ，表示推迟该客户端的读操作</span>
        <span class="token function">listAddNodeHead</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">,</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将客户端添加到 clients_pending_read 列表中</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>综上所述，Redis 在客户端读事件回调函数 <code>readQueryFromClient</code> 中，通过调用 <code>postponeClientRead</code> 函数来判断并推迟客户端读操作。接下来，我们将探讨 Redis 如何推迟客户端写操作。</p> <h4 id="分配-如何将待读客户端分配给-io-线程执行"><a href="#分配-如何将待读客户端分配给-io-线程执行" class="header-anchor">#</a> 分配：如何将待读客户端分配给 IO 线程执行？</h4> <p>首先，我们需要了解 <strong>handleClientsWithPendingReadsUsingThreads</strong> 函数的作用。该函数在 <code>beforeSleep</code> 函数中被调用。</p> <p>在 Redis 6.0 版本的实现中，事件驱动框架通过调用 <code>aeMain</code> 函数执行事件循环，<code>aeMain</code> 函数进一步调用 <code>aeProcessEvents</code> 处理各种事件。在 <code>aeProcessEvents</code> 实际调用 <code>aeApiPoll</code> 捕获 IO 事件之前，<code>beforeSleep</code> 函数会被执行。</p> <p>该过程如图所示：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409172240189.png" alt="image-20240917145125065"></p> <p><strong>handleClientsWithPendingReadsUsingThreads</strong> 函数的执行逻辑可分为四个步骤：</p> <p><strong>第一步</strong>，该函数首先检查全局变量 <code>server</code> 的 <code>io_threads_active</code> 成员变量，确认 IO 线程是否激活，同时依据 <code>io_threads_do_reads</code> 成员变量判断是否允许 IO 线程处理待读客户端。只有在 IO 线程被激活并且允许处理待读客户端的情况下，<code>handleClientsWithPendingReadsUsingThreads</code> 函数才会继续执行，否则函数将直接返回。判断逻辑如下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>io_threads_active <span class="token operator">||</span> <span class="token operator">!</span>server<span class="token punctuation">.</span>io_threads_do_reads<span class="token punctuation">)</span> 
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>第二步</strong>，函数获取 <code>clients_pending_read</code> 列表的长度，表示待处理客户端的数量。随后，函数从 <code>clients_pending_read</code> 列表中逐一取出待处理的客户端，并通过客户端在列表中的序号对 IO 线程数量进行取模运算。</p> <p>通过这种方式，客户端将被分配给对应的 IO 线程。接着，函数会调用 <code>listAddNodeTail</code> 将分配好的客户端添加到 <code>io_threads_list</code> 数组的相应元素中。<code>io_threads_list</code> 数组的每个元素是一个列表，保存了每个 IO 线程需要处理的客户端。</p> <p>以下是具体的示例：</p> <p>假设 IO 线程数量为 3，而 <code>clients_pending_read</code> 列表中有 5 个客户端，其序号分别为 0、1、2、3 和 4。在此步骤中，这些客户端的序号对线程数量 3 取模的结果分别是 0、1、2、0、1，这对应了处理这些客户端的 IO 线程编号。也就是说，客户端 0 由线程 0 处理，客户端 1 由线程 1 处理，以此类推。客户端的分配方式实际上是一种 <strong>轮询</strong> 方式。</p> <p>下图展示了这种分配结果：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409172240213.png" alt="image-20240917145140527"></p> <p>以下代码展示了如何以轮询方式将客户端分配给 IO 线程的执行逻辑：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> processed <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">listRewind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">,</span> <span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> item_id <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> target_id <span class="token operator">=</span> item_id <span class="token operator">%</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span>
    <span class="token function">listAddNodeTail</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>target_id<span class="token punctuation">]</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    item_id<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当 <code>handleClientsWithPendingReadsUsingThreads</code> 函数完成客户端的 IO 线程分配后，它会将 IO 线程的操作标识设置为 <strong>读操作</strong>，即 <code>IO_THREADS_OP_READ</code>。然后，它会遍历 <code>io_threads_list</code> 数组中的每个元素列表，记录每个线程待处理客户端的数量，并赋值给 <code>io_threads_pending</code> 数组。具体过程如下：</p> <div class="language-c extra-class"><pre class="language-c"><code>io_threads_op <span class="token operator">=</span> IO_THREADS_OP_READ<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    io_threads_pending<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> count<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>第三步</strong>，函数会将 <code>io_threads_list</code> 数组中的 0 号列表（即 <code>io_threads_list[0]</code>）中的客户端逐一取出，并调用 <code>readQueryFromClient</code> 函数进行处理。</p> <p>需要注意的是，<code>handleClientsWithPendingReadsUsingThreads</code> 函数本身由 IO 主线程执行，而 <code>io_threads_list</code> 数组中的 0 号线程即为 IO 主线程，因此此步骤是由主线程处理其待读客户端：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token function">listRewind</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 获取 0 号列表中的所有客户端</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ln <span class="token operator">=</span> <span class="token function">listNext</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>li<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">readQueryFromClient</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>conn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">listEmpty</span><span class="token punctuation">(</span>io_threads_list<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 处理完后，清空 0 号列表</span>
</code></pre></div><p>接下来，<code>handleClientsWithPendingReadsUsingThreads</code> 函数会进入一个 <code>while(1)</code> 循环，等待所有 IO 线程完成对待读客户端的处理，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> pending <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>io_threads_num<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>
        pending <span class="token operator">+=</span> io_threads_pending<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>第四步</strong>，函数会再次遍历 <code>clients_pending_read</code> 列表，逐一取出其中的客户端。接着，函数会检查客户端是否有 <code>CLIENT_PENDING_COMMAND</code> 标识。如果存在，说明该客户端的命令已被某个 IO 线程解析，可以执行。</p> <p>此时，<code>handleClientsWithPendingReadsUsingThreads</code> 函数会调用 <code>processCommandAndResetClient</code> 执行命令，并直接调用 <code>processInputBuffer</code> 解析客户端中所有命令并执行。</p> <p>相关代码如下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ln <span class="token operator">=</span> <span class="token function">listFirst</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_read<span class="token punctuation">)</span><span class="token punctuation">;</span>
    client <span class="token operator">*</span>c <span class="token operator">=</span> <span class="token function">listNodeValue</span><span class="token punctuation">(</span>ln<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// 如果命令已解析，则执行该命令</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_PENDING_COMMAND<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;=</span> <span class="token operator">~</span>CLIENT_PENDING_COMMAND<span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">processCommandAndResetClient</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">continue</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 解析并执行所有命令</span>
    <span class="token function">processInputBuffer</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>至此，你已经了解了如何将 <code>clients_pending_read</code> 列表中的待读客户端通过上述四个步骤分配给 IO 线程进行处理。下图展示了这一主要过程，你可以进一步回顾：</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409172240204.png" alt="image-20240917145158198"></p> <p>接下来，我们将探讨待写客户端的分配和处理方式。</p> <p>需要注意的是，当 <code>待处理客户端</code> 数量较少时，Redis 认为不需要多线程共同处理，所有任务将由主线程完成：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">stopThreadedIOIfNeeded</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> pending <span class="token operator">=</span> <span class="token function">listLength</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>pending <span class="token operator">&lt;</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_num <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_active<span class="token punctuation">)</span> <span class="token function">stopThreadedIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>当 <code>待处理客户端数量</code> 小于 <code>2倍的 IO 线程数</code> 时，所有客户端数据将由主线程处理。</p> <h3 id="_3、多线程写"><a href="#_3、多线程写" class="header-anchor">#</a> 3、多线程写</h3> <h4 id="入队-如何决定是否推迟客户端写操作"><a href="#入队-如何决定是否推迟客户端写操作" class="header-anchor">#</a> 入队：如何决定是否推迟客户端写操作？</h4> <p>在 Redis 中，当执行客户端命令后，需要向客户端返回结果时，会调用 <code>addReply</code> 函数将待返回的结果写入客户端的输出缓冲区。</p> <p>在 <code>addReply</code> 函数的开始部分，该函数会调用 <code>prepareClientToWrite</code> 函数来判断是否需要推迟执行客户端的写操作。以下代码展示了 <code>addReply</code> 函数如何调用 <code>prepareClientToWrite</code> 函数：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">addReply</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">,</span> robj <span class="token operator">*</span>obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">prepareClientToWrite</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">!=</span> C_OK<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>接下来，我们来看一下 <code>prepareClientToWrite</code> 函数。该函数根据客户端的设置进行一系列判断。其中，<code>clientHasPendingReplies</code> 函数会被调用，用于检查当前客户端的输出缓冲区中是否还有待写回的数据。</p> <p>如果缓冲区中没有待写回的数据，<code>prepareClientToWrite</code> 函数会进一步调用 <code>clientInstallWriteHandler</code> 函数，以判断是否能够推迟客户端的写操作。以下代码展示了这一调用过程：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">prepareClientToWrite</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">// 如果客户端没有待写回数据，则调用 clientInstallWriteHandler 函数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">clientHasPendingReplies</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token function">clientInstallWriteHandler</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>因此，推迟客户端写操作的最终决定由 <code>clientInstallWriteHandler</code> 函数做出。该函数会检查两个条件：</p> <ul><li><strong>条件一</strong>：客户端未设置 <code>CLIENT_PENDING_WRITE</code> 标识，即尚未推迟过写操作。</li> <li><strong>条件二</strong>：客户端所在实例未进行主从复制，或即使正在进行主从复制，客户端所在实例作为从节点且全量复制的 RDB 文件已传输完成，可以接收请求。</li></ul> <p>当上述两个条件都满足时，<code>clientInstallWriteHandler</code> 函数会将客户端标识设置为 <code>CLIENT_PENDING_WRITE</code>，以表示推迟该客户端的写操作。同时，该函数会将客户端添加到全局变量 <code>server</code> 的待写回客户端列表 <code>clients_pending_write</code> 中。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">clientInstallWriteHandler</span><span class="token punctuation">(</span>client <span class="token operator">*</span>c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 如果客户端没有设置过 CLIENT_PENDING_WRITE 标识，且客户端不在主从复制中，或作为从节点且已接收请求</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>flags <span class="token operator">&amp;</span> CLIENT_PENDING_WRITE<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
        <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>replstate <span class="token operator">==</span> REPL_STATE_NONE <span class="token operator">||</span>
         <span class="token punctuation">(</span>c<span class="token operator">-&gt;</span>replstate <span class="token operator">==</span> SLAVE_STATE_ONLINE <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>c<span class="token operator">-&gt;</span>repl_put_online_on_ack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token comment">// 将客户端标识设置为待写回，即 CLIENT_PENDING_WRITE</span>
        c<span class="token operator">-&gt;</span>flags <span class="token operator">|=</span> CLIENT_PENDING_WRITE<span class="token punctuation">;</span>
        <span class="token function">listAddNodeHead</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>clients_pending_write<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 将客户端添加到 clients_pending_write 列表</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>为帮助理解，我绘制了一张图，展示了 Redis 推迟客户端写操作的函数调用关系，供参考。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409172248379.png" alt="img"></p> <p>然而，当 Redis 使用 <code>clients_pending_read</code> 和 <code>clients_pending_write</code> 两个列表保存推迟执行的客户端时，<strong>这些客户端如何分配给多个 I/O 线程进行处理呢？</strong> 这涉及到以下两个函数：</p> <ul><li><code>handleClientsWithPendingReadsUsingThreads</code> 函数：负责将 <code>clients_pending_read</code> 列表中的客户端分配给 I/O 线程处理。</li> <li><code>handleClientsWithPendingWritesUsingThreads</code> 函数：负责将 <code>clients_pending_write</code> 列表中的客户端分配给 I/O 线程处理。</li></ul> <p>接下来，我们将详细介绍这两个函数的具体操作。</p> <h4 id="分配-如何将待读客户端分配给-10-个线程执行"><a href="#分配-如何将待读客户端分配给-10-个线程执行" class="header-anchor">#</a> 分配：如何将待读客户端分配给 10 个线程执行？</h4> <p>与待读客户端的分配类似，待写客户端的分配处理由 <code>handleClientsWithPendingWritesUsingThreads</code> 函数完成，该函数同样在 <code>beforeSleep</code> 函数中被调用。</p> <p><code>handleClientsWithPendingWritesUsingThreads</code> 函数的主要流程可以分为四个步骤，其中第二、第三和第四步的执行逻辑与 <code>handleClientsWithPendingReadsUsingThreads</code> 函数类似。</p> <p>简言之，在第二步中，<code>handleClientsWithPendingWritesUsingThreads</code> 函数会将待写客户端按照 <strong>轮询方式</strong> 分配给 I/O 线程，并将其添加到 <code>io_threads_list</code> 数组的各个元素中。</p> <p>在第三步中，<code>handleClientsWithPendingWritesUsingThreads</code> 函数会让主 I/O 线程处理其待写客户端，并执行 <code>while(1)</code> 循环以等待所有 I/O 线程完成处理。</p> <p>在第四步中，<code>handleClientsWithPendingWritesUsingThreads</code> 函数会再次检查 <code>clients_pending_write</code> 列表中是否还有待写客户端。如果存在且这些客户端仍有数据待写，函数会调用 <code>connSetWriteHandler</code> 函数注册可写事件，该事件的回调函数为 <code>sendReplyToClient</code>。</p> <p>当事件循环流程再次执行时，<code>sendReplyToClient</code> 函数会被调用，它会直接调用 <code>writeToClient</code> 函数，将客户端缓冲区中的数据写回。</p> <p>需要注意的是，<code>connSetWriteHandler</code> 函数最终会映射为 <code>connSocketSetWriteHandler</code> 函数，后者在 <a href="https://github.com/redis/redis/tree/5.0/src/connection.c" target="_blank" rel="noopener noreferrer">connection.c<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 文件中实现。<code>connSocketSetWriteHandler</code> 函数会调用 <code>aeCreateFileEvent</code> 函数创建 <code>AE_WRITABLE</code> 事件，这即为可写事件的注册（有关 <code>aeCreateFileEvent</code> 函数的使用，可以参见第 11 讲）。</p> <p>与 <code>handleClientsWithPendingReadsUsingThreads</code> 函数不同的是，在第一步中，<code>handleClientsWithPendingWritesUsingThreads</code> 函数会判断 I/O 线程数量是否为 1，或待写客户端数量是否少于 I/O 线程数量的两倍。</p> <p>如果满足上述任一条件，则 <code>handleClientsWithPendingWritesUsingThreads</code> 函数不会采用多线程处理客户端，而是调用 <code>handleClientsWithPendingWrites</code> 函数由主 I/O 线程直接处理待写客户端。这主要是为了在待写客户端数量较少时，<strong>节省 CPU 开销</strong>。</p> <p>以下是条件判断逻辑：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>io_threads_num <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">||</span> <span class="token function">stopThreadedIOIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">handleClientsWithPendingWrites</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>此外，<code>handleClientsWithPendingWritesUsingThreads</code> 函数在第一步中还会判断 I/O 线程是否已激活。如果未激活，则调用 <code>startThreadedIO</code> 函数，将全局变量 <code>server</code> 的 <code>io_threads_active</code> 成员变量设置为 1，以表示 I/O 线程已激活。此判断操作如下：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>io_threads_active<span class="token punctuation">)</span> <span class="token function">startThreadedIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>总之，Redis 通过 <code>handleClientsWithPendingWritesUsingThreads</code> 函数将待写客户端按轮询方式分配给各个 I/O 线程，并由这些线程负责数据的写回。</p> <h2 id="redis-多线程-io-的性能调优与实际问题"><a href="#redis-多线程-io-的性能调优与实际问题" class="header-anchor">#</a> Redis 多线程 IO 的性能调优与实际问题</h2> <p>redis 默认情况下不会开启多线程处理，官方也建议，除非性能达到瓶颈，否则没必要开启多线程。</p> <p><strong>配置多少合适？</strong></p> <p>官方文档 redis.conf 中介绍有：</p> <blockquote><p>By default threading is disabled, we suggest enabling it only in machines
that have at least 4 or more cores, leaving at least one spare core.
Using more than 8 threads is unlikely to help much. We also recommend using
threaded I/O only if you actually have performance problems, with Redis
instances being able to use a quite big percentage of CPU time, otherwise
there is no point in using this feature.</p> <p>So for instance if you have a four cores boxes, try to use 2 or 3 I/O
threads, if you have a 8 cores, try to use 6 threads. In order to
enable I/O threads use the following configuration directive:</p></blockquote> <p>CPU 4 核以上，才考虑开启多线程，其中：</p> <ul><li>4 核开启 2 - 3 个 IO 线程</li> <li>8 核 开启 6 个 IO 线程</li> <li>超过 8 个 IO 线程，性能提升已经不大</li></ul> <p>值得注意的是，以上的 IO 线程其实包含了主线程。</p> <p><strong>配置：</strong></p> <p>开启多线程：配置 io-thread 即可。io-thread = 1 表示只使用主线程</p> <blockquote><p>io-threads 4</p></blockquote> <p>开启之后，默认写操作会通过多线程来处理，而读操作则不会。</p> <p>如果读操作也想要开启多线程，则需要配置：</p> <blockquote><p>io-threads-do-reads yes</p></blockquote> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>今天这节课，我给你介绍了 Redis 6.0 中新设计实现的<strong>多 IO 线程机制</strong>。这个机制的设计主要是为了使用多个 IO 线程，来并发处理客户端读取数据、解析命令和写回数据。使用了多线程后，Redis 就可以充分利用服务器的多核特性，从而<strong>提高 IO 效率</strong>。</p> <p>总结来说，Redis 6.0 先是在初始化过程中，根据用户设置的 IO 线程数量，创建对应数量的 IO 线程。</p> <p>当 Redis server 初始化完成后正常运行时，它会在 readQueryFromClient 函数中通过调用 postponeClientRead 函数来决定是否推迟客户端读操作。同时，Redis server 会在 addReply 函数中通过调用 prepareClientToWrite 函数，来决定是否推迟客户端写操作。而待读写的客户端会被分别加入到 clients_pending_read 和 clients_pending_write 两个列表中。</p> <p>这样，每当 Redis server 要进入事件循环流程前，都会在 beforeSleep 函数中分别调用 handleClientsWithPendingReadsUsingThreads 函数和 handleClientsWithPendingWritesUsingThreads 函数，将待读写客户端<strong>以轮询方式分配给 IO 线程</strong>，加入到 IO 线程的待处理客户端列表 io_threads_list 中。</p> <p>而 IO 线程一旦运行后，本身会一直检测 io_threads_list 中的客户端，如果有待读写客户端，IO 线程就会调用 readQueryFromClient 或 writeToClient 函数来进行处理。</p> <p>最后，我也想再提醒你一下，<strong>多 IO 线程本身并不会执行命令</strong>，它们只是利用多核并行地读取数据和解析命令，或是将 server 数据写回（下节课我还会结合分布式锁的原子性保证，来给你介绍这一部分的源码实现。）。所以，<strong>Redis 执行命令的线程还是主线程</strong>。这一点对于你理解多 IO 线程机制很重要，可以避免你误解 Redis 有多线程同时执行命令。</p> <p>这样一来，我们原来针对 Redis 单个主线程做的优化仍然有效，比如避免 bigkey、避免阻塞操作等。</p> <h2 id="参考文献"><a href="#参考文献" class="header-anchor">#</a> 参考文献</h2> <ul><li><a href="https://zhuanlan.zhihu.com/p/556726757" target="_blank" rel="noopener noreferrer">redis 6.0之多线程，深入解读 - 知乎 (zhihu.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.zhihu.com/tardis/zm/art/144805500?source_id=1005" target="_blank" rel="noopener noreferrer">Redis 6.0 多线程IO处理过程详解 (zhihu.com)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://time.geekbang.org/column/intro/100084301" target="_blank" rel="noopener noreferrer">Redis 源码剖析与实战 (geekbang.org)<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/Redis 系统设计/03.三、主线任务/16.Redis 多IO线程.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新于:</span> <span class="time">2024/09/18, 11:29:27</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/e6d8ef/" class="prev">Redis 的执行模式</a></span> <span class="next"><a href="/pages/b43a19/">LRU 策略</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.bdcc6820.js" defer></script><script src="/assets/js/2.933750c6.js" defer></script><script src="/assets/js/70.b920a5f7.js" defer></script><script src="/assets/js/7.7eb70372.js" defer></script>
  </body>
</html>
