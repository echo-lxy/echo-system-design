<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>LRU 策略 | EchoDesign</title>
    <meta name="generator" content="VuePress 1.9.9">
    <link rel="icon" href="/img/favicon.ico">
    <meta name="description" content="系统设计之「讲解 + 面试指南」，水滴石穿，设计无银弹！">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/assets/css/0.styles.c76c3453.css" as="style"><link rel="preload" href="/assets/js/app.9830b779.js" as="script"><link rel="preload" href="/assets/js/2.933750c6.js" as="script"><link rel="preload" href="/assets/js/71.4f744076.js" as="script"><link rel="preload" href="/assets/js/7.7eb70372.js" as="script"><link rel="prefetch" href="/assets/js/10.2cc95be8.js"><link rel="prefetch" href="/assets/js/100.2b21dce5.js"><link rel="prefetch" href="/assets/js/101.96ca71f6.js"><link rel="prefetch" href="/assets/js/11.c7521a10.js"><link rel="prefetch" href="/assets/js/12.38d1989d.js"><link rel="prefetch" href="/assets/js/13.850793b0.js"><link rel="prefetch" href="/assets/js/14.1141ec27.js"><link rel="prefetch" href="/assets/js/15.12d1dea8.js"><link rel="prefetch" href="/assets/js/16.60cde607.js"><link rel="prefetch" href="/assets/js/17.acb3bf3d.js"><link rel="prefetch" href="/assets/js/18.e491edb6.js"><link rel="prefetch" href="/assets/js/19.daf31819.js"><link rel="prefetch" href="/assets/js/20.cb4a5c13.js"><link rel="prefetch" href="/assets/js/21.24c0f101.js"><link rel="prefetch" href="/assets/js/22.dd779f94.js"><link rel="prefetch" href="/assets/js/23.4d814163.js"><link rel="prefetch" href="/assets/js/24.891fe6fb.js"><link rel="prefetch" href="/assets/js/25.41dca26b.js"><link rel="prefetch" href="/assets/js/26.6337eac0.js"><link rel="prefetch" href="/assets/js/27.de80589e.js"><link rel="prefetch" href="/assets/js/28.95a1fb6b.js"><link rel="prefetch" href="/assets/js/29.371a40e1.js"><link rel="prefetch" href="/assets/js/3.e62a71e4.js"><link rel="prefetch" href="/assets/js/30.e32f6b31.js"><link rel="prefetch" href="/assets/js/31.a532917f.js"><link rel="prefetch" href="/assets/js/32.13b70e91.js"><link rel="prefetch" href="/assets/js/33.64ab8d0c.js"><link rel="prefetch" href="/assets/js/34.6d3cc288.js"><link rel="prefetch" href="/assets/js/35.2760ed8d.js"><link rel="prefetch" href="/assets/js/36.be98cc35.js"><link rel="prefetch" href="/assets/js/37.82be3556.js"><link rel="prefetch" href="/assets/js/38.40fe2658.js"><link rel="prefetch" href="/assets/js/39.84b6e82e.js"><link rel="prefetch" href="/assets/js/4.73518a0f.js"><link rel="prefetch" href="/assets/js/40.591baf2a.js"><link rel="prefetch" href="/assets/js/41.f961e422.js"><link rel="prefetch" href="/assets/js/42.b34f1599.js"><link rel="prefetch" href="/assets/js/43.5a509601.js"><link rel="prefetch" href="/assets/js/44.64fd3383.js"><link rel="prefetch" href="/assets/js/45.685623ac.js"><link rel="prefetch" href="/assets/js/46.7624d38c.js"><link rel="prefetch" href="/assets/js/47.5646b068.js"><link rel="prefetch" href="/assets/js/48.a1b270df.js"><link rel="prefetch" href="/assets/js/49.ee9681bc.js"><link rel="prefetch" href="/assets/js/5.94727770.js"><link rel="prefetch" href="/assets/js/50.b424b2c0.js"><link rel="prefetch" href="/assets/js/51.ef213b56.js"><link rel="prefetch" href="/assets/js/52.18c75eba.js"><link rel="prefetch" href="/assets/js/53.f76e624c.js"><link rel="prefetch" href="/assets/js/54.3098ec9f.js"><link rel="prefetch" href="/assets/js/55.4c46841d.js"><link rel="prefetch" href="/assets/js/56.10e3f10b.js"><link rel="prefetch" href="/assets/js/57.36581a94.js"><link rel="prefetch" href="/assets/js/58.e5a83b70.js"><link rel="prefetch" href="/assets/js/59.7b7e3faf.js"><link rel="prefetch" href="/assets/js/6.0b558b79.js"><link rel="prefetch" href="/assets/js/60.66a7f41d.js"><link rel="prefetch" href="/assets/js/61.52ab8e4e.js"><link rel="prefetch" href="/assets/js/62.cc8fdced.js"><link rel="prefetch" href="/assets/js/63.41ff19e4.js"><link rel="prefetch" href="/assets/js/64.9b3def35.js"><link rel="prefetch" href="/assets/js/65.0b2ab47d.js"><link rel="prefetch" href="/assets/js/66.2ae7a107.js"><link rel="prefetch" href="/assets/js/67.79dd6daf.js"><link rel="prefetch" href="/assets/js/68.1b76c178.js"><link rel="prefetch" href="/assets/js/69.7ac52a2f.js"><link rel="prefetch" href="/assets/js/70.7279b1df.js"><link rel="prefetch" href="/assets/js/72.44c999da.js"><link rel="prefetch" href="/assets/js/73.526febf1.js"><link rel="prefetch" href="/assets/js/74.26f8d9a5.js"><link rel="prefetch" href="/assets/js/75.dc7fdd0f.js"><link rel="prefetch" href="/assets/js/76.32858593.js"><link rel="prefetch" href="/assets/js/77.7b3f6980.js"><link rel="prefetch" href="/assets/js/78.31a353ef.js"><link rel="prefetch" href="/assets/js/79.173bbc8c.js"><link rel="prefetch" href="/assets/js/8.0ec7f6e8.js"><link rel="prefetch" href="/assets/js/80.78a31e84.js"><link rel="prefetch" href="/assets/js/81.8d6c43d2.js"><link rel="prefetch" href="/assets/js/82.3b90a7cc.js"><link rel="prefetch" href="/assets/js/83.f3a9ee0c.js"><link rel="prefetch" href="/assets/js/84.eeb423e8.js"><link rel="prefetch" href="/assets/js/85.4cd3a775.js"><link rel="prefetch" href="/assets/js/86.931cbb70.js"><link rel="prefetch" href="/assets/js/87.78b2eebd.js"><link rel="prefetch" href="/assets/js/88.605444aa.js"><link rel="prefetch" href="/assets/js/89.b5690031.js"><link rel="prefetch" href="/assets/js/9.6e274fca.js"><link rel="prefetch" href="/assets/js/90.cdc8eb8f.js"><link rel="prefetch" href="/assets/js/91.8ad18b18.js"><link rel="prefetch" href="/assets/js/92.b554f1c7.js"><link rel="prefetch" href="/assets/js/93.fb2397b7.js"><link rel="prefetch" href="/assets/js/94.1eade7f0.js"><link rel="prefetch" href="/assets/js/95.96f5db04.js"><link rel="prefetch" href="/assets/js/96.5ed2d348.js"><link rel="prefetch" href="/assets/js/97.4d4bfff5.js"><link rel="prefetch" href="/assets/js/98.10f4b27a.js"><link rel="prefetch" href="/assets/js/99.4a895015.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c76c3453.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/logo.png" alt="EchoDesign" class="logo"> <span class="site-name can-hide">EchoDesign</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 深度剖析</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><!----> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">🏠首页</a></div><div class="nav-item"><a href="/pages/fccd91/" class="nav-link">✒️热门算法</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🎖️赏析经典设计" class="dropdown-title"><!----> <span class="title" style="display:;">🎖️赏析经典设计</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/252196/" class="nav-link">Redis 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/b9733b/" class="nav-link">Kafka 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/bfab10/" class="nav-link">Netty 深度剖析</a></li><li class="dropdown-item"><!----> <a href="/pages/4601ca/" class="nav-link">Nginx 深度剖析</a></li></ul></div></div><div class="nav-item"><a href="/pages/84cb49/" class="nav-link">🧑‍💻实战系统设计</a></div><div class="nav-item"><a href="/pages/92b2ee/" class="nav-link">❓问答</a></div><div class="nav-item"><a href="/pages/52ebd8/" class="nav-link">👀动态</a></div> <a href="https://github.com/echo-lxy/echo-system-design" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>一、前言</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>二、基础知识</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>三、主线任务</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>四、支线任务</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/b43a19/" aria-current="page" class="active sidebar-link">LRU 策略</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/pages/b43a19/#前言" class="sidebar-link">前言</a></li><li class="sidebar-sub-header level2"><a href="/pages/b43a19/#概述" class="sidebar-link">概述</a></li><li class="sidebar-sub-header level2"><a href="/pages/b43a19/#全局-lru-时钟值的计算" class="sidebar-link">全局 LRU 时钟值的计算</a></li><li class="sidebar-sub-header level2"><a href="/pages/b43a19/#键值对中-lru-时钟值的初始化与更新" class="sidebar-link">键值对中 LRU 时钟值的初始化与更新</a></li><li class="sidebar-sub-header level2"><a href="/pages/b43a19/#近似-lru-算法的实际执行" class="sidebar-link">近似 LRU 算法的实际执行</a></li><li class="sidebar-sub-header level2"><a href="/pages/b43a19/#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header level2"><a href="/pages/b43a19/#参考资料" class="sidebar-link">参考资料</a></li></ul></li><li><a href="/pages/b43a89/" class="sidebar-link">LFU 策略</a></li><li><a href="/pages/f44fbe/" class="sidebar-link">Redis 过期策略</a></li><li><a href="/pages/9b17a6/" class="sidebar-link">RDB 持久化</a></li><li><a href="/pages/9b17a7/" class="sidebar-link">AOF 持久化</a></li><li><a href="/pages/aa75e9/" class="sidebar-link">Redis 中的延迟监控</a></li><li><a href="/pages/61d908/" class="sidebar-link">发布与订阅</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>五、集群</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><span data-v-06225672>Redis 系统设计</span></li><li data-v-06225672><span data-v-06225672>四、支线任务</span></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://gitee.com/brother-one" target="_blank" title="作者" class="beLink" data-v-06225672>echo</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2024-09-15</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">LRU 策略<!----></h1> <div class="page-slot page-slot-top">
    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>
    <style>
      .page-wwads{
        width:100%!important;
        min-height: 0;
        margin: 0;
      }
      .page-wwads .wwads-img img{
        width:80px!important;
      }
      .page-wwads .wwads-poweredby{
        width: 40px;
        position: absolute;
        right: 25px;
        bottom: 3px;
      }
      .wwads-content .wwads-text, .page-wwads .wwads-text{
        height: 100%;
        padding-top: 5px;
        display: block;
      }
  </style>
  </div> <div class="theme-vdoing-content content__default"><div class="custom-block note"><p class="custom-block-title">提出问题是一切智慧的开端</p> <ol><li>为什么严格 LRU 算法在 Redis 中性能开销高？近似 LRU 如何避免问题？</li> <li>Redis 如何利用全局 LRU 时钟判断淘汰数据？其优势与局限？</li> <li>为什么近似 LRU 算法中要使用“采样”策略？设计权衡是什么？</li> <li>Redis 的 LRU 时钟精度为 1 秒，访问间隔小于 1 秒会影响淘汰准确性吗？</li> <li>Redis 何时触发内存淘汰机制？与 Lua 脚本执行状态有何关联？</li> <li>Redis 如何找到“最近最少使用”的数据？EvictionPoolLRU 数组设计考量是什么？</li> <li>Redis 通过全局 LRU 时钟如何更新键值对的访问时间戳？哪些操作会更新？</li> <li>EvictionPoolLRU 数组的固定大小会导致淘汰不准确吗？</li> <li>Redis 为什么区分“同步删除”和“异步删除”？各自适用场景是什么？</li></ol></div> <h2 id="前言"><a href="#前言" class="header-anchor">#</a> 前言</h2> <p>LRU，全称 <em>Least Recently Used</em>，最近最少使用，在Redis中语义就是 <em>优先淘汰最近最不常用的数据</em>。</p> <p><strong>你觉得有哪几种方式可以实现 LRU 淘汰策略？</strong></p> <ul><li><p>「最直观的想法」：记录下每个 key 最近一次的访问时间 timestamp，timestamp 最小的 Key，就是最近未使用的，然后择时删除。**但是 **首先需要存储每个 Key 和它的 timestamp。其次，还要比较 timestamp 得出最小值。代价很大，不现实。</p></li> <li><p>「双链表+HashMap」：<a href="/pages/87589a">echo 的 LRU 算法详解</a>，不记录具体的访问时间点(unix timestamp)，而是记录空闲时间 idle time：idle time 越小，意味着是最近被访问的</p></li></ul> <p>你其实可以发现，如果要严格按照 LRU 基本算法「双链表+HashMap」来实现的话，你需要在代码中实现如下内容：</p> <ul><li>要为 Redis 可容纳的所有数据维护一个链表</li> <li>每当有新数据插入或是现有数据被再次访问时，需要执行多次链表操作</li></ul> <p>Redis 并没有采用常见的 LRU 实现，而是采用**「近似 LRU 算法」**，听 echo 娓娓道来....</p> <h2 id="概述"><a href="#概述" class="header-anchor">#</a> 概述</h2> <p>Redis 的 内存淘汰主要和两个 redis.conf 中的配置有关：</p> <ul><li><code>maxmemory</code>，该配置项设定了 Redis server 可以使用的最大内存容量，一旦 server 使用的实际内存量超出该阈值时，server 就会根据 <code>maxmemory-policy</code> 配置项定义的策略，执行内存淘汰操作</li> <li><code>maxmemory-policy</code>，该配置项设定了 Redis server 的内存淘汰策略，主要包括近似 LRU 算法、LFU 算法、按 TTL 值淘汰和随机淘汰等几种算法</li></ul> <p>我们把 Redis 对近似 LRU 算法的实现分成三个部分。</p> <ul><li><strong>全局 LRU 时钟值的计算</strong>：这部分包括，Redis 源码为了实现近似 LRU 算法的效果，是 <strong>如何计算全局 LRU 时钟值</strong> 的，以用来判断数据访问的时效性</li> <li><strong>键值对 LRU 时钟值的初始化与更新</strong>：这部分包括，Redis 源码在哪些函数中<strong>对每个键值对对应的 LRU 时钟值，进行初始化与更新</strong></li> <li><strong>近似 LRU 算法的实际执行</strong>：这部分包括，Redis 源码具体如何执行近似 LRU 算法，也就是<strong>何时触发数据淘汰</strong>，以及<strong>实际淘汰的机制</strong>是怎么实现的。</li></ul> <p>上述三部分的整体流程：Redis 在某个时刻去取 <em>全局LRU时钟值</em>  来刷新 <em>键值对的LRU时钟值</em>，然后在某个时刻根据这个时钟值去 <em>淘汰数据</em></p> <h2 id="全局-lru-时钟值的计算"><a href="#全局-lru-时钟值的计算" class="header-anchor">#</a> 全局 LRU 时钟值的计算</h2> <p>虽然 Redis 使用了近似 LRU 算法，但是，这个算法仍然需要区分不同数据的访问时效性，也就是说，<strong>Redis 需要知道数据的最近一次访问时间</strong>。因此，Redis 就设计了 <strong>LRU 时钟</strong>来记录数据每次访问的时间戳。</p> <p>Redis 在源码中对于每个键值对中的值，会使用一个 <strong>redisObject</strong> 结构体来保存指向值的指针。</p> <p>那么，redisObject 结构体除了记录值的指针以外，还会 <strong>使用 24 bits 来保存 LRU 时钟信息</strong>，对应的是 LRU 成员变量。所以这样一来，每个键值对都会把它最近一次被访问的时间戳，记录在 LRU 变量当中。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisObject</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> type<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> encoding<span class="token operator">:</span><span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">unsigned</span> lru<span class="token operator">:</span>LRU_BITS<span class="token punctuation">;</span>  <span class="token comment">//记录LRU信息，宏定义LRU_BITS是24 bits</span>
    <span class="token keyword">int</span> refcount<span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>
<span class="token punctuation">}</span> robj<span class="token punctuation">;</span>
</code></pre></div><p>但是，每个键值对的 LRU 时钟值具体是 <strong>如何计算</strong> 的呢？其实，Redis server 使用了一个实例级别的 <strong>全局 LRU 时钟</strong>，每个键值对的 LRU 时钟值会根据全局 LRU 时钟进行设置</p> <p><strong>这个全局 LRU 时钟保存在了 Redis 全局变量 server 的成员变量 lruclock 中</strong>。当 Redis server 启动后，调用 initServerConfig 函数初始化各项参数时，就会对这个全局 LRU 时钟 lruclock 进行设置。具体来说，initServerConfig 函数是调用 getLRUClock 函数，来设置 lruclock 的值，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// 调用getLRUClock函数计算全局LRU时钟值</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> lruclock <span class="token operator">=</span> <span class="token function">getLRUClock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//设置lruclock为刚计算的LRU时钟值</span>
<span class="token function">atomicSet</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>lruclock<span class="token punctuation">,</span>lruclock<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>所以，<strong>全局 LRU 时钟值就是通过 getLRUClock 函数计算得到的</strong>。</p> <p><code>getLRUClock</code> 函数是在 evict.c 文件中实现的，它会调用 mstime 函数（在 server.c 文件中）获得以毫秒为单位计算的 UNIX 时间戳，然后将这个 UNIX 时间戳除以宏定义 <strong>LRU_CLOCK_RESOLUTION</strong>。宏定义 <code>LRU_CLOCK_RESOLUTION</code> 是在 server.h 文件中定义的，它表示的是以毫秒为单位的 LRU 时钟精度，也就是以毫秒为单位来表示的 LRU 时钟最小单位。</p> <p>因为 <code>LRU_CLOCK_RESOLUTION</code> 的默认值是 1000，所以，LRU 时钟精度就是 1000 毫秒，也就是 1 秒。</p> <p>这样一来，你需要注意的就是，<strong>如果一个数据前后两次访问的时间间隔小于 1 秒，那么这两次访问的时间戳就是一样的</strong>。因为 LRU 时钟的精度就是 1 秒，它无法区分间隔小于 1 秒的不同时间戳。</p> <p>了解了宏定义 <code>LRU_CLOCK_RESOLUTION</code> 的含义之后，我们再来看下 <code>getLRUClock</code> 函数中的计算。</p> <ol><li>首先，<code>getLRUClock</code> 函数将获得的 UNIX 时间戳，除以 <code>LRU_CLOCK_RESOLUTION</code> 后，就得到了以 LRU 时钟精度来计算的 UNIX 时间戳，也就是当前的 LRU 时钟值。</li> <li>紧接着，<code>getLRUClock</code> 函数会把 LRU 时钟值和宏定义 <code>LRU_CLOCK_MAX</code> 做与运算，其中宏定义 <code>LRU_CLOCK_MAX</code> 表示的是 LRU 时钟能表示的最大值。</li></ol> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* Return the LRU clock, based on the clock resolution. This is a time
 * in a reduced-bits format that can be used to set and check the
 * object-&gt;lru field of redisObject structures. */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">getLRUClock</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token function">mstime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span>LRU_CLOCK_RESOLUTION<span class="token punctuation">)</span> <span class="token operator">&amp;</span> LRU_CLOCK_MAX<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LRU_BITS</span> <span class="token expression"><span class="token number">24</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LRU_CLOCK_MAX</span> <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">&lt;&lt;</span>LRU_BITS<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> </span><span class="token comment">/* Max value of obj-&gt;lru */</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">LRU_CLOCK_RESOLUTION</span> <span class="token expression"><span class="token number">1000</span> </span><span class="token comment">/* LRU clock resolution in ms */</span></span>
</code></pre></div><p>所以现在，你就知道了在默认情况下，全局 LRU 时钟值是 <strong>以 1 秒为精度</strong> 来计算的 UNIX 时间戳，并且它是在 <code>initServerConfig</code> 函数中进行了初始化。</p> <p>那么接下来，你可能还会困惑的问题是：在 Redis server 的运行过程中，<strong>全局 LRU 时钟值是如何更新的呢？</strong></p> <p>这就和 Redis server 在事件驱动框架中，定期运行的时间事件所对应的 <code>serverCron</code> 函数有关了</p> <p><code>serverCron</code> 函数作为时间事件的回调函数，本身会按照一定的频率周期性执行，其频率值是由 Redis 配置文件 redis.conf 中的 hz 配置项决定的。hz 配置项的默认值是 10，这表示 <code>serverCron</code> 函数会每 100 毫秒（1 秒 /10 = 100 毫秒）运行一次。</p> <p>这样，在 <code>serverCron</code> 函数中，全局 LRU 时钟值就会按照这个函数的执行频率，定期调用 <code>getLRUClock</code> 函数进行更新，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">serverCron</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">aeEventLoop</span> <span class="token operator">*</span>eventLoop<span class="token punctuation">,</span> <span class="token keyword">long</span> <span class="token keyword">long</span> id<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>clientData<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
   	<span class="token comment">//默认情况下，每100毫秒调用getLRUClock函数更新一次全局LRU时钟值</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> lruclock <span class="token operator">=</span> <span class="token function">getLRUClock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
    
    <span class="token comment">//设置lruclock变量</span>
    <span class="token function">atomicSet</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>lruclock<span class="token punctuation">,</span>lruclock<span class="token punctuation">)</span><span class="token punctuation">;</span> 
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>所以这样一来，每个键值对就可以从全局 LRU 时钟获取最新的访问时间戳了</p> <p>好，那么接下来，我们就来了解下，对于每个键值对来说，它对应的 redisObject 结构体中的 lru 变量，是在哪些函数中进行初始化和更新的</p> <h2 id="键值对中-lru-时钟值的初始化与更新"><a href="#键值对中-lru-时钟值的初始化与更新" class="header-anchor">#</a> 键值对中 LRU 时钟值的初始化与更新</h2> <p>首先，对于一个键值对来说，它的 LRU 时钟值最初是在这个键值对被创建的时候，进行初始化设置的，这个<strong>初始化操作是在 createObject 函数中调用的</strong>。</p> <p>createObject 函数实现在 object.c 文件当中，当 Redis 要创建一个键值对时，就会调用这个函数。</p> <div class="language-c extra-class"><pre class="language-c"><code>robj <span class="token operator">*</span><span class="token function">createObject</span><span class="token punctuation">(</span><span class="token keyword">int</span> type<span class="token punctuation">,</span> <span class="token keyword">void</span> <span class="token operator">*</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    robj <span class="token operator">*</span>o <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>o<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    o<span class="token operator">-&gt;</span>type <span class="token operator">=</span> type<span class="token punctuation">;</span>
    o<span class="token operator">-&gt;</span>encoding <span class="token operator">=</span> OBJ_ENCODING_RAW<span class="token punctuation">;</span>
    o<span class="token operator">-&gt;</span>ptr <span class="token operator">=</span> ptr<span class="token punctuation">;</span>
    o<span class="token operator">-&gt;</span>refcount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token comment">/* Set the LRU to the current lruclock (minutes resolution), or
     * alternatively the LFU counter. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_LFU<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        o<span class="token operator">-&gt;</span>lru <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">LFUGetTimeInMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;&lt;</span><span class="token number">8</span><span class="token punctuation">)</span> <span class="token operator">|</span> LFU_INIT_VAL<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        o<span class="token operator">-&gt;</span>lru <span class="token operator">=</span> <span class="token function">LRU_CLOCK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> o<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而 createObject 函数除了会给 redisObject 结构体分配内存空间之外，它还会根据我刚才提到的 <strong>maxmemory_policy</strong> 配置项的值，来初始化设置 redisObject 结构体中的 lru 变量。</p> <p>具体来说，就是如果 maxmemory_policy 配置为使用 LFU 策略，那么 lru 变量值会被初始化设置为 LFU 算法的计算值。而如果 maxmemory_policy 配置项没有使用 LFU 策略，那么，createObject 函数就会调用 LRU_CLOCK 函数来设置 lru 变量的值，也就是键值对对应的 LRU 时钟值。</p> <p><strong>LRU_CLOCK</strong> 函数是在 evict.c 文件中实现的，它的作用就是返回当前的全局 LRU 时钟值。因为一个键值对一旦被创建，也就相当于有了一次访问，所以它对应的 LRU 时钟值就表示了它的访问时间戳。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* This function is used to obtain the current LRU clock.
 * If the current resolution is lower than the frequency we refresh the
 * LRU clock (as it should be in production servers) we return the
 * precomputed value, otherwise we need to resort to a system call. */</span>
<span class="token keyword">unsigned</span> <span class="token keyword">int</span> <span class="token function">LRU_CLOCK</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> lruclock<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">1000</span><span class="token operator">/</span>server<span class="token punctuation">.</span>hz <span class="token operator">&lt;=</span> LRU_CLOCK_RESOLUTION<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">atomicGet</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>lruclock<span class="token punctuation">,</span>lruclock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        lruclock <span class="token operator">=</span> <span class="token function">getLRUClock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> lruclock<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么到这里，又出现了一个新的问题：<strong>一个键值对的 LRU 时钟值又是在什么时候被再次更新的呢？</strong></p> <p>其实，<strong>只要一个键值对被访问了，它的 LRU 时钟值就会被更新</strong>。而当一个键值对被访问时，访问操作最终都会调用 <code>lookupKey</code> 函数。</p> <p><code>lookupKey</code> 函数是在 db.c 文件中实现的，它会从全局哈希表中查找要访问的键值对。如果该键值对存在，那么 <code>lookupKey</code> 函数就会根据 maxmemory_policy 的配置值，来更新键值对的 LRU 时钟值，也就是它的访问时间戳。</p> <p>而当 maxmemory_policy 没有配置为 LFU 策略时，<code>lookupKey</code> 函数就会调用 LRU_CLOCK 函数，来获取当前的全局 LRU 时钟值，并将其赋值给键值对的 redisObject 结构体中的 lru 变量，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* Low level key lookup API, not actually called directly from commands
 * implementations that should instead rely on lookupKeyRead(),
 * lookupKeyWrite() and lookupKeyReadWithFlags(). */</span>
robj <span class="token operator">*</span><span class="token function">lookupKey</span><span class="token punctuation">(</span>redisDb <span class="token operator">*</span>db<span class="token punctuation">,</span> robj <span class="token operator">*</span>key<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    dictEntry <span class="token operator">*</span>de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>db<span class="token operator">-&gt;</span>dict<span class="token punctuation">,</span>key<span class="token operator">-&gt;</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 获取键值对对应的redisObject结构体</span>
        robj <span class="token operator">*</span>val <span class="token operator">=</span> <span class="token function">dictGetVal</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token comment">/* Update the access time for the ageing algorithm.
         * Don't do it if we have a saving child, as this will trigger
         * a copy on write madness. */</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">hasActiveChildProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span><span class="token punctuation">(</span>flags <span class="token operator">&amp;</span> LOOKUP_NOTOUCH<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_LFU<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 如果使用了LFU策略，更新LFU计数值</span>
                <span class="token function">updateLFU</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                 <span class="token comment">// 否则，调用LRU_CLOCK函数获取全局LRU时钟值</span>
                val<span class="token operator">-&gt;</span>lru <span class="token operator">=</span> <span class="token function">LRU_CLOCK</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样一来，每个键值对一旦被访问，就能获得最新的访问时间戳了</p> <p>不过现在，你可能要问了：这些访问时间戳最终是如何被用于近似 LRU 算法，来进行数据淘汰的呢？接下来，我们就来学习下近似 LRU 算法的实际执行过程</p> <h2 id="近似-lru-算法的实际执行"><a href="#近似-lru-算法的实际执行" class="header-anchor">#</a> 近似 LRU 算法的实际执行</h2> <p>现在我们已经知道，Redis 之所以实现近似 LRU 算法的目的，是为了减少内存资源和操作时间上的开销。那么在这里，我们其实可以从两个方面来了解近似 LRU 算法的执行过程，分别是</p> <ul><li><strong>When</strong>：什么时候执行</li> <li><strong>How</strong>：如何执行</li></ul> <h3 id="when-什么时候执行"><a href="#when-什么时候执行" class="header-anchor">#</a> <strong>When</strong>：什么时候执行</h3> <p>近似 LRU 算法的主要逻辑是在 <code>freeMemoryIfNeeded</code> 函数中实现的，而这个函数本身是在 evict.c 文件中实现。</p> <p>首先，近似 LRU 算法的主要逻辑是在 <code>freeMemoryIfNeeded</code> 函数中实现的，而这个函数本身是在 evict.c 文件中实现。</p> <p><code>freeMemoryIfNeeded</code> 函数是被 <code>freeMemoryIfNeededAndSafe</code> 函数（在 evict.c 文件中）调用，而 <code>freeMemoryIfNeededAndSafe</code> 函数又是被 <code>processCommand</code> 函数所调用的。你可以参考下面的图，展示了这三者的调用关系。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409160001754.png" alt="image-20240914175809292"></p> <p>所以，我们看到 <code>processCommand</code> 函数，就应该知道这个函数是 Redis 处理每个命令时都会被调用的。</p> <p>那么，<code>processCommand</code> 函数在执行的时候，实际上会根据两个条件来判断是否调用 <code>freeMemoryIfNeededAndSafe</code> 函数。</p> <ul><li>条件一：设置了 <code>maxmemory</code> 配置项为非 0 值。</li> <li>条件二：Lua 脚本没有在超时运行。</li></ul> <p>如果这两个条件成立，那么 <code>processCommand</code> 函数就会调用 <code>freeMemoryIfNeededAndSafe</code> 函数，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>server<span class="token punctuation">.</span>lua_timedout<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    
        <span class="token keyword">int</span> out_of_memory <span class="token operator">=</span> <span class="token function">freeMemoryIfNeededAndSafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_ERR<span class="token punctuation">;</span>
    
<span class="token punctuation">}</span>
</code></pre></div><p>也就是说，只有在这两个条件都不成立的情况下，freeMemoryIfNeeded 函数才会被调用。下面的代码展示了 freeMemoryIfNeededAndSafe 函数的执行逻辑，你可以看下。</p> <ul><li>条件一：Lua 脚本在超时运行</li> <li>条件二：Redis server 正在加载数据</li></ul> <p>也就是说，只有在这两个条件都不成立的情况下，<code>freeMemoryIfNeeded</code> 函数才会被调用。下面的代码展示了 <code>freeMemoryIfNeededAndSafe</code> 函数的执行逻辑，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">freeMemoryIfNeededAndSafe</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>lua_timedout <span class="token operator">||</span> server<span class="token punctuation">.</span>loading<span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">freeMemoryIfNeeded</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样，一旦 <code>freeMemoryIfNeeded</code> 函数被调用了，并且 <code>maxmemory-policy</code> 被设置为了 allkeys-lru 或 volatile-lru，那么近似 LRU 算法就开始被触发执行了。接下来，我们就来看下近似 LRU 算法具体是如何执行的，也就是来了解 <code>freeMemoryIfNeeded</code> 函数的主要执行流程。</p> <h3 id="how-如何执行"><a href="#how-如何执行" class="header-anchor">#</a> <strong>How</strong>：如何执行</h3> <p>近似 LRU 算法的执行可以分成三大步骤，分别是</p> <ol><li>判断当前内存使用情况</li> <li>更新待淘汰的候选键值对集合</li> <li>选择被淘汰的键值对并删除</li></ol> <h4 id="判断当前内存使用情况"><a href="#判断当前内存使用情况" class="header-anchor">#</a> 判断当前内存使用情况</h4> <ul><li>首先，<code>freeMemoryIfNeeded</code> 函数会调用 <code>getMaxmemoryState</code> 函数，评估当前的内存使用情况。<code>getMaxmemoryState</code> 函数是在 evict.c 文件中实现的，它会判断当前 Redis server 使用的内存容量是否超过了 <code>maxmemory</code> 配置的值。</li> <li>如果当前内存使用量没有超过 maxmemory，那么，<code>getMaxmemoryState</code> 函数会返回 C_OK，紧接着，<code>freeMemoryIfNeeded</code> 函数也会直接返回了。</li></ul> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">freeMemoryIfNeeded</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getMaxmemoryState</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mem_reported<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>mem_tofree<span class="token punctuation">,</span><span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token operator">==</span> C_OK<span class="token punctuation">)</span>
            <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里，你需要注意的是，<code>getMaxmemoryState</code> 函数在评估当前内存使用情况的时候，如果发现已用内存超出了 maxmemory，它就会计算需要释放的内存量。这个释放的内存大小等于已使用的内存量减去 maxmemory。不过，已使用的内存量并不包括用于主从复制的复制缓冲区大小，这是 <code>getMaxmemoryState</code> 函数，通过调用 <code>freeMemoryGetNotCountedMemory</code> 函数来计算的。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* Get the memory status from the point of view of the maxmemory directive:
 * if the memory used is under the maxmemory setting then C_OK is returned.
 * Otherwise, if we are over the memory limit, the function returns
 * C_ERR.
 *
 * The function may return additional info via reference, only if the
 * pointers to the respective arguments is not NULL. Certain fields are
 * populated only when C_ERR is returned:
 *
 *  'total'     total amount of bytes used.
 *              (Populated both for C_ERR and C_OK)
 *
 *  'logical'   the amount of memory used minus the slaves/AOF buffers.
 *              (Populated when C_ERR is returned)
 *
 *  'tofree'    the amount of memory that should be released
 *              in order to return back into the memory limits.
 *              (Populated when C_ERR is returned)
 *
 *  'level'     this usually ranges from 0 to 1, and reports the amount of
 *              memory currently used. May be &gt; 1 if we are over the memory
 *              limit.
 *              (Populated both for C_ERR and C_OK)
 */</span>
<span class="token keyword">int</span> <span class="token function">getMaxmemoryState</span><span class="token punctuation">(</span><span class="token class-name">size_t</span> <span class="token operator">*</span>total<span class="token punctuation">,</span> <span class="token class-name">size_t</span> <span class="token operator">*</span>logical<span class="token punctuation">,</span> <span class="token class-name">size_t</span> <span class="token operator">*</span>tofree<span class="token punctuation">,</span> <span class="token keyword">float</span> <span class="token operator">*</span>level<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">size_t</span> mem_reported<span class="token punctuation">,</span> mem_used<span class="token punctuation">,</span> mem_tofree<span class="token punctuation">;</span>

    <span class="token comment">/* Check if we are over the memory usage limit. If we are not, no need
     * to subtract the slaves output buffers. We can just return ASAP. */</span>
    <span class="token comment">// 计算已使用的内存量</span>
    mem_reported <span class="token operator">=</span> <span class="token function">zmalloc_used_memory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>total<span class="token punctuation">)</span> <span class="token operator">*</span>total <span class="token operator">=</span> mem_reported<span class="token punctuation">;</span>

    <span class="token comment">/* We may return ASAP if there is no need to compute the level. */</span>
    <span class="token keyword">int</span> return_ok_asap <span class="token operator">=</span> <span class="token operator">!</span>server<span class="token punctuation">.</span>maxmemory <span class="token operator">||</span> mem_reported <span class="token operator">&lt;=</span> server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>return_ok_asap <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>level<span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token comment">/* Remove the size of slaves output buffers and AOF buffer from the
     * count of used memory. */</span>
    <span class="token comment">// 将用于主从复制的复制缓冲区大小和AOF缓冲区大小从已使用内存量中扣除</span>
    mem_used <span class="token operator">=</span> mem_reported<span class="token punctuation">;</span>
    <span class="token class-name">size_t</span> overhead <span class="token operator">=</span> <span class="token function">freeMemoryGetNotCountedMemory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mem_used <span class="token operator">=</span> <span class="token punctuation">(</span>mem_used <span class="token operator">&gt;</span> overhead<span class="token punctuation">)</span> <span class="token operator">?</span> mem_used<span class="token operator">-</span>overhead <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>


    <span class="token comment">/* Compute the ratio of memory usage. */</span>
    <span class="token comment">// 计算内存使用率。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>level<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token operator">*</span>level <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token operator">*</span>level <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>mem_used <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>return_ok_asap<span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token comment">/* Check if we are still over the memory limit. */</span>
    <span class="token comment">// 检查我们是否仍然超过内存限制。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>mem_used <span class="token operator">&lt;=</span> server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">)</span> <span class="token keyword">return</span> C_OK<span class="token punctuation">;</span>

    <span class="token comment">// 计算需要释放的内存量</span>
    <span class="token comment">/* Compute how much memory we need to free. */</span>
    mem_tofree <span class="token operator">=</span> mem_used <span class="token operator">-</span> server<span class="token punctuation">.</span>maxmemory<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>logical<span class="token punctuation">)</span> <span class="token operator">*</span>logical <span class="token operator">=</span> mem_used<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>tofree<span class="token punctuation">)</span> <span class="token operator">*</span>tofree <span class="token operator">=</span> mem_tofree<span class="token punctuation">;</span>

    <span class="token keyword">return</span> C_ERR<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而如果当前 server 使用的内存量，的确已经超出 maxmemory 的上限了，那么 <code>freeMemoryIfNeeded</code> 函数就会执行一个 <strong>while 循环</strong>，来淘汰数据释放内存。</p> <p>其实，为了淘汰数据，Redis 定义了一个数组 <code>EvictionPoolLRU</code>，用来保存待淘汰的候选键值对。这个数组的元素类型是 <code>evictionPoolEntry</code> 结构体，该结构体保存了待淘汰键值对的空闲时间 idle、对应的 key 等信息。以下代码展示了 <code>EvictionPoolLRU</code> 数组和 <code>evictionPoolEntry</code> 结构体，它们都是在 evict.c 文件中定义的。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">evictionPoolEntry</span> <span class="token punctuation">{</span>
    <span class="token comment">// 待淘汰的键值对的空闲时间</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> idle<span class="token punctuation">;</span>    
    <span class="token comment">// 待淘汰的键值对的key</span>
    sds key<span class="token punctuation">;</span>                    
    <span class="token comment">// 缓存的SDS对象</span>
    sds cached<span class="token punctuation">;</span>                 
    <span class="token comment">// 待淘汰键值对的key所在的数据库ID</span>
    <span class="token keyword">int</span> dbid<span class="token punctuation">;</span>                   
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">static</span> <span class="token keyword">struct</span> <span class="token class-name">evictionPoolEntry</span> <span class="token operator">*</span>EvictionPoolLRU<span class="token punctuation">;</span>
</code></pre></div><p>这样，Redis server 在执行 initSever 函数进行初始化时，会调用 <code>evictionPoolAlloc</code> 函数（在 evict.c 文件中）为 EvictionPoolLRU 数组分配内存空间，该数组的大小由宏定义 EVPOOL_SIZE（在 evict.c 文件中）决定，默认是 16 个元素，也就是可以保存 16 个待淘汰的候选键值对。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">EVPOOL_SIZE</span> <span class="token expression"><span class="token number">16</span></span></span>

<span class="token comment">/* Create a new eviction pool. */</span>
<span class="token keyword">void</span> <span class="token function">evictionPoolAlloc</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">evictionPoolEntry</span> <span class="token operator">*</span>ep<span class="token punctuation">;</span>
    <span class="token keyword">int</span> j<span class="token punctuation">;</span>

    ep <span class="token operator">=</span> <span class="token function">zmalloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>ep<span class="token punctuation">)</span><span class="token operator">*</span>EVPOOL_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> EVPOOL_SIZE<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ep<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>idle <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
        ep<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
        ep<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>cached <span class="token operator">=</span> <span class="token function">sdsnewlen</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span>EVPOOL_CACHED_SDS_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
        ep<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    EvictionPoolLRU <span class="token operator">=</span> ep<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>那么，<code>freeMemoryIfNeeded</code> 函数在淘汰数据的循环流程中，就会更新这个待淘汰的候选键值对集合，也就是 EvictionPoolLRU 数组。下面我就来给你具体介绍一下。</p> <h4 id="更新待淘汰的候选键值对集合"><a href="#更新待淘汰的候选键值对集合" class="header-anchor">#</a> 更新待淘汰的候选键值对集合</h4> <p>首先，<code>freeMemoryIfNeeded</code> 函数会调用 <code>evictionPoolPopulate</code> 函数（在 evict.c 文件中），而 <code>evictionPoolPopulate</code> 函数会先调用 <code>dictGetSomeKeys</code> 函数（在 dict.c 文件中），从待采样的哈希表中随机获取一定数量的 key。</p> <p>不过，这里还有两个地方你需要注意下。</p> <p>第一点，<code>dictGetSomeKeys</code> 函数采样的哈希表，是由 maxmemory_policy 配置项来决定的。</p> <p>如果 maxmemory_policy 配置的是 allkeys_lru，那么待采样哈希表就是 Redis server 的全局哈希表，也就是在所有键值对中进行采样；否则，待采样哈希表就是保存着设置了过期时间的 key 的哈希表。</p> <p>以下代码是 <code>freeMemoryIfNeeded</code> 函数中对 <code>evictionPoolPopulate</code> 函数的调用过程，你可以看下。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">/* We don't want to make local-db choices when expiring keys,
 * so to start populate the eviction pool sampling keys from
 * every DB. */</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> server<span class="token punctuation">.</span>dbnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 对Redis server上的每一个数据库都执行</span>
    db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>i<span class="token punctuation">;</span>
    <span class="token comment">// 根据淘汰策略，决定使用全局哈希表还是设置了过期时间的key的哈希表</span>
    dict <span class="token operator">=</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_ALLKEYS<span class="token punctuation">)</span> <span class="token operator">?</span>
            db<span class="token operator">-&gt;</span>dict <span class="token operator">:</span> db<span class="token operator">-&gt;</span>expires<span class="token punctuation">;</span>
    <span class="token comment">// 将选择的哈希表dict传入evictionPoolPopulate函数，同时将全局哈希表也传给evictionPoolPopulate函数</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>keys <span class="token operator">=</span> <span class="token function">dictSize</span><span class="token punctuation">(</span>dict<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">evictionPoolPopulate</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> dict<span class="token punctuation">,</span> db<span class="token operator">-&gt;</span>dict<span class="token punctuation">,</span> pool<span class="token punctuation">)</span><span class="token punctuation">;</span>
        total_keys <span class="token operator">+=</span> keys<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>第二点，<code>dictGetSomeKeys</code> 函数采样的 key 的数量，是由 redis.conf 中的配置项 maxmemory-samples 决定的，该配置项的默认值是 5。下面代码就展示了 <code>evictionPoolPopulate</code> 函数对 <code>dictGetSomeKeys</code> 函数的调用：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">void</span> <span class="token function">evictionPoolPopulate</span><span class="token punctuation">(</span><span class="token keyword">int</span> dbid<span class="token punctuation">,</span> dict <span class="token operator">*</span>sampledict<span class="token punctuation">,</span> dict <span class="token operator">*</span>keydict<span class="token punctuation">,</span> <span class="token keyword">struct</span> <span class="token class-name">evictionPoolEntry</span> <span class="token operator">*</span>pool<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token comment">//采样后的集合，大小为maxmemory_samples</span>
    dictEntry <span class="token operator">*</span>samples<span class="token punctuation">[</span>server<span class="token punctuation">.</span>maxmemory_samples<span class="token punctuation">]</span><span class="token punctuation">;</span> 
    
    <span class="token comment">//将待采样的哈希表sampledict、采样后的集合samples、以及采样数量maxmemory_samples，作为参数传给dictGetSomeKeys</span>
    count <span class="token operator">=</span> <span class="token function">dictGetSomeKeys</span><span class="token punctuation">(</span>sampledict<span class="token punctuation">,</span>samples<span class="token punctuation">,</span>server<span class="token punctuation">.</span>maxmemory_samples<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如此一来，<code>dictGetSomeKeys</code> 函数就能返回采样的键值对集合了。然后，<code>evictionPoolPopulate</code> 函数会根据实际采样到的键值对数量 count，执行一个循环。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> count<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_LRU<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    	idle <span class="token operator">=</span> <span class="token function">estimateObjectIdleTime</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre></div><p>紧接着，<code>evictionPoolPopulate</code> 函数会遍历待淘汰的候选键值对集合，也就是 <code>EvictionPoolLRU</code> 数组。在遍历过程中，它会尝试把采样的每一个键值对插入 EvictionPoolLRU 数组，这主要取决于以下两个条件之一：</p> <ul><li>一是，它能在数组中找到一个尚未插入键值对的空位</li> <li>二是，它能在数组中找到一个空闲时间小于采样键值对空闲时间的键值对</li></ul> <p>这两个条件有一个成立的话，evictionPoolPopulate 函数就可以把采样键值对插入 EvictionPoolLRU 数组。等所有采样键值对都处理完后，<code>evictionPoolPopulate</code> 函数就完成对待淘汰候选键值对集合的更新了。</p> <p>接下来，<code>freeMemoryIfNeeded</code> 函数，就可以开始选择最终被淘汰的键值对了。</p> <h4 id="选择被淘汰的键值对并删除"><a href="#选择被淘汰的键值对并删除" class="header-anchor">#</a> 选择被淘汰的键值对并删除</h4> <p>因为 <code>evictionPoolPopulate</code> 函数已经更新了 EvictionPoolLRU 数组，而且这个数组里面的 key，是按照空闲时间从小到大排好序了。所以，<code>freeMemoryIfNeeded</code> 函数会遍历一次 EvictionPoolLRU 数组，从数组的最后一个 key 开始选择，如果选到的 key 不是空值，那么就把它作为最终淘汰的 key。</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token comment">// 从数组最后一个key开始查找</span>
<span class="token comment">/* Go backward from best to worst element to evict. */</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span> EVPOOL_SIZE<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> k<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 当前key为空值，则查找下一个key</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>
    bestdbid <span class="token operator">=</span> pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid<span class="token punctuation">;</span>
    <span class="token comment">// 从全局哈希表或是expire哈希表中，获取当前key对应的键值对；并将当前key从EvictionPoolLRU数组删除</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>maxmemory_policy <span class="token operator">&amp;</span> MAXMEMORY_FLAG_ALLKEYS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>db<span class="token punctuation">[</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid<span class="token punctuation">]</span><span class="token punctuation">.</span>dict<span class="token punctuation">,</span>
            pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        de <span class="token operator">=</span> <span class="token function">dictFind</span><span class="token punctuation">(</span>server<span class="token punctuation">.</span>db<span class="token punctuation">[</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>dbid<span class="token punctuation">]</span><span class="token punctuation">.</span>expires<span class="token punctuation">,</span>
            pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* Remove the entry from the pool. */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">!=</span> pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>cached<span class="token punctuation">)</span>
        <span class="token function">sdsfree</span><span class="token punctuation">(</span>pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>key <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
    pool<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>idle <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token comment">/* If the key exists, is our pick. Otherwise it is
     * a ghost and we need to try the next element. */</span>
    <span class="token comment">// 如果当前key对应的键值对不为空，选择当前key为被淘汰的key</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>de<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        bestkey <span class="token operator">=</span> <span class="token function">dictGetKey</span><span class="token punctuation">(</span>de<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">//否则，继续查找下个key</span>
        <span class="token comment">/* Ghost... Iterate again. */</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>最后，一旦选到了被淘汰的 key，freeMemoryIfNeeded 函数就会 <strong>根据 Redis server 的惰性删除配置</strong>，来执行同步删除或异步删除，如下所示：</p> <div class="language-c extra-class"><pre class="language-c"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>bestkey<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    db <span class="token operator">=</span> server<span class="token punctuation">.</span>db<span class="token operator">+</span>bestdbid<span class="token punctuation">;</span>
    robj <span class="token operator">*</span>keyobj <span class="token operator">=</span> <span class="token function">createStringObject</span><span class="token punctuation">(</span>bestkey<span class="token punctuation">,</span><span class="token function">sdslen</span><span class="token punctuation">(</span>bestkey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//将删除key的信息传递给从库和AOF文件</span>
    <span class="token function">propagateExpire</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">,</span>server<span class="token punctuation">.</span>lazyfree_lazy_eviction<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//如果配置了惰性删除，则进行异步删除</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>server<span class="token punctuation">.</span>lazyfree_lazy_eviction<span class="token punctuation">)</span>
    	<span class="token function">dbAsyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">else</span>  <span class="token comment">//否则进行同步删除</span>
    	<span class="token function">dbSyncDelete</span><span class="token punctuation">(</span>db<span class="token punctuation">,</span>keyobj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>好了，到这里，<code>freeMemoryIfNeeded</code> 函数就淘汰了一个 key。而如果此时，释放的内存空间还不够，也就是说没有达到我前面介绍的待释放空间，那么 <code>freeMemoryIfNeeded</code> 函数还会重复执行前面所说的更新待淘汰候选键值对集合、选择最终淘汰 key 的过程，直到满足待释放空间的大小要求。</p> <p>下图就展示了 <code>freeMemoryIfNeeded</code> 函数涉及的基本流程，你可以再来整体回顾下。</p> <p><img src="https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409160001829.png" alt="image-20240914180834370"></p> <p>所以，你会发现</p> <p>近似 LRU 算法并没有使用耗时耗空间的链表，而是<strong>使用了固定大小的待淘汰数据集合，每次随机选择一些 key 加入待淘汰数据集合中。最后，再按照待淘汰集合中 key 的空闲时间长度，删除空闲时间最长的 key</strong>。</p> <p>这样一来，Redis 就近似实现了 LRU 算法的效果了。</p> <h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>在本文中，我们深入探讨了 Redis 中LRU（Least Recently Used）算法的实现方式，以及其在内存淘汰策略中的应用。</p> <ol><li>我们了解了<strong>传统LRU算法</strong>，尽管它通过维护一个精确的双向链表来记录每个键的访问时间顺序，但在实际大规模应用中会带来严重的<strong>性能开销</strong>。这种实现需要频繁更新链表，尤其是在高并发情况下，操作成本极高且资源占用过多</li> <li>为了应对这些问题，Redis采用了<strong>近似LRU算法</strong>，通过<strong>全局LRU时钟</strong>和<strong>随机采样</strong>的方式，有效降低了资源消耗。全局时钟以秒为精度，尽管存在微小的时间戳冲突风险，但它大大减少了为每个键记录精确时间的开销。而通过随机采样选择淘汰对象，Redis避免了遍历所有数据带来的性能瓶颈，进一步提高了算法效率。</li> <li>探讨了Redis的内存管理机制，尤其是它何时以及如何触发内存淘汰。通过<strong>EvictionPoolLRU数组</strong>维护待淘汰键值对的集合，Redis确保可以在较小的时间复杂度内找到空闲时间最长的键。这个固定大小的数组设计避免了复杂的链表操作，实现了在性能和准确性之间的平衡。</li> <li>Redis提供了灵活的内存淘汰策略，如<strong>同步删除</strong>和<strong>异步删除</strong>，使得在不同使用场景下可以自由选择最适合的策略，进一步优化了内存管理的灵活性。</li> <li>Redis通过这种<strong>近似LRU策略</strong>实现了高效、低成本的内存管理机制，为大规模高并发场景提供了强有力的支持。这一设计展示了在资源受限的环境中，如何在<strong>性能</strong>与<strong>实现成本</strong>之间做出合理的权衡与优化</li></ol> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li><p><a href="https://time.geekbang.org/column/intro/100084301?utm_campaign=geektime_search&amp;utm_content=geektime_search&amp;utm_medium=geektime_search&amp;utm_source=geektime_search&amp;utm_term=geektime_search" target="_blank" rel="noopener noreferrer">极客时间：Redis源码剖析与实战<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://book.douban.com/subject/25900156/" target="_blank" rel="noopener noreferrer">Redis设计与实现 <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://github.com/redis/redis/blob/5.0/src/ae.c" target="_blank" rel="noopener noreferrer">Github：redis 源码<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/echo-lxy/echo-system-design/edit/master/docs/Redis 系统设计/04.四、支线任务/05.LRU 策略.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新于:</span> <span class="time">2024/09/18, 11:29:27</span></div></div> <div class="page-nav-wapper"><!----> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/0850b6/" class="prev">Redis 多IO线程</a></span> <span class="next"><a href="/pages/b43a89/">LFU 策略</a>→
      </span></p></div></div></div> <!----></main></div> <div class="footer"><div class="icons"><a href="mailto:lixinyang2002@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/echo-lxy" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=755597173" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2024-2024
    <span>Xinyang Li | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.9830b779.js" defer></script><script src="/assets/js/2.933750c6.js" defer></script><script src="/assets/js/71.4f744076.js" defer></script><script src="/assets/js/7.7eb70372.js" defer></script>
  </body>
</html>
