(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(e){function n(n){for(var r,a,s=n[0],c=n[1],l=n[2],d=0,h=[];d<s.length;d++)a=s[d],Object.prototype.hasOwnProperty.call(i,a)&&i[a]&&h.push(i[a][0]),i[a]=0;for(r in c)Object.prototype.hasOwnProperty.call(c,r)&&(e[r]=c[r]);for(u&&u(n);h.length;)h.shift()();return o.push.apply(o,l||[]),t()}function t(){for(var e,n=0;n<o.length;n++){for(var t=o[n],r=!0,s=1;s<t.length;s++){var c=t[s];0!==i[c]&&(r=!1)}r&&(o.splice(n--,1),e=a(a.s=t[0]))}return e}var r={},i={1:0},o=[];function a(n){if(r[n])return r[n].exports;var t=r[n]={i:n,l:!1,exports:{}};return e[n].call(t.exports,t,t.exports,a),t.l=!0,t.exports}a.e=function(e){var n=[],t=i[e];if(0!==t)if(t)n.push(t[2]);else{var r=new Promise((function(n,r){t=i[e]=[n,r]}));n.push(t[2]=r);var o,s=document.createElement("script");s.charset="utf-8",s.timeout=120,a.nc&&s.setAttribute("nonce",a.nc),s.src=function(e){return a.p+"assets/js/"+({}[e]||e)+"."+{2:"81691b95",3:"5c823049",4:"d012670c",5:"5f9e995c",6:"1d69a153",7:"99be63e1",8:"c5f532e7",9:"9a10a51e",10:"6869f4d5",11:"f33f1a9d",12:"952650dc",13:"3e99a433",14:"c4f16567",15:"782cef8f",16:"d2aa04ae",17:"82e86adf",18:"1f0c09a7",19:"7809214b",20:"0ca7027c",21:"ee4c4ecc",22:"eb167c4e",23:"1c43ec04",24:"1af4b06e",25:"0a985889",26:"3370bf71",27:"2b3c56ad",28:"880645d2",29:"31ef91c9",30:"56ac9a52",31:"97191c72",32:"1166b029",33:"c360fa8c",34:"a632c0e9"}[e]+".js"}(e);var c=new Error;o=function(n){s.onerror=s.onload=null,clearTimeout(l);var t=i[e];if(0!==t){if(t){var r=n&&("load"===n.type?"missing":n.type),o=n&&n.target&&n.target.src;c.message="Loading chunk "+e+" failed.\n("+r+": "+o+")",c.name="ChunkLoadError",c.type=r,c.request=o,t[1](c)}i[e]=void 0}};var l=setTimeout((function(){o({type:"timeout",target:s})}),12e4);s.onerror=s.onload=o,document.head.appendChild(s)}return Promise.all(n)},a.m=e,a.c=r,a.d=function(e,n,t){a.o(e,n)||Object.defineProperty(e,n,{enumerable:!0,get:t})},a.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},a.t=function(e,n){if(1&n&&(e=a(e)),8&n)return e;if(4&n&&"object"==typeof e&&e&&e.__esModule)return e;var t=Object.create(null);if(a.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:e}),2&n&&"string"!=typeof e)for(var r in e)a.d(t,r,function(n){return e[n]}.bind(null,r));return t},a.n=function(e){var n=e&&e.__esModule?function(){return e.default}:function(){return e};return a.d(n,"a",n),n},a.o=function(e,n){return Object.prototype.hasOwnProperty.call(e,n)},a.p="/",a.oe=function(e){throw console.error(e),e};var s=window.webpackJsonp=window.webpackJsonp||[],c=s.push.bind(s);s.push=n,s=s.slice();for(var l=0;l<s.length;l++)n(s[l]);var u=c;o.push([106,0]),t()}([function(e,n,t){"use strict";var r=function(e){return e&&e.Math===Math&&e};e.exports=r("object"==typeof globalThis&&globalThis)||r("object"==typeof window&&window)||r("object"==typeof self&&self)||r("object"==typeof global&&global)||r("object"==typeof this&&this)||function(){return this}()||Function("return this")()},function(e,n,t){"use strict";var r="object"==typeof document&&document.all;e.exports=void 0===r&&void 0!==r?function(e){return"function"==typeof e||e===r}:function(e){return"function"==typeof e}},function(e,n,t){"use strict";var r=t(26),i=Function.prototype,o=i.call,a=r&&i.bind.bind(o,o);e.exports=r?a:function(e){return function(){return o.apply(e,arguments)}}},function(e,n,t){"use strict";e.exports=function(e){try{return!!e()}catch(e){return!0}}},function(e,n,t){"use strict";function r(e,n,t,r,i,o,a,s){var c,l="function"==typeof e?e.options:e;if(n&&(l.render=n,l.staticRenderFns=t,l._compiled=!0),r&&(l.functional=!0),o&&(l._scopeId="data-v-"+o),a?(c=function(e){(e=e||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(e=__VUE_SSR_CONTEXT__),i&&i.call(this,e),e&&e._registeredComponents&&e._registeredComponents.add(a)},l._ssrRegister=c):i&&(c=s?function(){i.call(this,(l.functional?this.parent:this).$root.$options.shadowRoot)}:i),c)if(l.functional){l._injectStyles=c;var u=l.render;l.render=function(e,n){return c.call(n),u(e,n)}}else{var d=l.beforeCreate;l.beforeCreate=d?[].concat(d,c):[c]}return{exports:e,options:l}}t.d(n,"a",(function(){return r}))},function(e,n,t){"use strict";var r=t(3);e.exports=!r((function(){return 7!==Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(e,n){var t=Array.isArray;e.exports=t},function(e,n,t){"use strict";var r=t(1);e.exports=function(e){return"object"==typeof e?null!==e:r(e)}},function(e,n,t){var r=t(69),i="object"==typeof self&&self&&self.Object===Object&&self,o=r||i||Function("return this")();e.exports=o},function(e,n,t){"use strict";var r=t(2),i=t(31),o=r({}.hasOwnProperty);e.exports=Object.hasOwn||function(e,n){return o(i(e),n)}},function(e,n,t){var r=t(165),i=t(168);e.exports=function(e,n){var t=i(e,n);return r(t)?t:void 0}},function(e,n,t){"use strict";t.d(n,"e",(function(){return r})),t.d(n,"b",(function(){return o})),t.d(n,"j",(function(){return a})),t.d(n,"g",(function(){return c})),t.d(n,"h",(function(){return l})),t.d(n,"i",(function(){return u})),t.d(n,"c",(function(){return d})),t.d(n,"f",(function(){return h})),t.d(n,"l",(function(){return p})),t.d(n,"m",(function(){return f})),t.d(n,"d",(function(){return v})),t.d(n,"k",(function(){return g})),t.d(n,"n",(function(){return y})),t.d(n,"a",(function(){return _}));t(16);const r=/#.*$/,i=/\.(md|html)$/,o=/\/$/,a=/^[a-z]+:/i;function s(e){return decodeURI(e).replace(r,"").replace(i,"")}function c(e){return a.test(e)}function l(e){return/^mailto:/.test(e)}function u(e){return/^tel:/.test(e)}function d(e){if(c(e))return e;if(!e)return"404";const n=e.match(r),t=n?n[0]:"",i=s(e);return o.test(i)?e:i+".html"+t}function h(e,n){const t=e.hash,i=function(e){const n=e&&e.match(r);if(n)return n[0]}(n);if(i&&t!==i)return!1;return s(e.path)===s(n)}function p(e,n,t){if(c(n))return{type:"external",path:n};t&&(n=function(e,n,t){const r=e.charAt(0);if("/"===r)return e;if("?"===r||"#"===r)return n+e;const i=n.split("/");t&&i[i.length-1]||i.pop();const o=e.replace(/^\//,"").split("/");for(let e=0;e<o.length;e++){const n=o[e];".."===n?i.pop():"."!==n&&i.push(n)}""!==i[0]&&i.unshift("");return i.join("/")}(n,t));const r=s(n);for(let n=0;n<e.length;n++)if(s(e[n].regularPath)===r)return Object.assign({},e[n],{type:"page",path:d(e[n].path)});return console.error(`[vuepress] No matching page found for sidebar item "${n}"`),{}}function f(e,n,t,r){const{pages:i,themeConfig:o}=t,a=r&&o.locales&&o.locales[r]||o;if("auto"===(e.frontmatter.sidebar||a.sidebar||o.sidebar))return m(e);const s=a.sidebar||o.sidebar;if(s){const{base:t,config:r}=function(e,n){if(Array.isArray(n))return{base:"/",config:n};for(const r in n)if(0===(t=e,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(r)))return{base:r,config:n[r]};var t;return{}}(n,s);return"auto"===r?m(e):r?r.map(e=>function e(n,t,r,i=1){if("string"==typeof n)return p(t,n,r);if(Array.isArray(n))return Object.assign(p(t,n[0],r),{title:n[1]});{i>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const o=n.children||[];return 0===o.length&&n.path?Object.assign(p(t,n.path,r),{title:n.title}):{type:"group",path:n.path,title:n.title,sidebarDepth:n.sidebarDepth,initialOpenGroupIndex:n.initialOpenGroupIndex,children:o.map(n=>e(n,t,r,i+1)),collapsable:!1!==n.collapsable}}}(e,i,t)):[]}return[]}function m(e){const n=v(e.headers||[]);return[{type:"group",collapsable:!1,title:e.title,path:null,children:n.map(n=>({type:"auto",title:n.title,basePath:e.path,path:e.path+"#"+n.slug,children:n.children||[]}))}]}function v(e){let n;return(e=e.map(e=>Object.assign({},e))).forEach(e=>{2===e.level?n=e:n&&(n.children||(n.children=[])).push(e)}),e.filter(e=>2===e.level)}function g(e){return Object.assign(e,{type:e.items&&e.items.length?"links":"link"})}function y(e){return Object.prototype.toString.call(e).match(/\[object (.*?)\]/)[1].toLowerCase()}function b(e){let n=e.frontmatter.date||e.lastUpdated||new Date,t=new Date(n);return"Invalid Date"==t&&n&&(t=new Date(n.replace(/-/g,"/"))),t.getTime()}function _(e,n){return b(n)-b(e)}},function(e,n){e.exports=function(e){return null!=e&&"object"==typeof e}},function(e,n,t){var r=t(15),i=t(150),o=t(151),a=r?r.toStringTag:void 0;e.exports=function(e){return null==e?void 0===e?"[object Undefined]":"[object Null]":a&&a in Object(e)?i(e):o(e)}},function(e,n,t){"use strict";var r=t(5),i=t(17),o=t(34);e.exports=r?function(e,n,t){return i.f(e,n,o(1,t))}:function(e,n,t){return e[n]=t,e}},function(e,n,t){var r=t(8).Symbol;e.exports=r},function(e,n,t){"use strict";var r=t(25),i=t(31),o=t(32),a=t(144),s=t(146);r({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(e){return e instanceof TypeError}}()},{push:function(e){var n=i(this),t=o(n),r=arguments.length;s(t+r);for(var c=0;c<r;c++)n[t]=arguments[c],t++;return a(n,t),t}})},function(e,n,t){"use strict";var r=t(5),i=t(64),o=t(101),a=t(47),s=t(54),c=TypeError,l=Object.defineProperty,u=Object.getOwnPropertyDescriptor;n.f=r?o?function(e,n,t){if(a(e),n=s(n),a(t),"function"==typeof e&&"prototype"===n&&"value"in t&&"writable"in t&&!t.writable){var r=u(e,n);r&&r.writable&&(e[n]=t.value,t={configurable:"configurable"in t?t.configurable:r.configurable,enumerable:"enumerable"in t?t.enumerable:r.enumerable,writable:!1})}return l(e,n,t)}:l:function(e,n,t){if(a(e),n=s(n),a(t),i)try{return l(e,n,t)}catch(e){}if("get"in t||"set"in t)throw new c("Accessors not supported");return"value"in t&&(e[n]=t.value),e}},function(e,n,t){"use strict";var r=t(2),i=r({}.toString),o=r("".slice);e.exports=function(e){return o(i(e),8,-1)}},function(e,n,t){var r=t(155),i=t(156),o=t(157),a=t(158),s=t(159);function c(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var r=e[n];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=a,c.prototype.set=s,e.exports=c},function(e,n,t){var r=t(71);e.exports=function(e,n){for(var t=e.length;t--;)if(r(e[t][0],n))return t;return-1}},function(e,n,t){var r=t(10)(Object,"create");e.exports=r},function(e,n,t){var r=t(177);e.exports=function(e,n){var t=e.__data__;return r(n)?t["string"==typeof n?"string":"hash"]:t.map}},function(e,n,t){var r=t(45);e.exports=function(e){if("string"==typeof e||r(e))return e;var n=e+"";return"0"==n&&1/e==-1/0?"-0":n}},function(e,n,t){var r,i;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(i="function"==typeof(r=function(){var e,n,t={version:"0.2.0"},r=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function i(e,n,t){return e<n?n:e>t?t:e}function o(e){return 100*(-1+e)}t.configure=function(e){var n,t;for(n in e)void 0!==(t=e[n])&&e.hasOwnProperty(n)&&(r[n]=t);return this},t.status=null,t.set=function(e){var n=t.isStarted();e=i(e,r.minimum,1),t.status=1===e?null:e;var c=t.render(!n),l=c.querySelector(r.barSelector),u=r.speed,d=r.easing;return c.offsetWidth,a((function(n){""===r.positionUsing&&(r.positionUsing=t.getPositioningCSS()),s(l,function(e,n,t){var i;return(i="translate3d"===r.positionUsing?{transform:"translate3d("+o(e)+"%,0,0)"}:"translate"===r.positionUsing?{transform:"translate("+o(e)+"%,0)"}:{"margin-left":o(e)+"%"}).transition="all "+n+"ms "+t,i}(e,u,d)),1===e?(s(c,{transition:"none",opacity:1}),c.offsetWidth,setTimeout((function(){s(c,{transition:"all "+u+"ms linear",opacity:0}),setTimeout((function(){t.remove(),n()}),u)}),u)):setTimeout(n,u)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var e=function(){setTimeout((function(){t.status&&(t.trickle(),e())}),r.trickleSpeed)};return r.trickle&&e(),this},t.done=function(e){return e||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(e){var n=t.status;return n?("number"!=typeof e&&(e=(1-n)*i(Math.random()*n,.1,.95)),n=i(n+e,0,.994),t.set(n)):t.start()},t.trickle=function(){return t.inc(Math.random()*r.trickleRate)},e=0,n=0,t.promise=function(r){return r&&"resolved"!==r.state()?(0===n&&t.start(),e++,n++,r.always((function(){0==--n?(e=0,t.done()):t.set((e-n)/e)})),this):this},t.render=function(e){if(t.isRendered())return document.getElementById("nprogress");l(document.documentElement,"nprogress-busy");var n=document.createElement("div");n.id="nprogress",n.innerHTML=r.template;var i,a=n.querySelector(r.barSelector),c=e?"-100":o(t.status||0),u=document.querySelector(r.parent);return s(a,{transition:"all 0 linear",transform:"translate3d("+c+"%,0,0)"}),r.showSpinner||(i=n.querySelector(r.spinnerSelector))&&h(i),u!=document.body&&l(u,"nprogress-custom-parent"),u.appendChild(n),n},t.remove=function(){u(document.documentElement,"nprogress-busy"),u(document.querySelector(r.parent),"nprogress-custom-parent");var e=document.getElementById("nprogress");e&&h(e)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var e=document.body.style,n="WebkitTransform"in e?"Webkit":"MozTransform"in e?"Moz":"msTransform"in e?"ms":"OTransform"in e?"O":"";return n+"Perspective"in e?"translate3d":n+"Transform"in e?"translate":"margin"};var a=function(){var e=[];function n(){var t=e.shift();t&&t(n)}return function(t){e.push(t),1==e.length&&n()}}(),s=function(){var e=["Webkit","O","Moz","ms"],n={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(e,n){return n.toUpperCase()})),n[t]||(n[t]=function(n){var t=document.body.style;if(n in t)return n;for(var r,i=e.length,o=n.charAt(0).toUpperCase()+n.slice(1);i--;)if((r=e[i]+o)in t)return r;return n}(t))}function r(e,n,r){n=t(n),e.style[n]=r}return function(e,n){var t,i,o=arguments;if(2==o.length)for(t in n)void 0!==(i=n[t])&&n.hasOwnProperty(t)&&r(e,t,i);else r(e,o[1],o[2])}}();function c(e,n){return("string"==typeof e?e:d(e)).indexOf(" "+n+" ")>=0}function l(e,n){var t=d(e),r=t+n;c(t,n)||(e.className=r.substring(1))}function u(e,n){var t,r=d(e);c(e,n)&&(t=r.replace(" "+n+" "," "),e.className=t.substring(1,t.length-1))}function d(e){return(" "+(e.className||"")+" ").replace(/\s+/gi," ")}function h(e){e&&e.parentNode&&e.parentNode.removeChild(e)}return t})?r.call(n,t,n,e):r)||(e.exports=i)},function(e,n,t){"use strict";var r=t(0),i=t(52).f,o=t(14),a=t(97),s=t(37),c=t(65),l=t(124);e.exports=function(e,n){var t,u,d,h,p,f=e.target,m=e.global,v=e.stat;if(t=m?r:v?r[f]||s(f,{}):r[f]&&r[f].prototype)for(u in n){if(h=n[u],d=e.dontCallGetSet?(p=i(t,u))&&p.value:t[u],!l(m?u:f+(v?".":"#")+u,e.forced)&&void 0!==d){if(typeof h==typeof d)continue;c(h,d)}(e.sham||d&&d.sham)&&o(h,"sham",!0),a(t,u,h,e)}}},function(e,n,t){"use strict";var r=t(3);e.exports=!r((function(){var e=function(){}.bind();return"function"!=typeof e||e.hasOwnProperty("prototype")}))},function(e,n,t){"use strict";var r=t(48),i=t(35);e.exports=function(e){return r(i(e))}},function(e,n,t){"use strict";var r=t(0),i=t(1),o=function(e){return i(e)?e:void 0};e.exports=function(e,n){return arguments.length<2?o(r[e]):r[e]&&r[e][n]}},function(e,n,t){"use strict";var r=t(1),i=t(111),o=TypeError;e.exports=function(e){if(r(e))return e;throw new o(i(e)+" is not a function")}},function(e,n,t){"use strict";var r=t(0),i=t(61),o=t(9),a=t(63),s=t(58),c=t(57),l=r.Symbol,u=i("wks"),d=c?l.for||l:l&&l.withoutSetter||a;e.exports=function(e){return o(u,e)||(u[e]=s&&o(l,e)?l[e]:d("Symbol."+e)),u[e]}},function(e,n,t){"use strict";var r=t(35),i=Object;e.exports=function(e){return i(r(e))}},function(e,n,t){"use strict";var r=t(122);e.exports=function(e){return r(e.length)}},function(e,n,t){"use strict";var r=t(26),i=Function.prototype.call;e.exports=r?i.bind(i):function(){return i.apply(i,arguments)}},function(e,n,t){"use strict";e.exports=function(e,n){return{enumerable:!(1&e),configurable:!(2&e),writable:!(4&e),value:n}}},function(e,n,t){"use strict";var r=t(53),i=TypeError;e.exports=function(e){if(r(e))throw new i("Can't call method on "+e);return e}},function(e,n,t){"use strict";var r=t(62),i=t(0),o=t(37),a=e.exports=i["__core-js_shared__"]||o("__core-js_shared__",{});(a.versions||(a.versions=[])).push({version:"3.38.1",mode:r?"pure":"global",copyright:"© 2014-2024 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.38.1/LICENSE",source:"https://github.com/zloirock/core-js"})},function(e,n,t){"use strict";var r=t(0),i=Object.defineProperty;e.exports=function(e,n){try{i(r,e,{value:n,configurable:!0,writable:!0})}catch(t){r[e]=n}return n}},function(e,n,t){var r=t(149),i=t(12),o=Object.prototype,a=o.hasOwnProperty,s=o.propertyIsEnumerable,c=r(function(){return arguments}())?r:function(e){return i(e)&&a.call(e,"callee")&&!s.call(e,"callee")};e.exports=c},function(e,n,t){var r=t(10)(t(8),"Map");e.exports=r},function(e,n){e.exports=function(e){var n=typeof e;return null!=e&&("object"==n||"function"==n)}},function(e,n,t){var r=t(169),i=t(176),o=t(178),a=t(179),s=t(180);function c(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var r=e[n];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=a,c.prototype.set=s,e.exports=c},function(e,n){e.exports=function(e){var n=-1,t=Array(e.size);return e.forEach((function(e){t[++n]=e})),t}},function(e,n){e.exports=function(e){return"number"==typeof e&&e>-1&&e%1==0&&e<=9007199254740991}},function(e,n,t){var r=t(6),i=t(45),o=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,a=/^\w*$/;e.exports=function(e,n){if(r(e))return!1;var t=typeof e;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=e&&!i(e))||(a.test(e)||!o.test(e)||null!=n&&e in Object(n))}},function(e,n,t){var r=t(13),i=t(12);e.exports=function(e){return"symbol"==typeof e||i(e)&&"[object Symbol]"==r(e)}},function(e,n){e.exports=function(e){return e}},function(e,n,t){"use strict";var r=t(7),i=String,o=TypeError;e.exports=function(e){if(r(e))return e;throw new o(i(e)+" is not an object")}},function(e,n,t){"use strict";var r=t(2),i=t(3),o=t(18),a=Object,s=r("".split);e.exports=i((function(){return!a("z").propertyIsEnumerable(0)}))?function(e){return"String"===o(e)?s(e,""):a(e)}:a},function(e,n,t){"use strict";e.exports={}},function(e,n){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,n){var t=/^\s+|\s+$/g,r=/^[-+]0x[0-9a-f]+$/i,i=/^0b[01]+$/i,o=/^0o[0-7]+$/i,a=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,c="object"==typeof self&&self&&self.Object===Object&&self,l=s||c||Function("return this")(),u=Object.prototype.toString,d=Math.max,h=Math.min,p=function(){return l.Date.now()};function f(e){var n=typeof e;return!!e&&("object"==n||"function"==n)}function m(e){if("number"==typeof e)return e;if(function(e){return"symbol"==typeof e||function(e){return!!e&&"object"==typeof e}(e)&&"[object Symbol]"==u.call(e)}(e))return NaN;if(f(e)){var n="function"==typeof e.valueOf?e.valueOf():e;e=f(n)?n+"":n}if("string"!=typeof e)return 0===e?e:+e;e=e.replace(t,"");var s=i.test(e);return s||o.test(e)?a(e.slice(2),s?2:8):r.test(e)?NaN:+e}e.exports=function(e,n,t){var r,i,o,a,s,c,l=0,u=!1,v=!1,g=!0;if("function"!=typeof e)throw new TypeError("Expected a function");function y(n){var t=r,o=i;return r=i=void 0,l=n,a=e.apply(o,t)}function b(e){return l=e,s=setTimeout(x,n),u?y(e):a}function _(e){var t=e-c;return void 0===c||t>=n||t<0||v&&e-l>=o}function x(){var e=p();if(_(e))return k(e);s=setTimeout(x,function(e){var t=n-(e-c);return v?h(t,o-(e-l)):t}(e))}function k(e){return s=void 0,g&&r?y(e):(r=i=void 0,a)}function E(){var e=p(),t=_(e);if(r=arguments,i=this,c=e,t){if(void 0===s)return b(c);if(v)return s=setTimeout(x,n),y(c)}return void 0===s&&(s=setTimeout(x,n)),a}return n=m(n)||0,f(t)&&(u=!!t.leading,o=(v="maxWait"in t)?d(m(t.maxWait)||0,n):o,g="trailing"in t?!!t.trailing:g),E.cancel=function(){void 0!==s&&clearTimeout(s),l=0,r=c=i=s=void 0},E.flush=function(){return void 0===s?a:k(p())},E}},function(e,n,t){"use strict";var r=t(5),i=t(33),o=t(108),a=t(34),s=t(27),c=t(54),l=t(9),u=t(64),d=Object.getOwnPropertyDescriptor;n.f=r?d:function(e,n){if(e=s(e),n=c(n),u)try{return d(e,n)}catch(e){}if(l(e,n))return a(!i(o.f,e,n),e[n])}},function(e,n,t){"use strict";e.exports=function(e){return null==e}},function(e,n,t){"use strict";var r=t(109),i=t(55);e.exports=function(e){var n=r(e,"string");return i(n)?n:n+""}},function(e,n,t){"use strict";var r=t(28),i=t(1),o=t(56),a=t(57),s=Object;e.exports=a?function(e){return"symbol"==typeof e}:function(e){var n=r("Symbol");return i(n)&&o(n.prototype,s(e))}},function(e,n,t){"use strict";var r=t(2);e.exports=r({}.isPrototypeOf)},function(e,n,t){"use strict";var r=t(58);e.exports=r&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(e,n,t){"use strict";var r=t(59),i=t(3),o=t(0).String;e.exports=!!Object.getOwnPropertySymbols&&!i((function(){var e=Symbol("symbol detection");return!o(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&r&&r<41}))},function(e,n,t){"use strict";var r,i,o=t(0),a=t(60),s=o.process,c=o.Deno,l=s&&s.versions||c&&c.version,u=l&&l.v8;u&&(i=(r=u.split("."))[0]>0&&r[0]<4?1:+(r[0]+r[1])),!i&&a&&(!(r=a.match(/Edge\/(\d+)/))||r[1]>=74)&&(r=a.match(/Chrome\/(\d+)/))&&(i=+r[1]),e.exports=i},function(e,n,t){"use strict";var r=t(0).navigator,i=r&&r.userAgent;e.exports=i?String(i):""},function(e,n,t){"use strict";var r=t(36);e.exports=function(e,n){return r[e]||(r[e]=n||{})}},function(e,n,t){"use strict";e.exports=!1},function(e,n,t){"use strict";var r=t(2),i=0,o=Math.random(),a=r(1..toString);e.exports=function(e){return"Symbol("+(void 0===e?"":e)+")_"+a(++i+o,36)}},function(e,n,t){"use strict";var r=t(5),i=t(3),o=t(100);e.exports=!r&&!i((function(){return 7!==Object.defineProperty(o("div"),"a",{get:function(){return 7}}).a}))},function(e,n,t){"use strict";var r=t(9),i=t(117),o=t(52),a=t(17);e.exports=function(e,n,t){for(var s=i(n),c=a.f,l=o.f,u=0;u<s.length;u++){var d=s[u];r(e,d)||t&&r(t,d)||c(e,d,l(n,d))}}},function(e,n,t){"use strict";var r=t(121);e.exports=function(e){var n=+e;return n!=n||0===n?0:r(n)}},function(e,n,t){"use strict";var r=t(132),i=t(7),o=t(35),a=t(133);e.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var e,n=!1,t={};try{(e=r(Object.prototype,"__proto__","set"))(t,[]),n=t instanceof Array}catch(e){}return function(t,r){return o(t),a(r),i(t)?(n?e(t,r):t.__proto__=r,t):t}}():void 0)},function(e,n){e.exports=function(e,n){for(var t=-1,r=n.length,i=e.length;++t<r;)e[i+t]=n[t];return e}},function(e,n){var t="object"==typeof global&&global&&global.Object===Object&&global;e.exports=t},function(e,n,t){var r=t(19),i=t(160),o=t(161),a=t(162),s=t(163),c=t(164);function l(e){var n=this.__data__=new r(e);this.size=n.size}l.prototype.clear=i,l.prototype.delete=o,l.prototype.get=a,l.prototype.has=s,l.prototype.set=c,e.exports=l},function(e,n){e.exports=function(e,n){return e===n||e!=e&&n!=n}},function(e,n,t){var r=t(13),i=t(40);e.exports=function(e){if(!i(e))return!1;var n=r(e);return"[object Function]"==n||"[object GeneratorFunction]"==n||"[object AsyncFunction]"==n||"[object Proxy]"==n}},function(e,n){var t=Function.prototype.toString;e.exports=function(e){if(null!=e){try{return t.call(e)}catch(e){}try{return e+""}catch(e){}}return""}},function(e,n,t){var r=t(181),i=t(12);e.exports=function e(n,t,o,a,s){return n===t||(null==n||null==t||!i(n)&&!i(t)?n!=n&&t!=t:r(n,t,o,a,e,s))}},function(e,n,t){var r=t(76),i=t(184),o=t(77);e.exports=function(e,n,t,a,s,c){var l=1&t,u=e.length,d=n.length;if(u!=d&&!(l&&d>u))return!1;var h=c.get(e),p=c.get(n);if(h&&p)return h==n&&p==e;var f=-1,m=!0,v=2&t?new r:void 0;for(c.set(e,n),c.set(n,e);++f<u;){var g=e[f],y=n[f];if(a)var b=l?a(y,g,f,n,e,c):a(g,y,f,e,n,c);if(void 0!==b){if(b)continue;m=!1;break}if(v){if(!i(n,(function(e,n){if(!o(v,n)&&(g===e||s(g,e,t,a,c)))return v.push(n)}))){m=!1;break}}else if(g!==y&&!s(g,y,t,a,c)){m=!1;break}}return c.delete(e),c.delete(n),m}},function(e,n,t){var r=t(41),i=t(182),o=t(183);function a(e){var n=-1,t=null==e?0:e.length;for(this.__data__=new r;++n<t;)this.add(e[n])}a.prototype.add=a.prototype.push=i,a.prototype.has=o,e.exports=a},function(e,n){e.exports=function(e,n){return e.has(n)}},function(e,n,t){var r=t(194),i=t(200),o=t(82);e.exports=function(e){return o(e)?r(e):i(e)}},function(e,n,t){(function(e){var r=t(8),i=t(196),o=n&&!n.nodeType&&n,a=o&&"object"==typeof e&&e&&!e.nodeType&&e,s=a&&a.exports===o?r.Buffer:void 0,c=(s?s.isBuffer:void 0)||i;e.exports=c}).call(this,t(50)(e))},function(e,n){var t=/^(?:0|[1-9]\d*)$/;e.exports=function(e,n){var r=typeof e;return!!(n=null==n?9007199254740991:n)&&("number"==r||"symbol"!=r&&t.test(e))&&e>-1&&e%1==0&&e<n}},function(e,n,t){var r=t(197),i=t(198),o=t(199),a=o&&o.isTypedArray,s=a?i(a):r;e.exports=s},function(e,n,t){var r=t(72),i=t(43);e.exports=function(e){return null!=e&&i(e.length)&&!r(e)}},function(e,n,t){var r=t(10)(t(8),"Set");e.exports=r},function(e,n,t){var r=t(40);e.exports=function(e){return e==e&&!r(e)}},function(e,n){e.exports=function(e,n){return function(t){return null!=t&&(t[e]===n&&(void 0!==n||e in Object(t)))}}},function(e,n,t){var r=t(87),i=t(23);e.exports=function(e,n){for(var t=0,o=(n=r(n,e)).length;null!=e&&t<o;)e=e[i(n[t++])];return t&&t==o?e:void 0}},function(e,n,t){var r=t(6),i=t(44),o=t(211),a=t(214);e.exports=function(e,n){return r(e)?e:i(e,n)?[e]:o(a(e))}},function(e,n,t){},function(e,n,t){},function(e,n,t){},function(e,n,t){},function(e,n,t){var r=t(147),i=t(152),o=t(223),a=t(231),s=t(240),c=t(105),l=o((function(e){var n=c(e);return s(n)&&(n=void 0),a(r(e,1,s,!0),i(n,2))}));e.exports=l},function(e,n,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var r=/["'&<>]/;e.exports=function(e){var n,t=""+e,i=r.exec(t);if(!i)return t;var o="",a=0,s=0;for(a=i.index;a<t.length;a++){switch(t.charCodeAt(a)){case 34:n="&quot;";break;case 38:n="&amp;";break;case 39:n="&#39;";break;case 60:n="&lt;";break;case 62:n="&gt;";break;default:continue}s!==a&&(o+=t.substring(s,a)),s=a+1,o+=n}return s!==a?o+t.substring(s,a):o}},function(e){e.exports=JSON.parse('{"en-US":{"author":"author","beforeAuthor":"Copyright © ","afterAuthor":"\\nLink: "},"zh-CN":{"author":"作者","beforeAuthor":"著作权归","afterAuthor":"所有。\\n链接："}}')},function(e,n,t){"use strict";t.r(n);var r={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},i=(t(243),t(4)),o=Object(i.a)(r,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);n.default=o.exports},function(e,n,t){"use strict";t.r(n);var r={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(e){this.codeTabs.forEach(e=>{e.elm.classList.remove("theme-code-block__active")}),this.codeTabs[e].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(e=>Boolean(e.componentOptions)).map((e,n)=>(""===e.componentOptions.propsData.active&&(this.activeCodeTabIndex=n),{title:e.componentOptions.propsData.title,elm:e.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(e){this.activeCodeTabIndex=e}}},i=(t(244),t(4)),o=Object(i.a)(r,(function(){var e=this,n=e._self._c;return n("div",{staticClass:"theme-code-group"},[n("div",{staticClass:"theme-code-group__nav"},[n("ul",{staticClass:"theme-code-group__ul"},e._l(e.codeTabs,(function(t,r){return n("li",{key:t.title,staticClass:"theme-code-group__li"},[n("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":r===e.activeCodeTabIndex},on:{click:function(n){return e.changeCodeTab(r)}}},[e._v("\n            "+e._s(t.title)+"\n          ")])])})),0)]),e._v(" "),e._t("default"),e._v(" "),e.codeTabs.length<1?n("pre",{staticClass:"pre-blank"},[e._v("// Make sure to add code blocks to your code group")]):e._e()],2)}),[],!1,null,"2f5f1757",null);n.default=o.exports},function(e,n,t){"use strict";var r=t(1),i=t(17),o=t(102),a=t(37);e.exports=function(e,n,t,s){s||(s={});var c=s.enumerable,l=void 0!==s.name?s.name:n;if(r(t)&&o(t,l,s),s.global)c?e[n]=t:a(n,t);else{try{s.unsafe?e[n]&&(c=!0):delete e[n]}catch(e){}c?e[n]=t:i.f(e,n,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return e}},function(e,n,t){"use strict";e.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(e,n,t){"use strict";var r=t(138),i=String;e.exports=function(e){if("Symbol"===r(e))throw new TypeError("Cannot convert a Symbol value to a string");return i(e)}},function(e,n,t){"use strict";var r=t(0),i=t(7),o=r.document,a=i(o)&&i(o.createElement);e.exports=function(e){return a?o.createElement(e):{}}},function(e,n,t){"use strict";var r=t(5),i=t(3);e.exports=r&&i((function(){return 42!==Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(e,n,t){"use strict";var r=t(2),i=t(3),o=t(1),a=t(9),s=t(5),c=t(113).CONFIGURABLE,l=t(114),u=t(115),d=u.enforce,h=u.get,p=String,f=Object.defineProperty,m=r("".slice),v=r("".replace),g=r([].join),y=s&&!i((function(){return 8!==f((function(){}),"length",{value:8}).length})),b=String(String).split("String"),_=e.exports=function(e,n,t){"Symbol("===m(p(n),0,7)&&(n="["+v(p(n),/^Symbol\(([^)]*)\).*$/,"$1")+"]"),t&&t.getter&&(n="get "+n),t&&t.setter&&(n="set "+n),(!a(e,"name")||c&&e.name!==n)&&(s?f(e,"name",{value:n,configurable:!0}):e.name=n),y&&t&&a(t,"arity")&&e.length!==t.arity&&f(e,"length",{value:t.arity});try{t&&a(t,"constructor")&&t.constructor?s&&f(e,"prototype",{writable:!1}):e.prototype&&(e.prototype=void 0)}catch(e){}var r=d(e);return a(r,"source")||(r.source=g(b,"string"==typeof n?n:"")),e};Function.prototype.toString=_((function(){return o(this)&&h(this).source||l(this)}),"toString")},function(e,n,t){"use strict";var r=t(61),i=t(63),o=r("keys");e.exports=function(e){return o[e]||(o[e]=i(e))}},function(e,n,t){"use strict";var r=t(2),i=t(9),o=t(27),a=t(119).indexOf,s=t(49),c=r([].push);e.exports=function(e,n){var t,r=o(e),l=0,u=[];for(t in r)!i(s,t)&&i(r,t)&&c(u,t);for(;n.length>l;)i(r,t=n[l++])&&(~a(u,t)||c(u,t));return u}},function(e,n){e.exports=function(e){var n=null==e?0:e.length;return n?e[n-1]:void 0}},function(e,n,t){e.exports=t(249)},function(e,n,t){"use strict";var r=t(25),i=t(125).left,o=t(126),a=t(59);r({target:"Array",proto:!0,forced:!t(127)&&a>79&&a<83||!o("reduce")},{reduce:function(e){var n=arguments.length;return i(this,e,n,n>1?arguments[1]:void 0)}})},function(e,n,t){"use strict";var r={}.propertyIsEnumerable,i=Object.getOwnPropertyDescriptor,o=i&&!r.call({1:2},1);n.f=o?function(e){var n=i(this,e);return!!n&&n.enumerable}:r},function(e,n,t){"use strict";var r=t(33),i=t(7),o=t(55),a=t(110),s=t(112),c=t(30),l=TypeError,u=c("toPrimitive");e.exports=function(e,n){if(!i(e)||o(e))return e;var t,c=a(e,u);if(c){if(void 0===n&&(n="default"),t=r(c,e,n),!i(t)||o(t))return t;throw new l("Can't convert object to primitive value")}return void 0===n&&(n="number"),s(e,n)}},function(e,n,t){"use strict";var r=t(29),i=t(53);e.exports=function(e,n){var t=e[n];return i(t)?void 0:r(t)}},function(e,n,t){"use strict";var r=String;e.exports=function(e){try{return r(e)}catch(e){return"Object"}}},function(e,n,t){"use strict";var r=t(33),i=t(1),o=t(7),a=TypeError;e.exports=function(e,n){var t,s;if("string"===n&&i(t=e.toString)&&!o(s=r(t,e)))return s;if(i(t=e.valueOf)&&!o(s=r(t,e)))return s;if("string"!==n&&i(t=e.toString)&&!o(s=r(t,e)))return s;throw new a("Can't convert object to primitive value")}},function(e,n,t){"use strict";var r=t(5),i=t(9),o=Function.prototype,a=r&&Object.getOwnPropertyDescriptor,s=i(o,"name"),c=s&&"something"===function(){}.name,l=s&&(!r||r&&a(o,"name").configurable);e.exports={EXISTS:s,PROPER:c,CONFIGURABLE:l}},function(e,n,t){"use strict";var r=t(2),i=t(1),o=t(36),a=r(Function.toString);i(o.inspectSource)||(o.inspectSource=function(e){return a(e)}),e.exports=o.inspectSource},function(e,n,t){"use strict";var r,i,o,a=t(116),s=t(0),c=t(7),l=t(14),u=t(9),d=t(36),h=t(103),p=t(49),f=s.TypeError,m=s.WeakMap;if(a||d.state){var v=d.state||(d.state=new m);v.get=v.get,v.has=v.has,v.set=v.set,r=function(e,n){if(v.has(e))throw new f("Object already initialized");return n.facade=e,v.set(e,n),n},i=function(e){return v.get(e)||{}},o=function(e){return v.has(e)}}else{var g=h("state");p[g]=!0,r=function(e,n){if(u(e,g))throw new f("Object already initialized");return n.facade=e,l(e,g,n),n},i=function(e){return u(e,g)?e[g]:{}},o=function(e){return u(e,g)}}e.exports={set:r,get:i,has:o,enforce:function(e){return o(e)?i(e):r(e,{})},getterFor:function(e){return function(n){var t;if(!c(n)||(t=i(n)).type!==e)throw new f("Incompatible receiver, "+e+" required");return t}}}},function(e,n,t){"use strict";var r=t(0),i=t(1),o=r.WeakMap;e.exports=i(o)&&/native code/.test(String(o))},function(e,n,t){"use strict";var r=t(28),i=t(2),o=t(118),a=t(123),s=t(47),c=i([].concat);e.exports=r("Reflect","ownKeys")||function(e){var n=o.f(s(e)),t=a.f;return t?c(n,t(e)):n}},function(e,n,t){"use strict";var r=t(104),i=t(98).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(e){return r(e,i)}},function(e,n,t){"use strict";var r=t(27),i=t(120),o=t(32),a=function(e){return function(n,t,a){var s=r(n),c=o(s);if(0===c)return!e&&-1;var l,u=i(a,c);if(e&&t!=t){for(;c>u;)if((l=s[u++])!=l)return!0}else for(;c>u;u++)if((e||u in s)&&s[u]===t)return e||u||0;return!e&&-1}};e.exports={includes:a(!0),indexOf:a(!1)}},function(e,n,t){"use strict";var r=t(66),i=Math.max,o=Math.min;e.exports=function(e,n){var t=r(e);return t<0?i(t+n,0):o(t,n)}},function(e,n,t){"use strict";var r=Math.ceil,i=Math.floor;e.exports=Math.trunc||function(e){var n=+e;return(n>0?i:r)(n)}},function(e,n,t){"use strict";var r=t(66),i=Math.min;e.exports=function(e){var n=r(e);return n>0?i(n,9007199254740991):0}},function(e,n,t){"use strict";n.f=Object.getOwnPropertySymbols},function(e,n,t){"use strict";var r=t(3),i=t(1),o=/#|\.prototype\./,a=function(e,n){var t=c[s(e)];return t===u||t!==l&&(i(n)?r(n):!!n)},s=a.normalize=function(e){return String(e).replace(o,".").toLowerCase()},c=a.data={},l=a.NATIVE="N",u=a.POLYFILL="P";e.exports=a},function(e,n,t){"use strict";var r=t(29),i=t(31),o=t(48),a=t(32),s=TypeError,c="Reduce of empty array with no initial value",l=function(e){return function(n,t,l,u){var d=i(n),h=o(d),p=a(d);if(r(t),0===p&&l<2)throw new s(c);var f=e?p-1:0,m=e?-1:1;if(l<2)for(;;){if(f in h){u=h[f],f+=m;break}if(f+=m,e?f<0:p<=f)throw new s(c)}for(;e?f>=0:p>f;f+=m)f in h&&(u=t(u,h[f],f,d));return u}};e.exports={left:l(!1),right:l(!0)}},function(e,n,t){"use strict";var r=t(3);e.exports=function(e,n){var t=[][e];return!!t&&r((function(){t.call(null,n||function(){return 1},1)}))}},function(e,n,t){"use strict";var r=t(128);e.exports="NODE"===r},function(e,n,t){"use strict";var r=t(0),i=t(60),o=t(18),a=function(e){return i.slice(0,e.length)===e};e.exports=a("Bun/")?"BUN":a("Cloudflare-Workers")?"CLOUDFLARE":a("Deno/")?"DENO":a("Node.js/")?"NODE":r.Bun&&"string"==typeof Bun.version?"BUN":r.Deno&&"object"==typeof Deno.version?"DENO":"process"===o(r.process)?"NODE":r.window&&r.document?"BROWSER":"REST"},function(e,n,t){"use strict";var r=t(25),i=t(0),o=t(130),a=t(131),s=i.WebAssembly,c=7!==new Error("e",{cause:7}).cause,l=function(e,n){var t={};t[e]=a(e,n,c),r({global:!0,constructor:!0,arity:1,forced:c},t)},u=function(e,n){if(s&&s[e]){var t={};t[e]=a("WebAssembly."+e,n,c),r({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:c},t)}};l("Error",(function(e){return function(n){return o(e,this,arguments)}})),l("EvalError",(function(e){return function(n){return o(e,this,arguments)}})),l("RangeError",(function(e){return function(n){return o(e,this,arguments)}})),l("ReferenceError",(function(e){return function(n){return o(e,this,arguments)}})),l("SyntaxError",(function(e){return function(n){return o(e,this,arguments)}})),l("TypeError",(function(e){return function(n){return o(e,this,arguments)}})),l("URIError",(function(e){return function(n){return o(e,this,arguments)}})),u("CompileError",(function(e){return function(n){return o(e,this,arguments)}})),u("LinkError",(function(e){return function(n){return o(e,this,arguments)}})),u("RuntimeError",(function(e){return function(n){return o(e,this,arguments)}}))},function(e,n,t){"use strict";var r=t(26),i=Function.prototype,o=i.apply,a=i.call;e.exports="object"==typeof Reflect&&Reflect.apply||(r?a.bind(o):function(){return a.apply(o,arguments)})},function(e,n,t){"use strict";var r=t(28),i=t(9),o=t(14),a=t(56),s=t(67),c=t(65),l=t(135),u=t(136),d=t(137),h=t(140),p=t(141),f=t(5),m=t(62);e.exports=function(e,n,t,v){var g=v?2:1,y=e.split("."),b=y[y.length-1],_=r.apply(null,y);if(_){var x=_.prototype;if(!m&&i(x,"cause")&&delete x.cause,!t)return _;var k=r("Error"),E=n((function(e,n){var t=d(v?n:e,void 0),r=v?new _(e):new _;return void 0!==t&&o(r,"message",t),p(r,E,r.stack,2),this&&a(x,this)&&u(r,this,E),arguments.length>g&&h(r,arguments[g]),r}));if(E.prototype=x,"Error"!==b?s?s(E,k):c(E,k,{name:!0}):f&&"stackTraceLimit"in _&&(l(E,_,"stackTraceLimit"),l(E,_,"prepareStackTrace")),c(E,_),!m)try{x.name!==b&&o(x,"name",b),x.constructor=E}catch(e){}return E}}},function(e,n,t){"use strict";var r=t(2),i=t(29);e.exports=function(e,n,t){try{return r(i(Object.getOwnPropertyDescriptor(e,n)[t]))}catch(e){}}},function(e,n,t){"use strict";var r=t(134),i=String,o=TypeError;e.exports=function(e){if(r(e))return e;throw new o("Can't set "+i(e)+" as a prototype")}},function(e,n,t){"use strict";var r=t(7);e.exports=function(e){return r(e)||null===e}},function(e,n,t){"use strict";var r=t(17).f;e.exports=function(e,n,t){t in e||r(e,t,{configurable:!0,get:function(){return n[t]},set:function(e){n[t]=e}})}},function(e,n,t){"use strict";var r=t(1),i=t(7),o=t(67);e.exports=function(e,n,t){var a,s;return o&&r(a=n.constructor)&&a!==t&&i(s=a.prototype)&&s!==t.prototype&&o(e,s),e}},function(e,n,t){"use strict";var r=t(99);e.exports=function(e,n){return void 0===e?arguments.length<2?"":n:r(e)}},function(e,n,t){"use strict";var r=t(139),i=t(1),o=t(18),a=t(30)("toStringTag"),s=Object,c="Arguments"===o(function(){return arguments}());e.exports=r?o:function(e){var n,t,r;return void 0===e?"Undefined":null===e?"Null":"string"==typeof(t=function(e,n){try{return e[n]}catch(e){}}(n=s(e),a))?t:c?o(n):"Object"===(r=o(n))&&i(n.callee)?"Arguments":r}},function(e,n,t){"use strict";var r={};r[t(30)("toStringTag")]="z",e.exports="[object z]"===String(r)},function(e,n,t){"use strict";var r=t(7),i=t(14);e.exports=function(e,n){r(n)&&"cause"in n&&i(e,"cause",n.cause)}},function(e,n,t){"use strict";var r=t(14),i=t(142),o=t(143),a=Error.captureStackTrace;e.exports=function(e,n,t,s){o&&(a?a(e,n):r(e,"stack",i(t,s)))}},function(e,n,t){"use strict";var r=t(2),i=Error,o=r("".replace),a=String(new i("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,c=s.test(a);e.exports=function(e,n){if(c&&"string"==typeof e&&!i.prepareStackTrace)for(;n--;)e=o(e,s,"");return e}},function(e,n,t){"use strict";var r=t(3),i=t(34);e.exports=!r((function(){var e=new Error("a");return!("stack"in e)||(Object.defineProperty(e,"stack",i(1,7)),7!==e.stack)}))},function(e,n,t){"use strict";var r=t(5),i=t(145),o=TypeError,a=Object.getOwnPropertyDescriptor,s=r&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(e){return e instanceof TypeError}}();e.exports=s?function(e,n){if(i(e)&&!a(e,"length").writable)throw new o("Cannot set read only .length");return e.length=n}:function(e,n){return e.length=n}},function(e,n,t){"use strict";var r=t(18);e.exports=Array.isArray||function(e){return"Array"===r(e)}},function(e,n,t){"use strict";var r=TypeError;e.exports=function(e){if(e>9007199254740991)throw r("Maximum allowed index exceeded");return e}},function(e,n,t){var r=t(68),i=t(148);e.exports=function e(n,t,o,a,s){var c=-1,l=n.length;for(o||(o=i),s||(s=[]);++c<l;){var u=n[c];t>0&&o(u)?t>1?e(u,t-1,o,a,s):r(s,u):a||(s[s.length]=u)}return s}},function(e,n,t){var r=t(15),i=t(38),o=t(6),a=r?r.isConcatSpreadable:void 0;e.exports=function(e){return o(e)||i(e)||!!(a&&e&&e[a])}},function(e,n,t){var r=t(13),i=t(12);e.exports=function(e){return i(e)&&"[object Arguments]"==r(e)}},function(e,n,t){var r=t(15),i=Object.prototype,o=i.hasOwnProperty,a=i.toString,s=r?r.toStringTag:void 0;e.exports=function(e){var n=o.call(e,s),t=e[s];try{e[s]=void 0;var r=!0}catch(e){}var i=a.call(e);return r&&(n?e[s]=t:delete e[s]),i}},function(e,n){var t=Object.prototype.toString;e.exports=function(e){return t.call(e)}},function(e,n,t){var r=t(153),i=t(209),o=t(46),a=t(6),s=t(220);e.exports=function(e){return"function"==typeof e?e:null==e?o:"object"==typeof e?a(e)?i(e[0],e[1]):r(e):s(e)}},function(e,n,t){var r=t(154),i=t(208),o=t(85);e.exports=function(e){var n=i(e);return 1==n.length&&n[0][2]?o(n[0][0],n[0][1]):function(t){return t===e||r(t,e,n)}}},function(e,n,t){var r=t(70),i=t(74);e.exports=function(e,n,t,o){var a=t.length,s=a,c=!o;if(null==e)return!s;for(e=Object(e);a--;){var l=t[a];if(c&&l[2]?l[1]!==e[l[0]]:!(l[0]in e))return!1}for(;++a<s;){var u=(l=t[a])[0],d=e[u],h=l[1];if(c&&l[2]){if(void 0===d&&!(u in e))return!1}else{var p=new r;if(o)var f=o(d,h,u,e,n,p);if(!(void 0===f?i(h,d,3,o,p):f))return!1}}return!0}},function(e,n){e.exports=function(){this.__data__=[],this.size=0}},function(e,n,t){var r=t(20),i=Array.prototype.splice;e.exports=function(e){var n=this.__data__,t=r(n,e);return!(t<0)&&(t==n.length-1?n.pop():i.call(n,t,1),--this.size,!0)}},function(e,n,t){var r=t(20);e.exports=function(e){var n=this.__data__,t=r(n,e);return t<0?void 0:n[t][1]}},function(e,n,t){var r=t(20);e.exports=function(e){return r(this.__data__,e)>-1}},function(e,n,t){var r=t(20);e.exports=function(e,n){var t=this.__data__,i=r(t,e);return i<0?(++this.size,t.push([e,n])):t[i][1]=n,this}},function(e,n,t){var r=t(19);e.exports=function(){this.__data__=new r,this.size=0}},function(e,n){e.exports=function(e){var n=this.__data__,t=n.delete(e);return this.size=n.size,t}},function(e,n){e.exports=function(e){return this.__data__.get(e)}},function(e,n){e.exports=function(e){return this.__data__.has(e)}},function(e,n,t){var r=t(19),i=t(39),o=t(41);e.exports=function(e,n){var t=this.__data__;if(t instanceof r){var a=t.__data__;if(!i||a.length<199)return a.push([e,n]),this.size=++t.size,this;t=this.__data__=new o(a)}return t.set(e,n),this.size=t.size,this}},function(e,n,t){var r=t(72),i=t(166),o=t(40),a=t(73),s=/^\[object .+?Constructor\]$/,c=Function.prototype,l=Object.prototype,u=c.toString,d=l.hasOwnProperty,h=RegExp("^"+u.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");e.exports=function(e){return!(!o(e)||i(e))&&(r(e)?h:s).test(a(e))}},function(e,n,t){var r,i=t(167),o=(r=/[^.]+$/.exec(i&&i.keys&&i.keys.IE_PROTO||""))?"Symbol(src)_1."+r:"";e.exports=function(e){return!!o&&o in e}},function(e,n,t){var r=t(8)["__core-js_shared__"];e.exports=r},function(e,n){e.exports=function(e,n){return null==e?void 0:e[n]}},function(e,n,t){var r=t(170),i=t(19),o=t(39);e.exports=function(){this.size=0,this.__data__={hash:new r,map:new(o||i),string:new r}}},function(e,n,t){var r=t(171),i=t(172),o=t(173),a=t(174),s=t(175);function c(e){var n=-1,t=null==e?0:e.length;for(this.clear();++n<t;){var r=e[n];this.set(r[0],r[1])}}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=a,c.prototype.set=s,e.exports=c},function(e,n,t){var r=t(21);e.exports=function(){this.__data__=r?r(null):{},this.size=0}},function(e,n){e.exports=function(e){var n=this.has(e)&&delete this.__data__[e];return this.size-=n?1:0,n}},function(e,n,t){var r=t(21),i=Object.prototype.hasOwnProperty;e.exports=function(e){var n=this.__data__;if(r){var t=n[e];return"__lodash_hash_undefined__"===t?void 0:t}return i.call(n,e)?n[e]:void 0}},function(e,n,t){var r=t(21),i=Object.prototype.hasOwnProperty;e.exports=function(e){var n=this.__data__;return r?void 0!==n[e]:i.call(n,e)}},function(e,n,t){var r=t(21);e.exports=function(e,n){var t=this.__data__;return this.size+=this.has(e)?0:1,t[e]=r&&void 0===n?"__lodash_hash_undefined__":n,this}},function(e,n,t){var r=t(22);e.exports=function(e){var n=r(this,e).delete(e);return this.size-=n?1:0,n}},function(e,n){e.exports=function(e){var n=typeof e;return"string"==n||"number"==n||"symbol"==n||"boolean"==n?"__proto__"!==e:null===e}},function(e,n,t){var r=t(22);e.exports=function(e){return r(this,e).get(e)}},function(e,n,t){var r=t(22);e.exports=function(e){return r(this,e).has(e)}},function(e,n,t){var r=t(22);e.exports=function(e,n){var t=r(this,e),i=t.size;return t.set(e,n),this.size+=t.size==i?0:1,this}},function(e,n,t){var r=t(70),i=t(75),o=t(185),a=t(188),s=t(204),c=t(6),l=t(79),u=t(81),d="[object Object]",h=Object.prototype.hasOwnProperty;e.exports=function(e,n,t,p,f,m){var v=c(e),g=c(n),y=v?"[object Array]":s(e),b=g?"[object Array]":s(n),_=(y="[object Arguments]"==y?d:y)==d,x=(b="[object Arguments]"==b?d:b)==d,k=y==b;if(k&&l(e)){if(!l(n))return!1;v=!0,_=!1}if(k&&!_)return m||(m=new r),v||u(e)?i(e,n,t,p,f,m):o(e,n,y,t,p,f,m);if(!(1&t)){var E=_&&h.call(e,"__wrapped__"),w=x&&h.call(n,"__wrapped__");if(E||w){var A=E?e.value():e,C=w?n.value():n;return m||(m=new r),f(A,C,t,p,m)}}return!!k&&(m||(m=new r),a(e,n,t,p,f,m))}},function(e,n){e.exports=function(e){return this.__data__.set(e,"__lodash_hash_undefined__"),this}},function(e,n){e.exports=function(e){return this.__data__.has(e)}},function(e,n){e.exports=function(e,n){for(var t=-1,r=null==e?0:e.length;++t<r;)if(n(e[t],t,e))return!0;return!1}},function(e,n,t){var r=t(15),i=t(186),o=t(71),a=t(75),s=t(187),c=t(42),l=r?r.prototype:void 0,u=l?l.valueOf:void 0;e.exports=function(e,n,t,r,l,d,h){switch(t){case"[object DataView]":if(e.byteLength!=n.byteLength||e.byteOffset!=n.byteOffset)return!1;e=e.buffer,n=n.buffer;case"[object ArrayBuffer]":return!(e.byteLength!=n.byteLength||!d(new i(e),new i(n)));case"[object Boolean]":case"[object Date]":case"[object Number]":return o(+e,+n);case"[object Error]":return e.name==n.name&&e.message==n.message;case"[object RegExp]":case"[object String]":return e==n+"";case"[object Map]":var p=s;case"[object Set]":var f=1&r;if(p||(p=c),e.size!=n.size&&!f)return!1;var m=h.get(e);if(m)return m==n;r|=2,h.set(e,n);var v=a(p(e),p(n),r,l,d,h);return h.delete(e),v;case"[object Symbol]":if(u)return u.call(e)==u.call(n)}return!1}},function(e,n,t){var r=t(8).Uint8Array;e.exports=r},function(e,n){e.exports=function(e){var n=-1,t=Array(e.size);return e.forEach((function(e,r){t[++n]=[r,e]})),t}},function(e,n,t){var r=t(189),i=Object.prototype.hasOwnProperty;e.exports=function(e,n,t,o,a,s){var c=1&t,l=r(e),u=l.length;if(u!=r(n).length&&!c)return!1;for(var d=u;d--;){var h=l[d];if(!(c?h in n:i.call(n,h)))return!1}var p=s.get(e),f=s.get(n);if(p&&f)return p==n&&f==e;var m=!0;s.set(e,n),s.set(n,e);for(var v=c;++d<u;){var g=e[h=l[d]],y=n[h];if(o)var b=c?o(y,g,h,n,e,s):o(g,y,h,e,n,s);if(!(void 0===b?g===y||a(g,y,t,o,s):b)){m=!1;break}v||(v="constructor"==h)}if(m&&!v){var _=e.constructor,x=n.constructor;_==x||!("constructor"in e)||!("constructor"in n)||"function"==typeof _&&_ instanceof _&&"function"==typeof x&&x instanceof x||(m=!1)}return s.delete(e),s.delete(n),m}},function(e,n,t){var r=t(190),i=t(191),o=t(78);e.exports=function(e){return r(e,o,i)}},function(e,n,t){var r=t(68),i=t(6);e.exports=function(e,n,t){var o=n(e);return i(e)?o:r(o,t(e))}},function(e,n,t){var r=t(192),i=t(193),o=Object.prototype.propertyIsEnumerable,a=Object.getOwnPropertySymbols,s=a?function(e){return null==e?[]:(e=Object(e),r(a(e),(function(n){return o.call(e,n)})))}:i;e.exports=s},function(e,n){e.exports=function(e,n){for(var t=-1,r=null==e?0:e.length,i=0,o=[];++t<r;){var a=e[t];n(a,t,e)&&(o[i++]=a)}return o}},function(e,n){e.exports=function(){return[]}},function(e,n,t){var r=t(195),i=t(38),o=t(6),a=t(79),s=t(80),c=t(81),l=Object.prototype.hasOwnProperty;e.exports=function(e,n){var t=o(e),u=!t&&i(e),d=!t&&!u&&a(e),h=!t&&!u&&!d&&c(e),p=t||u||d||h,f=p?r(e.length,String):[],m=f.length;for(var v in e)!n&&!l.call(e,v)||p&&("length"==v||d&&("offset"==v||"parent"==v)||h&&("buffer"==v||"byteLength"==v||"byteOffset"==v)||s(v,m))||f.push(v);return f}},function(e,n){e.exports=function(e,n){for(var t=-1,r=Array(e);++t<e;)r[t]=n(t);return r}},function(e,n){e.exports=function(){return!1}},function(e,n,t){var r=t(13),i=t(43),o=t(12),a={};a["[object Float32Array]"]=a["[object Float64Array]"]=a["[object Int8Array]"]=a["[object Int16Array]"]=a["[object Int32Array]"]=a["[object Uint8Array]"]=a["[object Uint8ClampedArray]"]=a["[object Uint16Array]"]=a["[object Uint32Array]"]=!0,a["[object Arguments]"]=a["[object Array]"]=a["[object ArrayBuffer]"]=a["[object Boolean]"]=a["[object DataView]"]=a["[object Date]"]=a["[object Error]"]=a["[object Function]"]=a["[object Map]"]=a["[object Number]"]=a["[object Object]"]=a["[object RegExp]"]=a["[object Set]"]=a["[object String]"]=a["[object WeakMap]"]=!1,e.exports=function(e){return o(e)&&i(e.length)&&!!a[r(e)]}},function(e,n){e.exports=function(e){return function(n){return e(n)}}},function(e,n,t){(function(e){var r=t(69),i=n&&!n.nodeType&&n,o=i&&"object"==typeof e&&e&&!e.nodeType&&e,a=o&&o.exports===i&&r.process,s=function(){try{var e=o&&o.require&&o.require("util").types;return e||a&&a.binding&&a.binding("util")}catch(e){}}();e.exports=s}).call(this,t(50)(e))},function(e,n,t){var r=t(201),i=t(202),o=Object.prototype.hasOwnProperty;e.exports=function(e){if(!r(e))return i(e);var n=[];for(var t in Object(e))o.call(e,t)&&"constructor"!=t&&n.push(t);return n}},function(e,n){var t=Object.prototype;e.exports=function(e){var n=e&&e.constructor;return e===("function"==typeof n&&n.prototype||t)}},function(e,n,t){var r=t(203)(Object.keys,Object);e.exports=r},function(e,n){e.exports=function(e,n){return function(t){return e(n(t))}}},function(e,n,t){var r=t(205),i=t(39),o=t(206),a=t(83),s=t(207),c=t(13),l=t(73),u=l(r),d=l(i),h=l(o),p=l(a),f=l(s),m=c;(r&&"[object DataView]"!=m(new r(new ArrayBuffer(1)))||i&&"[object Map]"!=m(new i)||o&&"[object Promise]"!=m(o.resolve())||a&&"[object Set]"!=m(new a)||s&&"[object WeakMap]"!=m(new s))&&(m=function(e){var n=c(e),t="[object Object]"==n?e.constructor:void 0,r=t?l(t):"";if(r)switch(r){case u:return"[object DataView]";case d:return"[object Map]";case h:return"[object Promise]";case p:return"[object Set]";case f:return"[object WeakMap]"}return n}),e.exports=m},function(e,n,t){var r=t(10)(t(8),"DataView");e.exports=r},function(e,n,t){var r=t(10)(t(8),"Promise");e.exports=r},function(e,n,t){var r=t(10)(t(8),"WeakMap");e.exports=r},function(e,n,t){var r=t(84),i=t(78);e.exports=function(e){for(var n=i(e),t=n.length;t--;){var o=n[t],a=e[o];n[t]=[o,a,r(a)]}return n}},function(e,n,t){var r=t(74),i=t(210),o=t(217),a=t(44),s=t(84),c=t(85),l=t(23);e.exports=function(e,n){return a(e)&&s(n)?c(l(e),n):function(t){var a=i(t,e);return void 0===a&&a===n?o(t,e):r(n,a,3)}}},function(e,n,t){var r=t(86);e.exports=function(e,n,t){var i=null==e?void 0:r(e,n);return void 0===i?t:i}},function(e,n,t){var r=t(212),i=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,o=/\\(\\)?/g,a=r((function(e){var n=[];return 46===e.charCodeAt(0)&&n.push(""),e.replace(i,(function(e,t,r,i){n.push(r?i.replace(o,"$1"):t||e)})),n}));e.exports=a},function(e,n,t){var r=t(213);e.exports=function(e){var n=r(e,(function(e){return 500===t.size&&t.clear(),e})),t=n.cache;return n}},function(e,n,t){var r=t(41);function i(e,n){if("function"!=typeof e||null!=n&&"function"!=typeof n)throw new TypeError("Expected a function");var t=function(){var r=arguments,i=n?n.apply(this,r):r[0],o=t.cache;if(o.has(i))return o.get(i);var a=e.apply(this,r);return t.cache=o.set(i,a)||o,a};return t.cache=new(i.Cache||r),t}i.Cache=r,e.exports=i},function(e,n,t){var r=t(215);e.exports=function(e){return null==e?"":r(e)}},function(e,n,t){var r=t(15),i=t(216),o=t(6),a=t(45),s=r?r.prototype:void 0,c=s?s.toString:void 0;e.exports=function e(n){if("string"==typeof n)return n;if(o(n))return i(n,e)+"";if(a(n))return c?c.call(n):"";var t=n+"";return"0"==t&&1/n==-1/0?"-0":t}},function(e,n){e.exports=function(e,n){for(var t=-1,r=null==e?0:e.length,i=Array(r);++t<r;)i[t]=n(e[t],t,e);return i}},function(e,n,t){var r=t(218),i=t(219);e.exports=function(e,n){return null!=e&&i(e,n,r)}},function(e,n){e.exports=function(e,n){return null!=e&&n in Object(e)}},function(e,n,t){var r=t(87),i=t(38),o=t(6),a=t(80),s=t(43),c=t(23);e.exports=function(e,n,t){for(var l=-1,u=(n=r(n,e)).length,d=!1;++l<u;){var h=c(n[l]);if(!(d=null!=e&&t(e,h)))break;e=e[h]}return d||++l!=u?d:!!(u=null==e?0:e.length)&&s(u)&&a(h,u)&&(o(e)||i(e))}},function(e,n,t){var r=t(221),i=t(222),o=t(44),a=t(23);e.exports=function(e){return o(e)?r(a(e)):i(e)}},function(e,n){e.exports=function(e){return function(n){return null==n?void 0:n[e]}}},function(e,n,t){var r=t(86);e.exports=function(e){return function(n){return r(n,e)}}},function(e,n,t){var r=t(46),i=t(224),o=t(226);e.exports=function(e,n){return o(i(e,n,r),e+"")}},function(e,n,t){var r=t(225),i=Math.max;e.exports=function(e,n,t){return n=i(void 0===n?e.length-1:n,0),function(){for(var o=arguments,a=-1,s=i(o.length-n,0),c=Array(s);++a<s;)c[a]=o[n+a];a=-1;for(var l=Array(n+1);++a<n;)l[a]=o[a];return l[n]=t(c),r(e,this,l)}}},function(e,n){e.exports=function(e,n,t){switch(t.length){case 0:return e.call(n);case 1:return e.call(n,t[0]);case 2:return e.call(n,t[0],t[1]);case 3:return e.call(n,t[0],t[1],t[2])}return e.apply(n,t)}},function(e,n,t){var r=t(227),i=t(230)(r);e.exports=i},function(e,n,t){var r=t(228),i=t(229),o=t(46),a=i?function(e,n){return i(e,"toString",{configurable:!0,enumerable:!1,value:r(n),writable:!0})}:o;e.exports=a},function(e,n){e.exports=function(e){return function(){return e}}},function(e,n,t){var r=t(10),i=function(){try{var e=r(Object,"defineProperty");return e({},"",{}),e}catch(e){}}();e.exports=i},function(e,n){var t=Date.now;e.exports=function(e){var n=0,r=0;return function(){var i=t(),o=16-(i-r);if(r=i,o>0){if(++n>=800)return arguments[0]}else n=0;return e.apply(void 0,arguments)}}},function(e,n,t){var r=t(76),i=t(232),o=t(237),a=t(77),s=t(238),c=t(42);e.exports=function(e,n,t){var l=-1,u=i,d=e.length,h=!0,p=[],f=p;if(t)h=!1,u=o;else if(d>=200){var m=n?null:s(e);if(m)return c(m);h=!1,u=a,f=new r}else f=n?[]:p;e:for(;++l<d;){var v=e[l],g=n?n(v):v;if(v=t||0!==v?v:0,h&&g==g){for(var y=f.length;y--;)if(f[y]===g)continue e;n&&f.push(g),p.push(v)}else u(f,g,t)||(f!==p&&f.push(g),p.push(v))}return p}},function(e,n,t){var r=t(233);e.exports=function(e,n){return!!(null==e?0:e.length)&&r(e,n,0)>-1}},function(e,n,t){var r=t(234),i=t(235),o=t(236);e.exports=function(e,n,t){return n==n?o(e,n,t):r(e,i,t)}},function(e,n){e.exports=function(e,n,t,r){for(var i=e.length,o=t+(r?1:-1);r?o--:++o<i;)if(n(e[o],o,e))return o;return-1}},function(e,n){e.exports=function(e){return e!=e}},function(e,n){e.exports=function(e,n,t){for(var r=t-1,i=e.length;++r<i;)if(e[r]===n)return r;return-1}},function(e,n){e.exports=function(e,n,t){for(var r=-1,i=null==e?0:e.length;++r<i;)if(t(n,e[r]))return!0;return!1}},function(e,n,t){var r=t(83),i=t(239),o=t(42),a=r&&1/o(new r([,-0]))[1]==1/0?function(e){return new r(e)}:i;e.exports=a},function(e,n){e.exports=function(){}},function(e,n,t){var r=t(82),i=t(12);e.exports=function(e){return i(e)&&r(e)}},function(e,n,t){},function(e,n,t){},function(e,n,t){"use strict";t(88)},function(e,n,t){"use strict";t(89)},function(e,n,t){},function(e,n,t){},function(e,n,t){"use strict";t(90)},function(e,n,t){"use strict";t(91)},function(e,n,t){"use strict";t.r(n);
/*!
 * Vue.js v2.7.16
 * (c) 2014-2023 Evan You
 * Released under the MIT License.
 */
var r=Object.freeze({}),i=Array.isArray;function o(e){return null==e}function a(e){return null!=e}function s(e){return!0===e}function c(e){return"string"==typeof e||"number"==typeof e||"symbol"==typeof e||"boolean"==typeof e}function l(e){return"function"==typeof e}function u(e){return null!==e&&"object"==typeof e}var d=Object.prototype.toString;function p(e){return"[object Object]"===d.call(e)}function f(e){return"[object RegExp]"===d.call(e)}function m(e){var n=parseFloat(String(e));return n>=0&&Math.floor(n)===n&&isFinite(e)}function v(e){return a(e)&&"function"==typeof e.then&&"function"==typeof e.catch}function g(e){return null==e?"":Array.isArray(e)||p(e)&&e.toString===d?JSON.stringify(e,y,2):String(e)}function y(e,n){return n&&n.__v_isRef?n.value:n}function b(e){var n=parseFloat(e);return isNaN(n)?e:n}function _(e,n){for(var t=Object.create(null),r=e.split(","),i=0;i<r.length;i++)t[r[i]]=!0;return n?function(e){return t[e.toLowerCase()]}:function(e){return t[e]}}_("slot,component",!0);var x=_("key,ref,slot,slot-scope,is");function k(e,n){var t=e.length;if(t){if(n===e[t-1])return void(e.length=t-1);var r=e.indexOf(n);if(r>-1)return e.splice(r,1)}}var E=Object.prototype.hasOwnProperty;function w(e,n){return E.call(e,n)}function A(e){var n=Object.create(null);return function(t){return n[t]||(n[t]=e(t))}}var C=/-(\w)/g,L=A((function(e){return e.replace(C,(function(e,n){return n?n.toUpperCase():""}))})),T=A((function(e){return e.charAt(0).toUpperCase()+e.slice(1)})),R=/\B([A-Z])/g,S=A((function(e){return e.replace(R,"-$1").toLowerCase()}));var O=Function.prototype.bind?function(e,n){return e.bind(n)}:function(e,n){function t(t){var r=arguments.length;return r?r>1?e.apply(n,arguments):e.call(n,t):e.call(n)}return t._length=e.length,t};function j(e,n){n=n||0;for(var t=e.length-n,r=new Array(t);t--;)r[t]=e[t+n];return r}function U(e,n){for(var t in n)e[t]=n[t];return e}function I(e){for(var n={},t=0;t<e.length;t++)e[t]&&U(n,e[t]);return n}function z(e,n,t){}var P=function(e,n,t){return!1},B=function(e){return e};function $(e,n){if(e===n)return!0;var t=u(e),r=u(n);if(!t||!r)return!t&&!r&&String(e)===String(n);try{var i=Array.isArray(e),o=Array.isArray(n);if(i&&o)return e.length===n.length&&e.every((function(e,t){return $(e,n[t])}));if(e instanceof Date&&n instanceof Date)return e.getTime()===n.getTime();if(i||o)return!1;var a=Object.keys(e),s=Object.keys(n);return a.length===s.length&&a.every((function(t){return $(e[t],n[t])}))}catch(e){return!1}}function M(e,n){for(var t=0;t<e.length;t++)if($(e[t],n))return t;return-1}function F(e){var n=!1;return function(){n||(n=!0,e.apply(this,arguments))}}function D(e,n){return e===n?0===e&&1/e!=1/n:e==e||n==n}var N=["component","directive","filter"],H=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],q={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:P,isReservedAttr:P,isUnknownElement:P,getTagNamespace:z,parsePlatformTagName:B,mustUseProp:P,async:!0,_lifecycleHooks:H},K=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function V(e){var n=(e+"").charCodeAt(0);return 36===n||95===n}function G(e,n,t,r){Object.defineProperty(e,n,{value:t,enumerable:!!r,writable:!0,configurable:!0})}var X=new RegExp("[^".concat(K.source,".$_\\d]"));var W="__proto__"in{},Z="undefined"!=typeof window,Y=Z&&window.navigator.userAgent.toLowerCase(),J=Y&&/msie|trident/.test(Y),Q=Y&&Y.indexOf("msie 9.0")>0,ee=Y&&Y.indexOf("edge/")>0;Y&&Y.indexOf("android");var ne=Y&&/iphone|ipad|ipod|ios/.test(Y);Y&&/chrome\/\d+/.test(Y),Y&&/phantomjs/.test(Y);var te,re=Y&&Y.match(/firefox\/(\d+)/),ie={}.watch,oe=!1;if(Z)try{var ae={};Object.defineProperty(ae,"passive",{get:function(){oe=!0}}),window.addEventListener("test-passive",null,ae)}catch(e){}var se=function(){return void 0===te&&(te=!Z&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),te},ce=Z&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function le(e){return"function"==typeof e&&/native code/.test(e.toString())}var ue,de="undefined"!=typeof Symbol&&le(Symbol)&&"undefined"!=typeof Reflect&&le(Reflect.ownKeys);ue="undefined"!=typeof Set&&le(Set)?Set:function(){function e(){this.set=Object.create(null)}return e.prototype.has=function(e){return!0===this.set[e]},e.prototype.add=function(e){this.set[e]=!0},e.prototype.clear=function(){this.set=Object.create(null)},e}();var he=null;function pe(e){void 0===e&&(e=null),e||he&&he._scope.off(),he=e,e&&e._scope.on()}var fe=function(){function e(e,n,t,r,i,o,a,s){this.tag=e,this.data=n,this.children=t,this.text=r,this.elm=i,this.ns=void 0,this.context=o,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=n&&n.key,this.componentOptions=a,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(e.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),e}(),me=function(e){void 0===e&&(e="");var n=new fe;return n.text=e,n.isComment=!0,n};function ve(e){return new fe(void 0,void 0,void 0,String(e))}function ge(e){var n=new fe(e.tag,e.data,e.children&&e.children.slice(),e.text,e.elm,e.context,e.componentOptions,e.asyncFactory);return n.ns=e.ns,n.isStatic=e.isStatic,n.key=e.key,n.isComment=e.isComment,n.fnContext=e.fnContext,n.fnOptions=e.fnOptions,n.fnScopeId=e.fnScopeId,n.asyncMeta=e.asyncMeta,n.isCloned=!0,n}"function"==typeof SuppressedError&&SuppressedError;var ye=0,be=[],_e=function(){function e(){this._pending=!1,this.id=ye++,this.subs=[]}return e.prototype.addSub=function(e){this.subs.push(e)},e.prototype.removeSub=function(e){this.subs[this.subs.indexOf(e)]=null,this._pending||(this._pending=!0,be.push(this))},e.prototype.depend=function(n){e.target&&e.target.addDep(this)},e.prototype.notify=function(e){var n=this.subs.filter((function(e){return e}));for(var t=0,r=n.length;t<r;t++){0,n[t].update()}},e}();_e.target=null;var xe=[];function ke(e){xe.push(e),_e.target=e}function Ee(){xe.pop(),_e.target=xe[xe.length-1]}var we=Array.prototype,Ae=Object.create(we);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(e){var n=we[e];G(Ae,e,(function(){for(var t=[],r=0;r<arguments.length;r++)t[r]=arguments[r];var i,o=n.apply(this,t),a=this.__ob__;switch(e){case"push":case"unshift":i=t;break;case"splice":i=t.slice(2)}return i&&a.observeArray(i),a.dep.notify(),o}))}));var Ce=Object.getOwnPropertyNames(Ae),Le={},Te=!0;function Re(e){Te=e}var Se={notify:z,depend:z,addSub:z,removeSub:z},Oe=function(){function e(e,n,t){if(void 0===n&&(n=!1),void 0===t&&(t=!1),this.value=e,this.shallow=n,this.mock=t,this.dep=t?Se:new _e,this.vmCount=0,G(e,"__ob__",this),i(e)){if(!t)if(W)e.__proto__=Ae;else for(var r=0,o=Ce.length;r<o;r++){G(e,s=Ce[r],Ae[s])}n||this.observeArray(e)}else{var a=Object.keys(e);for(r=0;r<a.length;r++){var s;Ue(e,s=a[r],Le,void 0,n,t)}}}return e.prototype.observeArray=function(e){for(var n=0,t=e.length;n<t;n++)je(e[n],!1,this.mock)},e}();function je(e,n,t){return e&&w(e,"__ob__")&&e.__ob__ instanceof Oe?e.__ob__:!Te||!t&&se()||!i(e)&&!p(e)||!Object.isExtensible(e)||e.__v_skip||Fe(e)||e instanceof fe?void 0:new Oe(e,n,t)}function Ue(e,n,t,r,o,a,s){void 0===s&&(s=!1);var c=new _e,l=Object.getOwnPropertyDescriptor(e,n);if(!l||!1!==l.configurable){var u=l&&l.get,d=l&&l.set;u&&!d||t!==Le&&2!==arguments.length||(t=e[n]);var h=o?t&&t.__ob__:je(t,!1,a);return Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){var n=u?u.call(e):t;return _e.target&&(c.depend(),h&&(h.dep.depend(),i(n)&&Pe(n))),Fe(n)&&!o?n.value:n},set:function(n){var r=u?u.call(e):t;if(D(r,n)){if(d)d.call(e,n);else{if(u)return;if(!o&&Fe(r)&&!Fe(n))return void(r.value=n);t=n}h=o?n&&n.__ob__:je(n,!1,a),c.notify()}}}),c}}function Ie(e,n,t){if(!Me(e)){var r=e.__ob__;return i(e)&&m(n)?(e.length=Math.max(e.length,n),e.splice(n,1,t),r&&!r.shallow&&r.mock&&je(t,!1,!0),t):n in e&&!(n in Object.prototype)?(e[n]=t,t):e._isVue||r&&r.vmCount?t:r?(Ue(r.value,n,t,void 0,r.shallow,r.mock),r.dep.notify(),t):(e[n]=t,t)}}function ze(e,n){if(i(e)&&m(n))e.splice(n,1);else{var t=e.__ob__;e._isVue||t&&t.vmCount||Me(e)||w(e,n)&&(delete e[n],t&&t.dep.notify())}}function Pe(e){for(var n=void 0,t=0,r=e.length;t<r;t++)(n=e[t])&&n.__ob__&&n.__ob__.dep.depend(),i(n)&&Pe(n)}function Be(e){return $e(e,!0),G(e,"__v_isShallow",!0),e}function $e(e,n){if(!Me(e)){je(e,n,se());0}}function Me(e){return!(!e||!e.__v_isReadonly)}function Fe(e){return!(!e||!0!==e.__v_isRef)}function De(e,n,t){Object.defineProperty(e,t,{enumerable:!0,configurable:!0,get:function(){var e=n[t];if(Fe(e))return e.value;var r=e&&e.__ob__;return r&&r.dep.depend(),e},set:function(e){var r=n[t];Fe(r)&&!Fe(e)?r.value=e:n[t]=e}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Ne;var He=function(){function e(e){void 0===e&&(e=!1),this.detached=e,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Ne,!e&&Ne&&(this.index=(Ne.scopes||(Ne.scopes=[])).push(this)-1)}return e.prototype.run=function(e){if(this.active){var n=Ne;try{return Ne=this,e()}finally{Ne=n}}else 0},e.prototype.on=function(){Ne=this},e.prototype.off=function(){Ne=this.parent},e.prototype.stop=function(e){if(this.active){var n=void 0,t=void 0;for(n=0,t=this.effects.length;n<t;n++)this.effects[n].teardown();for(n=0,t=this.cleanups.length;n<t;n++)this.cleanups[n]();if(this.scopes)for(n=0,t=this.scopes.length;n<t;n++)this.scopes[n].stop(!0);if(!this.detached&&this.parent&&!e){var r=this.parent.scopes.pop();r&&r!==this&&(this.parent.scopes[this.index]=r,r.index=this.index)}this.parent=void 0,this.active=!1}},e}();function qe(e){var n=e._provided,t=e.$parent&&e.$parent._provided;return t===n?e._provided=Object.create(t):n}var Ke=A((function(e){var n="&"===e.charAt(0),t="~"===(e=n?e.slice(1):e).charAt(0),r="!"===(e=t?e.slice(1):e).charAt(0);return{name:e=r?e.slice(1):e,once:t,capture:r,passive:n}}));function Ve(e,n){function t(){var e=t.fns;if(!i(e))return Rn(e,null,arguments,n,"v-on handler");for(var r=e.slice(),o=0;o<r.length;o++)Rn(r[o],null,arguments,n,"v-on handler")}return t.fns=e,t}function Ge(e,n,t,r,i,a){var c,l,u,d;for(c in e)l=e[c],u=n[c],d=Ke(c),o(l)||(o(u)?(o(l.fns)&&(l=e[c]=Ve(l,a)),s(d.once)&&(l=e[c]=i(d.name,l,d.capture)),t(d.name,l,d.capture,d.passive,d.params)):l!==u&&(u.fns=l,e[c]=u));for(c in n)o(e[c])&&r((d=Ke(c)).name,n[c],d.capture)}function Xe(e,n,t){var r;e instanceof fe&&(e=e.data.hook||(e.data.hook={}));var i=e[n];function c(){t.apply(this,arguments),k(r.fns,c)}o(i)?r=Ve([c]):a(i.fns)&&s(i.merged)?(r=i).fns.push(c):r=Ve([i,c]),r.merged=!0,e[n]=r}function We(e,n,t,r,i){if(a(n)){if(w(n,t))return e[t]=n[t],i||delete n[t],!0;if(w(n,r))return e[t]=n[r],i||delete n[r],!0}return!1}function Ze(e){return c(e)?[ve(e)]:i(e)?function e(n,t){var r,l,u,d,h=[];for(r=0;r<n.length;r++)o(l=n[r])||"boolean"==typeof l||(u=h.length-1,d=h[u],i(l)?l.length>0&&(Ye((l=e(l,"".concat(t||"","_").concat(r)))[0])&&Ye(d)&&(h[u]=ve(d.text+l[0].text),l.shift()),h.push.apply(h,l)):c(l)?Ye(d)?h[u]=ve(d.text+l):""!==l&&h.push(ve(l)):Ye(l)&&Ye(d)?h[u]=ve(d.text+l.text):(s(n._isVList)&&a(l.tag)&&o(l.key)&&a(t)&&(l.key="__vlist".concat(t,"_").concat(r,"__")),h.push(l)));return h}(e):void 0}function Ye(e){return a(e)&&a(e.text)&&!1===e.isComment}function Je(e,n){var t,r,o,s,c=null;if(i(e)||"string"==typeof e)for(c=new Array(e.length),t=0,r=e.length;t<r;t++)c[t]=n(e[t],t);else if("number"==typeof e)for(c=new Array(e),t=0;t<e;t++)c[t]=n(t+1,t);else if(u(e))if(de&&e[Symbol.iterator]){c=[];for(var l=e[Symbol.iterator](),d=l.next();!d.done;)c.push(n(d.value,c.length)),d=l.next()}else for(o=Object.keys(e),c=new Array(o.length),t=0,r=o.length;t<r;t++)s=o[t],c[t]=n(e[s],s,t);return a(c)||(c=[]),c._isVList=!0,c}function Qe(e,n,t,r){var i,o=this.$scopedSlots[e];o?(t=t||{},r&&(t=U(U({},r),t)),i=o(t)||(l(n)?n():n)):i=this.$slots[e]||(l(n)?n():n);var a=t&&t.slot;return a?this.$createElement("template",{slot:a},i):i}function en(e){return jt(this.$options,"filters",e,!0)||B}function nn(e,n){return i(e)?-1===e.indexOf(n):e!==n}function tn(e,n,t,r,i){var o=q.keyCodes[n]||t;return i&&r&&!q.keyCodes[n]?nn(i,r):o?nn(o,e):r?S(r)!==n:void 0===e}function rn(e,n,t,r,o){if(t)if(u(t)){i(t)&&(t=I(t));var a=void 0,s=function(i){if("class"===i||"style"===i||x(i))a=e;else{var s=e.attrs&&e.attrs.type;a=r||q.mustUseProp(n,s,i)?e.domProps||(e.domProps={}):e.attrs||(e.attrs={})}var c=L(i),l=S(i);c in a||l in a||(a[i]=t[i],o&&((e.on||(e.on={}))["update:".concat(i)]=function(e){t[i]=e}))};for(var c in t)s(c)}else;return e}function on(e,n){var t=this._staticTrees||(this._staticTrees=[]),r=t[e];return r&&!n||sn(r=t[e]=this.$options.staticRenderFns[e].call(this._renderProxy,this._c,this),"__static__".concat(e),!1),r}function an(e,n,t){return sn(e,"__once__".concat(n).concat(t?"_".concat(t):""),!0),e}function sn(e,n,t){if(i(e))for(var r=0;r<e.length;r++)e[r]&&"string"!=typeof e[r]&&cn(e[r],"".concat(n,"_").concat(r),t);else cn(e,n,t)}function cn(e,n,t){e.isStatic=!0,e.key=n,e.isOnce=t}function ln(e,n){if(n)if(p(n)){var t=e.on=e.on?U({},e.on):{};for(var r in n){var i=t[r],o=n[r];t[r]=i?[].concat(i,o):o}}else;return e}function un(e,n,t,r){n=n||{$stable:!t};for(var o=0;o<e.length;o++){var a=e[o];i(a)?un(a,n,t):a&&(a.proxy&&(a.fn.proxy=!0),n[a.key]=a.fn)}return r&&(n.$key=r),n}function dn(e,n){for(var t=0;t<n.length;t+=2){var r=n[t];"string"==typeof r&&r&&(e[n[t]]=n[t+1])}return e}function hn(e,n){return"string"==typeof e?n+e:e}function pn(e){e._o=an,e._n=b,e._s=g,e._l=Je,e._t=Qe,e._q=$,e._i=M,e._m=on,e._f=en,e._k=tn,e._b=rn,e._v=ve,e._e=me,e._u=un,e._g=ln,e._d=dn,e._p=hn}function fn(e,n){if(!e||!e.length)return{};for(var t={},r=0,i=e.length;r<i;r++){var o=e[r],a=o.data;if(a&&a.attrs&&a.attrs.slot&&delete a.attrs.slot,o.context!==n&&o.fnContext!==n||!a||null==a.slot)(t.default||(t.default=[])).push(o);else{var s=a.slot,c=t[s]||(t[s]=[]);"template"===o.tag?c.push.apply(c,o.children||[]):c.push(o)}}for(var l in t)t[l].every(mn)&&delete t[l];return t}function mn(e){return e.isComment&&!e.asyncFactory||" "===e.text}function vn(e){return e.isComment&&e.asyncFactory}function gn(e,n,t,i){var o,a=Object.keys(t).length>0,s=n?!!n.$stable:!a,c=n&&n.$key;if(n){if(n._normalized)return n._normalized;if(s&&i&&i!==r&&c===i.$key&&!a&&!i.$hasNormal)return i;for(var l in o={},n)n[l]&&"$"!==l[0]&&(o[l]=yn(e,t,l,n[l]))}else o={};for(var u in t)u in o||(o[u]=bn(t,u));return n&&Object.isExtensible(n)&&(n._normalized=o),G(o,"$stable",s),G(o,"$key",c),G(o,"$hasNormal",a),o}function yn(e,n,t,r){var o=function(){var n=he;pe(e);var t=arguments.length?r.apply(null,arguments):r({}),o=(t=t&&"object"==typeof t&&!i(t)?[t]:Ze(t))&&t[0];return pe(n),t&&(!o||1===t.length&&o.isComment&&!vn(o))?void 0:t};return r.proxy&&Object.defineProperty(n,t,{get:o,enumerable:!0,configurable:!0}),o}function bn(e,n){return function(){return e[n]}}function _n(e){return{get attrs(){if(!e._attrsProxy){var n=e._attrsProxy={};G(n,"_v_attr_proxy",!0),xn(n,e.$attrs,r,e,"$attrs")}return e._attrsProxy},get listeners(){e._listenersProxy||xn(e._listenersProxy={},e.$listeners,r,e,"$listeners");return e._listenersProxy},get slots(){return function(e){e._slotsProxy||En(e._slotsProxy={},e.$scopedSlots);return e._slotsProxy}(e)},emit:O(e.$emit,e),expose:function(n){n&&Object.keys(n).forEach((function(t){return De(e,n,t)}))}}}function xn(e,n,t,r,i){var o=!1;for(var a in n)a in e?n[a]!==t[a]&&(o=!0):(o=!0,kn(e,a,r,i));for(var a in e)a in n||(o=!0,delete e[a]);return o}function kn(e,n,t,r){Object.defineProperty(e,n,{enumerable:!0,configurable:!0,get:function(){return t[r][n]}})}function En(e,n){for(var t in n)e[t]=n[t];for(var t in e)t in n||delete e[t]}var wn=null;function An(e,n){return(e.__esModule||de&&"Module"===e[Symbol.toStringTag])&&(e=e.default),u(e)?n.extend(e):e}function Cn(e){if(i(e))for(var n=0;n<e.length;n++){var t=e[n];if(a(t)&&(a(t.componentOptions)||vn(t)))return t}}function Ln(e,n,t,r,d,h){return(i(t)||c(t))&&(d=r,r=t,t=void 0),s(h)&&(d=2),function(e,n,t,r,c){if(a(t)&&a(t.__ob__))return me();a(t)&&a(t.is)&&(n=t.is);if(!n)return me();0;i(r)&&l(r[0])&&((t=t||{}).scopedSlots={default:r[0]},r.length=0);2===c?r=Ze(r):1===c&&(r=function(e){for(var n=0;n<e.length;n++)if(i(e[n]))return Array.prototype.concat.apply([],e);return e}(r));var d,h;if("string"==typeof n){var p=void 0;h=e.$vnode&&e.$vnode.ns||q.getTagNamespace(n),d=q.isReservedTag(n)?new fe(q.parsePlatformTagName(n),t,r,void 0,void 0,e):t&&t.pre||!a(p=jt(e.$options,"components",n))?new fe(n,t,r,void 0,void 0,e):kt(p,t,e,r,n)}else d=kt(n,t,e,r);return i(d)?d:a(d)?(a(h)&&function e(n,t,r){n.ns=t,"foreignObject"===n.tag&&(t=void 0,r=!0);if(a(n.children))for(var i=0,c=n.children.length;i<c;i++){var l=n.children[i];a(l.tag)&&(o(l.ns)||s(r)&&"svg"!==l.tag)&&e(l,t,r)}}(d,h),a(t)&&function(e){u(e.style)&&qn(e.style);u(e.class)&&qn(e.class)}(t),d):me()}(e,n,t,r,d)}function Tn(e,n,t){ke();try{if(n)for(var r=n;r=r.$parent;){var i=r.$options.errorCaptured;if(i)for(var o=0;o<i.length;o++)try{if(!1===i[o].call(r,e,n,t))return}catch(e){Sn(e,r,"errorCaptured hook")}}Sn(e,n,t)}finally{Ee()}}function Rn(e,n,t,r,i){var o;try{(o=t?e.apply(n,t):e.call(n))&&!o._isVue&&v(o)&&!o._handled&&(o.catch((function(e){return Tn(e,r,i+" (Promise/async)")})),o._handled=!0)}catch(e){Tn(e,r,i)}return o}function Sn(e,n,t){if(q.errorHandler)try{return q.errorHandler.call(null,e,n,t)}catch(n){n!==e&&On(n,null,"config.errorHandler")}On(e,n,t)}function On(e,n,t){if(!Z||"undefined"==typeof console)throw e;console.error(e)}var jn,Un=!1,In=[],zn=!1;function Pn(){zn=!1;var e=In.slice(0);In.length=0;for(var n=0;n<e.length;n++)e[n]()}if("undefined"!=typeof Promise&&le(Promise)){var Bn=Promise.resolve();jn=function(){Bn.then(Pn),ne&&setTimeout(z)},Un=!0}else if(J||"undefined"==typeof MutationObserver||!le(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())jn="undefined"!=typeof setImmediate&&le(setImmediate)?function(){setImmediate(Pn)}:function(){setTimeout(Pn,0)};else{var $n=1,Mn=new MutationObserver(Pn),Fn=document.createTextNode(String($n));Mn.observe(Fn,{characterData:!0}),jn=function(){$n=($n+1)%2,Fn.data=String($n)},Un=!0}function Dn(e,n){var t;if(In.push((function(){if(e)try{e.call(n)}catch(e){Tn(e,n,"nextTick")}else t&&t(n)})),zn||(zn=!0,jn()),!e&&"undefined"!=typeof Promise)return new Promise((function(e){t=e}))}function Nn(e){return function(n,t){if(void 0===t&&(t=he),t)return function(e,n,t){var r=e.$options;r[n]=Tt(r[n],t)}(t,e,n)}}Nn("beforeMount"),Nn("mounted"),Nn("beforeUpdate"),Nn("updated"),Nn("beforeDestroy"),Nn("destroyed"),Nn("activated"),Nn("deactivated"),Nn("serverPrefetch"),Nn("renderTracked"),Nn("renderTriggered"),Nn("errorCaptured");var Hn=new ue;function qn(e){return function e(n,t){var r,o,a=i(n);if(!a&&!u(n)||n.__v_skip||Object.isFrozen(n)||n instanceof fe)return;if(n.__ob__){var s=n.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(a)for(r=n.length;r--;)e(n[r],t);else if(Fe(n))e(n.value,t);else for(o=Object.keys(n),r=o.length;r--;)e(n[o[r]],t)}(e,Hn),Hn.clear(),e}var Kn,Vn=0,Gn=function(){function e(e,n,t,r,i){var o,a;o=this,void 0===(a=Ne&&!Ne._vm?Ne:e?e._scope:void 0)&&(a=Ne),a&&a.active&&a.effects.push(o),(this.vm=e)&&i&&(e._watcher=this),r?(this.deep=!!r.deep,this.user=!!r.user,this.lazy=!!r.lazy,this.sync=!!r.sync,this.before=r.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++Vn,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new ue,this.newDepIds=new ue,this.expression="",l(n)?this.getter=n:(this.getter=function(e){if(!X.test(e)){var n=e.split(".");return function(e){for(var t=0;t<n.length;t++){if(!e)return;e=e[n[t]]}return e}}}(n),this.getter||(this.getter=z)),this.value=this.lazy?void 0:this.get()}return e.prototype.get=function(){var e;ke(this);var n=this.vm;try{e=this.getter.call(n,n)}catch(e){if(!this.user)throw e;Tn(e,n,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&qn(e),Ee(),this.cleanupDeps()}return e},e.prototype.addDep=function(e){var n=e.id;this.newDepIds.has(n)||(this.newDepIds.add(n),this.newDeps.push(e),this.depIds.has(n)||e.addSub(this))},e.prototype.cleanupDeps=function(){for(var e=this.deps.length;e--;){var n=this.deps[e];this.newDepIds.has(n.id)||n.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},e.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ft(this)},e.prototype.run=function(){if(this.active){var e=this.get();if(e!==this.value||u(e)||this.deep){var n=this.value;if(this.value=e,this.user){var t='callback for watcher "'.concat(this.expression,'"');Rn(this.cb,this.vm,[e,n],this.vm,t)}else this.cb.call(this.vm,e,n)}}},e.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},e.prototype.depend=function(){for(var e=this.deps.length;e--;)this.deps[e].depend()},e.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&k(this.vm._scope.effects,this),this.active){for(var e=this.deps.length;e--;)this.deps[e].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},e}();function Xn(e,n){Kn.$on(e,n)}function Wn(e,n){Kn.$off(e,n)}function Zn(e,n){var t=Kn;return function r(){var i=n.apply(null,arguments);null!==i&&t.$off(e,r)}}function Yn(e,n,t){Kn=e,Ge(n,t||{},Xn,Wn,Zn,e),Kn=void 0}var Jn=null;function Qn(e){var n=Jn;return Jn=e,function(){Jn=n}}function et(e){for(;e&&(e=e.$parent);)if(e._inactive)return!0;return!1}function nt(e,n){if(n){if(e._directInactive=!1,et(e))return}else if(e._directInactive)return;if(e._inactive||null===e._inactive){e._inactive=!1;for(var t=0;t<e.$children.length;t++)nt(e.$children[t]);tt(e,"activated")}}function tt(e,n,t,r){void 0===r&&(r=!0),ke();var i=he,o=Ne;r&&pe(e);var a=e.$options[n],s="".concat(n," hook");if(a)for(var c=0,l=a.length;c<l;c++)Rn(a[c],e,t||null,e,s);e._hasHookEvent&&e.$emit("hook:"+n),r&&(pe(i),o&&o.on()),Ee()}var rt=[],it=[],ot={},at=!1,st=!1,ct=0;var lt=0,ut=Date.now;if(Z&&!J){var dt=window.performance;dt&&"function"==typeof dt.now&&ut()>document.createEvent("Event").timeStamp&&(ut=function(){return dt.now()})}var ht=function(e,n){if(e.post){if(!n.post)return 1}else if(n.post)return-1;return e.id-n.id};function pt(){var e,n;for(lt=ut(),st=!0,rt.sort(ht),ct=0;ct<rt.length;ct++)(e=rt[ct]).before&&e.before(),n=e.id,ot[n]=null,e.run();var t=it.slice(),r=rt.slice();ct=rt.length=it.length=0,ot={},at=st=!1,function(e){for(var n=0;n<e.length;n++)e[n]._inactive=!0,nt(e[n],!0)}(t),function(e){var n=e.length;for(;n--;){var t=e[n],r=t.vm;r&&r._watcher===t&&r._isMounted&&!r._isDestroyed&&tt(r,"updated")}}(r),function(){for(var e=0;e<be.length;e++){var n=be[e];n.subs=n.subs.filter((function(e){return e})),n._pending=!1}be.length=0}(),ce&&q.devtools&&ce.emit("flush")}function ft(e){var n=e.id;if(null==ot[n]&&(e!==_e.target||!e.noRecurse)){if(ot[n]=!0,st){for(var t=rt.length-1;t>ct&&rt[t].id>e.id;)t--;rt.splice(t+1,0,e)}else rt.push(e);at||(at=!0,Dn(pt))}}function mt(e,n){if(e){for(var t=Object.create(null),r=de?Reflect.ownKeys(e):Object.keys(e),i=0;i<r.length;i++){var o=r[i];if("__ob__"!==o){var a=e[o].from;if(a in n._provided)t[o]=n._provided[a];else if("default"in e[o]){var s=e[o].default;t[o]=l(s)?s.call(n):s}else 0}}return t}}function vt(e,n,t,o,a){var c,l=this,u=a.options;w(o,"_uid")?(c=Object.create(o))._original=o:(c=o,o=o._original);var d=s(u._compiled),h=!d;this.data=e,this.props=n,this.children=t,this.parent=o,this.listeners=e.on||r,this.injections=mt(u.inject,o),this.slots=function(){return l.$slots||gn(o,e.scopedSlots,l.$slots=fn(t,o)),l.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return gn(o,e.scopedSlots,this.slots())}}),d&&(this.$options=u,this.$slots=this.slots(),this.$scopedSlots=gn(o,e.scopedSlots,this.$slots)),u._scopeId?this._c=function(e,n,t,r){var a=Ln(c,e,n,t,r,h);return a&&!i(a)&&(a.fnScopeId=u._scopeId,a.fnContext=o),a}:this._c=function(e,n,t,r){return Ln(c,e,n,t,r,h)}}function gt(e,n,t,r,i){var o=ge(e);return o.fnContext=t,o.fnOptions=r,n.slot&&((o.data||(o.data={})).slot=n.slot),o}function yt(e,n){for(var t in n)e[L(t)]=n[t]}function bt(e){return e.name||e.__name||e._componentTag}pn(vt.prototype);var _t={init:function(e,n){if(e.componentInstance&&!e.componentInstance._isDestroyed&&e.data.keepAlive){var t=e;_t.prepatch(t,t)}else{(e.componentInstance=function(e,n){var t={_isComponent:!0,_parentVnode:e,parent:n},r=e.data.inlineTemplate;a(r)&&(t.render=r.render,t.staticRenderFns=r.staticRenderFns);return new e.componentOptions.Ctor(t)}(e,Jn)).$mount(n?e.elm:void 0,n)}},prepatch:function(e,n){var t=n.componentOptions;!function(e,n,t,i,o){var a=i.data.scopedSlots,s=e.$scopedSlots,c=!!(a&&!a.$stable||s!==r&&!s.$stable||a&&e.$scopedSlots.$key!==a.$key||!a&&e.$scopedSlots.$key),l=!!(o||e.$options._renderChildren||c),u=e.$vnode;e.$options._parentVnode=i,e.$vnode=i,e._vnode&&(e._vnode.parent=i),e.$options._renderChildren=o;var d=i.data.attrs||r;e._attrsProxy&&xn(e._attrsProxy,d,u.data&&u.data.attrs||r,e,"$attrs")&&(l=!0),e.$attrs=d,t=t||r;var h=e.$options._parentListeners;if(e._listenersProxy&&xn(e._listenersProxy,t,h||r,e,"$listeners"),e.$listeners=e.$options._parentListeners=t,Yn(e,t,h),n&&e.$options.props){Re(!1);for(var p=e._props,f=e.$options._propKeys||[],m=0;m<f.length;m++){var v=f[m],g=e.$options.props;p[v]=Ut(v,g,n,e)}Re(!0),e.$options.propsData=n}l&&(e.$slots=fn(o,i.context),e.$forceUpdate())}(n.componentInstance=e.componentInstance,t.propsData,t.listeners,n,t.children)},insert:function(e){var n,t=e.context,r=e.componentInstance;r._isMounted||(r._isMounted=!0,tt(r,"mounted")),e.data.keepAlive&&(t._isMounted?((n=r)._inactive=!1,it.push(n)):nt(r,!0))},destroy:function(e){var n=e.componentInstance;n._isDestroyed||(e.data.keepAlive?function e(n,t){if(!(t&&(n._directInactive=!0,et(n))||n._inactive)){n._inactive=!0;for(var r=0;r<n.$children.length;r++)e(n.$children[r]);tt(n,"deactivated")}}(n,!0):n.$destroy())}},xt=Object.keys(_t);function kt(e,n,t,c,l){if(!o(e)){var d=t.$options._base;if(u(e)&&(e=d.extend(e)),"function"==typeof e){var h;if(o(e.cid)&&void 0===(e=function(e,n){if(s(e.error)&&a(e.errorComp))return e.errorComp;if(a(e.resolved))return e.resolved;var t=wn;if(t&&a(e.owners)&&-1===e.owners.indexOf(t)&&e.owners.push(t),s(e.loading)&&a(e.loadingComp))return e.loadingComp;if(t&&!a(e.owners)){var r=e.owners=[t],i=!0,c=null,l=null;t.$on("hook:destroyed",(function(){return k(r,t)}));var d=function(e){for(var n=0,t=r.length;n<t;n++)r[n].$forceUpdate();e&&(r.length=0,null!==c&&(clearTimeout(c),c=null),null!==l&&(clearTimeout(l),l=null))},h=F((function(t){e.resolved=An(t,n),i?r.length=0:d(!0)})),p=F((function(n){a(e.errorComp)&&(e.error=!0,d(!0))})),f=e(h,p);return u(f)&&(v(f)?o(e.resolved)&&f.then(h,p):v(f.component)&&(f.component.then(h,p),a(f.error)&&(e.errorComp=An(f.error,n)),a(f.loading)&&(e.loadingComp=An(f.loading,n),0===f.delay?e.loading=!0:c=setTimeout((function(){c=null,o(e.resolved)&&o(e.error)&&(e.loading=!0,d(!1))}),f.delay||200)),a(f.timeout)&&(l=setTimeout((function(){l=null,o(e.resolved)&&p(null)}),f.timeout)))),i=!1,e.loading?e.loadingComp:e.resolved}}(h=e,d)))return function(e,n,t,r,i){var o=me();return o.asyncFactory=e,o.asyncMeta={data:n,context:t,children:r,tag:i},o}(h,n,t,c,l);n=n||{},Gt(e),a(n.model)&&function(e,n){var t=e.model&&e.model.prop||"value",r=e.model&&e.model.event||"input";(n.attrs||(n.attrs={}))[t]=n.model.value;var o=n.on||(n.on={}),s=o[r],c=n.model.callback;a(s)?(i(s)?-1===s.indexOf(c):s!==c)&&(o[r]=[c].concat(s)):o[r]=c}(e.options,n);var p=function(e,n,t){var r=n.options.props;if(!o(r)){var i={},s=e.attrs,c=e.props;if(a(s)||a(c))for(var l in r){var u=S(l);We(i,c,l,u,!0)||We(i,s,l,u,!1)}return i}}(n,e);if(s(e.options.functional))return function(e,n,t,o,s){var c=e.options,l={},u=c.props;if(a(u))for(var d in u)l[d]=Ut(d,u,n||r);else a(t.attrs)&&yt(l,t.attrs),a(t.props)&&yt(l,t.props);var h=new vt(t,l,s,o,e),p=c.render.call(null,h._c,h);if(p instanceof fe)return gt(p,t,h.parent,c,h);if(i(p)){for(var f=Ze(p)||[],m=new Array(f.length),v=0;v<f.length;v++)m[v]=gt(f[v],t,h.parent,c,h);return m}}(e,p,n,t,c);var f=n.on;if(n.on=n.nativeOn,s(e.options.abstract)){var m=n.slot;n={},m&&(n.slot=m)}!function(e){for(var n=e.hook||(e.hook={}),t=0;t<xt.length;t++){var r=xt[t],i=n[r],o=_t[r];i===o||i&&i._merged||(n[r]=i?Et(o,i):o)}}(n);var g=bt(e.options)||l;return new fe("vue-component-".concat(e.cid).concat(g?"-".concat(g):""),n,void 0,void 0,void 0,t,{Ctor:e,propsData:p,listeners:f,tag:l,children:c},h)}}}function Et(e,n){var t=function(t,r){e(t,r),n(t,r)};return t._merged=!0,t}var wt=z,At=q.optionMergeStrategies;function Ct(e,n,t){if(void 0===t&&(t=!0),!n)return e;for(var r,i,o,a=de?Reflect.ownKeys(n):Object.keys(n),s=0;s<a.length;s++)"__ob__"!==(r=a[s])&&(i=e[r],o=n[r],t&&w(e,r)?i!==o&&p(i)&&p(o)&&Ct(i,o):Ie(e,r,o));return e}function Lt(e,n,t){return t?function(){var r=l(n)?n.call(t,t):n,i=l(e)?e.call(t,t):e;return r?Ct(r,i):i}:n?e?function(){return Ct(l(n)?n.call(this,this):n,l(e)?e.call(this,this):e)}:n:e}function Tt(e,n){var t=n?e?e.concat(n):i(n)?n:[n]:e;return t?function(e){for(var n=[],t=0;t<e.length;t++)-1===n.indexOf(e[t])&&n.push(e[t]);return n}(t):t}function Rt(e,n,t,r){var i=Object.create(e||null);return n?U(i,n):i}At.data=function(e,n,t){return t?Lt(e,n,t):n&&"function"!=typeof n?e:Lt(e,n)},H.forEach((function(e){At[e]=Tt})),N.forEach((function(e){At[e+"s"]=Rt})),At.watch=function(e,n,t,r){if(e===ie&&(e=void 0),n===ie&&(n=void 0),!n)return Object.create(e||null);if(!e)return n;var o={};for(var a in U(o,e),n){var s=o[a],c=n[a];s&&!i(s)&&(s=[s]),o[a]=s?s.concat(c):i(c)?c:[c]}return o},At.props=At.methods=At.inject=At.computed=function(e,n,t,r){if(!e)return n;var i=Object.create(null);return U(i,e),n&&U(i,n),i},At.provide=function(e,n){return e?function(){var t=Object.create(null);return Ct(t,l(e)?e.call(this):e),n&&Ct(t,l(n)?n.call(this):n,!1),t}:n};var St=function(e,n){return void 0===n?e:n};function Ot(e,n,t){if(l(n)&&(n=n.options),function(e,n){var t=e.props;if(t){var r,o,a={};if(i(t))for(r=t.length;r--;)"string"==typeof(o=t[r])&&(a[L(o)]={type:null});else if(p(t))for(var s in t)o=t[s],a[L(s)]=p(o)?o:{type:o};else 0;e.props=a}}(n),function(e,n){var t=e.inject;if(t){var r=e.inject={};if(i(t))for(var o=0;o<t.length;o++)r[t[o]]={from:t[o]};else if(p(t))for(var a in t){var s=t[a];r[a]=p(s)?U({from:a},s):{from:s}}else 0}}(n),function(e){var n=e.directives;if(n)for(var t in n){var r=n[t];l(r)&&(n[t]={bind:r,update:r})}}(n),!n._base&&(n.extends&&(e=Ot(e,n.extends,t)),n.mixins))for(var r=0,o=n.mixins.length;r<o;r++)e=Ot(e,n.mixins[r],t);var a,s={};for(a in e)c(a);for(a in n)w(e,a)||c(a);function c(r){var i=At[r]||St;s[r]=i(e[r],n[r],t,r)}return s}function jt(e,n,t,r){if("string"==typeof t){var i=e[n];if(w(i,t))return i[t];var o=L(t);if(w(i,o))return i[o];var a=T(o);return w(i,a)?i[a]:i[t]||i[o]||i[a]}}function Ut(e,n,t,r){var i=n[e],o=!w(t,e),a=t[e],s=Bt(Boolean,i.type);if(s>-1)if(o&&!w(i,"default"))a=!1;else if(""===a||a===S(e)){var c=Bt(String,i.type);(c<0||s<c)&&(a=!0)}if(void 0===a){a=function(e,n,t){if(!w(n,"default"))return;var r=n.default;0;if(e&&e.$options.propsData&&void 0===e.$options.propsData[t]&&void 0!==e._props[t])return e._props[t];return l(r)&&"Function"!==zt(n.type)?r.call(e):r}(r,i,e);var u=Te;Re(!0),je(a),Re(u)}return a}var It=/^\s*function (\w+)/;function zt(e){var n=e&&e.toString().match(It);return n?n[1]:""}function Pt(e,n){return zt(e)===zt(n)}function Bt(e,n){if(!i(n))return Pt(n,e)?0:-1;for(var t=0,r=n.length;t<r;t++)if(Pt(n[t],e))return t;return-1}var $t={enumerable:!0,configurable:!0,get:z,set:z};function Mt(e,n,t){$t.get=function(){return this[n][t]},$t.set=function(e){this[n][t]=e},Object.defineProperty(e,t,$t)}function Ft(e){var n=e.$options;if(n.props&&function(e,n){var t=e.$options.propsData||{},r=e._props=Be({}),i=e.$options._propKeys=[];e.$parent&&Re(!1);var o=function(o){i.push(o);var a=Ut(o,n,t,e);Ue(r,o,a,void 0,!0),o in e||Mt(e,"_props",o)};for(var a in n)o(a);Re(!0)}(e,n.props),function(e){var n=e.$options,t=n.setup;if(t){var r=e._setupContext=_n(e);pe(e),ke();var i=Rn(t,null,[e._props||Be({}),r],e,"setup");if(Ee(),pe(),l(i))n.render=i;else if(u(i))if(e._setupState=i,i.__sfc){var o=e._setupProxy={};for(var a in i)"__sfc"!==a&&De(o,i,a)}else for(var a in i)V(a)||De(e,i,a);else 0}}(e),n.methods&&function(e,n){e.$options.props;for(var t in n)e[t]="function"!=typeof n[t]?z:O(n[t],e)}(e,n.methods),n.data)!function(e){var n=e.$options.data;p(n=e._data=l(n)?function(e,n){ke();try{return e.call(n,n)}catch(e){return Tn(e,n,"data()"),{}}finally{Ee()}}(n,e):n||{})||(n={});var t=Object.keys(n),r=e.$options.props,i=(e.$options.methods,t.length);for(;i--;){var o=t[i];0,r&&w(r,o)||V(o)||Mt(e,"_data",o)}var a=je(n);a&&a.vmCount++}(e);else{var t=je(e._data={});t&&t.vmCount++}n.computed&&function(e,n){var t=e._computedWatchers=Object.create(null),r=se();for(var i in n){var o=n[i],a=l(o)?o:o.get;0,r||(t[i]=new Gn(e,a||z,z,Dt)),i in e||Nt(e,i,o)}}(e,n.computed),n.watch&&n.watch!==ie&&function(e,n){for(var t in n){var r=n[t];if(i(r))for(var o=0;o<r.length;o++)Kt(e,t,r[o]);else Kt(e,t,r)}}(e,n.watch)}var Dt={lazy:!0};function Nt(e,n,t){var r=!se();l(t)?($t.get=r?Ht(n):qt(t),$t.set=z):($t.get=t.get?r&&!1!==t.cache?Ht(n):qt(t.get):z,$t.set=t.set||z),Object.defineProperty(e,n,$t)}function Ht(e){return function(){var n=this._computedWatchers&&this._computedWatchers[e];if(n)return n.dirty&&n.evaluate(),_e.target&&n.depend(),n.value}}function qt(e){return function(){return e.call(this,this)}}function Kt(e,n,t,r){return p(t)&&(r=t,t=t.handler),"string"==typeof t&&(t=e[t]),e.$watch(n,t,r)}var Vt=0;function Gt(e){var n=e.options;if(e.super){var t=Gt(e.super);if(t!==e.superOptions){e.superOptions=t;var r=function(e){var n,t=e.options,r=e.sealedOptions;for(var i in t)t[i]!==r[i]&&(n||(n={}),n[i]=t[i]);return n}(e);r&&U(e.extendOptions,r),(n=e.options=Ot(t,e.extendOptions)).name&&(n.components[n.name]=e)}}return n}function Xt(e){this._init(e)}function Wt(e){e.cid=0;var n=1;e.extend=function(e){e=e||{};var t=this,r=t.cid,i=e._Ctor||(e._Ctor={});if(i[r])return i[r];var o=bt(e)||bt(t.options);var a=function(e){this._init(e)};return(a.prototype=Object.create(t.prototype)).constructor=a,a.cid=n++,a.options=Ot(t.options,e),a.super=t,a.options.props&&function(e){var n=e.options.props;for(var t in n)Mt(e.prototype,"_props",t)}(a),a.options.computed&&function(e){var n=e.options.computed;for(var t in n)Nt(e.prototype,t,n[t])}(a),a.extend=t.extend,a.mixin=t.mixin,a.use=t.use,N.forEach((function(e){a[e]=t[e]})),o&&(a.options.components[o]=a),a.superOptions=t.options,a.extendOptions=e,a.sealedOptions=U({},a.options),i[r]=a,a}}function Zt(e){return e&&(bt(e.Ctor.options)||e.tag)}function Yt(e,n){return i(e)?e.indexOf(n)>-1:"string"==typeof e?e.split(",").indexOf(n)>-1:!!f(e)&&e.test(n)}function Jt(e,n){var t=e.cache,r=e.keys,i=e._vnode,o=e.$vnode;for(var a in t){var s=t[a];if(s){var c=s.name;c&&!n(c)&&Qt(t,a,r,i)}}o.componentOptions.children=void 0}function Qt(e,n,t,r){var i=e[n];!i||r&&i.tag===r.tag||i.componentInstance.$destroy(),e[n]=null,k(t,n)}!function(e){e.prototype._init=function(e){var n=this;n._uid=Vt++,n._isVue=!0,n.__v_skip=!0,n._scope=new He(!0),n._scope.parent=void 0,n._scope._vm=!0,e&&e._isComponent?function(e,n){var t=e.$options=Object.create(e.constructor.options),r=n._parentVnode;t.parent=n.parent,t._parentVnode=r;var i=r.componentOptions;t.propsData=i.propsData,t._parentListeners=i.listeners,t._renderChildren=i.children,t._componentTag=i.tag,n.render&&(t.render=n.render,t.staticRenderFns=n.staticRenderFns)}(n,e):n.$options=Ot(Gt(n.constructor),e||{},n),n._renderProxy=n,n._self=n,function(e){var n=e.$options,t=n.parent;if(t&&!n.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(e)}e.$parent=t,e.$root=t?t.$root:e,e.$children=[],e.$refs={},e._provided=t?t._provided:Object.create(null),e._watcher=null,e._inactive=null,e._directInactive=!1,e._isMounted=!1,e._isDestroyed=!1,e._isBeingDestroyed=!1}(n),function(e){e._events=Object.create(null),e._hasHookEvent=!1;var n=e.$options._parentListeners;n&&Yn(e,n)}(n),function(e){e._vnode=null,e._staticTrees=null;var n=e.$options,t=e.$vnode=n._parentVnode,i=t&&t.context;e.$slots=fn(n._renderChildren,i),e.$scopedSlots=t?gn(e.$parent,t.data.scopedSlots,e.$slots):r,e._c=function(n,t,r,i){return Ln(e,n,t,r,i,!1)},e.$createElement=function(n,t,r,i){return Ln(e,n,t,r,i,!0)};var o=t&&t.data;Ue(e,"$attrs",o&&o.attrs||r,null,!0),Ue(e,"$listeners",n._parentListeners||r,null,!0)}(n),tt(n,"beforeCreate",void 0,!1),function(e){var n=mt(e.$options.inject,e);n&&(Re(!1),Object.keys(n).forEach((function(t){Ue(e,t,n[t])})),Re(!0))}(n),Ft(n),function(e){var n=e.$options.provide;if(n){var t=l(n)?n.call(e):n;if(!u(t))return;for(var r=qe(e),i=de?Reflect.ownKeys(t):Object.keys(t),o=0;o<i.length;o++){var a=i[o];Object.defineProperty(r,a,Object.getOwnPropertyDescriptor(t,a))}}}(n),tt(n,"created"),n.$options.el&&n.$mount(n.$options.el)}}(Xt),function(e){var n={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(e.prototype,"$data",n),Object.defineProperty(e.prototype,"$props",t),e.prototype.$set=Ie,e.prototype.$delete=ze,e.prototype.$watch=function(e,n,t){if(p(n))return Kt(this,e,n,t);(t=t||{}).user=!0;var r=new Gn(this,e,n,t);if(t.immediate){var i='callback for immediate watcher "'.concat(r.expression,'"');ke(),Rn(n,this,[r.value],this,i),Ee()}return function(){r.teardown()}}}(Xt),function(e){var n=/^hook:/;e.prototype.$on=function(e,t){var r=this;if(i(e))for(var o=0,a=e.length;o<a;o++)r.$on(e[o],t);else(r._events[e]||(r._events[e]=[])).push(t),n.test(e)&&(r._hasHookEvent=!0);return r},e.prototype.$once=function(e,n){var t=this;function r(){t.$off(e,r),n.apply(t,arguments)}return r.fn=n,t.$on(e,r),t},e.prototype.$off=function(e,n){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(i(e)){for(var r=0,o=e.length;r<o;r++)t.$off(e[r],n);return t}var a,s=t._events[e];if(!s)return t;if(!n)return t._events[e]=null,t;for(var c=s.length;c--;)if((a=s[c])===n||a.fn===n){s.splice(c,1);break}return t},e.prototype.$emit=function(e){var n=this,t=n._events[e];if(t){t=t.length>1?j(t):t;for(var r=j(arguments,1),i='event handler for "'.concat(e,'"'),o=0,a=t.length;o<a;o++)Rn(t[o],n,r,n,i)}return n}}(Xt),function(e){e.prototype._update=function(e,n){var t=this,r=t.$el,i=t._vnode,o=Qn(t);t._vnode=e,t.$el=i?t.__patch__(i,e):t.__patch__(t.$el,e,n,!1),o(),r&&(r.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var a=t;a&&a.$vnode&&a.$parent&&a.$vnode===a.$parent._vnode;)a.$parent.$el=a.$el,a=a.$parent},e.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},e.prototype.$destroy=function(){var e=this;if(!e._isBeingDestroyed){tt(e,"beforeDestroy"),e._isBeingDestroyed=!0;var n=e.$parent;!n||n._isBeingDestroyed||e.$options.abstract||k(n.$children,e),e._scope.stop(),e._data.__ob__&&e._data.__ob__.vmCount--,e._isDestroyed=!0,e.__patch__(e._vnode,null),tt(e,"destroyed"),e.$off(),e.$el&&(e.$el.__vue__=null),e.$vnode&&(e.$vnode.parent=null)}}}(Xt),function(e){pn(e.prototype),e.prototype.$nextTick=function(e){return Dn(e,this)},e.prototype._render=function(){var e=this,n=e.$options,t=n.render,r=n._parentVnode;r&&e._isMounted&&(e.$scopedSlots=gn(e.$parent,r.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&En(e._slotsProxy,e.$scopedSlots)),e.$vnode=r;var o,a=he,s=wn;try{pe(e),wn=e,o=t.call(e._renderProxy,e.$createElement)}catch(n){Tn(n,e,"render"),o=e._vnode}finally{wn=s,pe(a)}return i(o)&&1===o.length&&(o=o[0]),o instanceof fe||(o=me()),o.parent=r,o}}(Xt);var er=[String,RegExp,Array],nr={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:er,exclude:er,max:[String,Number]},methods:{cacheVNode:function(){var e=this.cache,n=this.keys,t=this.vnodeToCache,r=this.keyToCache;if(t){var i=t.tag,o=t.componentInstance,a=t.componentOptions;e[r]={name:Zt(a),tag:i,componentInstance:o},n.push(r),this.max&&n.length>parseInt(this.max)&&Qt(e,n[0],n,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var e in this.cache)Qt(this.cache,e,this.keys)},mounted:function(){var e=this;this.cacheVNode(),this.$watch("include",(function(n){Jt(e,(function(e){return Yt(n,e)}))})),this.$watch("exclude",(function(n){Jt(e,(function(e){return!Yt(n,e)}))}))},updated:function(){this.cacheVNode()},render:function(){var e=this.$slots.default,n=Cn(e),t=n&&n.componentOptions;if(t){var r=Zt(t),i=this.include,o=this.exclude;if(i&&(!r||!Yt(i,r))||o&&r&&Yt(o,r))return n;var a=this.cache,s=this.keys,c=null==n.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):n.key;a[c]?(n.componentInstance=a[c].componentInstance,k(s,c),s.push(c)):(this.vnodeToCache=n,this.keyToCache=c),n.data.keepAlive=!0}return n||e&&e[0]}}};!function(e){var n={get:function(){return q}};Object.defineProperty(e,"config",n),e.util={warn:wt,extend:U,mergeOptions:Ot,defineReactive:Ue},e.set=Ie,e.delete=ze,e.nextTick=Dn,e.observable=function(e){return je(e),e},e.options=Object.create(null),N.forEach((function(n){e.options[n+"s"]=Object.create(null)})),e.options._base=e,U(e.options.components,nr),function(e){e.use=function(e){var n=this._installedPlugins||(this._installedPlugins=[]);if(n.indexOf(e)>-1)return this;var t=j(arguments,1);return t.unshift(this),l(e.install)?e.install.apply(e,t):l(e)&&e.apply(null,t),n.push(e),this}}(e),function(e){e.mixin=function(e){return this.options=Ot(this.options,e),this}}(e),Wt(e),function(e){N.forEach((function(n){e[n]=function(e,t){return t?("component"===n&&p(t)&&(t.name=t.name||e,t=this.options._base.extend(t)),"directive"===n&&l(t)&&(t={bind:t,update:t}),this.options[n+"s"][e]=t,t):this.options[n+"s"][e]}}))}(e)}(Xt),Object.defineProperty(Xt.prototype,"$isServer",{get:se}),Object.defineProperty(Xt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Xt,"FunctionalRenderContext",{value:vt}),Xt.version="2.7.16";var tr=_("style,class"),rr=_("input,textarea,option,select,progress"),ir=_("contenteditable,draggable,spellcheck"),or=_("events,caret,typing,plaintext-only"),ar=_("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),sr="http://www.w3.org/1999/xlink",cr=function(e){return":"===e.charAt(5)&&"xlink"===e.slice(0,5)},lr=function(e){return cr(e)?e.slice(6,e.length):""},ur=function(e){return null==e||!1===e};function dr(e){for(var n=e.data,t=e,r=e;a(r.componentInstance);)(r=r.componentInstance._vnode)&&r.data&&(n=hr(r.data,n));for(;a(t=t.parent);)t&&t.data&&(n=hr(n,t.data));return function(e,n){if(a(e)||a(n))return pr(e,fr(n));return""}(n.staticClass,n.class)}function hr(e,n){return{staticClass:pr(e.staticClass,n.staticClass),class:a(e.class)?[e.class,n.class]:n.class}}function pr(e,n){return e?n?e+" "+n:e:n||""}function fr(e){return Array.isArray(e)?function(e){for(var n,t="",r=0,i=e.length;r<i;r++)a(n=fr(e[r]))&&""!==n&&(t&&(t+=" "),t+=n);return t}(e):u(e)?function(e){var n="";for(var t in e)e[t]&&(n&&(n+=" "),n+=t);return n}(e):"string"==typeof e?e:""}var mr={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},vr=_("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),gr=_("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),yr=function(e){return vr(e)||gr(e)};var br=Object.create(null);var _r=_("text,number,password,search,email,tel,url");var xr=Object.freeze({__proto__:null,createElement:function(e,n){var t=document.createElement(e);return"select"!==e||n.data&&n.data.attrs&&void 0!==n.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(e,n){return document.createElementNS(mr[e],n)},createTextNode:function(e){return document.createTextNode(e)},createComment:function(e){return document.createComment(e)},insertBefore:function(e,n,t){e.insertBefore(n,t)},removeChild:function(e,n){e.removeChild(n)},appendChild:function(e,n){e.appendChild(n)},parentNode:function(e){return e.parentNode},nextSibling:function(e){return e.nextSibling},tagName:function(e){return e.tagName},setTextContent:function(e,n){e.textContent=n},setStyleScope:function(e,n){e.setAttribute(n,"")}}),kr={create:function(e,n){Er(n)},update:function(e,n){e.data.ref!==n.data.ref&&(Er(e,!0),Er(n))},destroy:function(e){Er(e,!0)}};function Er(e,n){var t=e.data.ref;if(a(t)){var r=e.context,o=e.componentInstance||e.elm,s=n?null:o,c=n?void 0:o;if(l(t))Rn(t,r,[s],r,"template ref function");else{var u=e.data.refInFor,d="string"==typeof t||"number"==typeof t,h=Fe(t),p=r.$refs;if(d||h)if(u){var f=d?p[t]:t.value;n?i(f)&&k(f,o):i(f)?f.includes(o)||f.push(o):d?(p[t]=[o],wr(r,t,p[t])):t.value=[o]}else if(d){if(n&&p[t]!==o)return;p[t]=c,wr(r,t,s)}else if(h){if(n&&t.value!==o)return;t.value=s}else 0}}}function wr(e,n,t){var r=e._setupState;r&&w(r,n)&&(Fe(r[n])?r[n].value=t:r[n]=t)}var Ar=new fe("",{},[]),Cr=["create","activate","update","remove","destroy"];function Lr(e,n){return e.key===n.key&&e.asyncFactory===n.asyncFactory&&(e.tag===n.tag&&e.isComment===n.isComment&&a(e.data)===a(n.data)&&function(e,n){if("input"!==e.tag)return!0;var t,r=a(t=e.data)&&a(t=t.attrs)&&t.type,i=a(t=n.data)&&a(t=t.attrs)&&t.type;return r===i||_r(r)&&_r(i)}(e,n)||s(e.isAsyncPlaceholder)&&o(n.asyncFactory.error))}function Tr(e,n,t){var r,i,o={};for(r=n;r<=t;++r)a(i=e[r].key)&&(o[i]=r);return o}var Rr={create:Sr,update:Sr,destroy:function(e){Sr(e,Ar)}};function Sr(e,n){(e.data.directives||n.data.directives)&&function(e,n){var t,r,i,o=e===Ar,a=n===Ar,s=jr(e.data.directives,e.context),c=jr(n.data.directives,n.context),l=[],u=[];for(t in c)r=s[t],i=c[t],r?(i.oldValue=r.value,i.oldArg=r.arg,Ir(i,"update",n,e),i.def&&i.def.componentUpdated&&u.push(i)):(Ir(i,"bind",n,e),i.def&&i.def.inserted&&l.push(i));if(l.length){var d=function(){for(var t=0;t<l.length;t++)Ir(l[t],"inserted",n,e)};o?Xe(n,"insert",d):d()}u.length&&Xe(n,"postpatch",(function(){for(var t=0;t<u.length;t++)Ir(u[t],"componentUpdated",n,e)}));if(!o)for(t in s)c[t]||Ir(s[t],"unbind",e,e,a)}(e,n)}var Or=Object.create(null);function jr(e,n){var t,r,i=Object.create(null);if(!e)return i;for(t=0;t<e.length;t++){if((r=e[t]).modifiers||(r.modifiers=Or),i[Ur(r)]=r,n._setupState&&n._setupState.__sfc){var o=r.def||jt(n,"_setupState","v-"+r.name);r.def="function"==typeof o?{bind:o,update:o}:o}r.def=r.def||jt(n.$options,"directives",r.name)}return i}function Ur(e){return e.rawName||"".concat(e.name,".").concat(Object.keys(e.modifiers||{}).join("."))}function Ir(e,n,t,r,i){var o=e.def&&e.def[n];if(o)try{o(t.elm,e,t,r,i)}catch(r){Tn(r,t.context,"directive ".concat(e.name," ").concat(n," hook"))}}var zr=[kr,Rr];function Pr(e,n){var t=n.componentOptions;if(!(a(t)&&!1===t.Ctor.options.inheritAttrs||o(e.data.attrs)&&o(n.data.attrs))){var r,i,c=n.elm,l=e.data.attrs||{},u=n.data.attrs||{};for(r in(a(u.__ob__)||s(u._v_attr_proxy))&&(u=n.data.attrs=U({},u)),u)i=u[r],l[r]!==i&&Br(c,r,i,n.data.pre);for(r in(J||ee)&&u.value!==l.value&&Br(c,"value",u.value),l)o(u[r])&&(cr(r)?c.removeAttributeNS(sr,lr(r)):ir(r)||c.removeAttribute(r))}}function Br(e,n,t,r){r||e.tagName.indexOf("-")>-1?$r(e,n,t):ar(n)?ur(t)?e.removeAttribute(n):(t="allowfullscreen"===n&&"EMBED"===e.tagName?"true":n,e.setAttribute(n,t)):ir(n)?e.setAttribute(n,function(e,n){return ur(n)||"false"===n?"false":"contenteditable"===e&&or(n)?n:"true"}(n,t)):cr(n)?ur(t)?e.removeAttributeNS(sr,lr(n)):e.setAttributeNS(sr,n,t):$r(e,n,t)}function $r(e,n,t){if(ur(t))e.removeAttribute(n);else{if(J&&!Q&&"TEXTAREA"===e.tagName&&"placeholder"===n&&""!==t&&!e.__ieph){var r=function(n){n.stopImmediatePropagation(),e.removeEventListener("input",r)};e.addEventListener("input",r),e.__ieph=!0}e.setAttribute(n,t)}}var Mr={create:Pr,update:Pr};function Fr(e,n){var t=n.elm,r=n.data,i=e.data;if(!(o(r.staticClass)&&o(r.class)&&(o(i)||o(i.staticClass)&&o(i.class)))){var s=dr(n),c=t._transitionClasses;a(c)&&(s=pr(s,fr(c))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var Dr,Nr={create:Fr,update:Fr};function Hr(e,n,t){var r=Dr;return function i(){var o=n.apply(null,arguments);null!==o&&Vr(e,i,t,r)}}var qr=Un&&!(re&&Number(re[1])<=53);function Kr(e,n,t,r){if(qr){var i=lt,o=n;n=o._wrapper=function(e){if(e.target===e.currentTarget||e.timeStamp>=i||e.timeStamp<=0||e.target.ownerDocument!==document)return o.apply(this,arguments)}}Dr.addEventListener(e,n,oe?{capture:t,passive:r}:t)}function Vr(e,n,t,r){(r||Dr).removeEventListener(e,n._wrapper||n,t)}function Gr(e,n){if(!o(e.data.on)||!o(n.data.on)){var t=n.data.on||{},r=e.data.on||{};Dr=n.elm||e.elm,function(e){if(a(e.__r)){var n=J?"change":"input";e[n]=[].concat(e.__r,e[n]||[]),delete e.__r}a(e.__c)&&(e.change=[].concat(e.__c,e.change||[]),delete e.__c)}(t),Ge(t,r,Kr,Vr,Hr,n.context),Dr=void 0}}var Xr,Wr={create:Gr,update:Gr,destroy:function(e){return Gr(e,Ar)}};function Zr(e,n){if(!o(e.data.domProps)||!o(n.data.domProps)){var t,r,i=n.elm,c=e.data.domProps||{},l=n.data.domProps||{};for(t in(a(l.__ob__)||s(l._v_attr_proxy))&&(l=n.data.domProps=U({},l)),c)t in l||(i[t]="");for(t in l){if(r=l[t],"textContent"===t||"innerHTML"===t){if(n.children&&(n.children.length=0),r===c[t])continue;1===i.childNodes.length&&i.removeChild(i.childNodes[0])}if("value"===t&&"PROGRESS"!==i.tagName){i._value=r;var u=o(r)?"":String(r);Yr(i,u)&&(i.value=u)}else if("innerHTML"===t&&gr(i.tagName)&&o(i.innerHTML)){(Xr=Xr||document.createElement("div")).innerHTML="<svg>".concat(r,"</svg>");for(var d=Xr.firstChild;i.firstChild;)i.removeChild(i.firstChild);for(;d.firstChild;)i.appendChild(d.firstChild)}else if(r!==c[t])try{i[t]=r}catch(e){}}}}function Yr(e,n){return!e.composing&&("OPTION"===e.tagName||function(e,n){var t=!0;try{t=document.activeElement!==e}catch(e){}return t&&e.value!==n}(e,n)||function(e,n){var t=e.value,r=e._vModifiers;if(a(r)){if(r.number)return b(t)!==b(n);if(r.trim)return t.trim()!==n.trim()}return t!==n}(e,n))}var Jr={create:Zr,update:Zr},Qr=A((function(e){var n={},t=/:(.+)/;return e.split(/;(?![^(]*\))/g).forEach((function(e){if(e){var r=e.split(t);r.length>1&&(n[r[0].trim()]=r[1].trim())}})),n}));function ei(e){var n=ni(e.style);return e.staticStyle?U(e.staticStyle,n):n}function ni(e){return Array.isArray(e)?I(e):"string"==typeof e?Qr(e):e}var ti,ri=/^--/,ii=/\s*!important$/,oi=function(e,n,t){if(ri.test(n))e.style.setProperty(n,t);else if(ii.test(t))e.style.setProperty(S(n),t.replace(ii,""),"important");else{var r=si(n);if(Array.isArray(t))for(var i=0,o=t.length;i<o;i++)e.style[r]=t[i];else e.style[r]=t}},ai=["Webkit","Moz","ms"],si=A((function(e){if(ti=ti||document.createElement("div").style,"filter"!==(e=L(e))&&e in ti)return e;for(var n=e.charAt(0).toUpperCase()+e.slice(1),t=0;t<ai.length;t++){var r=ai[t]+n;if(r in ti)return r}}));function ci(e,n){var t=n.data,r=e.data;if(!(o(t.staticStyle)&&o(t.style)&&o(r.staticStyle)&&o(r.style))){var i,s,c=n.elm,l=r.staticStyle,u=r.normalizedStyle||r.style||{},d=l||u,h=ni(n.data.style)||{};n.data.normalizedStyle=a(h.__ob__)?U({},h):h;var p=function(e,n){var t,r={};if(n)for(var i=e;i.componentInstance;)(i=i.componentInstance._vnode)&&i.data&&(t=ei(i.data))&&U(r,t);(t=ei(e.data))&&U(r,t);for(var o=e;o=o.parent;)o.data&&(t=ei(o.data))&&U(r,t);return r}(n,!0);for(s in d)o(p[s])&&oi(c,s,"");for(s in p)i=p[s],oi(c,s,null==i?"":i)}}var li={create:ci,update:ci},ui=/\s+/;function di(e,n){if(n&&(n=n.trim()))if(e.classList)n.indexOf(" ")>-1?n.split(ui).forEach((function(n){return e.classList.add(n)})):e.classList.add(n);else{var t=" ".concat(e.getAttribute("class")||""," ");t.indexOf(" "+n+" ")<0&&e.setAttribute("class",(t+n).trim())}}function hi(e,n){if(n&&(n=n.trim()))if(e.classList)n.indexOf(" ")>-1?n.split(ui).forEach((function(n){return e.classList.remove(n)})):e.classList.remove(n),e.classList.length||e.removeAttribute("class");else{for(var t=" ".concat(e.getAttribute("class")||""," "),r=" "+n+" ";t.indexOf(r)>=0;)t=t.replace(r," ");(t=t.trim())?e.setAttribute("class",t):e.removeAttribute("class")}}function pi(e){if(e){if("object"==typeof e){var n={};return!1!==e.css&&U(n,fi(e.name||"v")),U(n,e),n}return"string"==typeof e?fi(e):void 0}}var fi=A((function(e){return{enterClass:"".concat(e,"-enter"),enterToClass:"".concat(e,"-enter-to"),enterActiveClass:"".concat(e,"-enter-active"),leaveClass:"".concat(e,"-leave"),leaveToClass:"".concat(e,"-leave-to"),leaveActiveClass:"".concat(e,"-leave-active")}})),mi=Z&&!Q,vi="transition",gi="transitionend",yi="animation",bi="animationend";mi&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(vi="WebkitTransition",gi="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(yi="WebkitAnimation",bi="webkitAnimationEnd"));var _i=Z?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(e){return e()};function xi(e){_i((function(){_i(e)}))}function ki(e,n){var t=e._transitionClasses||(e._transitionClasses=[]);t.indexOf(n)<0&&(t.push(n),di(e,n))}function Ei(e,n){e._transitionClasses&&k(e._transitionClasses,n),hi(e,n)}function wi(e,n,t){var r=Ci(e,n),i=r.type,o=r.timeout,a=r.propCount;if(!i)return t();var s="transition"===i?gi:bi,c=0,l=function(){e.removeEventListener(s,u),t()},u=function(n){n.target===e&&++c>=a&&l()};setTimeout((function(){c<a&&l()}),o+1),e.addEventListener(s,u)}var Ai=/\b(transform|all)(,|$)/;function Ci(e,n){var t,r=window.getComputedStyle(e),i=(r[vi+"Delay"]||"").split(", "),o=(r[vi+"Duration"]||"").split(", "),a=Li(i,o),s=(r[yi+"Delay"]||"").split(", "),c=(r[yi+"Duration"]||"").split(", "),l=Li(s,c),u=0,d=0;return"transition"===n?a>0&&(t="transition",u=a,d=o.length):"animation"===n?l>0&&(t="animation",u=l,d=c.length):d=(t=(u=Math.max(a,l))>0?a>l?"transition":"animation":null)?"transition"===t?o.length:c.length:0,{type:t,timeout:u,propCount:d,hasTransform:"transition"===t&&Ai.test(r[vi+"Property"])}}function Li(e,n){for(;e.length<n.length;)e=e.concat(e);return Math.max.apply(null,n.map((function(n,t){return Ti(n)+Ti(e[t])})))}function Ti(e){return 1e3*Number(e.slice(0,-1).replace(",","."))}function Ri(e,n){var t=e.elm;a(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var r=pi(e.data.transition);if(!o(r)&&!a(t._enterCb)&&1===t.nodeType){for(var i=r.css,s=r.type,c=r.enterClass,d=r.enterToClass,h=r.enterActiveClass,p=r.appearClass,f=r.appearToClass,m=r.appearActiveClass,v=r.beforeEnter,g=r.enter,y=r.afterEnter,_=r.enterCancelled,x=r.beforeAppear,k=r.appear,E=r.afterAppear,w=r.appearCancelled,A=r.duration,C=Jn,L=Jn.$vnode;L&&L.parent;)C=L.context,L=L.parent;var T=!C._isMounted||!e.isRootInsert;if(!T||k||""===k){var R=T&&p?p:c,S=T&&m?m:h,O=T&&f?f:d,j=T&&x||v,U=T&&l(k)?k:g,I=T&&E||y,z=T&&w||_,P=b(u(A)?A.enter:A);0;var B=!1!==i&&!Q,$=ji(U),M=t._enterCb=F((function(){B&&(Ei(t,O),Ei(t,S)),M.cancelled?(B&&Ei(t,R),z&&z(t)):I&&I(t),t._enterCb=null}));e.data.show||Xe(e,"insert",(function(){var n=t.parentNode,r=n&&n._pending&&n._pending[e.key];r&&r.tag===e.tag&&r.elm._leaveCb&&r.elm._leaveCb(),U&&U(t,M)})),j&&j(t),B&&(ki(t,R),ki(t,S),xi((function(){Ei(t,R),M.cancelled||(ki(t,O),$||(Oi(P)?setTimeout(M,P):wi(t,s,M)))}))),e.data.show&&(n&&n(),U&&U(t,M)),B||$||M()}}}function Si(e,n){var t=e.elm;a(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var r=pi(e.data.transition);if(o(r)||1!==t.nodeType)return n();if(!a(t._leaveCb)){var i=r.css,s=r.type,c=r.leaveClass,l=r.leaveToClass,d=r.leaveActiveClass,h=r.beforeLeave,p=r.leave,f=r.afterLeave,m=r.leaveCancelled,v=r.delayLeave,g=r.duration,y=!1!==i&&!Q,_=ji(p),x=b(u(g)?g.leave:g);0;var k=t._leaveCb=F((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[e.key]=null),y&&(Ei(t,l),Ei(t,d)),k.cancelled?(y&&Ei(t,c),m&&m(t)):(n(),f&&f(t)),t._leaveCb=null}));v?v(E):E()}function E(){k.cancelled||(!e.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[e.key]=e),h&&h(t),y&&(ki(t,c),ki(t,d),xi((function(){Ei(t,c),k.cancelled||(ki(t,l),_||(Oi(x)?setTimeout(k,x):wi(t,s,k)))}))),p&&p(t,k),y||_||k())}}function Oi(e){return"number"==typeof e&&!isNaN(e)}function ji(e){if(o(e))return!1;var n=e.fns;return a(n)?ji(Array.isArray(n)?n[0]:n):(e._length||e.length)>1}function Ui(e,n){!0!==n.data.show&&Ri(n)}var Ii=function(e){var n,t,r={},l=e.modules,u=e.nodeOps;for(n=0;n<Cr.length;++n)for(r[Cr[n]]=[],t=0;t<l.length;++t)a(l[t][Cr[n]])&&r[Cr[n]].push(l[t][Cr[n]]);function d(e){var n=u.parentNode(e);a(n)&&u.removeChild(n,e)}function h(e,n,t,i,o,c,l){if(a(e.elm)&&a(c)&&(e=c[l]=ge(e)),e.isRootInsert=!o,!function(e,n,t,i){var o=e.data;if(a(o)){var c=a(e.componentInstance)&&o.keepAlive;if(a(o=o.hook)&&a(o=o.init)&&o(e,!1),a(e.componentInstance))return p(e,n),f(t,e.elm,i),s(c)&&function(e,n,t,i){var o,s=e;for(;s.componentInstance;)if(s=s.componentInstance._vnode,a(o=s.data)&&a(o=o.transition)){for(o=0;o<r.activate.length;++o)r.activate[o](Ar,s);n.push(s);break}f(t,e.elm,i)}(e,n,t,i),!0}}(e,n,t,i)){var d=e.data,h=e.children,v=e.tag;a(v)?(e.elm=e.ns?u.createElementNS(e.ns,v):u.createElement(v,e),y(e),m(e,h,n),a(d)&&g(e,n),f(t,e.elm,i)):s(e.isComment)?(e.elm=u.createComment(e.text),f(t,e.elm,i)):(e.elm=u.createTextNode(e.text),f(t,e.elm,i))}}function p(e,n){a(e.data.pendingInsert)&&(n.push.apply(n,e.data.pendingInsert),e.data.pendingInsert=null),e.elm=e.componentInstance.$el,v(e)?(g(e,n),y(e)):(Er(e),n.push(e))}function f(e,n,t){a(e)&&(a(t)?u.parentNode(t)===e&&u.insertBefore(e,n,t):u.appendChild(e,n))}function m(e,n,t){if(i(n)){0;for(var r=0;r<n.length;++r)h(n[r],t,e.elm,null,!0,n,r)}else c(e.text)&&u.appendChild(e.elm,u.createTextNode(String(e.text)))}function v(e){for(;e.componentInstance;)e=e.componentInstance._vnode;return a(e.tag)}function g(e,t){for(var i=0;i<r.create.length;++i)r.create[i](Ar,e);a(n=e.data.hook)&&(a(n.create)&&n.create(Ar,e),a(n.insert)&&t.push(e))}function y(e){var n;if(a(n=e.fnScopeId))u.setStyleScope(e.elm,n);else for(var t=e;t;)a(n=t.context)&&a(n=n.$options._scopeId)&&u.setStyleScope(e.elm,n),t=t.parent;a(n=Jn)&&n!==e.context&&n!==e.fnContext&&a(n=n.$options._scopeId)&&u.setStyleScope(e.elm,n)}function b(e,n,t,r,i,o){for(;r<=i;++r)h(t[r],o,e,n,!1,t,r)}function x(e){var n,t,i=e.data;if(a(i))for(a(n=i.hook)&&a(n=n.destroy)&&n(e),n=0;n<r.destroy.length;++n)r.destroy[n](e);if(a(n=e.children))for(t=0;t<e.children.length;++t)x(e.children[t])}function k(e,n,t){for(;n<=t;++n){var r=e[n];a(r)&&(a(r.tag)?(E(r),x(r)):d(r.elm))}}function E(e,n){if(a(n)||a(e.data)){var t,i=r.remove.length+1;for(a(n)?n.listeners+=i:n=function(e,n){function t(){0==--t.listeners&&d(e)}return t.listeners=n,t}(e.elm,i),a(t=e.componentInstance)&&a(t=t._vnode)&&a(t.data)&&E(t,n),t=0;t<r.remove.length;++t)r.remove[t](e,n);a(t=e.data.hook)&&a(t=t.remove)?t(e,n):n()}else d(e.elm)}function w(e,n,t,r){for(var i=t;i<r;i++){var o=n[i];if(a(o)&&Lr(e,o))return i}}function A(e,n,t,i,c,l){if(e!==n){a(n.elm)&&a(i)&&(n=i[c]=ge(n));var d=n.elm=e.elm;if(s(e.isAsyncPlaceholder))a(n.asyncFactory.resolved)?T(e.elm,n,t):n.isAsyncPlaceholder=!0;else if(s(n.isStatic)&&s(e.isStatic)&&n.key===e.key&&(s(n.isCloned)||s(n.isOnce)))n.componentInstance=e.componentInstance;else{var p,f=n.data;a(f)&&a(p=f.hook)&&a(p=p.prepatch)&&p(e,n);var m=e.children,g=n.children;if(a(f)&&v(n)){for(p=0;p<r.update.length;++p)r.update[p](e,n);a(p=f.hook)&&a(p=p.update)&&p(e,n)}o(n.text)?a(m)&&a(g)?m!==g&&function(e,n,t,r,i){var s,c,l,d=0,p=0,f=n.length-1,m=n[0],v=n[f],g=t.length-1,y=t[0],_=t[g],x=!i;for(0;d<=f&&p<=g;)o(m)?m=n[++d]:o(v)?v=n[--f]:Lr(m,y)?(A(m,y,r,t,p),m=n[++d],y=t[++p]):Lr(v,_)?(A(v,_,r,t,g),v=n[--f],_=t[--g]):Lr(m,_)?(A(m,_,r,t,g),x&&u.insertBefore(e,m.elm,u.nextSibling(v.elm)),m=n[++d],_=t[--g]):Lr(v,y)?(A(v,y,r,t,p),x&&u.insertBefore(e,v.elm,m.elm),v=n[--f],y=t[++p]):(o(s)&&(s=Tr(n,d,f)),o(c=a(y.key)?s[y.key]:w(y,n,d,f))?h(y,r,e,m.elm,!1,t,p):Lr(l=n[c],y)?(A(l,y,r,t,p),n[c]=void 0,x&&u.insertBefore(e,l.elm,m.elm)):h(y,r,e,m.elm,!1,t,p),y=t[++p]);d>f?b(e,o(t[g+1])?null:t[g+1].elm,t,p,g,r):p>g&&k(n,d,f)}(d,m,g,t,l):a(g)?(a(e.text)&&u.setTextContent(d,""),b(d,null,g,0,g.length-1,t)):a(m)?k(m,0,m.length-1):a(e.text)&&u.setTextContent(d,""):e.text!==n.text&&u.setTextContent(d,n.text),a(f)&&a(p=f.hook)&&a(p=p.postpatch)&&p(e,n)}}}function C(e,n,t){if(s(t)&&a(e.parent))e.parent.data.pendingInsert=n;else for(var r=0;r<n.length;++r)n[r].data.hook.insert(n[r])}var L=_("attrs,class,staticClass,staticStyle,key");function T(e,n,t,r){var i,o=n.tag,c=n.data,l=n.children;if(r=r||c&&c.pre,n.elm=e,s(n.isComment)&&a(n.asyncFactory))return n.isAsyncPlaceholder=!0,!0;if(a(c)&&(a(i=c.hook)&&a(i=i.init)&&i(n,!0),a(i=n.componentInstance)))return p(n,t),!0;if(a(o)){if(a(l))if(e.hasChildNodes())if(a(i=c)&&a(i=i.domProps)&&a(i=i.innerHTML)){if(i!==e.innerHTML)return!1}else{for(var u=!0,d=e.firstChild,h=0;h<l.length;h++){if(!d||!T(d,l[h],t,r)){u=!1;break}d=d.nextSibling}if(!u||d)return!1}else m(n,l,t);if(a(c)){var f=!1;for(var v in c)if(!L(v)){f=!0,g(n,t);break}!f&&c.class&&qn(c.class)}}else e.data!==n.text&&(e.data=n.text);return!0}return function(e,n,t,i){if(!o(n)){var c,l=!1,d=[];if(o(e))l=!0,h(n,d);else{var p=a(e.nodeType);if(!p&&Lr(e,n))A(e,n,d,null,null,i);else{if(p){if(1===e.nodeType&&e.hasAttribute("data-server-rendered")&&(e.removeAttribute("data-server-rendered"),t=!0),s(t)&&T(e,n,d))return C(n,d,!0),e;c=e,e=new fe(u.tagName(c).toLowerCase(),{},[],void 0,c)}var f=e.elm,m=u.parentNode(f);if(h(n,d,f._leaveCb?null:m,u.nextSibling(f)),a(n.parent))for(var g=n.parent,y=v(n);g;){for(var b=0;b<r.destroy.length;++b)r.destroy[b](g);if(g.elm=n.elm,y){for(var _=0;_<r.create.length;++_)r.create[_](Ar,g);var E=g.data.hook.insert;if(E.merged)for(var w=E.fns.slice(1),L=0;L<w.length;L++)w[L]()}else Er(g);g=g.parent}a(m)?k([e],0,0):a(e.tag)&&x(e)}}return C(n,d,l),n.elm}a(e)&&x(e)}}({nodeOps:xr,modules:[Mr,Nr,Wr,Jr,li,Z?{create:Ui,activate:Ui,remove:function(e,n){!0!==e.data.show?Si(e,n):n()}}:{}].concat(zr)});Q&&document.addEventListener("selectionchange",(function(){var e=document.activeElement;e&&e.vmodel&&Ni(e,"input")}));var zi={inserted:function(e,n,t,r){"select"===t.tag?(r.elm&&!r.elm._vOptions?Xe(t,"postpatch",(function(){zi.componentUpdated(e,n,t)})):Pi(e,n,t.context),e._vOptions=[].map.call(e.options,Mi)):("textarea"===t.tag||_r(e.type))&&(e._vModifiers=n.modifiers,n.modifiers.lazy||(e.addEventListener("compositionstart",Fi),e.addEventListener("compositionend",Di),e.addEventListener("change",Di),Q&&(e.vmodel=!0)))},componentUpdated:function(e,n,t){if("select"===t.tag){Pi(e,n,t.context);var r=e._vOptions,i=e._vOptions=[].map.call(e.options,Mi);if(i.some((function(e,n){return!$(e,r[n])})))(e.multiple?n.value.some((function(e){return $i(e,i)})):n.value!==n.oldValue&&$i(n.value,i))&&Ni(e,"change")}}};function Pi(e,n,t){Bi(e,n,t),(J||ee)&&setTimeout((function(){Bi(e,n,t)}),0)}function Bi(e,n,t){var r=n.value,i=e.multiple;if(!i||Array.isArray(r)){for(var o,a,s=0,c=e.options.length;s<c;s++)if(a=e.options[s],i)o=M(r,Mi(a))>-1,a.selected!==o&&(a.selected=o);else if($(Mi(a),r))return void(e.selectedIndex!==s&&(e.selectedIndex=s));i||(e.selectedIndex=-1)}}function $i(e,n){return n.every((function(n){return!$(n,e)}))}function Mi(e){return"_value"in e?e._value:e.value}function Fi(e){e.target.composing=!0}function Di(e){e.target.composing&&(e.target.composing=!1,Ni(e.target,"input"))}function Ni(e,n){var t=document.createEvent("HTMLEvents");t.initEvent(n,!0,!0),e.dispatchEvent(t)}function Hi(e){return!e.componentInstance||e.data&&e.data.transition?e:Hi(e.componentInstance._vnode)}var qi={model:zi,show:{bind:function(e,n,t){var r=n.value,i=(t=Hi(t)).data&&t.data.transition,o=e.__vOriginalDisplay="none"===e.style.display?"":e.style.display;r&&i?(t.data.show=!0,Ri(t,(function(){e.style.display=o}))):e.style.display=r?o:"none"},update:function(e,n,t){var r=n.value;!r!=!n.oldValue&&((t=Hi(t)).data&&t.data.transition?(t.data.show=!0,r?Ri(t,(function(){e.style.display=e.__vOriginalDisplay})):Si(t,(function(){e.style.display="none"}))):e.style.display=r?e.__vOriginalDisplay:"none")},unbind:function(e,n,t,r,i){i||(e.style.display=e.__vOriginalDisplay)}}},Ki={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function Vi(e){var n=e&&e.componentOptions;return n&&n.Ctor.options.abstract?Vi(Cn(n.children)):e}function Gi(e){var n={},t=e.$options;for(var r in t.propsData)n[r]=e[r];var i=t._parentListeners;for(var r in i)n[L(r)]=i[r];return n}function Xi(e,n){if(/\d-keep-alive$/.test(n.tag))return e("keep-alive",{props:n.componentOptions.propsData})}var Wi=function(e){return e.tag||vn(e)},Zi=function(e){return"show"===e.name},Yi={name:"transition",props:Ki,abstract:!0,render:function(e){var n=this,t=this.$slots.default;if(t&&(t=t.filter(Wi)).length){0;var r=this.mode;0;var i=t[0];if(function(e){for(;e=e.parent;)if(e.data.transition)return!0}(this.$vnode))return i;var o=Vi(i);if(!o)return i;if(this._leaving)return Xi(e,i);var a="__transition-".concat(this._uid,"-");o.key=null==o.key?o.isComment?a+"comment":a+o.tag:c(o.key)?0===String(o.key).indexOf(a)?o.key:a+o.key:o.key;var s=(o.data||(o.data={})).transition=Gi(this),l=this._vnode,u=Vi(l);if(o.data.directives&&o.data.directives.some(Zi)&&(o.data.show=!0),u&&u.data&&!function(e,n){return n.key===e.key&&n.tag===e.tag}(o,u)&&!vn(u)&&(!u.componentInstance||!u.componentInstance._vnode.isComment)){var d=u.data.transition=U({},s);if("out-in"===r)return this._leaving=!0,Xe(d,"afterLeave",(function(){n._leaving=!1,n.$forceUpdate()})),Xi(e,i);if("in-out"===r){if(vn(o))return l;var h,p=function(){h()};Xe(s,"afterEnter",p),Xe(s,"enterCancelled",p),Xe(d,"delayLeave",(function(e){h=e}))}}return i}}},Ji=U({tag:String,moveClass:String},Ki);function Qi(e){e.elm._moveCb&&e.elm._moveCb(),e.elm._enterCb&&e.elm._enterCb()}function eo(e){e.data.newPos=e.elm.getBoundingClientRect()}function no(e){var n=e.data.pos,t=e.data.newPos,r=n.left-t.left,i=n.top-t.top;if(r||i){e.data.moved=!0;var o=e.elm.style;o.transform=o.WebkitTransform="translate(".concat(r,"px,").concat(i,"px)"),o.transitionDuration="0s"}}delete Ji.mode;var to={Transition:Yi,TransitionGroup:{props:Ji,beforeMount:function(){var e=this,n=this._update;this._update=function(t,r){var i=Qn(e);e.__patch__(e._vnode,e.kept,!1,!0),e._vnode=e.kept,i(),n.call(e,t,r)}},render:function(e){for(var n=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),r=this.prevChildren=this.children,i=this.$slots.default||[],o=this.children=[],a=Gi(this),s=0;s<i.length;s++){if((u=i[s]).tag)if(null!=u.key&&0!==String(u.key).indexOf("__vlist"))o.push(u),t[u.key]=u,(u.data||(u.data={})).transition=a;else;}if(r){var c=[],l=[];for(s=0;s<r.length;s++){var u;(u=r[s]).data.transition=a,u.data.pos=u.elm.getBoundingClientRect(),t[u.key]?c.push(u):l.push(u)}this.kept=e(n,null,c),this.removed=l}return e(n,null,o)},updated:function(){var e=this.prevChildren,n=this.moveClass||(this.name||"v")+"-move";e.length&&this.hasMove(e[0].elm,n)&&(e.forEach(Qi),e.forEach(eo),e.forEach(no),this._reflow=document.body.offsetHeight,e.forEach((function(e){if(e.data.moved){var t=e.elm,r=t.style;ki(t,n),r.transform=r.WebkitTransform=r.transitionDuration="",t.addEventListener(gi,t._moveCb=function e(r){r&&r.target!==t||r&&!/transform$/.test(r.propertyName)||(t.removeEventListener(gi,e),t._moveCb=null,Ei(t,n))})}})))},methods:{hasMove:function(e,n){if(!mi)return!1;if(this._hasMove)return this._hasMove;var t=e.cloneNode();e._transitionClasses&&e._transitionClasses.forEach((function(e){hi(t,e)})),di(t,n),t.style.display="none",this.$el.appendChild(t);var r=Ci(t);return this.$el.removeChild(t),this._hasMove=r.hasTransform}}}};function ro(e,n){for(var t in n)e[t]=n[t];return e}Xt.config.mustUseProp=function(e,n,t){return"value"===t&&rr(e)&&"button"!==n||"selected"===t&&"option"===e||"checked"===t&&"input"===e||"muted"===t&&"video"===e},Xt.config.isReservedTag=yr,Xt.config.isReservedAttr=tr,Xt.config.getTagNamespace=function(e){return gr(e)?"svg":"math"===e?"math":void 0},Xt.config.isUnknownElement=function(e){if(!Z)return!0;if(yr(e))return!1;if(e=e.toLowerCase(),null!=br[e])return br[e];var n=document.createElement(e);return e.indexOf("-")>-1?br[e]=n.constructor===window.HTMLUnknownElement||n.constructor===window.HTMLElement:br[e]=/HTMLUnknownElement/.test(n.toString())},U(Xt.options.directives,qi),U(Xt.options.components,to),Xt.prototype.__patch__=Z?Ii:z,Xt.prototype.$mount=function(e,n){return function(e,n,t){var r;e.$el=n,e.$options.render||(e.$options.render=me),tt(e,"beforeMount"),r=function(){e._update(e._render(),t)},new Gn(e,r,z,{before:function(){e._isMounted&&!e._isDestroyed&&tt(e,"beforeUpdate")}},!0),t=!1;var i=e._preWatchers;if(i)for(var o=0;o<i.length;o++)i[o].run();return null==e.$vnode&&(e._isMounted=!0,tt(e,"mounted")),e}(this,e=e&&Z?function(e){if("string"==typeof e){var n=document.querySelector(e);return n||document.createElement("div")}return e}(e):void 0,n)},Z&&setTimeout((function(){q.devtools&&ce&&ce.emit("init",Xt)}),0);var io=/[!'()*]/g,oo=function(e){return"%"+e.charCodeAt(0).toString(16)},ao=/%2C/g,so=function(e){return encodeURIComponent(e).replace(io,oo).replace(ao,",")};function co(e){try{return decodeURIComponent(e)}catch(e){0}return e}var lo=function(e){return null==e||"object"==typeof e?e:String(e)};function uo(e){var n={};return(e=e.trim().replace(/^(\?|#|&)/,""))?(e.split("&").forEach((function(e){var t=e.replace(/\+/g," ").split("="),r=co(t.shift()),i=t.length>0?co(t.join("=")):null;void 0===n[r]?n[r]=i:Array.isArray(n[r])?n[r].push(i):n[r]=[n[r],i]})),n):n}function ho(e){var n=e?Object.keys(e).map((function(n){var t=e[n];if(void 0===t)return"";if(null===t)return so(n);if(Array.isArray(t)){var r=[];return t.forEach((function(e){void 0!==e&&(null===e?r.push(so(n)):r.push(so(n)+"="+so(e)))})),r.join("&")}return so(n)+"="+so(t)})).filter((function(e){return e.length>0})).join("&"):null;return n?"?"+n:""}var po=/\/?$/;function fo(e,n,t,r){var i=r&&r.options.stringifyQuery,o=n.query||{};try{o=mo(o)}catch(e){}var a={name:n.name||e&&e.name,meta:e&&e.meta||{},path:n.path||"/",hash:n.hash||"",query:o,params:n.params||{},fullPath:yo(n,i),matched:e?go(e):[]};return t&&(a.redirectedFrom=yo(t,i)),Object.freeze(a)}function mo(e){if(Array.isArray(e))return e.map(mo);if(e&&"object"==typeof e){var n={};for(var t in e)n[t]=mo(e[t]);return n}return e}var vo=fo(null,{path:"/"});function go(e){for(var n=[];e;)n.unshift(e),e=e.parent;return n}function yo(e,n){var t=e.path,r=e.query;void 0===r&&(r={});var i=e.hash;return void 0===i&&(i=""),(t||"/")+(n||ho)(r)+i}function bo(e,n,t){return n===vo?e===n:!!n&&(e.path&&n.path?e.path.replace(po,"")===n.path.replace(po,"")&&(t||e.hash===n.hash&&_o(e.query,n.query)):!(!e.name||!n.name)&&(e.name===n.name&&(t||e.hash===n.hash&&_o(e.query,n.query)&&_o(e.params,n.params))))}function _o(e,n){if(void 0===e&&(e={}),void 0===n&&(n={}),!e||!n)return e===n;var t=Object.keys(e).sort(),r=Object.keys(n).sort();return t.length===r.length&&t.every((function(t,i){var o=e[t];if(r[i]!==t)return!1;var a=n[t];return null==o||null==a?o===a:"object"==typeof o&&"object"==typeof a?_o(o,a):String(o)===String(a)}))}function xo(e){for(var n=0;n<e.matched.length;n++){var t=e.matched[n];for(var r in t.instances){var i=t.instances[r],o=t.enteredCbs[r];if(i&&o){delete t.enteredCbs[r];for(var a=0;a<o.length;a++)i._isBeingDestroyed||o[a](i)}}}}var ko={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(e,n){var t=n.props,r=n.children,i=n.parent,o=n.data;o.routerView=!0;for(var a=i.$createElement,s=t.name,c=i.$route,l=i._routerViewCache||(i._routerViewCache={}),u=0,d=!1;i&&i._routerRoot!==i;){var h=i.$vnode?i.$vnode.data:{};h.routerView&&u++,h.keepAlive&&i._directInactive&&i._inactive&&(d=!0),i=i.$parent}if(o.routerViewDepth=u,d){var p=l[s],f=p&&p.component;return f?(p.configProps&&Eo(f,o,p.route,p.configProps),a(f,o,r)):a()}var m=c.matched[u],v=m&&m.components[s];if(!m||!v)return l[s]=null,a();l[s]={component:v},o.registerRouteInstance=function(e,n){var t=m.instances[s];(n&&t!==e||!n&&t===e)&&(m.instances[s]=n)},(o.hook||(o.hook={})).prepatch=function(e,n){m.instances[s]=n.componentInstance},o.hook.init=function(e){e.data.keepAlive&&e.componentInstance&&e.componentInstance!==m.instances[s]&&(m.instances[s]=e.componentInstance),xo(c)};var g=m.props&&m.props[s];return g&&(ro(l[s],{route:c,configProps:g}),Eo(v,o,c,g)),a(v,o,r)}};function Eo(e,n,t,r){var i=n.props=function(e,n){switch(typeof n){case"undefined":return;case"object":return n;case"function":return n(e);case"boolean":return n?e.params:void 0;default:0}}(t,r);if(i){i=n.props=ro({},i);var o=n.attrs=n.attrs||{};for(var a in i)e.props&&a in e.props||(o[a]=i[a],delete i[a])}}function wo(e,n,t){var r=e.charAt(0);if("/"===r)return e;if("?"===r||"#"===r)return n+e;var i=n.split("/");t&&i[i.length-1]||i.pop();for(var o=e.replace(/^\//,"").split("/"),a=0;a<o.length;a++){var s=o[a];".."===s?i.pop():"."!==s&&i.push(s)}return""!==i[0]&&i.unshift(""),i.join("/")}function Ao(e){return e.replace(/\/(?:\s*\/)+/g,"/")}var Co=Array.isArray||function(e){return"[object Array]"==Object.prototype.toString.call(e)},Lo=Do,To=Uo,Ro=function(e,n){return zo(Uo(e,n),n)},So=zo,Oo=Fo,jo=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Uo(e,n){for(var t,r=[],i=0,o=0,a="",s=n&&n.delimiter||"/";null!=(t=jo.exec(e));){var c=t[0],l=t[1],u=t.index;if(a+=e.slice(o,u),o=u+c.length,l)a+=l[1];else{var d=e[o],h=t[2],p=t[3],f=t[4],m=t[5],v=t[6],g=t[7];a&&(r.push(a),a="");var y=null!=h&&null!=d&&d!==h,b="+"===v||"*"===v,_="?"===v||"*"===v,x=t[2]||s,k=f||m;r.push({name:p||i++,prefix:h||"",delimiter:x,optional:_,repeat:b,partial:y,asterisk:!!g,pattern:k?Bo(k):g?".*":"[^"+Po(x)+"]+?"})}}return o<e.length&&(a+=e.substr(o)),a&&r.push(a),r}function Io(e){return encodeURI(e).replace(/[\/?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()}))}function zo(e,n){for(var t=new Array(e.length),r=0;r<e.length;r++)"object"==typeof e[r]&&(t[r]=new RegExp("^(?:"+e[r].pattern+")$",Mo(n)));return function(n,r){for(var i="",o=n||{},a=(r||{}).pretty?Io:encodeURIComponent,s=0;s<e.length;s++){var c=e[s];if("string"!=typeof c){var l,u=o[c.name];if(null==u){if(c.optional){c.partial&&(i+=c.prefix);continue}throw new TypeError('Expected "'+c.name+'" to be defined')}if(Co(u)){if(!c.repeat)throw new TypeError('Expected "'+c.name+'" to not repeat, but received `'+JSON.stringify(u)+"`");if(0===u.length){if(c.optional)continue;throw new TypeError('Expected "'+c.name+'" to not be empty')}for(var d=0;d<u.length;d++){if(l=a(u[d]),!t[s].test(l))throw new TypeError('Expected all "'+c.name+'" to match "'+c.pattern+'", but received `'+JSON.stringify(l)+"`");i+=(0===d?c.prefix:c.delimiter)+l}}else{if(l=c.asterisk?encodeURI(u).replace(/[?#]/g,(function(e){return"%"+e.charCodeAt(0).toString(16).toUpperCase()})):a(u),!t[s].test(l))throw new TypeError('Expected "'+c.name+'" to match "'+c.pattern+'", but received "'+l+'"');i+=c.prefix+l}}else i+=c}return i}}function Po(e){return e.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Bo(e){return e.replace(/([=!:$\/()])/g,"\\$1")}function $o(e,n){return e.keys=n,e}function Mo(e){return e&&e.sensitive?"":"i"}function Fo(e,n,t){Co(n)||(t=n||t,n=[]);for(var r=(t=t||{}).strict,i=!1!==t.end,o="",a=0;a<e.length;a++){var s=e[a];if("string"==typeof s)o+=Po(s);else{var c=Po(s.prefix),l="(?:"+s.pattern+")";n.push(s),s.repeat&&(l+="(?:"+c+l+")*"),o+=l=s.optional?s.partial?c+"("+l+")?":"(?:"+c+"("+l+"))?":c+"("+l+")"}}var u=Po(t.delimiter||"/"),d=o.slice(-u.length)===u;return r||(o=(d?o.slice(0,-u.length):o)+"(?:"+u+"(?=$))?"),o+=i?"$":r&&d?"":"(?="+u+"|$)",$o(new RegExp("^"+o,Mo(t)),n)}function Do(e,n,t){return Co(n)||(t=n||t,n=[]),t=t||{},e instanceof RegExp?function(e,n){var t=e.source.match(/\((?!\?)/g);if(t)for(var r=0;r<t.length;r++)n.push({name:r,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return $o(e,n)}(e,n):Co(e)?function(e,n,t){for(var r=[],i=0;i<e.length;i++)r.push(Do(e[i],n,t).source);return $o(new RegExp("(?:"+r.join("|")+")",Mo(t)),n)}(e,n,t):function(e,n,t){return Fo(Uo(e,t),n,t)}(e,n,t)}Lo.parse=To,Lo.compile=Ro,Lo.tokensToFunction=So,Lo.tokensToRegExp=Oo;var No=Object.create(null);function Ho(e,n,t){n=n||{};try{var r=No[e]||(No[e]=Lo.compile(e));return"string"==typeof n.pathMatch&&(n[0]=n.pathMatch),r(n,{pretty:!0})}catch(e){return""}finally{delete n[0]}}function qo(e,n,t,r){var i="string"==typeof e?{path:e}:e;if(i._normalized)return i;if(i.name){var o=(i=ro({},e)).params;return o&&"object"==typeof o&&(i.params=ro({},o)),i}if(!i.path&&i.params&&n){(i=ro({},i))._normalized=!0;var a=ro(ro({},n.params),i.params);if(n.name)i.name=n.name,i.params=a;else if(n.matched.length){var s=n.matched[n.matched.length-1].path;i.path=Ho(s,a,n.path)}else 0;return i}var c=function(e){var n="",t="",r=e.indexOf("#");r>=0&&(n=e.slice(r),e=e.slice(0,r));var i=e.indexOf("?");return i>=0&&(t=e.slice(i+1),e=e.slice(0,i)),{path:e,query:t,hash:n}}(i.path||""),l=n&&n.path||"/",u=c.path?wo(c.path,l,t||i.append):l,d=function(e,n,t){void 0===n&&(n={});var r,i=t||uo;try{r=i(e||"")}catch(e){r={}}for(var o in n){var a=n[o];r[o]=Array.isArray(a)?a.map(lo):lo(a)}return r}(c.query,i.query,r&&r.options.parseQuery),h=i.hash||c.hash;return h&&"#"!==h.charAt(0)&&(h="#"+h),{_normalized:!0,path:u,query:d,hash:h}}var Ko,Vo=function(){},Go={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(e){var n=this,t=this.$router,r=this.$route,i=t.resolve(this.to,r,this.append),o=i.location,a=i.route,s=i.href,c={},l=t.options.linkActiveClass,u=t.options.linkExactActiveClass,d=null==l?"router-link-active":l,h=null==u?"router-link-exact-active":u,p=null==this.activeClass?d:this.activeClass,f=null==this.exactActiveClass?h:this.exactActiveClass,m=a.redirectedFrom?fo(null,qo(a.redirectedFrom),null,t):a;c[f]=bo(r,m,this.exactPath),c[p]=this.exact||this.exactPath?c[f]:function(e,n){return 0===e.path.replace(po,"/").indexOf(n.path.replace(po,"/"))&&(!n.hash||e.hash===n.hash)&&function(e,n){for(var t in n)if(!(t in e))return!1;return!0}(e.query,n.query)}(r,m);var v=c[f]?this.ariaCurrentValue:null,g=function(e){Xo(e)&&(n.replace?t.replace(o,Vo):t.push(o,Vo))},y={click:Xo};Array.isArray(this.event)?this.event.forEach((function(e){y[e]=g})):y[this.event]=g;var b={class:c},_=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:a,navigate:g,isActive:c[p],isExactActive:c[f]});if(_){if(1===_.length)return _[0];if(_.length>1||!_.length)return 0===_.length?e():e("span",{},_)}if("a"===this.tag)b.on=y,b.attrs={href:s,"aria-current":v};else{var x=function e(n){var t;if(n)for(var r=0;r<n.length;r++){if("a"===(t=n[r]).tag)return t;if(t.children&&(t=e(t.children)))return t}}(this.$slots.default);if(x){x.isStatic=!1;var k=x.data=ro({},x.data);for(var E in k.on=k.on||{},k.on){var w=k.on[E];E in y&&(k.on[E]=Array.isArray(w)?w:[w])}for(var A in y)A in k.on?k.on[A].push(y[A]):k.on[A]=g;var C=x.data.attrs=ro({},x.data.attrs);C.href=s,C["aria-current"]=v}else b.on=y}return e(this.tag,b,this.$slots.default)}};function Xo(e){if(!(e.metaKey||e.altKey||e.ctrlKey||e.shiftKey||e.defaultPrevented||void 0!==e.button&&0!==e.button)){if(e.currentTarget&&e.currentTarget.getAttribute){var n=e.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(n))return}return e.preventDefault&&e.preventDefault(),!0}}var Wo="undefined"!=typeof window;function Zo(e,n,t,r,i){var o=n||[],a=t||Object.create(null),s=r||Object.create(null);e.forEach((function(e){!function e(n,t,r,i,o,a){var s=i.path,c=i.name;0;var l=i.pathToRegexpOptions||{},u=function(e,n,t){t||(e=e.replace(/\/$/,""));if("/"===e[0])return e;if(null==n)return e;return Ao(n.path+"/"+e)}(s,o,l.strict);"boolean"==typeof i.caseSensitive&&(l.sensitive=i.caseSensitive);var d={path:u,regex:Yo(u,l),components:i.components||{default:i.component},alias:i.alias?"string"==typeof i.alias?[i.alias]:i.alias:[],instances:{},enteredCbs:{},name:c,parent:o,matchAs:a,redirect:i.redirect,beforeEnter:i.beforeEnter,meta:i.meta||{},props:null==i.props?{}:i.components?i.props:{default:i.props}};i.children&&i.children.forEach((function(i){var o=a?Ao(a+"/"+i.path):void 0;e(n,t,r,i,d,o)}));t[d.path]||(n.push(d.path),t[d.path]=d);if(void 0!==i.alias)for(var h=Array.isArray(i.alias)?i.alias:[i.alias],p=0;p<h.length;++p){0;var f={path:h[p],children:i.children};e(n,t,r,f,o,d.path||"/")}c&&(r[c]||(r[c]=d))}(o,a,s,e,i)}));for(var c=0,l=o.length;c<l;c++)"*"===o[c]&&(o.push(o.splice(c,1)[0]),l--,c--);return{pathList:o,pathMap:a,nameMap:s}}function Yo(e,n){return Lo(e,[],n)}function Jo(e,n){var t=Zo(e),r=t.pathList,i=t.pathMap,o=t.nameMap;function a(e,t,a){var s=qo(e,t,!1,n),l=s.name;if(l){var u=o[l];if(!u)return c(null,s);var d=u.regex.keys.filter((function(e){return!e.optional})).map((function(e){return e.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var h in t.params)!(h in s.params)&&d.indexOf(h)>-1&&(s.params[h]=t.params[h]);return s.path=Ho(u.path,s.params),c(u,s,a)}if(s.path){s.params={};for(var p=0;p<r.length;p++){var f=r[p],m=i[f];if(Qo(m.regex,s.path,s.params))return c(m,s,a)}}return c(null,s)}function s(e,t){var r=e.redirect,i="function"==typeof r?r(fo(e,t,null,n)):r;if("string"==typeof i&&(i={path:i}),!i||"object"!=typeof i)return c(null,t);var s=i,l=s.name,u=s.path,d=t.query,h=t.hash,p=t.params;if(d=s.hasOwnProperty("query")?s.query:d,h=s.hasOwnProperty("hash")?s.hash:h,p=s.hasOwnProperty("params")?s.params:p,l){o[l];return a({_normalized:!0,name:l,query:d,hash:h,params:p},void 0,t)}if(u){var f=function(e,n){return wo(e,n.parent?n.parent.path:"/",!0)}(u,e);return a({_normalized:!0,path:Ho(f,p),query:d,hash:h},void 0,t)}return c(null,t)}function c(e,t,r){return e&&e.redirect?s(e,r||t):e&&e.matchAs?function(e,n,t){var r=a({_normalized:!0,path:Ho(t,n.params)});if(r){var i=r.matched,o=i[i.length-1];return n.params=r.params,c(o,n)}return c(null,n)}(0,t,e.matchAs):fo(e,t,r,n)}return{match:a,addRoute:function(e,n){var t="object"!=typeof e?o[e]:void 0;Zo([n||e],r,i,o,t),t&&t.alias.length&&Zo(t.alias.map((function(e){return{path:e,children:[n]}})),r,i,o,t)},getRoutes:function(){return r.map((function(e){return i[e]}))},addRoutes:function(e){Zo(e,r,i,o)}}}function Qo(e,n,t){var r=n.match(e);if(!r)return!1;if(!t)return!0;for(var i=1,o=r.length;i<o;++i){var a=e.keys[i-1];a&&(t[a.name||"pathMatch"]="string"==typeof r[i]?co(r[i]):r[i])}return!0}var ea=Wo&&window.performance&&window.performance.now?window.performance:Date;function na(){return ea.now().toFixed(3)}var ta=na();function ra(){return ta}function ia(e){return ta=e}var oa=Object.create(null);function aa(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var e=window.location.protocol+"//"+window.location.host,n=window.location.href.replace(e,""),t=ro({},window.history.state);return t.key=ra(),window.history.replaceState(t,"",n),window.addEventListener("popstate",la),function(){window.removeEventListener("popstate",la)}}function sa(e,n,t,r){if(e.app){var i=e.options.scrollBehavior;i&&e.app.$nextTick((function(){var o=function(){var e=ra();if(e)return oa[e]}(),a=i.call(e,n,t,r?o:null);a&&("function"==typeof a.then?a.then((function(e){fa(e,o)})).catch((function(e){0})):fa(a,o))}))}}function ca(){var e=ra();e&&(oa[e]={x:window.pageXOffset,y:window.pageYOffset})}function la(e){ca(),e.state&&e.state.key&&ia(e.state.key)}function ua(e){return ha(e.x)||ha(e.y)}function da(e){return{x:ha(e.x)?e.x:window.pageXOffset,y:ha(e.y)?e.y:window.pageYOffset}}function ha(e){return"number"==typeof e}var pa=/^#\d/;function fa(e,n){var t,r="object"==typeof e;if(r&&"string"==typeof e.selector){var i=pa.test(e.selector)?document.getElementById(e.selector.slice(1)):document.querySelector(e.selector);if(i){var o=e.offset&&"object"==typeof e.offset?e.offset:{};n=function(e,n){var t=document.documentElement.getBoundingClientRect(),r=e.getBoundingClientRect();return{x:r.left-t.left-n.x,y:r.top-t.top-n.y}}(i,o={x:ha((t=o).x)?t.x:0,y:ha(t.y)?t.y:0})}else ua(e)&&(n=da(e))}else r&&ua(e)&&(n=da(e));n&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:n.x,top:n.y,behavior:e.behavior}):window.scrollTo(n.x,n.y))}var ma,va=Wo&&((-1===(ma=window.navigator.userAgent).indexOf("Android 2.")&&-1===ma.indexOf("Android 4.0")||-1===ma.indexOf("Mobile Safari")||-1!==ma.indexOf("Chrome")||-1!==ma.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function ga(e,n){ca();var t=window.history;try{if(n){var r=ro({},t.state);r.key=ra(),t.replaceState(r,"",e)}else t.pushState({key:ia(na())},"",e)}catch(t){window.location[n?"replace":"assign"](e)}}function ya(e){ga(e,!0)}var ba={redirected:2,aborted:4,cancelled:8,duplicated:16};function _a(e,n){return ka(e,n,ba.redirected,'Redirected when going from "'+e.fullPath+'" to "'+function(e){if("string"==typeof e)return e;if("path"in e)return e.path;var n={};return Ea.forEach((function(t){t in e&&(n[t]=e[t])})),JSON.stringify(n,null,2)}(n)+'" via a navigation guard.')}function xa(e,n){return ka(e,n,ba.cancelled,'Navigation cancelled from "'+e.fullPath+'" to "'+n.fullPath+'" with a new navigation.')}function ka(e,n,t,r){var i=new Error(r);return i._isRouter=!0,i.from=e,i.to=n,i.type=t,i}var Ea=["params","query","hash"];function wa(e){return Object.prototype.toString.call(e).indexOf("Error")>-1}function Aa(e,n){return wa(e)&&e._isRouter&&(null==n||e.type===n)}function Ca(e,n,t){var r=function(i){i>=e.length?t():e[i]?n(e[i],(function(){r(i+1)})):r(i+1)};r(0)}function La(e){return function(n,t,r){var i=!1,o=0,a=null;Ta(e,(function(e,n,t,s){if("function"==typeof e&&void 0===e.cid){i=!0,o++;var c,l=Oa((function(n){var i;((i=n).__esModule||Sa&&"Module"===i[Symbol.toStringTag])&&(n=n.default),e.resolved="function"==typeof n?n:Ko.extend(n),t.components[s]=n,--o<=0&&r()})),u=Oa((function(e){var n="Failed to resolve async component "+s+": "+e;a||(a=wa(e)?e:new Error(n),r(a))}));try{c=e(l,u)}catch(e){u(e)}if(c)if("function"==typeof c.then)c.then(l,u);else{var d=c.component;d&&"function"==typeof d.then&&d.then(l,u)}}})),i||r()}}function Ta(e,n){return Ra(e.map((function(e){return Object.keys(e.components).map((function(t){return n(e.components[t],e.instances[t],e,t)}))})))}function Ra(e){return Array.prototype.concat.apply([],e)}var Sa="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function Oa(e){var n=!1;return function(){for(var t=[],r=arguments.length;r--;)t[r]=arguments[r];if(!n)return n=!0,e.apply(this,t)}}var ja=function(e,n){this.router=e,this.base=function(e){if(!e)if(Wo){var n=document.querySelector("base");e=(e=n&&n.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else e="/";"/"!==e.charAt(0)&&(e="/"+e);return e.replace(/\/$/,"")}(n),this.current=vo,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function Ua(e,n,t,r){var i=Ta(e,(function(e,r,i,o){var a=function(e,n){"function"!=typeof e&&(e=Ko.extend(e));return e.options[n]}(e,n);if(a)return Array.isArray(a)?a.map((function(e){return t(e,r,i,o)})):t(a,r,i,o)}));return Ra(r?i.reverse():i)}function Ia(e,n){if(n)return function(){return e.apply(n,arguments)}}ja.prototype.listen=function(e){this.cb=e},ja.prototype.onReady=function(e,n){this.ready?e():(this.readyCbs.push(e),n&&this.readyErrorCbs.push(n))},ja.prototype.onError=function(e){this.errorCbs.push(e)},ja.prototype.transitionTo=function(e,n,t){var r,i=this;try{r=this.router.match(e,this.current)}catch(e){throw this.errorCbs.forEach((function(n){n(e)})),e}var o=this.current;this.confirmTransition(r,(function(){i.updateRoute(r),n&&n(r),i.ensureURL(),i.router.afterHooks.forEach((function(e){e&&e(r,o)})),i.ready||(i.ready=!0,i.readyCbs.forEach((function(e){e(r)})))}),(function(e){t&&t(e),e&&!i.ready&&(Aa(e,ba.redirected)&&o===vo||(i.ready=!0,i.readyErrorCbs.forEach((function(n){n(e)}))))}))},ja.prototype.confirmTransition=function(e,n,t){var r=this,i=this.current;this.pending=e;var o,a,s=function(e){!Aa(e)&&wa(e)&&(r.errorCbs.length?r.errorCbs.forEach((function(n){n(e)})):console.error(e)),t&&t(e)},c=e.matched.length-1,l=i.matched.length-1;if(bo(e,i)&&c===l&&e.matched[c]===i.matched[l])return this.ensureURL(),e.hash&&sa(this.router,i,e,!1),s(((a=ka(o=i,e,ba.duplicated,'Avoided redundant navigation to current location: "'+o.fullPath+'".')).name="NavigationDuplicated",a));var u=function(e,n){var t,r=Math.max(e.length,n.length);for(t=0;t<r&&e[t]===n[t];t++);return{updated:n.slice(0,t),activated:n.slice(t),deactivated:e.slice(t)}}(this.current.matched,e.matched),d=u.updated,h=u.deactivated,p=u.activated,f=[].concat(function(e){return Ua(e,"beforeRouteLeave",Ia,!0)}(h),this.router.beforeHooks,function(e){return Ua(e,"beforeRouteUpdate",Ia)}(d),p.map((function(e){return e.beforeEnter})),La(p)),m=function(n,t){if(r.pending!==e)return s(xa(i,e));try{n(e,i,(function(n){!1===n?(r.ensureURL(!0),s(function(e,n){return ka(e,n,ba.aborted,'Navigation aborted from "'+e.fullPath+'" to "'+n.fullPath+'" via a navigation guard.')}(i,e))):wa(n)?(r.ensureURL(!0),s(n)):"string"==typeof n||"object"==typeof n&&("string"==typeof n.path||"string"==typeof n.name)?(s(_a(i,e)),"object"==typeof n&&n.replace?r.replace(n):r.push(n)):t(n)}))}catch(e){s(e)}};Ca(f,m,(function(){Ca(function(e){return Ua(e,"beforeRouteEnter",(function(e,n,t,r){return function(e,n,t){return function(r,i,o){return e(r,i,(function(e){"function"==typeof e&&(n.enteredCbs[t]||(n.enteredCbs[t]=[]),n.enteredCbs[t].push(e)),o(e)}))}}(e,t,r)}))}(p).concat(r.router.resolveHooks),m,(function(){if(r.pending!==e)return s(xa(i,e));r.pending=null,n(e),r.router.app&&r.router.app.$nextTick((function(){xo(e)}))}))}))},ja.prototype.updateRoute=function(e){this.current=e,this.cb&&this.cb(e)},ja.prototype.setupListeners=function(){},ja.prototype.teardown=function(){this.listeners.forEach((function(e){e()})),this.listeners=[],this.current=vo,this.pending=null};var za=function(e){function n(n,t){e.call(this,n,t),this._startLocation=Pa(this.base)}return e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n,n.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var n=this.router,t=n.options.scrollBehavior,r=va&&t;r&&this.listeners.push(aa());var i=function(){var t=e.current,i=Pa(e.base);e.current===vo&&i===e._startLocation||e.transitionTo(i,(function(e){r&&sa(n,e,t,!0)}))};window.addEventListener("popstate",i),this.listeners.push((function(){window.removeEventListener("popstate",i)}))}},n.prototype.go=function(e){window.history.go(e)},n.prototype.push=function(e,n,t){var r=this,i=this.current;this.transitionTo(e,(function(e){ga(Ao(r.base+e.fullPath)),sa(r.router,e,i,!1),n&&n(e)}),t)},n.prototype.replace=function(e,n,t){var r=this,i=this.current;this.transitionTo(e,(function(e){ya(Ao(r.base+e.fullPath)),sa(r.router,e,i,!1),n&&n(e)}),t)},n.prototype.ensureURL=function(e){if(Pa(this.base)!==this.current.fullPath){var n=Ao(this.base+this.current.fullPath);e?ga(n):ya(n)}},n.prototype.getCurrentLocation=function(){return Pa(this.base)},n}(ja);function Pa(e){var n=window.location.pathname,t=n.toLowerCase(),r=e.toLowerCase();return!e||t!==r&&0!==t.indexOf(Ao(r+"/"))||(n=n.slice(e.length)),(n||"/")+window.location.search+window.location.hash}var Ba=function(e){function n(n,t,r){e.call(this,n,t),r&&function(e){var n=Pa(e);if(!/^\/#/.test(n))return window.location.replace(Ao(e+"/#"+n)),!0}(this.base)||$a()}return e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n,n.prototype.setupListeners=function(){var e=this;if(!(this.listeners.length>0)){var n=this.router.options.scrollBehavior,t=va&&n;t&&this.listeners.push(aa());var r=function(){var n=e.current;$a()&&e.transitionTo(Ma(),(function(r){t&&sa(e.router,r,n,!0),va||Na(r.fullPath)}))},i=va?"popstate":"hashchange";window.addEventListener(i,r),this.listeners.push((function(){window.removeEventListener(i,r)}))}},n.prototype.push=function(e,n,t){var r=this,i=this.current;this.transitionTo(e,(function(e){Da(e.fullPath),sa(r.router,e,i,!1),n&&n(e)}),t)},n.prototype.replace=function(e,n,t){var r=this,i=this.current;this.transitionTo(e,(function(e){Na(e.fullPath),sa(r.router,e,i,!1),n&&n(e)}),t)},n.prototype.go=function(e){window.history.go(e)},n.prototype.ensureURL=function(e){var n=this.current.fullPath;Ma()!==n&&(e?Da(n):Na(n))},n.prototype.getCurrentLocation=function(){return Ma()},n}(ja);function $a(){var e=Ma();return"/"===e.charAt(0)||(Na("/"+e),!1)}function Ma(){var e=window.location.href,n=e.indexOf("#");return n<0?"":e=e.slice(n+1)}function Fa(e){var n=window.location.href,t=n.indexOf("#");return(t>=0?n.slice(0,t):n)+"#"+e}function Da(e){va?ga(Fa(e)):window.location.hash=e}function Na(e){va?ya(Fa(e)):window.location.replace(Fa(e))}var Ha=function(e){function n(n,t){e.call(this,n,t),this.stack=[],this.index=-1}return e&&(n.__proto__=e),n.prototype=Object.create(e&&e.prototype),n.prototype.constructor=n,n.prototype.push=function(e,n,t){var r=this;this.transitionTo(e,(function(e){r.stack=r.stack.slice(0,r.index+1).concat(e),r.index++,n&&n(e)}),t)},n.prototype.replace=function(e,n,t){var r=this;this.transitionTo(e,(function(e){r.stack=r.stack.slice(0,r.index).concat(e),n&&n(e)}),t)},n.prototype.go=function(e){var n=this,t=this.index+e;if(!(t<0||t>=this.stack.length)){var r=this.stack[t];this.confirmTransition(r,(function(){var e=n.current;n.index=t,n.updateRoute(r),n.router.afterHooks.forEach((function(n){n&&n(r,e)}))}),(function(e){Aa(e,ba.duplicated)&&(n.index=t)}))}},n.prototype.getCurrentLocation=function(){var e=this.stack[this.stack.length-1];return e?e.fullPath:"/"},n.prototype.ensureURL=function(){},n}(ja),qa=function(e){void 0===e&&(e={}),this.app=null,this.apps=[],this.options=e,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Jo(e.routes||[],this);var n=e.mode||"hash";switch(this.fallback="history"===n&&!va&&!1!==e.fallback,this.fallback&&(n="hash"),Wo||(n="abstract"),this.mode=n,n){case"history":this.history=new za(this,e.base);break;case"hash":this.history=new Ba(this,e.base,this.fallback);break;case"abstract":this.history=new Ha(this,e.base);break;default:0}},Ka={currentRoute:{configurable:!0}};qa.prototype.match=function(e,n,t){return this.matcher.match(e,n,t)},Ka.currentRoute.get=function(){return this.history&&this.history.current},qa.prototype.init=function(e){var n=this;if(this.apps.push(e),e.$once("hook:destroyed",(function(){var t=n.apps.indexOf(e);t>-1&&n.apps.splice(t,1),n.app===e&&(n.app=n.apps[0]||null),n.app||n.history.teardown()})),!this.app){this.app=e;var t=this.history;if(t instanceof za||t instanceof Ba){var r=function(e){t.setupListeners(),function(e){var r=t.current,i=n.options.scrollBehavior;va&&i&&"fullPath"in e&&sa(n,e,r,!1)}(e)};t.transitionTo(t.getCurrentLocation(),r,r)}t.listen((function(e){n.apps.forEach((function(n){n._route=e}))}))}},qa.prototype.beforeEach=function(e){return Ga(this.beforeHooks,e)},qa.prototype.beforeResolve=function(e){return Ga(this.resolveHooks,e)},qa.prototype.afterEach=function(e){return Ga(this.afterHooks,e)},qa.prototype.onReady=function(e,n){this.history.onReady(e,n)},qa.prototype.onError=function(e){this.history.onError(e)},qa.prototype.push=function(e,n,t){var r=this;if(!n&&!t&&"undefined"!=typeof Promise)return new Promise((function(n,t){r.history.push(e,n,t)}));this.history.push(e,n,t)},qa.prototype.replace=function(e,n,t){var r=this;if(!n&&!t&&"undefined"!=typeof Promise)return new Promise((function(n,t){r.history.replace(e,n,t)}));this.history.replace(e,n,t)},qa.prototype.go=function(e){this.history.go(e)},qa.prototype.back=function(){this.go(-1)},qa.prototype.forward=function(){this.go(1)},qa.prototype.getMatchedComponents=function(e){var n=e?e.matched?e:this.resolve(e).route:this.currentRoute;return n?[].concat.apply([],n.matched.map((function(e){return Object.keys(e.components).map((function(n){return e.components[n]}))}))):[]},qa.prototype.resolve=function(e,n,t){var r=qo(e,n=n||this.history.current,t,this),i=this.match(r,n),o=i.redirectedFrom||i.fullPath;return{location:r,route:i,href:function(e,n,t){var r="hash"===t?"#"+n:n;return e?Ao(e+"/"+r):r}(this.history.base,o,this.mode),normalizedTo:r,resolved:i}},qa.prototype.getRoutes=function(){return this.matcher.getRoutes()},qa.prototype.addRoute=function(e,n){this.matcher.addRoute(e,n),this.history.current!==vo&&this.history.transitionTo(this.history.getCurrentLocation())},qa.prototype.addRoutes=function(e){this.matcher.addRoutes(e),this.history.current!==vo&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(qa.prototype,Ka);var Va=qa;function Ga(e,n){return e.push(n),function(){var t=e.indexOf(n);t>-1&&e.splice(t,1)}}qa.install=function e(n){if(!e.installed||Ko!==n){e.installed=!0,Ko=n;var t=function(e){return void 0!==e},r=function(e,n){var r=e.$options._parentVnode;t(r)&&t(r=r.data)&&t(r=r.registerRouteInstance)&&r(e,n)};n.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),n.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,r(this,this)},destroyed:function(){r(this)}}),Object.defineProperty(n.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(n.prototype,"$route",{get:function(){return this._routerRoot._route}}),n.component("RouterView",ko),n.component("RouterLink",Go);var i=n.config.optionMergeStrategies;i.beforeRouteEnter=i.beforeRouteLeave=i.beforeRouteUpdate=i.created}},qa.version="3.6.5",qa.isNavigationFailure=Aa,qa.NavigationFailureType=ba,qa.START_LOCATION=vo,Wo&&window.Vue&&window.Vue.use(qa);t(107);t(129),t(16);var Xa={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,335)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,334))},Wa={"v-14d5b00e":()=>t.e(5).then(t.bind(null,336)),"v-6f4636bc":()=>t.e(6).then(t.bind(null,337)),"v-30a03cb6":()=>t.e(7).then(t.bind(null,338)),"v-be411e82":()=>t.e(8).then(t.bind(null,339)),"v-24d5fda5":()=>t.e(9).then(t.bind(null,340)),"v-67babc0e":()=>t.e(10).then(t.bind(null,341)),"v-639e0f9a":()=>t.e(11).then(t.bind(null,342)),"v-fb7b08d2":()=>t.e(12).then(t.bind(null,343)),"v-d89ce0de":()=>t.e(13).then(t.bind(null,344)),"v-2b8f38b0":()=>t.e(14).then(t.bind(null,345)),"v-345df50e":()=>t.e(15).then(t.bind(null,346)),"v-33f15289":()=>t.e(16).then(t.bind(null,347)),"v-71660c7c":()=>t.e(17).then(t.bind(null,348)),"v-072dd135":()=>t.e(18).then(t.bind(null,349)),"v-2d6b4bec":()=>t.e(20).then(t.bind(null,350)),"v-5d56c92a":()=>t.e(22).then(t.bind(null,351)),"v-0ac18964":()=>t.e(21).then(t.bind(null,352)),"v-23e43bec":()=>t.e(23).then(t.bind(null,353)),"v-0e70e808":()=>t.e(24).then(t.bind(null,354)),"v-4fb0b446":()=>t.e(19).then(t.bind(null,355)),"v-4e80661c":()=>t.e(25).then(t.bind(null,356)),"v-ca3de854":()=>t.e(26).then(t.bind(null,357)),"v-82af755a":()=>t.e(27).then(t.bind(null,358)),"v-f75dbe40":()=>t.e(28).then(t.bind(null,359)),"v-4985a9a2":()=>t.e(30).then(t.bind(null,360)),"v-15eefc95":()=>t.e(29).then(t.bind(null,361)),"v-0b0ed22c":()=>t.e(31).then(t.bind(null,362)),"v-551313d7":()=>t.e(32).then(t.bind(null,363)),"v-61d0fb85":()=>t.e(33).then(t.bind(null,364)),"v-a11d1cc4":()=>t.e(34).then(t.bind(null,365))};function Za(e){const n=Object.create(null);return function(t){return n[t]||(n[t]=e(t))}}const Ya=/-(\w)/g,Ja=Za(e=>e.replace(Ya,(e,n)=>n?n.toUpperCase():"")),Qa=/\B([A-Z])/g,es=Za(e=>e.replace(Qa,"-$1").toLowerCase()),ns=Za(e=>e.charAt(0).toUpperCase()+e.slice(1));function ts(e,n){if(!n)return;if(e(n))return e(n);return n.includes("-")?e(ns(Ja(n))):e(ns(n))||e(es(n))}const rs=Object.assign({},Xa,Wa),is=e=>rs[e],os=e=>Wa[e],as=e=>Xa[e],ss=e=>Xt.component(e);function cs(e){return ts(os,e)}function ls(e){return ts(as,e)}function us(e){return ts(is,e)}function ds(e){return ts(ss,e)}function hs(...e){return Promise.all(e.filter(e=>e).map(async e=>{if(!ds(e)&&us(e)){const n=await us(e)();Xt.component(e,n.default)}}))}function ps(e,n){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[e]=n)}var fs=t(92),ms=t.n(fs),vs=t(93),gs=t.n(vs),ys={created(){if(this.siteMeta=this.$site.headTags.filter(([e])=>"meta"===e).map(([e,n])=>n),this.$ssrContext){const n=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(e=n)?e.map(e=>{let n="<meta";return Object.keys(e).forEach(t=>{n+=` ${t}="${gs()(e[t])}"`}),n+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=_s(this.$canonicalUrl)}var e},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const e=this.getMergedMetaTags();this.currentMetaTags=xs(e,this.currentMetaTags)},getMergedMetaTags(){const e=this.$page.frontmatter.meta||[];return ms()([{name:"description",content:this.$description}],e,this.siteMeta,ks)},updateCanonicalLink(){bs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",_s(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){xs(null,this.currentMetaTags),bs()}};function bs(){const e=document.querySelector("link[rel='canonical']");e&&e.remove()}function _s(e=""){return e?`<link href="${e}" rel="canonical" />`:""}function xs(e,n){if(n&&[...n].filter(e=>e.parentNode===document.head).forEach(e=>document.head.removeChild(e)),e)return e.map(e=>{const n=document.createElement("meta");return Object.keys(e).forEach(t=>{n.setAttribute(t,e[t])}),document.head.appendChild(n),n})}function ks(e){for(const n of["name","property","itemprop"])if(e.hasOwnProperty(n))return e[n]+n;return JSON.stringify(e)}var Es=t(51),ws={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(Es)()((function(){this.setActiveHash()}),300),setActiveHash(){const e=[].slice.call(document.querySelectorAll(".sidebar-link")),n=[].slice.call(document.querySelectorAll(".header-anchor")).filter(n=>e.some(e=>e.hash===n.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),r=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),i=window.innerHeight+t;for(let e=0;e<n.length;e++){const o=n[e],a=n[e+1],s=0===e&&0===t||t>=o.parentElement.offsetTop+10&&(!a||t<a.parentElement.offsetTop-10),c=decodeURIComponent(this.$route.hash);if(s&&c!==decodeURIComponent(o.hash)){const t=o;if(i===r)for(let t=e+1;t<n.length;t++)if(c===decodeURIComponent(n[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},As=t(24),Cs=t.n(As),Ls={mounted(){Cs.a.configure({showSpinner:!1}),this.$router.beforeEach((e,n,t)=>{e.path===n.path||Xt.component(e.name)||Cs.a.start(),t()}),this.$router.afterEach(()=>{Cs.a.done(),this.isSidebarOpen=!1})}},Ts=t(94),Rs={noCopy:!0,noSelect:!1,disabled:!1,minLength:100,authorName:""},Ss={props:{html:String,lang:String},created(){this.authorName="string"==typeof Rs.authorName?Rs.authorName:this.getI18nValue(Rs.authorName),this.text=this.getI18nValue(Ts),this.location=String(location).replace(/#.+$/,"")},methods:{getI18nValue(e){return this.lang in e?e[this.lang]:e["en-US"]}}},Os=t(4),js=Object(Os.a)(Ss,(function(){var e=this,n=e._self._c;return n("div",[n("p",[e._v(e._s(e.text.beforeAuthor)+e._s(e.authorName||e.text.author)+e._s(e.text.afterAuthor)),n("a",{attrs:{href:e.location}},[e._v(e._s(decodeURIComponent(e.location)))])]),e._v("\n\n"),n("div",{domProps:{innerHTML:e._s(e.html)}})])}),[],!1,null,null,null).exports,Us={data:()=>({isElement:!1}),created(){this.onCopy=e=>{const n=getSelection().getRangeAt(0);if(String(n).length<this.minLength)return;if(e.preventDefault(),this.noCopy)return;const t=document.createElement("div");t.appendChild(getSelection().getRangeAt(0).cloneContents());const r=this.$lang,i=new Xt({render:e=>e(js,{props:{html:t.innerHTML,lang:r}})}).$mount(),{innerHTML:o,innerText:a}=i.$el;e.clipboardData?(e.clipboardData.setData("text/html",o),e.clipboardData.setData("text/plain",a)):window.clipboardData&&window.clipboardData.setData("text",a)}},watch:{isElement(e){if(!e)return;let{copyright:n=!Rs.disabled}=this.$frontmatter;if(!n)return;"object"!=typeof n&&(n={});const t=n.noSelect||Rs.noSelect;this.minLength=n.minLength||Rs.minLength,this.noCopy=n.noCopy||Rs.noCopy,t?this.$el.style.userSelect="none":this.$el.addEventListener("copy",this.onCopy)}},updated(){this.isElement="#comment"!==this.$el.nodeName},beforeDestory(){this.$el.removeEventListener("copy",this.onCopy)}};t(241),t(242);class Is{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:e="",duration:n=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${e}</div>\n    `,this.containerEl.appendChild(t),n>0&&setTimeout(()=>{this.close(t)},n)}close(e){e.className=e.className.replace("move-in",""),e.className+="move-out",e.addEventListener("animationend",()=>{e.remove()})}}var zs={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(e=>{document.querySelectorAll(e).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(e){if(e.classList.contains("codecopy-enabled"))return;const n=document.createElement("i");n.className="code-copy",n.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',n.title="Copy to clipboard",n.addEventListener("click",()=>{this.copyToClipboard(e.innerText)}),e.appendChild(n),e.classList.add("codecopy-enabled")},copyToClipboard(e){const n=document.createElement("textarea");n.value=e,n.setAttribute("readonly",""),n.style.position="absolute",n.style.left="-9999px",document.body.appendChild(n);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);n.select(),document.execCommand("copy");(new Is).show({text:"复制成功",duration:1e3}),document.body.removeChild(n),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(e,n){void 0===n&&(n={});var t=n.insertAt;if(e&&"undefined"!=typeof document){var r=document.head||document.getElementsByTagName("head")[0],i=document.createElement("style");i.type="text/css","top"===t&&r.firstChild?r.insertBefore(i,r.firstChild):r.appendChild(i),i.styleSheet?i.styleSheet.cssText=e:i.appendChild(document.createTextNode(e))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Ps={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},Bs={},$s=function(e){return'<div id="app">\n'.concat(e,"\n</div>")},Ms=function(e){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[e]?window.$VUEPRESS_DEMO_BLOCK[e]:Ps[e]},Fs=function e(n,t,r){var i=document.createElement(n);return t&&Object.keys(t).forEach((function(e){if(e.indexOf("data"))i[e]=t[e];else{var n=e.replace("data","");i.dataset[n]=t[e]}})),r&&r.forEach((function(n){var t=n.tag,r=n.attrs,o=n.children;i.appendChild(e(t,r,o))})),i},Ds=function(e,n,t){var r,i=(r=e.querySelectorAll(".".concat(n)),Array.prototype.slice.call(r));return 1!==i.length||t?i:i[0]},Ns=function(e,n){var t,r,i=e.match(/<style>([\s\S]+)<\/style>/),o=e.match(/<template>([\s\S]+)<\/template>/),a=e.match(/<script>([\s\S]+)<\/script>/),s={css:i&&i[1].replace(/^\n|\n$/g,""),html:o&&o[1].replace(/^\n|\n$/g,""),js:a&&a[1].replace(/^\n|\n$/g,""),jsLib:n.jsLib||[],cssLib:n.cssLib||[]};s.htmlTpl=$s(s.html),s.jsTpl=(t=s.js,r=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(r,"\n})")),s.script=function(e,n){var t=e.split(/export\s+default/),r="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),i=window.Babel?window.Babel.transform(r,{presets:["es2015"]}).code:r,o=[eval][0](i);return o.template=n,o}(s.js,s.html);var c=Ms("vue");return s.jsLib.unshift(c),s},Hs=function(e,n){var t,r=e.match(/<style>([\s\S]+)<\/style>/),i=e.match(/<html>([\s\S]+)<\/html>/),o=e.match(/<script>([\s\S]+)<\/script>/),a={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:n.jsLib||[],cssLib:n.cssLib||[]};return a.htmlTpl=a.html,a.jsTpl=a.js,a.script=(t=a.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),a},qs=function(e){return e=e.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),e+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Ks(){var e=Ds(document,"vuepress-plugin-demo-block__wrapper",!0);e.length?e.forEach((function(e){if("true"!==e.dataset.created){e.style.display="block";var n=Ds(e,"vuepress-plugin-demo-block__code"),t=Ds(e,"vuepress-plugin-demo-block__display"),r=Ds(e,"vuepress-plugin-demo-block__footer"),i=Ds(t,"vuepress-plugin-demo-block__app"),o=decodeURIComponent(e.dataset.code),a=decodeURIComponent(e.dataset.config),s=decodeURIComponent(e.dataset.type);a=a?JSON.parse(a):{};var c=n.querySelector("div").clientHeight,l="react"===s?function(e,n){var t=(0,window.Babel.transform)(e,{presets:["es2015","react"]}).code,r="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),i=new Function("return ".concat(r))(),o={js:i,css:i.__style__||"",jsLib:n.jsLib||[],cssLib:n.cssLib||[],jsTpl:qs(e),htmlTpl:$s("")},a=Ms("react"),s=Ms("reactDOM");return o.jsLib.unshift(a,s),o}(o,a):"vanilla"===s?Hs(o,a):Ns(o,a),u=Fs("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(r.appendChild(u),u.addEventListener("click",Vs.bind(null,u,c,n,r)),Ms("jsfiddle")&&r.appendChild(function(e){var n=e.css,t=e.htmlTpl,r=e.jsTpl,i=e.jsLib,o=e.cssLib,a=i.concat(o).concat(Ms("cssLib")).concat(Ms("jsLib")).join(",");return Fs("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:n}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:r}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:a}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(l)),Ms("codepen")&&r.appendChild(function(e){var n=e.css,t=e.htmlTpl,r=e.jsTpl,i=e.jsLib,o=e.cssLib,a=JSON.stringify({css:n,html:t,js:r,js_external:i.concat(Ms("jsLib")).join(";"),css_external:o.concat(Ms("cssLib")).join(";"),layout:Ms("codepenLayout"),js_pre_processor:Ms("codepenJsProcessor"),editors:Ms("codepenEditors")});return Fs("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:a}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(l)),void 0!==a.horizontal?a.horizontal:Ms("horizontal")){e.classList.add("vuepress-plugin-demo-block__horizontal");var d=n.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(l.css&&function(e){if(!Bs[e]){var n=Fs("style",{innerHTML:e});document.body.appendChild(n),Bs[e]=!0}}(l.css),"react"===s)ReactDOM.render(React.createElement(l.js),i);else if("vue"===s){var h=(new(Vue.extend(l.script))).$mount();i.appendChild(h.$el)}else"vanilla"===s&&(i.innerHTML=l.html,new Function("return (function(){".concat(l.script,"})()"))());e.dataset.created="true"}})):setTimeout((function(e){Ks()}),300)}function Vs(e,n,t,r){var i="1"!==e.dataset.isExpand;t.style.height=i?"".concat(n,"px"):0,i?r.classList.add("vuepress-plugin-demo-block__show-link"):r.classList.remove("vuepress-plugin-demo-block__show-link"),e.dataset.isExpand=i?"1":"0"}var Gs={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Ks()},updated:function(){Ks()}},Xs="auto",Ws="zoom-in",Zs="zoom-out",Ys="grab",Js="move";function Qs(e,n,t){var r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],i={passive:!1};r?e.addEventListener(n,t,i):e.removeEventListener(n,t,i)}function ec(e,n){if(e){var t=new Image;t.onload=function(){n&&n(t)},t.src=e}}function nc(e){return e.dataset.original?e.dataset.original:"A"===e.parentNode.tagName?e.parentNode.getAttribute("href"):null}function tc(e,n,t){!function(e){var n=rc,t=ic;if(e.transition){var r=e.transition;delete e.transition,e[n]=r}if(e.transform){var i=e.transform;delete e.transform,e[t]=i}}(n);var r=e.style,i={};for(var o in n)t&&(i[o]=r[o]||""),r[o]=n[o];return i}var rc="transition",ic="transform",oc="transform",ac="transitionend";var sc=function(){},cc={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:sc,onClose:sc,onGrab:sc,onMove:sc,onRelease:sc,onBeforeOpen:sc,onBeforeClose:sc,onBeforeGrab:sc,onBeforeRelease:sc,onImageLoading:sc,onImageLoaded:sc},lc={init:function(e){var n,t;n=this,t=e,Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach((function(e){n[e]=n[e].bind(t)}))},click:function(e){if(e.preventDefault(),dc(e))return window.open(this.target.srcOriginal||e.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(e.currentTarget)},scroll:function(){var e=document.documentElement||document.body.parentNode||document.body,n=window.pageXOffset||e.scrollLeft,t=window.pageYOffset||e.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:n,y:t});var r=this.lastScrollPosition.x-n,i=this.lastScrollPosition.y-t,o=this.options.scrollThreshold;(Math.abs(i)>=o||Math.abs(r)>=o)&&(this.lastScrollPosition=null,this.close())},keydown:function(e){(function(e){return"Escape"===(e.key||e.code)||27===e.keyCode})(e)&&(this.released?this.close():this.release(this.close))},mousedown:function(e){if(uc(e)&&!dc(e)){e.preventDefault();var n=e.clientX,t=e.clientY;this.pressTimer=setTimeout(function(){this.grab(n,t)}.bind(this),200)}},mousemove:function(e){this.released||this.move(e.clientX,e.clientY)},mouseup:function(e){uc(e)&&!dc(e)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(e){e.preventDefault();var n=e.touches[0],t=n.clientX,r=n.clientY;this.pressTimer=setTimeout(function(){this.grab(t,r)}.bind(this),200)},touchmove:function(e){if(!this.released){var n=e.touches[0],t=n.clientX,r=n.clientY;this.move(t,r)}},touchend:function(e){(function(e){e.targetTouches.length})(e)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function uc(e){return 0===e.button}function dc(e){return e.metaKey||e.ctrlKey}var hc={init:function(e){this.el=document.createElement("div"),this.instance=e,this.parent=document.body,tc(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(e.options),Qs(this.el,"click",e.handler.clickOverlay.bind(e))},updateStyle:function(e){tc(this.el,{zIndex:e.zIndex,backgroundColor:e.bgColor,transition:"opacity\n        "+e.transitionDuration+"s\n        "+e.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},pc="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},fc=function(){function e(e,n){for(var t=0;t<n.length;t++){var r=n[t];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}return function(n,t,r){return t&&e(n.prototype,t),r&&e(n,r),n}}(),mc=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var t=arguments[n];for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r])}return e},vc={init:function(e,n){this.el=e,this.instance=n,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=nc(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var e=this.instance.options,n=e.zIndex,t=e.enableGrab,r=e.transitionDuration,i=e.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:n+1,cursor:t?Ys:Zs,transition:oc+"\n        "+r+"s\n        "+i,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=tc(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,tc(this.el,{transform:"none"})},grab:function(e,n,t){var r=gc(),i=r.x-e,o=r.y-n;tc(this.el,{cursor:Js,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(e,n,t){var r=gc(),i=r.x-e,o=r.y-n;tc(this.el,{transition:oc,transform:"translate3d(\n        "+(this.translate.x+i)+"px, "+(this.translate.y+o)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){tc(this.el,this.styleClose)},restoreOpenStyle:function(){tc(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var e=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var n=this.el.cloneNode(!1);n.setAttribute("src",this.srcOriginal),n.style.position="fixed",n.style.visibility="hidden",e.appendChild(n),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),e.removeChild(n)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var e=gc(),n=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:e.x-n,y:e.y-t}},calculateScale:function(){var e=this.el.dataset,n=e.zoomingHeight,t=e.zoomingWidth,r=this.instance.options,i=r.customSize,o=r.scaleBase;if(!i&&n&&t)return{x:t/this.rect.width,y:n/this.rect.height};if(i&&"object"===(void 0===i?"undefined":pc(i)))return{x:i.width/this.rect.width,y:i.height/this.rect.height};var a=this.rect.width/2,s=this.rect.height/2,c=gc(),l={x:c.x-a,y:c.y-s},u=l.x/a,d=l.y/s,h=o+Math.min(u,d);if(i&&"string"==typeof i){var p=t||this.el.naturalWidth,f=n||this.el.naturalHeight,m=parseFloat(i)*p/(100*this.rect.width),v=parseFloat(i)*f/(100*this.rect.height);if(h>m||h>v)return{x:m,y:v}}return{x:h,y:h}}};function gc(){var e=document.documentElement;return{x:Math.min(e.clientWidth,window.innerWidth)/2,y:Math.min(e.clientHeight,window.innerHeight)/2}}function yc(e,n,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(r){Qs(e,r,n[r],t)}))}var bc=function(){function e(n){!function(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}(this,e),this.target=Object.create(vc),this.overlay=Object.create(hc),this.handler=Object.create(lc),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=mc({},cc,n),this.overlay.init(this),this.handler.init(this)}return fc(e,[{key:"listen",value:function(e){if("string"==typeof e)for(var n=document.querySelectorAll(e),t=n.length;t--;)this.listen(n[t]);else"IMG"===e.tagName&&(e.style.cursor=Ws,Qs(e,"click",this.handler.click),this.options.preloadImage&&ec(nc(e)));return this}},{key:"config",value:function(e){return e?(mc(this.options,e),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(e){var n=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var r="string"==typeof e?document.querySelector(e):e;if("IMG"===r.tagName){if(this.options.onBeforeOpen(r),this.target.init(r,this),!this.options.preloadImage){var i=this.target.srcOriginal;null!=i&&(this.options.onImageLoading(r),ec(i,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Qs(document,"scroll",this.handler.scroll),Qs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Qs(window,"resize",this.handler.resizeWindow);var o=function e(){Qs(r,ac,e,!1),n.lock=!1,n.target.upgradeSource(),n.options.enableGrab&&yc(document,n.handler,!0),t(r)};return Qs(r,ac,o),this}}}},{key:"close",value:function(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Xs,this.overlay.fadeOut(),this.target.zoomOut(),Qs(document,"scroll",this.handler.scroll,!1),Qs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Qs(window,"resize",this.handler.resizeWindow,!1);var r=function r(){Qs(t,ac,r,!1),e.shown=!1,e.lock=!1,e.target.downgradeSource(),e.options.enableGrab&&yc(document,e.handler,!1),e.target.restoreCloseStyle(),e.overlay.remove(),n(t)};return Qs(t,ac,r),this}}},{key:"grab",value:function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var i=this.target.el;this.options.onBeforeGrab(i),this.released=!1,this.target.grab(e,n,t);var o=function e(){Qs(i,ac,e,!1),r(i)};return Qs(i,ac,o),this}}},{key:"move",value:function(e,n){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=Js,this.target.move(e,n,t);var i=this.target.el,o=function e(){Qs(i,ac,e,!1),r(i)};return Qs(i,ac,o),this}}},{key:"release",value:function(){var e=this,n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Xs,this.target.restoreOpenStyle();var r=function r(){Qs(t,ac,r,!1),e.lock=!1,e.released=!0,n(t)};return Qs(t,ac,r),this}}}]),e}();const _c=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),xc=Number("500");class kc{constructor(){this.instance=new bc(_c)}update(e=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(e)}updateDelay(e=".theme-vdoing-content img:not(.no-zoom)",n=xc){setTimeout(()=>this.update(e),n)}}var Ec=[ys,ws,Ls,Us,zs,Gs,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new kc,this.$vuepress.zooming.updateDelay()}}],wc={name:"GlobalLayout",computed:{layout(){const e=this.getLayout();return ps("layout",e),Xt.component(e)}},methods:{getLayout(){if(this.$page.path){const e=this.$page.frontmatter.layout;return e&&(this.$vuepress.getLayoutAsyncComponent(e)||this.$vuepress.getVueComponent(e))?e:"Layout"}return"NotFound"}}},Ac=Object(Os.a)(wc,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(e,n,t){switch(n){case"components":e[n]||(e[n]={}),Object.assign(e[n],t);break;case"mixins":e[n]||(e[n]=[]),e[n].push(...t);break;default:throw new Error("Unknown option name.")}}(Ac,"mixins",Ec);const Cc=[{name:"v-14d5b00e",path:"/pages/fccd91/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-14d5b00e").then(t)}},{path:"/pages/fccd91/index.html",redirect:"/pages/fccd91/"},{path:"/01.系统设计算法/01.系统设计算法/01.布隆过滤.html",redirect:"/pages/fccd91/"},{name:"v-6f4636bc",path:"/pages/1e28a2/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-6f4636bc").then(t)}},{path:"/pages/1e28a2/index.html",redirect:"/pages/1e28a2/"},{path:"/01.系统设计算法/01.系统设计算法/02.一致性哈希.html",redirect:"/pages/1e28a2/"},{name:"v-30a03cb6",path:"/pages/8624c5/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-30a03cb6").then(t)}},{path:"/pages/8624c5/index.html",redirect:"/pages/8624c5/"},{path:"/01.系统设计算法/01.系统设计算法/03.Count-Min Sketch.html",redirect:"/pages/8624c5/"},{name:"v-be411e82",path:"/pages/87589a/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-be411e82").then(t)}},{path:"/pages/87589a/index.html",redirect:"/pages/87589a/"},{path:"/01.系统设计算法/01.系统设计算法/04.LRU.html",redirect:"/pages/87589a/"},{name:"v-24d5fda5",path:"/pages/7d22be/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-24d5fda5").then(t)}},{path:"/pages/7d22be/index.html",redirect:"/pages/7d22be/"},{path:"/01.系统设计算法/01.系统设计算法/05.LFU.html",redirect:"/pages/7d22be/"},{name:"v-67babc0e",path:"/pages/2d43d1/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-67babc0e").then(t)}},{path:"/pages/2d43d1/index.html",redirect:"/pages/2d43d1/"},{path:"/01.系统设计算法/01.系统设计算法/06.渐进式 hash.html",redirect:"/pages/2d43d1/"},{name:"v-639e0f9a",path:"/pages/73ef48/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-639e0f9a").then(t)}},{path:"/pages/73ef48/index.html",redirect:"/pages/73ef48/"},{path:"/01.系统设计算法/",redirect:"/pages/73ef48/"},{name:"v-fb7b08d2",path:"/pages/a95d7d/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-fb7b08d2").then(t)}},{path:"/pages/a95d7d/index.html",redirect:"/pages/a95d7d/"},{path:"/02.设计热门应用/01.社交类/01.设计 微信.html",redirect:"/pages/a95d7d/"},{name:"v-d89ce0de",path:"/pages/90ad66/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-d89ce0de").then(t)}},{path:"/pages/90ad66/index.html",redirect:"/pages/90ad66/"},{path:"/02.设计热门应用/01.社交类/02.设计Twitter.html",redirect:"/pages/90ad66/"},{name:"v-2b8f38b0",path:"/pages/6e86ba/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-2b8f38b0").then(t)}},{path:"/pages/6e86ba/index.html",redirect:"/pages/6e86ba/"},{path:"/02.设计热门应用/",redirect:"/pages/6e86ba/"},{name:"v-345df50e",path:"/pages/def08a/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-345df50e").then(t)}},{path:"/pages/def08a/index.html",redirect:"/pages/def08a/"},{path:"/03.场景设计/01.热门场景设计/01.双写一致性.html",redirect:"/pages/def08a/"},{name:"v-33f15289",path:"/pages/1e9e8e/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-33f15289").then(t)}},{path:"/pages/1e9e8e/index.html",redirect:"/pages/1e9e8e/"},{path:"/03.场景设计/01.热门场景设计/02.缓存穿透.html",redirect:"/pages/1e9e8e/"},{name:"v-71660c7c",path:"/pages/1d96b2/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-71660c7c").then(t)}},{path:"/pages/1d96b2/index.html",redirect:"/pages/1d96b2/"},{path:"/03.场景设计/01.热门场景设计/03.缓存击穿.html",redirect:"/pages/1d96b2/"},{name:"v-072dd135",path:"/pages/24abe0/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-072dd135").then(t)}},{path:"/pages/24abe0/index.html",redirect:"/pages/24abe0/"},{path:"/03.场景设计/01.热门场景设计/04.任务补偿.html",redirect:"/pages/24abe0/"},{name:"v-2d6b4bec",path:"/pages/f3295f/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-2d6b4bec").then(t)}},{path:"/pages/f3295f/index.html",redirect:"/pages/f3295f/"},{path:"/03.场景设计/01.热门场景设计/06.海量数据计数.html",redirect:"/pages/f3295f/"},{name:"v-5d56c92a",path:"/pages/0dfb49/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-5d56c92a").then(t)}},{path:"/pages/0dfb49/index.html",redirect:"/pages/0dfb49/"},{path:"/03.场景设计/01.热门场景设计/08.超时&重试.html",redirect:"/pages/0dfb49/"},{name:"v-0ac18964",path:"/pages/51aa8b/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-0ac18964").then(t)}},{path:"/pages/51aa8b/index.html",redirect:"/pages/51aa8b/"},{path:"/03.场景设计/01.热门场景设计/07.多级缓存.html",redirect:"/pages/51aa8b/"},{name:"v-23e43bec",path:"/pages/4fc8cb/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-23e43bec").then(t)}},{path:"/pages/4fc8cb/index.html",redirect:"/pages/4fc8cb/"},{path:"/03.场景设计/01.热门场景设计/09.幂等&防重.html",redirect:"/pages/4fc8cb/"},{name:"v-0e70e808",path:"/pages/a027c2/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-0e70e808").then(t)}},{path:"/pages/a027c2/index.html",redirect:"/pages/a027c2/"},{path:"/03.场景设计/",redirect:"/pages/a027c2/"},{name:"v-4fb0b446",path:"/pages/a72629/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-4fb0b446").then(t)}},{path:"/pages/a72629/index.html",redirect:"/pages/a72629/"},{path:"/03.场景设计/01.热门场景设计/05.秒杀.html",redirect:"/pages/a72629/"},{name:"v-4e80661c",path:"/pages/84cb49/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-4e80661c").then(t)}},{path:"/pages/84cb49/index.html",redirect:"/pages/84cb49/"},{path:"/04.设计基础设施/01.基础设施/01.分布式缓存.html",redirect:"/pages/84cb49/"},{name:"v-ca3de854",path:"/pages/57d5a5/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-ca3de854").then(t)}},{path:"/pages/57d5a5/index.html",redirect:"/pages/57d5a5/"},{path:"/04.设计基础设施/01.基础设施/02.限流器.html",redirect:"/pages/57d5a5/"},{name:"v-82af755a",path:"/pages/5dcb6b/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-82af755a").then(t)}},{path:"/pages/5dcb6b/index.html",redirect:"/pages/5dcb6b/"},{path:"/04.设计基础设施/01.基础设施/03.热点探查（Top k）.html",redirect:"/pages/5dcb6b/"},{name:"v-f75dbe40",path:"/pages/567090/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-f75dbe40").then(t)}},{path:"/pages/567090/index.html",redirect:"/pages/567090/"},{path:"/04.设计基础设施/01.基础设施/04.消息队列.html",redirect:"/pages/567090/"},{name:"v-4985a9a2",path:"/pages/3c1db5/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-4985a9a2").then(t)}},{path:"/pages/3c1db5/index.html",redirect:"/pages/3c1db5/"},{path:"/04.设计基础设施/",redirect:"/pages/3c1db5/"},{name:"v-15eefc95",path:"/pages/8416e6/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-15eefc95").then(t)}},{path:"/pages/8416e6/index.html",redirect:"/pages/8416e6/"},{path:"/04.设计基础设施/01.基础设施/05.订阅发布.html",redirect:"/pages/8416e6/"},{name:"v-0b0ed22c",path:"/pages/92b2ee/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-0b0ed22c").then(t)}},{path:"/pages/92b2ee/index.html",redirect:"/pages/92b2ee/"},{path:"/05.问答/",redirect:"/pages/92b2ee/"},{name:"v-551313d7",path:"/pages/9b3c80/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-551313d7").then(t)}},{path:"/pages/9b3c80/index.html",redirect:"/pages/9b3c80/"},{path:"/06.动态/",redirect:"/pages/9b3c80/"},{name:"v-61d0fb85",path:"/blog/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-61d0fb85").then(t)}},{path:"/blog/index.html",redirect:"/blog/"},{path:"/@pages/archivesPage.html",redirect:"/blog/"},{name:"v-a11d1cc4",path:"/",component:Ac,beforeEnter:(e,n,t)=>{hs("Layout","v-a11d1cc4").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:Ac}],Lc={title:"Echo 系统设计之美",description:"将系统设计技能提升到一个新水平所需的一切",base:"/",headTags:[["link",{rel:"icon",href:"/img/favicon.ico"}],["meta",{name:"theme-color",content:"#11a8cd"}]],pages:[{title:"布隆过滤",frontmatter:{title:"布隆过滤",date:"2024-09-14T03:52:03.000Z",permalink:"/pages/fccd91/"},regularPath:"/01.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95/01.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95/01.%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4.html",relativePath:"01.系统设计算法/01.系统设计算法/01.布隆过滤.md",key:"v-14d5b00e",path:"/pages/fccd91/",headers:[{level:2,title:"布隆过滤器是什么",slug:"布隆过滤器是什么",normalizedTitle:"布隆过滤器是什么",charIndex:2},{level:3,title:"优点",slug:"优点",normalizedTitle:"优点",charIndex:181},{level:3,title:"缺点",slug:"缺点",normalizedTitle:"缺点",charIndex:311},{level:3,title:"使用场景",slug:"使用场景",normalizedTitle:"使用场景",charIndex:367},{level:2,title:"布隆过滤器的原理",slug:"布隆过滤器的原理",normalizedTitle:"布隆过滤器的原理",charIndex:646},{level:3,title:"数据结构",slug:"数据结构",normalizedTitle:"数据结构",charIndex:295},{level:3,title:"空间计算",slug:"空间计算",normalizedTitle:"空间计算",charIndex:915},{level:3,title:"增加元素",slug:"增加元素",normalizedTitle:"增加元素",charIndex:927},{level:3,title:"查询元素",slug:"查询元素",normalizedTitle:"查询元素",charIndex:198},{level:3,title:"修改元素",slug:"修改元素",normalizedTitle:"修改元素",charIndex:1797},{level:3,title:"删除元素",slug:"删除元素",normalizedTitle:"删除元素",charIndex:358},{level:2,title:"Redis 中的 布隆过滤器",slug:"redis-中的-布隆过滤器",normalizedTitle:"redis 中的 布隆过滤器",charIndex:1933},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:1952}],headersStr:"布隆过滤器是什么 优点 缺点 使用场景 布隆过滤器的原理 数据结构 空间计算 增加元素 查询元素 修改元素 删除元素 Redis 中的 布隆过滤器 参考文献",content:"# 布隆过滤器是什么\n\n布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是 一个很长的二进制向量 和 一系列随机映射函数。布隆过滤器可以用于 检索一个元素是否在一个集合中。\n\n如果还是不太好理解的话，就可以把布隆过滤器理解为一个 set 集合，我们可以通过 add 往里面添加元素，通过 contains 来判断是否包含某个元素\n\n\n# 优点\n\n * 时间复杂度低，增加和查询元素的时间复杂为 O(N)，（N 为哈希函数的个数，通常情况比较小）\n * 保密性强，布隆过滤器不存储元素本身\n * 存储空间小，如果允许存在一定的误判，布隆过滤器是非常节省空间的（相比其他数据结构如Set集合）\n\n\n# 缺点\n\n * 有点一定的误判率，但是可以通过调整参数来降低\n * 无法获取元素本身\n * 很难删除元素\n\n\n# 使用场景\n\n布隆过滤器可以告诉我们 “某样东西一定不存在或者可能存在”，也就是说布隆过滤器说这个数不存在则一定不存，布隆过滤器说这个数存在则可能不存在（误判，后续会讲），利用这个判断是否存在的特点可以做很多有趣的事情。\n\n * 解决 Redis 缓存穿透问题（面试重点）\n * 邮件过滤，使用布隆过滤器来做邮件黑名单过滤\n * 对爬虫网址进行过滤，爬过的不再爬\n * 解决新闻推荐过的不再推荐(类似抖音刷过的往下滑动不再刷到)\n * HBase RocksDB LevelDB 等数据库内置布隆过滤器，用于判断数据是否存在，可以减少数据库的IO请求\n\n\n# 布隆过滤器的原理\n\n\n# 数据结构\n\n布隆过滤器它实际上是 一个很长的二进制向量 和 一系列随机映射函数。以Redis中的布隆过滤器实现为例，Redis 中的布隆过滤器底层是一个大型位数组（二进制数组）+多个无偏hash函数。\n\n\n\n多个无偏hash函数\n\n无偏hash函数就是能把元素的hash值计算的 比较均匀 的hash函数，能使得计算后的元素下标比较均匀的映射到位数组中。能有效减少误差。\n\n如下就是一个简单的布隆过滤器示意图，其中 k1、k2 代表增加的元素，a、b、c即为无偏hash函数，最下层则为二进制数组。\n\n\n\n\n# 空间计算\n\n在布隆过滤器增加元素之前，首先需要初始化布隆过滤器的空间，也就是上面说的二进制数组，除此之外还需要计算无偏hash函数的个数。\n\n布隆过滤器提供了两个参数，分别是预计加入元素的大小 n，运行的错误率 p。\n\n布隆过滤器中有算法根据这两个参数会计算出二进制数组的大小 m，以及无偏hash函数的个数 k。\n\n它们之间的关系比较简单：\n\n如下地址是一个免费的在线布隆过滤器在线计算的网址：\n\n> https://krisives.github.io/bloom-calculator/\n\n\n\n\n# 增加元素\n\n往布隆过滤器增加元素，添加的key需要根据k个无偏hash函数计算得到多个hash值，然后对数组长度进行取模得到数组下标的位置，然后将对应数组下标的位置的值置为1\n\n * 通过k个无偏hash函数计算得到k个hash值\n * 依次取模数组长度，得到数组索引\n * 将计算得到的数组索引下标位置数据修改为1\n\n例如，key = Liziba，无偏hash函数的个数k=3，分别为hash1、hash2、hash3。三个hash函数计算后得到三个数组下标值，并将其值修改为1.\n\n如图所示\n\n\n\n\n# 查询元素\n\n布隆过滤器最大的用处就在于判断某样东西一定不存在或者可能存在，而这个就是查询元素的结果。其查询元素的过程如下：\n\n * 通过 k 个无偏hash函数计算得到 k 个hash值\n * 依次取模数组长度，得到数组索引\n * 判断索引处的值是否全部为 1，如果全部为 1 则存在（这种存在可能是误判），如果存在一个 0 则必定不存在\n\n关于误判，其实非常好理解，hash函数再怎么牛逼，也无法完全避免hash冲突，也就是说可能会存在多个元素计算的hash值是相同的，那么它们取模数组长度后的到的数组索引也是相同的，这就是误判的原因。例如李子捌和李子柒的hash值取模后得到的数组索引都是1，但其实这里只有李子捌，如果此时判断李子柒在不在这里，误判就出现啦！因此布隆过滤器最大的缺点误判只要知道其判断元素是否存在的原理就很容易明白了！\n\n\n# 修改元素\n\n不允许修改\n\n\n# 删除元素\n\n布隆过滤器对元素的删除不太支持，目前有一些变形的特定布隆过滤器支持元素的删除！关于为什么对删除不太支持，其实也非常好理解，hash冲突必然存在，删除肯定是很苦难的！你将 A 的数组下标置为 0，那可能 B 也为受到影响\n\n\n# Redis 中的 布隆过滤器\n\n\n# 参考文献\n\n布隆(Bloom Filter)过滤器——全面讲解，建议收藏-CSDN博客",normalizedContent:"# 布隆过滤器是什么\n\n布隆过滤器（bloom filter）是1970年由布隆提出的。它实际上是 一个很长的二进制向量 和 一系列随机映射函数。布隆过滤器可以用于 检索一个元素是否在一个集合中。\n\n如果还是不太好理解的话，就可以把布隆过滤器理解为一个 set 集合，我们可以通过 add 往里面添加元素，通过 contains 来判断是否包含某个元素\n\n\n# 优点\n\n * 时间复杂度低，增加和查询元素的时间复杂为 o(n)，（n 为哈希函数的个数，通常情况比较小）\n * 保密性强，布隆过滤器不存储元素本身\n * 存储空间小，如果允许存在一定的误判，布隆过滤器是非常节省空间的（相比其他数据结构如set集合）\n\n\n# 缺点\n\n * 有点一定的误判率，但是可以通过调整参数来降低\n * 无法获取元素本身\n * 很难删除元素\n\n\n# 使用场景\n\n布隆过滤器可以告诉我们 “某样东西一定不存在或者可能存在”，也就是说布隆过滤器说这个数不存在则一定不存，布隆过滤器说这个数存在则可能不存在（误判，后续会讲），利用这个判断是否存在的特点可以做很多有趣的事情。\n\n * 解决 redis 缓存穿透问题（面试重点）\n * 邮件过滤，使用布隆过滤器来做邮件黑名单过滤\n * 对爬虫网址进行过滤，爬过的不再爬\n * 解决新闻推荐过的不再推荐(类似抖音刷过的往下滑动不再刷到)\n * hbase rocksdb leveldb 等数据库内置布隆过滤器，用于判断数据是否存在，可以减少数据库的io请求\n\n\n# 布隆过滤器的原理\n\n\n# 数据结构\n\n布隆过滤器它实际上是 一个很长的二进制向量 和 一系列随机映射函数。以redis中的布隆过滤器实现为例，redis 中的布隆过滤器底层是一个大型位数组（二进制数组）+多个无偏hash函数。\n\n\n\n多个无偏hash函数\n\n无偏hash函数就是能把元素的hash值计算的 比较均匀 的hash函数，能使得计算后的元素下标比较均匀的映射到位数组中。能有效减少误差。\n\n如下就是一个简单的布隆过滤器示意图，其中 k1、k2 代表增加的元素，a、b、c即为无偏hash函数，最下层则为二进制数组。\n\n\n\n\n# 空间计算\n\n在布隆过滤器增加元素之前，首先需要初始化布隆过滤器的空间，也就是上面说的二进制数组，除此之外还需要计算无偏hash函数的个数。\n\n布隆过滤器提供了两个参数，分别是预计加入元素的大小 n，运行的错误率 p。\n\n布隆过滤器中有算法根据这两个参数会计算出二进制数组的大小 m，以及无偏hash函数的个数 k。\n\n它们之间的关系比较简单：\n\n如下地址是一个免费的在线布隆过滤器在线计算的网址：\n\n> https://krisives.github.io/bloom-calculator/\n\n\n\n\n# 增加元素\n\n往布隆过滤器增加元素，添加的key需要根据k个无偏hash函数计算得到多个hash值，然后对数组长度进行取模得到数组下标的位置，然后将对应数组下标的位置的值置为1\n\n * 通过k个无偏hash函数计算得到k个hash值\n * 依次取模数组长度，得到数组索引\n * 将计算得到的数组索引下标位置数据修改为1\n\n例如，key = liziba，无偏hash函数的个数k=3，分别为hash1、hash2、hash3。三个hash函数计算后得到三个数组下标值，并将其值修改为1.\n\n如图所示\n\n\n\n\n# 查询元素\n\n布隆过滤器最大的用处就在于判断某样东西一定不存在或者可能存在，而这个就是查询元素的结果。其查询元素的过程如下：\n\n * 通过 k 个无偏hash函数计算得到 k 个hash值\n * 依次取模数组长度，得到数组索引\n * 判断索引处的值是否全部为 1，如果全部为 1 则存在（这种存在可能是误判），如果存在一个 0 则必定不存在\n\n关于误判，其实非常好理解，hash函数再怎么牛逼，也无法完全避免hash冲突，也就是说可能会存在多个元素计算的hash值是相同的，那么它们取模数组长度后的到的数组索引也是相同的，这就是误判的原因。例如李子捌和李子柒的hash值取模后得到的数组索引都是1，但其实这里只有李子捌，如果此时判断李子柒在不在这里，误判就出现啦！因此布隆过滤器最大的缺点误判只要知道其判断元素是否存在的原理就很容易明白了！\n\n\n# 修改元素\n\n不允许修改\n\n\n# 删除元素\n\n布隆过滤器对元素的删除不太支持，目前有一些变形的特定布隆过滤器支持元素的删除！关于为什么对删除不太支持，其实也非常好理解，hash冲突必然存在，删除肯定是很苦难的！你将 a 的数组下标置为 0，那可能 b 也为受到影响\n\n\n# redis 中的 布隆过滤器\n\n\n# 参考文献\n\n布隆(bloom filter)过滤器——全面讲解，建议收藏-csdn博客",charsets:{cjk:!0},lastUpdated:"2024/09/14, 04:51:08",lastUpdatedTimestamp:1726289468e3},{title:"一致性哈希",frontmatter:{title:"一致性哈希",date:"2024-09-14T03:52:03.000Z",permalink:"/pages/1e28a2/"},regularPath:"/01.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95/01.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95/02.%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C.html",relativePath:"01.系统设计算法/01.系统设计算法/02.一致性哈希.md",key:"v-6f4636bc",path:"/pages/1e28a2/",headers:[{level:2,title:"使用普通 hash 算法 (取模算法)",slug:"使用普通-hash-算法-取模算法",normalizedTitle:"使用普通 hash 算法 (取模算法)",charIndex:2},{level:3,title:"普通 hash算法 与 使用场景描述：",slug:"普通-hash算法-与-使用场景描述",normalizedTitle:"普通 hash算法 与 使用场景描述：",charIndex:26},{level:3,title:"缺陷",slug:"缺陷",normalizedTitle:"缺陷",charIndex:801},{level:2,title:"一致性哈希算法",slug:"一致性哈希算法",normalizedTitle:"一致性哈希算法",charIndex:50},{level:3,title:"什么是 一致性 hash 算法",slug:"什么是-一致性-hash-算法",normalizedTitle:"什么是 一致性 hash 算法",charIndex:1158},{level:3,title:"一致性 hash 算法的优点",slug:"一致性-hash-算法的优点",normalizedTitle:"一致性 hash 算法的优点",charIndex:2080},{level:3,title:"hash 环的倾斜与虚拟节点",slug:"hash-环的倾斜与虚拟节点",normalizedTitle:"hash 环的倾斜与虚拟节点",charIndex:2518},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:2917}],headersStr:"使用普通 hash 算法 (取模算法) 普通 hash算法 与 使用场景描述： 缺陷 一致性哈希算法 什么是 一致性 hash 算法 一致性 hash 算法的优点 hash 环的倾斜与虚拟节点 参考文献",content:"# 使用普通 hash 算法 (取模算法)\n\n\n# 普通 hash算法 与 使用场景描述：\n\n在了解一致性哈希算法之前，我们先了解一下缓存中的一个应用场景，了解了这个应用场景之后，再来理解一致性哈希算法，就容易多了，也更能体现出一致性哈希算法的优点，那么，我们先来描述一下这个经典的分布式缓存的应用场景。\n\n假设我们有三台缓存服务器，用于缓存图片，我们为这三台缓存服务器编号为 0号、1号、2号，现在有3万张图片需要缓存，我们希望这些图片被均匀的缓存到这3台服务器上，以便它们能够分摊缓存的压力。也就是说，我们希望每台服务器能够缓存1万张左右的图片，那么我们应该怎样做呢？常见的做法是对缓存项的键进行哈希，将hash后的结果对缓存服务器的数量进行取模操作，通过取模后的结果，决定缓存项将会缓存在哪一台服务器上\n\n我们举例说明，以刚才描述的场景为例，假设图片名称是不重复的，那我们就可以使用图片名称作为访问图片的key，使用如下公式，计算出图片应该存放在哪台服务器上。\n\nhash(图片名称) % N\n\n当我们对同一个图片名称做相同的哈希计算时，得出的结果应该是不变的，如果我们有3台服务器，使用哈希后的结果对3求余，那么余数一定是0、1或者2；如果求余的结果为0， 就把当前图片缓存在0号服务器上，如果余数为1，就缓存在1号服务器上，以此类推；同理，当我们访问任意图片时，只要再次对图片名称进行上述运算，即可得出图片应该存放在哪一台缓存服务器上，我们只要在这一台服务器上查找图片即可，如果图片在对应的服务器上不存在，则证明对应的图片没有被缓存，也不用再去遍历其他缓存服务器了，通过这样的方法，即可将3万张图片随机的分布到3台缓存服务器上了，而且下次访问某张图片时，直接能够判断出该图片应该存在于哪台缓存服务器上，我们暂时称上述算法为 HASH 算法或者取模算法，取模算法的过程可以用下图表示：\n\n\n# 缺陷\n\n上述 HASH 算法时，会出现一些缺陷：如果服务器已经不能满足缓存需求，就需要增加服务器数量，假设我们增加了一台缓存服务器，此时如果仍然使用上述方法对同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来3台服务器时所在的服务器编号不同，因为除数由3变为了4，最终导致所有缓存的位置都要发生改变，也就是说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据；同理，假设突然有一台缓存服务器出现了故障，那么我们则需要将故障机器移除，那么缓存服务器数量从3台变为2台，同样会导致大量缓存在同一时间失效，造成了缓存的雪崩，后端服务器将会承受巨大的压力，整个系统很有可能被压垮。为了解决这种情况，就有了一致性哈希算法。\n\n\n# 一致性哈希算法\n\n\n# 什么是 一致性 hash 算法\n\n一致性哈希算法也是使用取模的方法，但是取模算法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，具体步骤如下：\n\n 1. 一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个虚拟的圆环，称为 Hash 环；\n 2. 接着将各个服务器使用 Hash 函数进行哈希，具体可以选择服务器的IP或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置\n 3. 最后使用算法定位数据访问到相应服务器：将数据key使用相同的函数Hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器\n\n下面我们使用具体案例说明一下一致性哈希算法的具体流程：\n\n步骤一：哈希环的组织\n\n我们将 2^32 想象成一个圆，像钟表一样，钟表的圆可以理解成由60个点组成的圆，而此处我们把这个圆想象成由**2^32个点**组成的圆，示意图如下：\n\n\n\n圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1，我们把这个由 2^32 个点组成的圆环称为hash环。\n\n步骤二：确定服务器在哈希环的位置\n\n哈希算法：hash(服务器的IP) % 2^32\n\n上述公式的计算结果一定是 0 到 2^32-1 之间的整数，那么上图中的 hash 环上必定有一个点与这个整数对应，所以我们可以使用这个整数代表服务器，也就是服务器就可以映射到这个环上，假设我们有 ABC 三台服务器，那么它们在哈希环上的示意图如下：\n\n步骤三：将数据映射到哈希环上\n\n我们还是使用图片的名称作为 key，所以我们使用下面算法将图片映射在哈希环上：hash（图片名称） % 2^32，假设我们有4张图片，映射后的示意图如下，其中橘黄色的点表示图片：\n\n\n\n那么，怎么算出上图中的图片应该被缓存到哪一台服务上面呢？我们只要从图片的位置开始，沿顺时针方向遇到的第一个服务器就是图片存放的服务器了。最终，1号、2号图片将会被缓存到服务器A上，3号图片将会被缓存到服务器B上，4号图片将会被缓存到服务器C上。\n\n\n# 一致性 hash 算法的优点\n\n前面提到，如果简单对服务器数量进行取模，那么当服务器数量发生变化时，会产生缓存的雪崩，从而很有可能导致系统崩溃，而使用一致性哈希算法就可以很好的解决这个问题，因为一致性Hash算法对于节点的增减都只需重定位环空间中的一小部分数据，只有部分缓存会失效，不至于将所有压力都在同一时间集中到后端服务器上，具有较好的容错性和可扩展性。\n\n假设服务器B出现了故障，需要将服务器B移除，那么移除前后的示意图如下图所示\n\n在服务器B未移除时，图片3应该被缓存到服务器B中，可是当服务器B移除以后，按照之前描述的一致性哈希算法的规则，图片3应该被缓存到服务器C中，因为从图片3的位置出发，沿顺时针方向遇到的第一个缓存服务器节点就是服务器C，也就是说，如果服务器B出现故障被移除时，图片3的缓存位置会发生改变，但是，图片4仍然会被缓存到服务器C中，图片1与图片2仍然会被缓存到服务器A中，这与服务器B移除之前并没有任何区别，这就是一致性哈希算法的优点。\n\n\n# hash 环的倾斜与虚拟节点\n\n一致性哈希算法在服务节点太少的情况下，容易因为节点分部不均匀而造成数据倾斜问题，也就是被缓存的对象大部分集中缓存在某一台服务器上，从而出现数据分布不均匀的情况，这种情况就称为 hash 环的倾斜。如下图所示：\n\n\n\n上述左图为理想情况，右图为出现了数据倾斜的情况\n\nhash 环的倾斜在极端情况下，仍然有可能引起系统的崩溃，为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点，一个实际物理节点可以对应多个虚拟节点，虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大，hash环倾斜所带来的影响就越小，同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射。具体做法可以在服务器ip或主机名的后面增加编号来实现，加入虚拟节点以后的hash环如下：\n\n\n# 参考文献\n\n一致性哈希算法原理详解-CSDN博客\n\n白话解析：一致性哈希算法 consistent hashing-朱双印博客 (zsythink.net)",normalizedContent:"# 使用普通 hash 算法 (取模算法)\n\n\n# 普通 hash算法 与 使用场景描述：\n\n在了解一致性哈希算法之前，我们先了解一下缓存中的一个应用场景，了解了这个应用场景之后，再来理解一致性哈希算法，就容易多了，也更能体现出一致性哈希算法的优点，那么，我们先来描述一下这个经典的分布式缓存的应用场景。\n\n假设我们有三台缓存服务器，用于缓存图片，我们为这三台缓存服务器编号为 0号、1号、2号，现在有3万张图片需要缓存，我们希望这些图片被均匀的缓存到这3台服务器上，以便它们能够分摊缓存的压力。也就是说，我们希望每台服务器能够缓存1万张左右的图片，那么我们应该怎样做呢？常见的做法是对缓存项的键进行哈希，将hash后的结果对缓存服务器的数量进行取模操作，通过取模后的结果，决定缓存项将会缓存在哪一台服务器上\n\n我们举例说明，以刚才描述的场景为例，假设图片名称是不重复的，那我们就可以使用图片名称作为访问图片的key，使用如下公式，计算出图片应该存放在哪台服务器上。\n\nhash(图片名称) % n\n\n当我们对同一个图片名称做相同的哈希计算时，得出的结果应该是不变的，如果我们有3台服务器，使用哈希后的结果对3求余，那么余数一定是0、1或者2；如果求余的结果为0， 就把当前图片缓存在0号服务器上，如果余数为1，就缓存在1号服务器上，以此类推；同理，当我们访问任意图片时，只要再次对图片名称进行上述运算，即可得出图片应该存放在哪一台缓存服务器上，我们只要在这一台服务器上查找图片即可，如果图片在对应的服务器上不存在，则证明对应的图片没有被缓存，也不用再去遍历其他缓存服务器了，通过这样的方法，即可将3万张图片随机的分布到3台缓存服务器上了，而且下次访问某张图片时，直接能够判断出该图片应该存在于哪台缓存服务器上，我们暂时称上述算法为 hash 算法或者取模算法，取模算法的过程可以用下图表示：\n\n\n# 缺陷\n\n上述 hash 算法时，会出现一些缺陷：如果服务器已经不能满足缓存需求，就需要增加服务器数量，假设我们增加了一台缓存服务器，此时如果仍然使用上述方法对同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来3台服务器时所在的服务器编号不同，因为除数由3变为了4，最终导致所有缓存的位置都要发生改变，也就是说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据；同理，假设突然有一台缓存服务器出现了故障，那么我们则需要将故障机器移除，那么缓存服务器数量从3台变为2台，同样会导致大量缓存在同一时间失效，造成了缓存的雪崩，后端服务器将会承受巨大的压力，整个系统很有可能被压垮。为了解决这种情况，就有了一致性哈希算法。\n\n\n# 一致性哈希算法\n\n\n# 什么是 一致性 hash 算法\n\n一致性哈希算法也是使用取模的方法，但是取模算法是对服务器的数量进行取模，而一致性哈希算法是对 2^32 取模，具体步骤如下：\n\n 1. 一致性哈希算法将整个哈希值空间按照顺时针方向组织成一个虚拟的圆环，称为 hash 环；\n 2. 接着将各个服务器使用 hash 函数进行哈希，具体可以选择服务器的ip或主机名作为关键字进行哈希，从而确定每台机器在哈希环上的位置\n 3. 最后使用算法定位数据访问到相应服务器：将数据key使用相同的函数hash计算出哈希值，并确定此数据在环上的位置，从此位置沿环顺时针寻找，第一台遇到的服务器就是其应该定位到的服务器\n\n下面我们使用具体案例说明一下一致性哈希算法的具体流程：\n\n步骤一：哈希环的组织\n\n我们将 2^32 想象成一个圆，像钟表一样，钟表的圆可以理解成由60个点组成的圆，而此处我们把这个圆想象成由**2^32个点**组成的圆，示意图如下：\n\n\n\n圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1,也就是说0点左侧的第一个点代表2^32-1，我们把这个由 2^32 个点组成的圆环称为hash环。\n\n步骤二：确定服务器在哈希环的位置\n\n哈希算法：hash(服务器的ip) % 2^32\n\n上述公式的计算结果一定是 0 到 2^32-1 之间的整数，那么上图中的 hash 环上必定有一个点与这个整数对应，所以我们可以使用这个整数代表服务器，也就是服务器就可以映射到这个环上，假设我们有 abc 三台服务器，那么它们在哈希环上的示意图如下：\n\n步骤三：将数据映射到哈希环上\n\n我们还是使用图片的名称作为 key，所以我们使用下面算法将图片映射在哈希环上：hash（图片名称） % 2^32，假设我们有4张图片，映射后的示意图如下，其中橘黄色的点表示图片：\n\n\n\n那么，怎么算出上图中的图片应该被缓存到哪一台服务上面呢？我们只要从图片的位置开始，沿顺时针方向遇到的第一个服务器就是图片存放的服务器了。最终，1号、2号图片将会被缓存到服务器a上，3号图片将会被缓存到服务器b上，4号图片将会被缓存到服务器c上。\n\n\n# 一致性 hash 算法的优点\n\n前面提到，如果简单对服务器数量进行取模，那么当服务器数量发生变化时，会产生缓存的雪崩，从而很有可能导致系统崩溃，而使用一致性哈希算法就可以很好的解决这个问题，因为一致性hash算法对于节点的增减都只需重定位环空间中的一小部分数据，只有部分缓存会失效，不至于将所有压力都在同一时间集中到后端服务器上，具有较好的容错性和可扩展性。\n\n假设服务器b出现了故障，需要将服务器b移除，那么移除前后的示意图如下图所示\n\n在服务器b未移除时，图片3应该被缓存到服务器b中，可是当服务器b移除以后，按照之前描述的一致性哈希算法的规则，图片3应该被缓存到服务器c中，因为从图片3的位置出发，沿顺时针方向遇到的第一个缓存服务器节点就是服务器c，也就是说，如果服务器b出现故障被移除时，图片3的缓存位置会发生改变，但是，图片4仍然会被缓存到服务器c中，图片1与图片2仍然会被缓存到服务器a中，这与服务器b移除之前并没有任何区别，这就是一致性哈希算法的优点。\n\n\n# hash 环的倾斜与虚拟节点\n\n一致性哈希算法在服务节点太少的情况下，容易因为节点分部不均匀而造成数据倾斜问题，也就是被缓存的对象大部分集中缓存在某一台服务器上，从而出现数据分布不均匀的情况，这种情况就称为 hash 环的倾斜。如下图所示：\n\n\n\n上述左图为理想情况，右图为出现了数据倾斜的情况\n\nhash 环的倾斜在极端情况下，仍然有可能引起系统的崩溃，为了解决这种数据倾斜问题，一致性哈希算法引入了虚拟节点机制，即对每一个服务节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点，一个实际物理节点可以对应多个虚拟节点，虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大，hash环倾斜所带来的影响就越小，同时数据定位算法不变，只是多了一步虚拟节点到实际节点的映射。具体做法可以在服务器ip或主机名的后面增加编号来实现，加入虚拟节点以后的hash环如下：\n\n\n# 参考文献\n\n一致性哈希算法原理详解-csdn博客\n\n白话解析：一致性哈希算法 consistent hashing-朱双印博客 (zsythink.net)",charsets:{cjk:!0},lastUpdated:"2024/09/14, 06:13:04",lastUpdatedTimestamp:1726294384e3},{title:"Count-Min Sketch",frontmatter:{title:"Count-Min Sketch",date:"2024-09-14T13:30:19.000Z",permalink:"/pages/8624c5"},regularPath:"/01.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95/01.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95/03.Count-Min%20Sketch.html",relativePath:"01.系统设计算法/01.系统设计算法/03.Count-Min Sketch.md",key:"v-30a03cb6",path:"/pages/8624c5/",headers:[{level:2,title:"如何统计元素出现频率？",slug:"如何统计元素出现频率",normalizedTitle:"如何统计元素出现频率？",charIndex:2},{level:4,title:"hashmap 解决",slug:"hashmap-解决",normalizedTitle:"hashmap 解决",charIndex:82},{level:2,title:"CMS简介",slug:"cms简介",normalizedTitle:"cms简介",charIndex:850},{level:4,title:"举个栗子",slug:"举个栗子",normalizedTitle:"举个栗子",charIndex:1041},{level:2,title:"CMS 的具体实现",slug:"cms-的具体实现",normalizedTitle:"cms 的具体实现",charIndex:1486},{level:2,title:"CMS 的参数选择",slug:"cms-的参数选择",normalizedTitle:"cms 的参数选择",charIndex:2916},{level:2,title:"Count-Mean-Min-Sketch",slug:"count-mean-min-sketch",normalizedTitle:"count-mean-min-sketch",charIndex:3168},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:3878}],headersStr:"如何统计元素出现频率？ hashmap 解决 CMS简介 举个栗子 CMS 的具体实现 CMS 的参数选择 Count-Mean-Min-Sketch 参考文献",content:"# 如何统计元素出现频率？\n\n问题： 如果老板让你统计一个实时的数据流中元素出现的频率，并且准备随时回答某个元素出现的频率，不需要的精确的计数，那该怎么办？\n\n# hashmap 解决\n\n在大数据场景下，比如网页的 TopK 问题，爬虫的是否访问过的问题，都是一种出现频次相关的问题，那么在系统设计的时候，如何选择策略和数据结构去存储相关的数据是最高效合适的呢？\n\n计算元素的出现频次，如果出现与普通的场景下，简单的方案就是用 hashmap 来记录元素出现的次数：\n\n// 用HashMap存储元素及其频率\nHashMap<String, Integer> freq = new HashMap<>();\n\n// 统计频率\nfor (String e : elements) {\n    if (!freq.containsKey(e)) {\n    \tfreq.put(e, 1);\n    } else {\n    \tfreq.put(e, freq.get(e) + 1);\n    }\n}\n\n\n但是这种方式在大量数据流的情况下，如果存在大量唯一元素的情况下，会占用大量的内存，导致其无法应对大数据场景，因此在”时间换空间” 的策略选择中，这里就需要考虑通过时间，或者准确率等其他的因素来换空间。\n\n通常来说，针对大数据场景，会无限扩张的数据结构显然是不适用的，所以希望能用固定的空间来进行计数的管理，同时希望尽量不要影响到运行的时间，换言之，可以牺牲掉一定的准确性，来实现节省空间的效果。\n\n基于上述需求，我们可以想到 Hash 算法：将无限大的空间映射到固定的 size 的输出上；而大数据场景下的 Hash 会遇到冲突会被无限放大的问题\n\n如何解决冲突是最核心的问题\n\n * 基于概率数据结构实现的 Bloom Filter 算法采取多 Hash 的方法来减少冲突\n * 而其衍生出来的 CMS 算法以同样的思想，基于不同的设计，更为适应这种计数场景 下面介绍该方法的具体实现\n\n\n# CMS简介\n\nCount-min Sketch 算法是一个可以用来计数的算法，在数据大小非常大时，一种高效的计数算法，通过牺牲准确性提高的效率。\n\n * 是一个概率数据机构\n\n * 算法效率高\n * 提供计数上线\n\n其中，重要参数包括\n\n * Hash 哈希函数的数量： k\n * 计数表格列的数量： m\n * 内存中用空间： k x m x size of counter\n\n# 举个栗子\n\n我们规定一个 m=5，k=3 的Count-min Sketch，用来计数，其中所有hash函数如下\n\n\n\n注意，所有hash函数的结果需 mod m\n\n下面开始填表，首先初始状态为\n\n\n\n首先，向里面添加字母B，其ASCII码为66，求hash函数的结果为\n\n\n\n因此，表格变为\n\n\n\n接下来，我们查询字母A，其ASCII码为65，求hash函数的结果为\n\n\n\n用这个结果去读表，发现其对应位置均为0，因此字母A最多出现0次，这个值是准确的。\n\n然后，我们在查询字母G，其ASCII码为71，求hash函数的结果为\n\n\n\n用这个结果去读表，发现其对应位置均为1，因此字母G最多出现1次；**出错了！**我们从未向里面添加过字母G，这就是一次collision。Count-min Sketch的确会有这种问题，因为这个模型是从Bloom Filter衍生过来的。所以说Count-min Sketch是一个概率模型，返回的结果是一个上限值（upper-bound）。\n\n\n# CMS 的具体实现\n\n首先第一点，通过 hash 来实现数值空间的转换，通过哈希函数 H 将输入元素 x 映射到一维数组上，通过该 index 的值来判断元素的 Count（是否存在）\n\nfor (char x : input_element)\n{\n\tidx = Hash(x);\n\tarray[idx] += 1;\n}\n\n\n实际上这就是 Bloom Filter 的基础思想，然而无论是定长数组的”有限”还是 Hash 函数本身，都需要考虑冲突问题（两个元素被映射到同一个 index 上），冲突会导致 Count 比真实的大。\n\n于是接下来面临的问题就是：**如何降低冲突的概率？**如何提高计数的准确性（实际上也包含在降低冲突的概率中）\n\n可以参考 Bloom Filter 的策略，其通过多个 Hash 函数来映射同一个数，从而来降低元素的冲突概率（未考虑超大数据场景），进而也能提高计数的准确性，那么我们看一下 bloom filter 方法：\n\n> Bloom Filter 算法解决的是存在性问题，因此只需要一个 01 向量，当且仅当所有 Hash 计算出来的 index 的值都为 1 的时候，这个元素才可能存在；\n\n考虑将该方法向 Count 问题上迁移：\n\n * 计数过程中：使用 n 个 Hash 函数计算 idx{1~n} ，然后 vec[idx[i]] += 1 对count+1\n * 查询过程中：使用 n 个 Hash 函数计算 idx{1~n}，然后取 vec[idx[i]] 的最小值，考虑冲突场景可知，这个最小值>=实际的 count。\n\nint query_count = INT_MAX;\nfor (size_t i=0; i < function_size; ++i){\n\tint idx = Hash[i](query);\n\tint tmp_count = count_set[idx];\n\tquery_count = (tmp_count < query_count)? tmp_count: query_count;\n}\n\n\n实际上取多个 hash 的最小值就是 Count-Min Sketch 的核心，但如果仅是如此很明显有个问题，就是多个 hash 函数算出的多个 idx 会进一步的“污染”计数，得不偿失，导致 Count 更加不准确。\n\n实际上很容易想到，为了通过多个 hash 来减少冲突，并使得多 hash 的索引更加的唯一，最好的办法就是使得每个 hash 对应的计数空间是独立的，也就是将我们的计数空间在拓展成二维数组,其 size 为 depth × width 其中 depth 就代表 hash 函数的个数。\n\n那么假设每个 Hash 函数的冲突概率是 p~i~ 那么优化后的冲突概率就从 min(P~i~) 减小到\n\n\n\nfor (size_t i=0; i<function_size; ++i){\n\tint idx = Hash[i](query);\n\tint tmp_count = count_set[i][idx];\n\tquery_count = (tmp_count < query_count)? tmp_count: query_count;\n}\n\n\n结合了这个二维数组就是完整的 CMS 算法了，最终求得的 count 是实际 Count 的近似值（上界）。\n\n\n# CMS 的参数选择\n\n如果确定使用 CMS，接下来面对的就是计数的精度问题，那么如何选择这个数组的 shape 才能尽可能的减少误差呢？（很明显都是越大越好，那么怎么样是最优/达标的呢）\n\n确定一些变量参数：\n\n\n\n设定误差范围：\n\n\n\n以及结果在这个范围内的概率为:\n\n\n\n那么可以计算出：e 是自然常数\n\n\n\n计算公式来自论文，有效性分析也可以从论文中阅读\n\n> 添加一个新哈希函数以指数级别迅速降低超出边界异常数据的概率；当然，增加矩阵的宽度也可以增加减少冲突的概率，但这个只是线性级别。\n\n\n# Count-Mean-Min-Sketch\n\n由于 Hash 的冲突，CMS 对于低频的元素误差还是太大了，引入噪音对于高频元素可以接受（topk）但是对于低频长尾来说太不准确了，因此有了以下的改进：\n\n * 首先按照 CMS 的流程取出 d 个 sketch\n * 对于每个 hash 估计出一个噪音，噪音为该行的所有整数（除了被查询元素）的平均值\n * 该行的 sketch 减去该行的噪音，作为真正的 sketch\n * 返回 d 个 sketch 的中位数\n\nclass CountMeanMinSketch {\n    // initialization and addition procedures as in CountMinSketch\n    // n is total number of added elements\n    long estimateFrequency(value) {\n        long e[] = new long[d]\n        for(i = 0; i < d; i++) {\n            sketchCounter = estimators[i][ hash(value, i) ]\n            noiseEstimation = (n - sketchCounter) / (m - 1)\n            e[i] = sketchCounter – noiseEstimator\n        }\n        return median(e)\n    }\n}\n\n\n该算法显著改善了在长尾数据上的精确度。\n\n\n# 参考文献\n\nCount-min Sketch 算法 - 知乎 (zhihu.com)\n\nCount_Min Sketch算法 - AikenH Blogs",normalizedContent:"# 如何统计元素出现频率？\n\n问题： 如果老板让你统计一个实时的数据流中元素出现的频率，并且准备随时回答某个元素出现的频率，不需要的精确的计数，那该怎么办？\n\n# hashmap 解决\n\n在大数据场景下，比如网页的 topk 问题，爬虫的是否访问过的问题，都是一种出现频次相关的问题，那么在系统设计的时候，如何选择策略和数据结构去存储相关的数据是最高效合适的呢？\n\n计算元素的出现频次，如果出现与普通的场景下，简单的方案就是用 hashmap 来记录元素出现的次数：\n\n// 用hashmap存储元素及其频率\nhashmap<string, integer> freq = new hashmap<>();\n\n// 统计频率\nfor (string e : elements) {\n    if (!freq.containskey(e)) {\n    \tfreq.put(e, 1);\n    } else {\n    \tfreq.put(e, freq.get(e) + 1);\n    }\n}\n\n\n但是这种方式在大量数据流的情况下，如果存在大量唯一元素的情况下，会占用大量的内存，导致其无法应对大数据场景，因此在”时间换空间” 的策略选择中，这里就需要考虑通过时间，或者准确率等其他的因素来换空间。\n\n通常来说，针对大数据场景，会无限扩张的数据结构显然是不适用的，所以希望能用固定的空间来进行计数的管理，同时希望尽量不要影响到运行的时间，换言之，可以牺牲掉一定的准确性，来实现节省空间的效果。\n\n基于上述需求，我们可以想到 hash 算法：将无限大的空间映射到固定的 size 的输出上；而大数据场景下的 hash 会遇到冲突会被无限放大的问题\n\n如何解决冲突是最核心的问题\n\n * 基于概率数据结构实现的 bloom filter 算法采取多 hash 的方法来减少冲突\n * 而其衍生出来的 cms 算法以同样的思想，基于不同的设计，更为适应这种计数场景 下面介绍该方法的具体实现\n\n\n# cms简介\n\ncount-min sketch 算法是一个可以用来计数的算法，在数据大小非常大时，一种高效的计数算法，通过牺牲准确性提高的效率。\n\n * 是一个概率数据机构\n\n * 算法效率高\n * 提供计数上线\n\n其中，重要参数包括\n\n * hash 哈希函数的数量： k\n * 计数表格列的数量： m\n * 内存中用空间： k x m x size of counter\n\n# 举个栗子\n\n我们规定一个 m=5，k=3 的count-min sketch，用来计数，其中所有hash函数如下\n\n\n\n注意，所有hash函数的结果需 mod m\n\n下面开始填表，首先初始状态为\n\n\n\n首先，向里面添加字母b，其ascii码为66，求hash函数的结果为\n\n\n\n因此，表格变为\n\n\n\n接下来，我们查询字母a，其ascii码为65，求hash函数的结果为\n\n\n\n用这个结果去读表，发现其对应位置均为0，因此字母a最多出现0次，这个值是准确的。\n\n然后，我们在查询字母g，其ascii码为71，求hash函数的结果为\n\n\n\n用这个结果去读表，发现其对应位置均为1，因此字母g最多出现1次；**出错了！**我们从未向里面添加过字母g，这就是一次collision。count-min sketch的确会有这种问题，因为这个模型是从bloom filter衍生过来的。所以说count-min sketch是一个概率模型，返回的结果是一个上限值（upper-bound）。\n\n\n# cms 的具体实现\n\n首先第一点，通过 hash 来实现数值空间的转换，通过哈希函数 h 将输入元素 x 映射到一维数组上，通过该 index 的值来判断元素的 count（是否存在）\n\nfor (char x : input_element)\n{\n\tidx = hash(x);\n\tarray[idx] += 1;\n}\n\n\n实际上这就是 bloom filter 的基础思想，然而无论是定长数组的”有限”还是 hash 函数本身，都需要考虑冲突问题（两个元素被映射到同一个 index 上），冲突会导致 count 比真实的大。\n\n于是接下来面临的问题就是：**如何降低冲突的概率？**如何提高计数的准确性（实际上也包含在降低冲突的概率中）\n\n可以参考 bloom filter 的策略，其通过多个 hash 函数来映射同一个数，从而来降低元素的冲突概率（未考虑超大数据场景），进而也能提高计数的准确性，那么我们看一下 bloom filter 方法：\n\n> bloom filter 算法解决的是存在性问题，因此只需要一个 01 向量，当且仅当所有 hash 计算出来的 index 的值都为 1 的时候，这个元素才可能存在；\n\n考虑将该方法向 count 问题上迁移：\n\n * 计数过程中：使用 n 个 hash 函数计算 idx{1~n} ，然后 vec[idx[i]] += 1 对count+1\n * 查询过程中：使用 n 个 hash 函数计算 idx{1~n}，然后取 vec[idx[i]] 的最小值，考虑冲突场景可知，这个最小值>=实际的 count。\n\nint query_count = int_max;\nfor (size_t i=0; i < function_size; ++i){\n\tint idx = hash[i](query);\n\tint tmp_count = count_set[idx];\n\tquery_count = (tmp_count < query_count)? tmp_count: query_count;\n}\n\n\n实际上取多个 hash 的最小值就是 count-min sketch 的核心，但如果仅是如此很明显有个问题，就是多个 hash 函数算出的多个 idx 会进一步的“污染”计数，得不偿失，导致 count 更加不准确。\n\n实际上很容易想到，为了通过多个 hash 来减少冲突，并使得多 hash 的索引更加的唯一，最好的办法就是使得每个 hash 对应的计数空间是独立的，也就是将我们的计数空间在拓展成二维数组,其 size 为 depth × width 其中 depth 就代表 hash 函数的个数。\n\n那么假设每个 hash 函数的冲突概率是 p~i~ 那么优化后的冲突概率就从 min(p~i~) 减小到\n\n\n\nfor (size_t i=0; i<function_size; ++i){\n\tint idx = hash[i](query);\n\tint tmp_count = count_set[i][idx];\n\tquery_count = (tmp_count < query_count)? tmp_count: query_count;\n}\n\n\n结合了这个二维数组就是完整的 cms 算法了，最终求得的 count 是实际 count 的近似值（上界）。\n\n\n# cms 的参数选择\n\n如果确定使用 cms，接下来面对的就是计数的精度问题，那么如何选择这个数组的 shape 才能尽可能的减少误差呢？（很明显都是越大越好，那么怎么样是最优/达标的呢）\n\n确定一些变量参数：\n\n\n\n设定误差范围：\n\n\n\n以及结果在这个范围内的概率为:\n\n\n\n那么可以计算出：e 是自然常数\n\n\n\n计算公式来自论文，有效性分析也可以从论文中阅读\n\n> 添加一个新哈希函数以指数级别迅速降低超出边界异常数据的概率；当然，增加矩阵的宽度也可以增加减少冲突的概率，但这个只是线性级别。\n\n\n# count-mean-min-sketch\n\n由于 hash 的冲突，cms 对于低频的元素误差还是太大了，引入噪音对于高频元素可以接受（topk）但是对于低频长尾来说太不准确了，因此有了以下的改进：\n\n * 首先按照 cms 的流程取出 d 个 sketch\n * 对于每个 hash 估计出一个噪音，噪音为该行的所有整数（除了被查询元素）的平均值\n * 该行的 sketch 减去该行的噪音，作为真正的 sketch\n * 返回 d 个 sketch 的中位数\n\nclass countmeanminsketch {\n    // initialization and addition procedures as in countminsketch\n    // n is total number of added elements\n    long estimatefrequency(value) {\n        long e[] = new long[d]\n        for(i = 0; i < d; i++) {\n            sketchcounter = estimators[i][ hash(value, i) ]\n            noiseestimation = (n - sketchcounter) / (m - 1)\n            e[i] = sketchcounter – noiseestimator\n        }\n        return median(e)\n    }\n}\n\n\n该算法显著改善了在长尾数据上的精确度。\n\n\n# 参考文献\n\ncount-min sketch 算法 - 知乎 (zhihu.com)\n\ncount_min sketch算法 - aikenh blogs",charsets:{cjk:!0},lastUpdated:"2024/09/14, 08:45:30",lastUpdatedTimestamp:172630353e4},{title:"LRU 算法",frontmatter:{title:"LRU 算法",date:"2024-09-14T16:39:57.000Z",permalink:"/pages/87589a"},regularPath:"/01.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95/01.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95/04.LRU.html",relativePath:"01.系统设计算法/01.系统设计算法/04.LRU.md",key:"v-be411e82",path:"/pages/87589a/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:2},{level:2,title:"基于 HashMap 和 双向链表 实现 LRU",slug:"基于-hashmap-和-双向链表-实现-lru",normalizedTitle:"基于 hashmap 和 双向链表 实现 lru",charIndex:427},{level:2,title:"Redis 如何实现 LRU",slug:"redis-如何实现-lru",normalizedTitle:"redis 如何实现 lru",charIndex:2875},{level:3,title:"一些点子",slug:"一些点子",normalizedTitle:"一些点子",charIndex:2894},{level:3,title:"如何实现",slug:"如何实现",normalizedTitle:"如何实现",charIndex:2881},{level:3,title:"全局 LRU 时钟值的计算",slug:"全局-lru-时钟值的计算",normalizedTitle:"全局 lru 时钟值的计算",charIndex:3985},{level:3,title:"键值对 LRU 时钟值的初始化与更新",slug:"键值对-lru-时钟值的初始化与更新",normalizedTitle:"键值对 lru 时钟值的初始化与更新",charIndex:4065},{level:3,title:"近似 LRU 算法的实际执行",slug:"近似-lru-算法的实际执行",normalizedTitle:"近似 lru 算法的实际执行",charIndex:4135},{level:4,title:"何时触发算法执行？",slug:"何时触发算法执行",normalizedTitle:"何时触发算法执行？",charIndex:10069},{level:4,title:"近似 LRU 算法具体如何执行？",slug:"近似-lru-算法具体如何执行",normalizedTitle:"近似 lru 算法具体如何执行？",charIndex:11265},{level:5,title:"判断当前内存使用情况",slug:"判断当前内存使用情况",normalizedTitle:"判断当前内存使用情况",charIndex:11312},{level:5,title:"更新待淘汰的候选键值对集合",slug:"更新待淘汰的候选键值对集合",normalizedTitle:"更新待淘汰的候选键值对集合",charIndex:11326},{level:5,title:"选择被淘汰的键值对并删除",slug:"选择被淘汰的键值对并删除",normalizedTitle:"选择被淘汰的键值对并删除",charIndex:11343},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:19982},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:20514}],headersStr:"简介 基于 HashMap 和 双向链表 实现 LRU Redis 如何实现 LRU 一些点子 如何实现 全局 LRU 时钟值的计算 键值对 LRU 时钟值的初始化与更新 近似 LRU 算法的实际执行 何时触发算法执行？ 近似 LRU 算法具体如何执行？ 判断当前内存使用情况 更新待淘汰的候选键值对集合 选择被淘汰的键值对并删除 总结 参考文献",content:"# 简介\n\nLRU 是 Least Recently Used 的缩写，即最近最少使用置换算法，最经典的场景是作为虚拟页式存储管理服务的，是根据页面调入内存后的使用情况进行决策了。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似，因此，LRU算法就是将最近最久未使用的页面予以淘汰。\n\n操作系统课程里有学过，在内存不够的场景下，淘汰旧内容的策略。LRU … Least Recent Used，淘汰掉最不经常使用的。可以稍微多补充两句，因为计算机体系结构中，最大的最可靠的存储是硬盘，它容量很大，并且内容可以固化，但是访问速度很慢，所以需要把使用的内容载入内存中；内存速度很快，但是容量有限，并且断电后内容会丢失，并且为了进一步提升性能，还有CPU内部的 L1 Cache，L2 Cache等概念。因为速度越快的地方，它的单位成本越高，容量越小，新的内容不断被载入，旧的内容肯定要被淘汰，所以就有这样的使用背景。\n\n\n# 基于 HashMap 和 双向链表 实现 LRU\n\n146. LRU 缓存 - 力扣（LeetCode）\n\npublic class LRUCache {\n    class DLinkedNode {\n        int key;\n        int value;\n        DLinkedNode prev;\n        DLinkedNode next;\n        public DLinkedNode() {}\n        public DLinkedNode(int _key, int _value) {key = _key; value = _value;}\n    }\n\n    private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();\n    private int size;\n    private int capacity;\n    private DLinkedNode head, tail;\n\n    public LRUCache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        // 使用伪头部和伪尾部节点\n        head = new DLinkedNode();\n        tail = new DLinkedNode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        moveToHead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        DLinkedNode node = cache.get(key);\n        if (node == null) {\n            // 如果 key 不存在，创建一个新的节点\n            DLinkedNode newNode = new DLinkedNode(key, value);\n            // 添加进哈希表\n            cache.put(key, newNode);\n            // 添加至双向链表的头部\n            addToHead(newNode);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                DLinkedNode tail = removeTail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node.value = value;\n            moveToHead(node);\n        }\n    }\n\n    private void addToHead(DLinkedNode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removeNode(DLinkedNode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void moveToHead(DLinkedNode node) {\n        removeNode(node);\n        addToHead(node);\n    }\n\n    private DLinkedNode removeTail() {\n        DLinkedNode res = tail.prev;\n        removeNode(res);\n        return res;\n    }\n}\n\n\nLRU 算法的执行，可以分成三种情况来掌握\n\n * 当有新数据插入时，LRU 算法会把该数据插入到链表头部，同时把原来链表头部的数据及其之后的数据，都向尾部移动一位。\n * 当有数据刚被访问了一次之后，LRU 算法就会把该数据从它在链表中的当前位置，移动到链表头部。同时，把从链表头部到它当前位置的其他数据，都向尾部移动一位。\n * 情况三：当链表长度无法再容纳更多数据时，若再有新数据插入，LRU 算法就会去除链表尾部的数据，这也相当于将数据从缓存中淘汰掉。\n\n\n# Redis 如何实现 LRU\n\n\n# 一些点子\n\n最直观的想法：LRU啊，记录下每个key 最近一次的访问时间（比如unix timestamp），unix timestamp最小的Key，就是最近未使用的，把这个Key移除。看下来一个HashMap就能搞定啊。是的，但是首先需要存储每个Key和它的timestamp。其次，还要比较timestamp得出最小值。代价很大，不现实啊。\n\n第二种方法：换个角度，不记录具体的访问时间点(unix timestamp)，而是记录idle time：idle time越小，意味着是最近被访问的。\n\n> The LRU algorithm evicts the Least Recently Used key, which means the one with the greatest idle time.\n\n\n\n比如A、B、C、D四个Key，A每5s访问一次，B每2s访问一次，C和D每10s访问一次。（一个波浪号代表1s），从上图中可看出：A的空闲时间是2s，B的idle time是1s，C的idle time是5s，D刚刚访问了所以idle time是0s\n\n这里，用一个双向链表(linkedlist)把所有的Key链表起来，如果一个Key被访问了，将就这个Key移到链表的表头，而要移除Key时，直接从表尾移除。\n\n你其实可以发现，如果要严格按照 LRU 算法的基本原理来实现的话，你需要在代码中实现如下内容：\n\n * 要为 Redis 使用最大内存时，可容纳的所有数据维护一个链表；\n * 每当有新数据插入或是现有数据被再次访问时，需要执行多次链表操作。\n\n而假设 Redis 保存的数据比较多的话，那么，这两部分的代码实现，就既需要额外的内存空间来保存链表，还会在访问数据的过程中，让 Redis 受到数据移动和链表操作的开销影响，从而就会降低 Redis 访问性能。\n\n\n# 如何实现\n\n这和 Redis 配置文件 redis.conf 中的两个配置参数有关：\n\n * maxmemory，该配置项设定了 Redis server 可以使用的最大内存容量，一旦 server 使用的实际内存量超出该阈值时，server 就会根据 maxmemory-policy 配置项定义的策略，执行内存淘汰操作；\n * maxmemory-policy，该配置项设定了 Redis server 的内存淘汰策略，主要包括近似 LRU 算法、LFU 算法、按 TTL 值淘汰和随机淘汰等几种算法。\n\n我们把 Redis 对近似 LRU 算法的实现分成三个部分。\n\n * 全局 LRU 时钟值的计算：这部分包括，Redis 源码为了实现近似 LRU 算法的效果，是如何计算全局 LRU 时钟值的，以用来判断数据访问的时效性；\n * 键值对 LRU 时钟值的初始化与更新：这部分包括，Redis 源码在哪些函数中对每个键值对对应的 LRU 时钟值，进行初始化与更新；\n * 近似 LRU 算法的实际执行：这部分包括，Redis 源码具体如何执行近似 LRU 算法，也就是何时触发数据淘汰，以及实际淘汰的机制是怎么实现的。\n\n\n# 全局 LRU 时钟值的计算\n\n虽然 Redis 使用了近似 LRU 算法，但是，这个算法仍然需要区分不同数据的访问时效性，也就是说，Redis 需要知道数据的最近一次访问时间。因此，Redis 就设计了 LRU 时钟来记录数据每次访问的时间戳。\n\n我们在前面中已经了解到，Redis 在源码中对于每个键值对中的值，会使用一个 redisObject 结构体来保存指向值的指针。那么，redisObject 结构体除了记录值的指针以外，它其实还会使用 24 bits 来保存 LRU 时钟信息，对应的是 lru 成员变量。所以这样一来，每个键值对都会把它最近一次被访问的时间戳，记录在 lru 变量当中。\n\ntypedef struct redisObject {\n    unsigned type:4;\n    unsigned encoding:4;\n    unsigned lru:LRU_BITS;  //记录LRU信息，宏定义LRU_BITS是24 bits\n    int refcount;\n    void *ptr;\n} robj;\n\n\n那么，每个键值对的 LRU 时钟值具体是如何计算的呢？其实，Redis server 使用了一个实例级别的全局 LRU 时钟，每个键值对的 LRU 时钟值会根据全局 LRU 时钟进行设置。\n\n这个全局 LRU 时钟保存在了 Redis 全局变量 server 的成员变量 lruclock 中。当 Redis server 启动后，调用 initServerConfig 函数初始化各项参数时，就会对这个全局 LRU 时钟 lruclock 进行设置。具体来说，initServerConfig 函数是调用 getLRUClock 函数，来设置 lruclock 的值，如下所示：\n\n// 调用getLRUClock函数计算全局LRU时钟值\nunsigned int lruclock = getLRUClock();\n//设置lruclock为刚计算的LRU时钟值\natomicSet(server.lruclock,lruclock);\n\n\n所以，全局 LRU 时钟值就是通过 getLRUClock 函数计算得到的。\n\ngetLRUClock 函数是在evict.c文件中实现的，它会调用 mstime 函数（在server.c文件中）获得以毫秒为单位计算的 UNIX 时间戳，然后将这个 UNIX 时间戳除以宏定义 LRU_CLOCK_RESOLUTION。宏定义 LRU_CLOCK_RESOLUTION 是在 server.h 文件中定义的，它表示的是以毫秒为单位的 LRU 时钟精度，也就是以毫秒为单位来表示的 LRU 时钟最小单位。\n\n因为 LRU_CLOCK_RESOLUTION 的默认值是 1000，所以，LRU 时钟精度就是 1000 毫秒，也就是 1 秒。\n\n这样一来，你需要注意的就是，如果一个数据前后两次访问的时间间隔小于 1 秒，那么这两次访问的时间戳就是一样的。因为 LRU 时钟的精度就是 1 秒，它无法区分间隔小于 1 秒的不同时间戳。\n\n了解了宏定义 LRU_CLOCK_RESOLUTION 的含义之后，我们再来看下 getLRUClock 函数中的计算。\n\n 1. 首先，getLRUClock 函数将获得的 UNIX 时间戳，除以 LRU_CLOCK_RESOLUTION 后，就得到了以 LRU 时钟精度来计算的 UNIX 时间戳，也就是当前的 LRU 时钟值。\n 2. 紧接着，getLRUClock 函数会把 LRU 时钟值和宏定义 LRU_CLOCK_MAX 做与运算，其中宏定义 LRU_CLOCK_MAX 表示的是 LRU 时钟能表示的最大值。\n\n/* Return the LRU clock, based on the clock resolution. This is a time\n * in a reduced-bits format that can be used to set and check the\n * object->lru field of redisObject structures. */\nunsigned int getLRUClock(void) {\n    return (mstime()/LRU_CLOCK_RESOLUTION) & LRU_CLOCK_MAX;\n}\n\n\n#define LRU_BITS 24\n#define LRU_CLOCK_MAX ((1<<LRU_BITS)-1) /* Max value of obj->lru */\n#define LRU_CLOCK_RESOLUTION 1000 /* LRU clock resolution in ms */\n\n\n所以现在，你就知道了在默认情况下，全局 LRU 时钟值是以 1 秒为精度来计算的 UNIX 时间戳，并且它是在 initServerConfig 函数中进行了初始化。那么接下来，你可能还会困惑的问题是：在 Redis server 的运行过程中，全局 LRU 时钟值是如何更新的呢？\n\n这就和 Redis server 在事件驱动框架中，定期运行的时间事件所对应的 serverCron 函数有关了。\n\nserverCron 函数作为时间事件的回调函数，本身会按照一定的频率周期性执行，其频率值是由 Redis 配置文件 redis.conf 中的 hz 配置项决定的。hz 配置项的默认值是 10，这表示 serverCron 函数会每 100 毫秒（1 秒 /10 = 100 毫秒）运行一次。\n\n这样，在 serverCron 函数中，全局 LRU 时钟值就会按照这个函数的执行频率，定期调用 getLRUClock 函数进行更新，如下所示：\n\nint serverCron(struct aeEventLoop *eventLoop, long long id, void *clientData) {\n    ...\n    unsigned int lruclock = getLRUClock(); //默认情况下，每100毫秒调用getLRUClock函数更新一次全局LRU时钟值\n    atomicSet(server.lruclock,lruclock); //设置lruclock变量\n    ...\n}\n\n\n所以这样一来，每个键值对就可以从全局 LRU 时钟获取最新的访问时间戳了。\n\n好，那么接下来，我们就来了解下，对于每个键值对来说，它对应的 redisObject 结构体中的 lru 变量，是在哪些函数中进行初始化和更新的。\n\n\n# 键值对 LRU 时钟值的初始化与更新\n\n首先，对于一个键值对来说，它的 LRU 时钟值最初是在这个键值对被创建的时候，进行初始化设置的，这个初始化操作是在 createObject 函数中调用的。createObject 函数实现在object.c文件当中，当 Redis 要创建一个键值对时，就会调用这个函数。\n\nrobj *createObject(int type, void *ptr) {\n    robj *o = zmalloc(sizeof(*o));\n    o->type = type;\n    o->encoding = OBJ_ENCODING_RAW;\n    o->ptr = ptr;\n    o->refcount = 1;\n\n    /* Set the LRU to the current lruclock (minutes resolution), or\n     * alternatively the LFU counter. */\n    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {\n        o->lru = (LFUGetTimeInMinutes()<<8) | LFU_INIT_VAL;\n    } else {\n        o->lru = LRU_CLOCK();\n    }\n    return o;\n}\n\n\n而 createObject 函数除了会给 redisObject 结构体分配内存空间之外，它还会根据我刚才提到的 maxmemory_policy 配置项的值，来初始化设置 redisObject 结构体中的 lru 变量。\n\n具体来说，就是如果 maxmemory_policy 配置为使用 LFU 策略，那么 lru 变量值会被初始化设置为 LFU 算法的计算值。而如果 maxmemory_policy 配置项没有使用 LFU 策略，那么，createObject 函数就会调用 LRU_CLOCK 函数来设置 lru 变量的值，也就是键值对对应的 LRU 时钟值。\n\nLRU_CLOCK 函数是在 evict.c 文件中实现的，它的作用就是返回当前的全局 LRU 时钟值。因为一个键值对一旦被创建，也就相当于有了一次访问，所以它对应的 LRU 时钟值就表示了它的访问时间戳。\n\n/* This function is used to obtain the current LRU clock.\n * If the current resolution is lower than the frequency we refresh the\n * LRU clock (as it should be in production servers) we return the\n * precomputed value, otherwise we need to resort to a system call. */\nunsigned int LRU_CLOCK(void) {\n    unsigned int lruclock;\n    if (1000/server.hz <= LRU_CLOCK_RESOLUTION) {\n        atomicGet(server.lruclock,lruclock);\n    } else {\n        lruclock = getLRUClock();\n    }\n    return lruclock;\n}\n\n\n那么到这里，又出现了一个新的问题：一个键值对的 LRU 时钟值又是在什么时候被再次更新的呢？\n\n其实，只要一个键值对被访问了，它的 LRU 时钟值就会被更新。而当一个键值对被访问时，访问操作最终都会调用 lookupKey 函数。\n\nlookupKey 函数是在db.c文件中实现的，它会从全局哈希表中查找要访问的键值对。如果该键值对存在，那么 lookupKey 函数就会根据 maxmemory_policy 的配置值，来更新键值对的 LRU 时钟值，也就是它的访问时间戳。\n\n而当 maxmemory_policy 没有配置为 LFU 策略时，lookupKey 函数就会调用 LRU_CLOCK 函数，来获取当前的全局 LRU 时钟值，并将其赋值给键值对的 redisObject 结构体中的 lru 变量，如下所示：\n\n/* Low level key lookup API, not actually called directly from commands\n * implementations that should instead rely on lookupKeyRead(),\n * lookupKeyWrite() and lookupKeyReadWithFlags(). */\nrobj *lookupKey(redisDb *db, robj *key, int flags) {\n    dictEntry *de = dictFind(db->dict,key->ptr);\n    if (de) {\n        // 获取键值对对应的redisObject结构体\n        robj *val = dictGetVal(de);\n\n        /* Update the access time for the ageing algorithm.\n         * Don't do it if we have a saving child, as this will trigger\n         * a copy on write madness. */\n        if (!hasActiveChildProcess() && !(flags & LOOKUP_NOTOUCH)){\n            if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {\n                // 如果使用了LFU策略，更新LFU计数值\n                updateLFU(val);\n            } else {\n                 // 否则，调用LRU_CLOCK函数获取全局LRU时钟值\n                val->lru = LRU_CLOCK();\n            }\n        }\n        return val;\n    } else {\n        return NULL;\n    }\n}\n\n\n这样一来，每个键值对一旦被访问，就能获得最新的访问时间戳了。不过现在，你可能要问了：这些访问时间戳最终是如何被用于近似 LRU 算法，来进行数据淘汰的呢？接下来，我们就来学习下近似 LRU 算法的实际执行过程。\n\n\n# 近似 LRU 算法的实际执行\n\n现在我们已经知道，Redis 之所以实现近似 LRU 算法的目的，是为了减少内存资源和操作时间上的开销。那么在这里，我们其实可以从两个方面来了解近似 LRU 算法的执行过程，分别是：\n\n * 何时触发算法执行？\n * 算法具体如何执行？\n\n# 何时触发算法执行？\n\n首先，近似 LRU 算法的主要逻辑是在 freeMemoryIfNeeded 函数中实现的，而这个函数本身是在 evict.c 文件中实现。\n\nfreeMemoryIfNeeded 函数是被 freeMemoryIfNeededAndSafe 函数（在 evict.c 文件中）调用，而 freeMemoryIfNeededAndSafe 函数又是被 processCommand 函数所调用的。你可以参考下面的图，展示了这三者的调用关系。\n\n\n\n所以，我们看到 processCommand 函数，就应该知道这个函数是 Redis 处理每个命令时都会被调用的。\n\n那么，processCommand 函数在执行的时候，实际上会根据两个条件来判断是否调用 freeMemoryIfNeededAndSafe 函数。\n\n * 条件一：设置了 maxmemory 配置项为非 0 值。\n * 条件二：Lua 脚本没有在超时运行。\n\n如果这两个条件成立，那么 processCommand 函数就会调用 freeMemoryIfNeededAndSafe 函数，如下所示：\n\nif (server.maxmemory && !server.lua_timedout) {\n        int out_of_memory = freeMemoryIfNeededAndSafe() == C_ERR;\n\n\n也就是说，只有在这两个条件都不成立的情况下，freeMemoryIfNeeded 函数才会被调用。下面的代码展示了 freeMemoryIfNeededAndSafe 函数的执行逻辑，你可以看下。\n\n * 条件一：Lua 脚本在超时运行。\n * 条件二：Redis server 正在加载数据。\n\n也就是说，只有在这两个条件都不成立的情况下，freeMemoryIfNeeded 函数才会被调用。下面的代码展示了 freeMemoryIfNeededAndSafe 函数的执行逻辑，你可以看下。\n\nint freeMemoryIfNeededAndSafe(void) {\n    if (server.lua_timedout || server.loading) return C_OK;\n    return freeMemoryIfNeeded();\n}\n\n\n这样，一旦 freeMemoryIfNeeded 函数被调用了，并且 maxmemory-policy 被设置为了 allkeys-lru 或 volatile-lru，那么近似 LRU 算法就开始被触发执行了。接下来，我们就来看下近似 LRU 算法具体是如何执行的，也就是来了解 freeMemoryIfNeeded 函数的主要执行流程。\n\n# 近似 LRU 算法具体如何执行？\n\n近似 LRU 算法的执行可以分成三大步骤，分别是\n\n * 判断当前内存使用情况\n * 更新待淘汰的候选键值对集合\n * 选择被淘汰的键值对并删除\n\n下面我们就依次来看下。\n\n# 判断当前内存使用情况\n\n * 首先，freeMemoryIfNeeded 函数会调用 getMaxmemoryState 函数，评估当前的内存使用情况。getMaxmemoryState 函数是在 evict.c 文件中实现的，它会判断当前 Redis server 使用的内存容量是否超过了 maxmemory 配置的值。\n * 如果当前内存使用量没有超过 maxmemory，那么，getMaxmemoryState 函数会返回 C_OK，紧接着，freeMemoryIfNeeded 函数也会直接返回了。\n\nint freeMemoryIfNeeded(void) {\n    ...\n    if (getMaxmemoryState(&mem_reported,NULL,&mem_tofree,NULL) == C_OK)\n            return C_OK;\n    ...\n}\n\n\n这里，你需要注意的是，getMaxmemoryState 函数在评估当前内存使用情况的时候，如果发现已用内存超出了 maxmemory，它就会计算需要释放的内存量。这个释放的内存大小等于已使用的内存量减去 maxmemory。不过，已使用的内存量并不包括用于主从复制的复制缓冲区大小，这是 getMaxmemoryState 函数，通过调用 freeMemoryGetNotCountedMemory 函数来计算的。\n\n/* Get the memory status from the point of view of the maxmemory directive:\n * if the memory used is under the maxmemory setting then C_OK is returned.\n * Otherwise, if we are over the memory limit, the function returns\n * C_ERR.\n *\n * The function may return additional info via reference, only if the\n * pointers to the respective arguments is not NULL. Certain fields are\n * populated only when C_ERR is returned:\n *\n *  'total'     total amount of bytes used.\n *              (Populated both for C_ERR and C_OK)\n *\n *  'logical'   the amount of memory used minus the slaves/AOF buffers.\n *              (Populated when C_ERR is returned)\n *\n *  'tofree'    the amount of memory that should be released\n *              in order to return back into the memory limits.\n *              (Populated when C_ERR is returned)\n *\n *  'level'     this usually ranges from 0 to 1, and reports the amount of\n *              memory currently used. May be > 1 if we are over the memory\n *              limit.\n *              (Populated both for C_ERR and C_OK)\n */\nint getMaxmemoryState(size_t *total, size_t *logical, size_t *tofree, float *level) {\n    size_t mem_reported, mem_used, mem_tofree;\n\n    /* Check if we are over the memory usage limit. If we are not, no need\n     * to subtract the slaves output buffers. We can just return ASAP. */\n    // 计算已使用的内存量\n    mem_reported = zmalloc_used_memory();\n    if (total) *total = mem_reported;\n\n    /* We may return ASAP if there is no need to compute the level. */\n    int return_ok_asap = !server.maxmemory || mem_reported <= server.maxmemory;\n    if (return_ok_asap && !level) return C_OK;\n\n    /* Remove the size of slaves output buffers and AOF buffer from the\n     * count of used memory. */\n    // 将用于主从复制的复制缓冲区大小和AOF缓冲区大小从已使用内存量中扣除\n    mem_used = mem_reported;\n    size_t overhead = freeMemoryGetNotCountedMemory();\n    mem_used = (mem_used > overhead) ? mem_used-overhead : 0;\n\n\n    /* Compute the ratio of memory usage. */\n    // 计算内存使用率。\n    if (level) {\n        if (!server.maxmemory) {\n            *level = 0;\n        } else {\n            *level = (float)mem_used / (float)server.maxmemory;\n        }\n    }\n\n    if (return_ok_asap) return C_OK;\n\n    /* Check if we are still over the memory limit. */\n    // 检查我们是否仍然超过内存限制。\n    if (mem_used <= server.maxmemory) return C_OK;\n\n    // 计算需要释放的内存量\n    /* Compute how much memory we need to free. */\n    mem_tofree = mem_used - server.maxmemory;\n\n    if (logical) *logical = mem_used;\n    if (tofree) *tofree = mem_tofree;\n\n    return C_ERR;\n}\n\n\n而如果当前 server 使用的内存量，的确已经超出 maxmemory 的上限了，那么 freeMemoryIfNeeded 函数就会执行一个 while 循环，来淘汰数据释放内存。\n\n其实，为了淘汰数据，Redis 定义了一个数组 EvictionPoolLRU，用来保存待淘汰的候选键值对。这个数组的元素类型是 evictionPoolEntry 结构体，该结构体保存了待淘汰键值对的空闲时间 idle、对应的 key 等信息。以下代码展示了 EvictionPoolLRU 数组和 evictionPoolEntry 结构体，它们都是在 evict.c 文件中定义的。\n\nstruct evictionPoolEntry {\n    // 待淘汰的键值对的空闲时间\n    unsigned long long idle;    /* Object idle time (inverse frequency for LFU) */\n    // 待淘汰的键值对的key\n    sds key;                    /* Key name. */\n    // 缓存的SDS对象\n    sds cached;                 /* Cached SDS object for key name. */\n    // 待淘汰键值对的key所在的数据库ID\n    int dbid;                   /* Key DB number. */\n};\n\nstatic struct evictionPoolEntry *EvictionPoolLRU;\n\n\n这样，Redis server 在执行 initSever 函数进行初始化时，会调用 evictionPoolAlloc 函数（在 evict.c 文件中）为 EvictionPoolLRU 数组分配内存空间，该数组的大小由宏定义 EVPOOL_SIZE（在 evict.c 文件中）决定，默认是 16 个元素，也就是可以保存 16 个待淘汰的候选键值对。\n\n#define EVPOOL_SIZE 16\n\n/* Create a new eviction pool. */\nvoid evictionPoolAlloc(void) {\n    struct evictionPoolEntry *ep;\n    int j;\n\n    ep = zmalloc(sizeof(*ep)*EVPOOL_SIZE);\n    for (j = 0; j < EVPOOL_SIZE; j++) {\n        ep[j].idle = 0;\n        ep[j].key = NULL;\n        ep[j].cached = sdsnewlen(NULL,EVPOOL_CACHED_SDS_SIZE);\n        ep[j].dbid = 0;\n    }\n    EvictionPoolLRU = ep;\n}\n\n\n那么，freeMemoryIfNeeded 函数在淘汰数据的循环流程中，就会更新这个待淘汰的候选键值对集合，也就是 EvictionPoolLRU 数组。下面我就来给你具体介绍一下。\n\n# 更新待淘汰的候选键值对集合\n\n首先，freeMemoryIfNeeded 函数会调用 evictionPoolPopulate 函数（在 evict.c 文件中），而 evictionPoolPopulate 函数会先调用 dictGetSomeKeys 函数（在 dict.c 文件中），从待采样的哈希表中随机获取一定数量的 key。不过，这里还有两个地方你需要注意下。\n\n第一点，dictGetSomeKeys 函数采样的哈希表，是由 maxmemory_policy 配置项来决定的。如果 maxmemory_policy 配置的是 allkeys_lru，那么待采样哈希表就是 Redis server 的全局哈希表，也就是在所有键值对中进行采样；否则，待采样哈希表就是保存着设置了过期时间的 key 的哈希表。\n\n以下代码是 freeMemoryIfNeeded 函数中对 evictionPoolPopulate 函数的调用过程，你可以看下。\n\n/* We don't want to make local-db choices when expiring keys,\n * so to start populate the eviction pool sampling keys from\n * every DB. */\nfor (i = 0; i < server.dbnum; i++) {\n    // 对Redis server上的每一个数据库都执行\n    db = server.db+i;\n    // 根据淘汰策略，决定使用全局哈希表还是设置了过期时间的key的哈希表\n    dict = (server.maxmemory_policy & MAXMEMORY_FLAG_ALLKEYS) ?\n            db->dict : db->expires;\n    // 将选择的哈希表dict传入evictionPoolPopulate函数，同时将全局哈希表也传给evictionPoolPopulate函数\n    if ((keys = dictSize(dict)) != 0) {\n        evictionPoolPopulate(i, dict, db->dict, pool);\n        total_keys += keys;\n    }\n}\n\n\n第二点，dictGetSomeKeys 函数采样的 key 的数量，是由 redis.conf 中的配置项 maxmemory-samples 决定的，该配置项的默认值是 5。下面代码就展示了 evictionPoolPopulate 函数对 dictGetSomeKeys 函数的调用：\n\nvoid evictionPoolPopulate(int dbid, dict *sampledict, dict *keydict, struct evictionPoolEntry *pool) {\n    ...\n    dictEntry *samples[server.maxmemory_samples];  //采样后的集合，大小为maxmemory_samples\n    //将待采样的哈希表sampledict、采样后的集合samples、以及采样数量maxmemory_samples，作为参数传给dictGetSomeKeys\n    count = dictGetSomeKeys(sampledict,samples,server.maxmemory_samples);\n    ...\n}\n\n\n如此一来，dictGetSomeKeys 函数就能返回采样的键值对集合了。然后，evictionPoolPopulate 函数会根据实际采样到的键值对数量 count，执行一个循环。\n\nfor (j = 0; j < count; j++) {\n...\nif (server.maxmemory_policy & MAXMEMORY_FLAG_LRU) {\n            idle = estimateObjectIdleTime(o);\n}\n...\n\n\n紧接着，evictionPoolPopulate 函数会遍历待淘汰的候选键值对集合，也就是 EvictionPoolLRU 数组。在遍历过程中，它会尝试把采样的每一个键值对插入 EvictionPoolLRU 数组，这主要取决于以下两个条件之一：\n\n * 一是，它能在数组中找到一个尚未插入键值对的空位；\n * 二是，它能在数组中找到一个空闲时间小于采样键值对空闲时间的键值对\n\n这两个条件有一个成立的话，evictionPoolPopulate 函数就可以把采样键值对插入 EvictionPoolLRU 数组。等所有采样键值对都处理完后，evictionPoolPopulate 函数就完成对待淘汰候选键值对集合的更新了。\n\n接下来，freeMemoryIfNeeded 函数，就可以开始选择最终被淘汰的键值对了。\n\n# 选择被淘汰的键值对并删除\n\n因为 evictionPoolPopulate 函数已经更新了 EvictionPoolLRU 数组，而且这个数组里面的 key，是按照空闲时间从小到大排好序了。所以，freeMemoryIfNeeded 函数会遍历一次 EvictionPoolLRU 数组，从数组的最后一个 key 开始选择，如果选到的 key 不是空值，那么就把它作为最终淘汰的 key。\n\n// 从数组最后一个key开始查找\n/* Go backward from best to worst element to evict. */\nfor (k = EVPOOL_SIZE-1; k >= 0; k--) {\n    // 当前key为空值，则查找下一个key\n    if (pool[k].key == NULL) continue;\n    bestdbid = pool[k].dbid;\n    // 从全局哈希表或是expire哈希表中，获取当前key对应的键值对；并将当前key从EvictionPoolLRU数组删除\n    if (server.maxmemory_policy & MAXMEMORY_FLAG_ALLKEYS) {\n        de = dictFind(server.db[pool[k].dbid].dict,\n            pool[k].key);\n    } else {\n        de = dictFind(server.db[pool[k].dbid].expires,\n            pool[k].key);\n    }\n\n    /* Remove the entry from the pool. */\n    if (pool[k].key != pool[k].cached)\n        sdsfree(pool[k].key);\n    pool[k].key = NULL;\n    pool[k].idle = 0;\n\n    /* If the key exists, is our pick. Otherwise it is\n     * a ghost and we need to try the next element. */\n    // 如果当前key对应的键值对不为空，选择当前key为被淘汰的key\n    if (de) {\n        bestkey = dictGetKey(de);\n        break;\n    } else {\n        //否则，继续查找下个key\n        /* Ghost... Iterate again. */\n    }\n}\n\n\n最后，一旦选到了被淘汰的 key，freeMemoryIfNeeded 函数就会根据 Redis server 的惰性删除配置，来执行同步删除或异步删除，如下所示：\n\nif (bestkey) {\n    db = server.db+bestdbid;\n    robj *keyobj = createStringObject(bestkey,sdslen(bestkey));        //将删除key的信息传递给从库和AOF文件\n    propagateExpire(db,keyobj,server.lazyfree_lazy_eviction);\n    //如果配置了惰性删除，则进行异步删除\n    if (server.lazyfree_lazy_eviction)\n    \tdbAsyncDelete(db,keyobj);\n    else  //否则进行同步删除\n    \tdbSyncDelete(db,keyobj);\n}\n\n\n好了，到这里，freeMemoryIfNeeded 函数就淘汰了一个 key。而如果此时，释放的内存空间还不够，也就是说没有达到我前面介绍的待释放空间，那么 freeMemoryIfNeeded 函数还会重复执行前面所说的更新待淘汰候选键值对集合、选择最终淘汰 key 的过程，直到满足待释放空间的大小要求。\n\n下图就展示了 freeMemoryIfNeeded 函数涉及的基本流程，你可以再来整体回顾下。\n\n\n\n其实，从刚才介绍的内容中，你就可以看到，近似 LRU 算法并没有使用耗时耗空间的链表，而是使用了固定大小的待淘汰数据集合，每次随机选择一些 key 加入待淘汰数据集合中。最后，再按照待淘汰集合中 key 的空闲时间长度，删除空闲时间最长的 key。这样一来，Redis 就近似实现了 LRU 算法的效果了。\n\n\n# 总结\n\n你现在应该知道了 Redis 是如何实现 LRU 算法来进行缓存数据替换的。其中，我们根据 LRU 算法的基本原理，可以发现如果严格按照原理来实现 LRU 算法，那么开发的系统就需要用额外的内存空间来保存 LRU 链表，而且系统运行时也会受到 LRU 链表操作的开销影响。\n\n而对于 Redis 来说，内存资源和性能都很重要，所以 Redis 实现了近似 LRU 算法。而为了实现近似 LRU 算法，Redis 首先是设置了全局 LRU 时钟，并在键值对创建时获取全局 LRU 时钟值作为访问时间戳，以及在每次访问时获取全局 LRU 时钟值，更新访问时间戳。\n\n然后，当 Redis 每处理一个命令时，都会调用 freeMemoryIfNeeded 函数来判断是否需要释放内存。如果已使用内存超出了 maxmemory，那么，近似 LRU 算法就会随机选择一些键值对，组成待淘汰候选集合，并根据它们的访问时间戳，选出最旧的数据，将其淘汰。\n\nRedis 计算实例内存时，不会把「主从复制」的缓冲区计算在内，也就是说不管一个实例后面挂了多少个从库，主库不会把主从复制所需的「缓冲区」内存，计算到实例内存中，即这部分内存增加，不会对数据淘汰产生影响。\n\n\n# 参考文献\n\nRedis 源码剖析与实战 (geekbang.org)",normalizedContent:"# 简介\n\nlru 是 least recently used 的缩写，即最近最少使用置换算法，最经典的场景是作为虚拟页式存储管理服务的，是根据页面调入内存后的使用情况进行决策了。由于无法预测各页面将来的使用情况，只能利用“最近的过去”作为“最近的将来”的近似，因此，lru算法就是将最近最久未使用的页面予以淘汰。\n\n操作系统课程里有学过，在内存不够的场景下，淘汰旧内容的策略。lru … least recent used，淘汰掉最不经常使用的。可以稍微多补充两句，因为计算机体系结构中，最大的最可靠的存储是硬盘，它容量很大，并且内容可以固化，但是访问速度很慢，所以需要把使用的内容载入内存中；内存速度很快，但是容量有限，并且断电后内容会丢失，并且为了进一步提升性能，还有cpu内部的 l1 cache，l2 cache等概念。因为速度越快的地方，它的单位成本越高，容量越小，新的内容不断被载入，旧的内容肯定要被淘汰，所以就有这样的使用背景。\n\n\n# 基于 hashmap 和 双向链表 实现 lru\n\n146. lru 缓存 - 力扣（leetcode）\n\npublic class lrucache {\n    class dlinkednode {\n        int key;\n        int value;\n        dlinkednode prev;\n        dlinkednode next;\n        public dlinkednode() {}\n        public dlinkednode(int _key, int _value) {key = _key; value = _value;}\n    }\n\n    private map<integer, dlinkednode> cache = new hashmap<integer, dlinkednode>();\n    private int size;\n    private int capacity;\n    private dlinkednode head, tail;\n\n    public lrucache(int capacity) {\n        this.size = 0;\n        this.capacity = capacity;\n        // 使用伪头部和伪尾部节点\n        head = new dlinkednode();\n        tail = new dlinkednode();\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public int get(int key) {\n        dlinkednode node = cache.get(key);\n        if (node == null) {\n            return -1;\n        }\n        // 如果 key 存在，先通过哈希表定位，再移到头部\n        movetohead(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        dlinkednode node = cache.get(key);\n        if (node == null) {\n            // 如果 key 不存在，创建一个新的节点\n            dlinkednode newnode = new dlinkednode(key, value);\n            // 添加进哈希表\n            cache.put(key, newnode);\n            // 添加至双向链表的头部\n            addtohead(newnode);\n            ++size;\n            if (size > capacity) {\n                // 如果超出容量，删除双向链表的尾部节点\n                dlinkednode tail = removetail();\n                // 删除哈希表中对应的项\n                cache.remove(tail.key);\n                --size;\n            }\n        }\n        else {\n            // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n            node.value = value;\n            movetohead(node);\n        }\n    }\n\n    private void addtohead(dlinkednode node) {\n        node.prev = head;\n        node.next = head.next;\n        head.next.prev = node;\n        head.next = node;\n    }\n\n    private void removenode(dlinkednode node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n\n    private void movetohead(dlinkednode node) {\n        removenode(node);\n        addtohead(node);\n    }\n\n    private dlinkednode removetail() {\n        dlinkednode res = tail.prev;\n        removenode(res);\n        return res;\n    }\n}\n\n\nlru 算法的执行，可以分成三种情况来掌握\n\n * 当有新数据插入时，lru 算法会把该数据插入到链表头部，同时把原来链表头部的数据及其之后的数据，都向尾部移动一位。\n * 当有数据刚被访问了一次之后，lru 算法就会把该数据从它在链表中的当前位置，移动到链表头部。同时，把从链表头部到它当前位置的其他数据，都向尾部移动一位。\n * 情况三：当链表长度无法再容纳更多数据时，若再有新数据插入，lru 算法就会去除链表尾部的数据，这也相当于将数据从缓存中淘汰掉。\n\n\n# redis 如何实现 lru\n\n\n# 一些点子\n\n最直观的想法：lru啊，记录下每个key 最近一次的访问时间（比如unix timestamp），unix timestamp最小的key，就是最近未使用的，把这个key移除。看下来一个hashmap就能搞定啊。是的，但是首先需要存储每个key和它的timestamp。其次，还要比较timestamp得出最小值。代价很大，不现实啊。\n\n第二种方法：换个角度，不记录具体的访问时间点(unix timestamp)，而是记录idle time：idle time越小，意味着是最近被访问的。\n\n> the lru algorithm evicts the least recently used key, which means the one with the greatest idle time.\n\n\n\n比如a、b、c、d四个key，a每5s访问一次，b每2s访问一次，c和d每10s访问一次。（一个波浪号代表1s），从上图中可看出：a的空闲时间是2s，b的idle time是1s，c的idle time是5s，d刚刚访问了所以idle time是0s\n\n这里，用一个双向链表(linkedlist)把所有的key链表起来，如果一个key被访问了，将就这个key移到链表的表头，而要移除key时，直接从表尾移除。\n\n你其实可以发现，如果要严格按照 lru 算法的基本原理来实现的话，你需要在代码中实现如下内容：\n\n * 要为 redis 使用最大内存时，可容纳的所有数据维护一个链表；\n * 每当有新数据插入或是现有数据被再次访问时，需要执行多次链表操作。\n\n而假设 redis 保存的数据比较多的话，那么，这两部分的代码实现，就既需要额外的内存空间来保存链表，还会在访问数据的过程中，让 redis 受到数据移动和链表操作的开销影响，从而就会降低 redis 访问性能。\n\n\n# 如何实现\n\n这和 redis 配置文件 redis.conf 中的两个配置参数有关：\n\n * maxmemory，该配置项设定了 redis server 可以使用的最大内存容量，一旦 server 使用的实际内存量超出该阈值时，server 就会根据 maxmemory-policy 配置项定义的策略，执行内存淘汰操作；\n * maxmemory-policy，该配置项设定了 redis server 的内存淘汰策略，主要包括近似 lru 算法、lfu 算法、按 ttl 值淘汰和随机淘汰等几种算法。\n\n我们把 redis 对近似 lru 算法的实现分成三个部分。\n\n * 全局 lru 时钟值的计算：这部分包括，redis 源码为了实现近似 lru 算法的效果，是如何计算全局 lru 时钟值的，以用来判断数据访问的时效性；\n * 键值对 lru 时钟值的初始化与更新：这部分包括，redis 源码在哪些函数中对每个键值对对应的 lru 时钟值，进行初始化与更新；\n * 近似 lru 算法的实际执行：这部分包括，redis 源码具体如何执行近似 lru 算法，也就是何时触发数据淘汰，以及实际淘汰的机制是怎么实现的。\n\n\n# 全局 lru 时钟值的计算\n\n虽然 redis 使用了近似 lru 算法，但是，这个算法仍然需要区分不同数据的访问时效性，也就是说，redis 需要知道数据的最近一次访问时间。因此，redis 就设计了 lru 时钟来记录数据每次访问的时间戳。\n\n我们在前面中已经了解到，redis 在源码中对于每个键值对中的值，会使用一个 redisobject 结构体来保存指向值的指针。那么，redisobject 结构体除了记录值的指针以外，它其实还会使用 24 bits 来保存 lru 时钟信息，对应的是 lru 成员变量。所以这样一来，每个键值对都会把它最近一次被访问的时间戳，记录在 lru 变量当中。\n\ntypedef struct redisobject {\n    unsigned type:4;\n    unsigned encoding:4;\n    unsigned lru:lru_bits;  //记录lru信息，宏定义lru_bits是24 bits\n    int refcount;\n    void *ptr;\n} robj;\n\n\n那么，每个键值对的 lru 时钟值具体是如何计算的呢？其实，redis server 使用了一个实例级别的全局 lru 时钟，每个键值对的 lru 时钟值会根据全局 lru 时钟进行设置。\n\n这个全局 lru 时钟保存在了 redis 全局变量 server 的成员变量 lruclock 中。当 redis server 启动后，调用 initserverconfig 函数初始化各项参数时，就会对这个全局 lru 时钟 lruclock 进行设置。具体来说，initserverconfig 函数是调用 getlruclock 函数，来设置 lruclock 的值，如下所示：\n\n// 调用getlruclock函数计算全局lru时钟值\nunsigned int lruclock = getlruclock();\n//设置lruclock为刚计算的lru时钟值\natomicset(server.lruclock,lruclock);\n\n\n所以，全局 lru 时钟值就是通过 getlruclock 函数计算得到的。\n\ngetlruclock 函数是在evict.c文件中实现的，它会调用 mstime 函数（在server.c文件中）获得以毫秒为单位计算的 unix 时间戳，然后将这个 unix 时间戳除以宏定义 lru_clock_resolution。宏定义 lru_clock_resolution 是在 server.h 文件中定义的，它表示的是以毫秒为单位的 lru 时钟精度，也就是以毫秒为单位来表示的 lru 时钟最小单位。\n\n因为 lru_clock_resolution 的默认值是 1000，所以，lru 时钟精度就是 1000 毫秒，也就是 1 秒。\n\n这样一来，你需要注意的就是，如果一个数据前后两次访问的时间间隔小于 1 秒，那么这两次访问的时间戳就是一样的。因为 lru 时钟的精度就是 1 秒，它无法区分间隔小于 1 秒的不同时间戳。\n\n了解了宏定义 lru_clock_resolution 的含义之后，我们再来看下 getlruclock 函数中的计算。\n\n 1. 首先，getlruclock 函数将获得的 unix 时间戳，除以 lru_clock_resolution 后，就得到了以 lru 时钟精度来计算的 unix 时间戳，也就是当前的 lru 时钟值。\n 2. 紧接着，getlruclock 函数会把 lru 时钟值和宏定义 lru_clock_max 做与运算，其中宏定义 lru_clock_max 表示的是 lru 时钟能表示的最大值。\n\n/* return the lru clock, based on the clock resolution. this is a time\n * in a reduced-bits format that can be used to set and check the\n * object->lru field of redisobject structures. */\nunsigned int getlruclock(void) {\n    return (mstime()/lru_clock_resolution) & lru_clock_max;\n}\n\n\n#define lru_bits 24\n#define lru_clock_max ((1<<lru_bits)-1) /* max value of obj->lru */\n#define lru_clock_resolution 1000 /* lru clock resolution in ms */\n\n\n所以现在，你就知道了在默认情况下，全局 lru 时钟值是以 1 秒为精度来计算的 unix 时间戳，并且它是在 initserverconfig 函数中进行了初始化。那么接下来，你可能还会困惑的问题是：在 redis server 的运行过程中，全局 lru 时钟值是如何更新的呢？\n\n这就和 redis server 在事件驱动框架中，定期运行的时间事件所对应的 servercron 函数有关了。\n\nservercron 函数作为时间事件的回调函数，本身会按照一定的频率周期性执行，其频率值是由 redis 配置文件 redis.conf 中的 hz 配置项决定的。hz 配置项的默认值是 10，这表示 servercron 函数会每 100 毫秒（1 秒 /10 = 100 毫秒）运行一次。\n\n这样，在 servercron 函数中，全局 lru 时钟值就会按照这个函数的执行频率，定期调用 getlruclock 函数进行更新，如下所示：\n\nint servercron(struct aeeventloop *eventloop, long long id, void *clientdata) {\n    ...\n    unsigned int lruclock = getlruclock(); //默认情况下，每100毫秒调用getlruclock函数更新一次全局lru时钟值\n    atomicset(server.lruclock,lruclock); //设置lruclock变量\n    ...\n}\n\n\n所以这样一来，每个键值对就可以从全局 lru 时钟获取最新的访问时间戳了。\n\n好，那么接下来，我们就来了解下，对于每个键值对来说，它对应的 redisobject 结构体中的 lru 变量，是在哪些函数中进行初始化和更新的。\n\n\n# 键值对 lru 时钟值的初始化与更新\n\n首先，对于一个键值对来说，它的 lru 时钟值最初是在这个键值对被创建的时候，进行初始化设置的，这个初始化操作是在 createobject 函数中调用的。createobject 函数实现在object.c文件当中，当 redis 要创建一个键值对时，就会调用这个函数。\n\nrobj *createobject(int type, void *ptr) {\n    robj *o = zmalloc(sizeof(*o));\n    o->type = type;\n    o->encoding = obj_encoding_raw;\n    o->ptr = ptr;\n    o->refcount = 1;\n\n    /* set the lru to the current lruclock (minutes resolution), or\n     * alternatively the lfu counter. */\n    if (server.maxmemory_policy & maxmemory_flag_lfu) {\n        o->lru = (lfugettimeinminutes()<<8) | lfu_init_val;\n    } else {\n        o->lru = lru_clock();\n    }\n    return o;\n}\n\n\n而 createobject 函数除了会给 redisobject 结构体分配内存空间之外，它还会根据我刚才提到的 maxmemory_policy 配置项的值，来初始化设置 redisobject 结构体中的 lru 变量。\n\n具体来说，就是如果 maxmemory_policy 配置为使用 lfu 策略，那么 lru 变量值会被初始化设置为 lfu 算法的计算值。而如果 maxmemory_policy 配置项没有使用 lfu 策略，那么，createobject 函数就会调用 lru_clock 函数来设置 lru 变量的值，也就是键值对对应的 lru 时钟值。\n\nlru_clock 函数是在 evict.c 文件中实现的，它的作用就是返回当前的全局 lru 时钟值。因为一个键值对一旦被创建，也就相当于有了一次访问，所以它对应的 lru 时钟值就表示了它的访问时间戳。\n\n/* this function is used to obtain the current lru clock.\n * if the current resolution is lower than the frequency we refresh the\n * lru clock (as it should be in production servers) we return the\n * precomputed value, otherwise we need to resort to a system call. */\nunsigned int lru_clock(void) {\n    unsigned int lruclock;\n    if (1000/server.hz <= lru_clock_resolution) {\n        atomicget(server.lruclock,lruclock);\n    } else {\n        lruclock = getlruclock();\n    }\n    return lruclock;\n}\n\n\n那么到这里，又出现了一个新的问题：一个键值对的 lru 时钟值又是在什么时候被再次更新的呢？\n\n其实，只要一个键值对被访问了，它的 lru 时钟值就会被更新。而当一个键值对被访问时，访问操作最终都会调用 lookupkey 函数。\n\nlookupkey 函数是在db.c文件中实现的，它会从全局哈希表中查找要访问的键值对。如果该键值对存在，那么 lookupkey 函数就会根据 maxmemory_policy 的配置值，来更新键值对的 lru 时钟值，也就是它的访问时间戳。\n\n而当 maxmemory_policy 没有配置为 lfu 策略时，lookupkey 函数就会调用 lru_clock 函数，来获取当前的全局 lru 时钟值，并将其赋值给键值对的 redisobject 结构体中的 lru 变量，如下所示：\n\n/* low level key lookup api, not actually called directly from commands\n * implementations that should instead rely on lookupkeyread(),\n * lookupkeywrite() and lookupkeyreadwithflags(). */\nrobj *lookupkey(redisdb *db, robj *key, int flags) {\n    dictentry *de = dictfind(db->dict,key->ptr);\n    if (de) {\n        // 获取键值对对应的redisobject结构体\n        robj *val = dictgetval(de);\n\n        /* update the access time for the ageing algorithm.\n         * don't do it if we have a saving child, as this will trigger\n         * a copy on write madness. */\n        if (!hasactivechildprocess() && !(flags & lookup_notouch)){\n            if (server.maxmemory_policy & maxmemory_flag_lfu) {\n                // 如果使用了lfu策略，更新lfu计数值\n                updatelfu(val);\n            } else {\n                 // 否则，调用lru_clock函数获取全局lru时钟值\n                val->lru = lru_clock();\n            }\n        }\n        return val;\n    } else {\n        return null;\n    }\n}\n\n\n这样一来，每个键值对一旦被访问，就能获得最新的访问时间戳了。不过现在，你可能要问了：这些访问时间戳最终是如何被用于近似 lru 算法，来进行数据淘汰的呢？接下来，我们就来学习下近似 lru 算法的实际执行过程。\n\n\n# 近似 lru 算法的实际执行\n\n现在我们已经知道，redis 之所以实现近似 lru 算法的目的，是为了减少内存资源和操作时间上的开销。那么在这里，我们其实可以从两个方面来了解近似 lru 算法的执行过程，分别是：\n\n * 何时触发算法执行？\n * 算法具体如何执行？\n\n# 何时触发算法执行？\n\n首先，近似 lru 算法的主要逻辑是在 freememoryifneeded 函数中实现的，而这个函数本身是在 evict.c 文件中实现。\n\nfreememoryifneeded 函数是被 freememoryifneededandsafe 函数（在 evict.c 文件中）调用，而 freememoryifneededandsafe 函数又是被 processcommand 函数所调用的。你可以参考下面的图，展示了这三者的调用关系。\n\n\n\n所以，我们看到 processcommand 函数，就应该知道这个函数是 redis 处理每个命令时都会被调用的。\n\n那么，processcommand 函数在执行的时候，实际上会根据两个条件来判断是否调用 freememoryifneededandsafe 函数。\n\n * 条件一：设置了 maxmemory 配置项为非 0 值。\n * 条件二：lua 脚本没有在超时运行。\n\n如果这两个条件成立，那么 processcommand 函数就会调用 freememoryifneededandsafe 函数，如下所示：\n\nif (server.maxmemory && !server.lua_timedout) {\n        int out_of_memory = freememoryifneededandsafe() == c_err;\n\n\n也就是说，只有在这两个条件都不成立的情况下，freememoryifneeded 函数才会被调用。下面的代码展示了 freememoryifneededandsafe 函数的执行逻辑，你可以看下。\n\n * 条件一：lua 脚本在超时运行。\n * 条件二：redis server 正在加载数据。\n\n也就是说，只有在这两个条件都不成立的情况下，freememoryifneeded 函数才会被调用。下面的代码展示了 freememoryifneededandsafe 函数的执行逻辑，你可以看下。\n\nint freememoryifneededandsafe(void) {\n    if (server.lua_timedout || server.loading) return c_ok;\n    return freememoryifneeded();\n}\n\n\n这样，一旦 freememoryifneeded 函数被调用了，并且 maxmemory-policy 被设置为了 allkeys-lru 或 volatile-lru，那么近似 lru 算法就开始被触发执行了。接下来，我们就来看下近似 lru 算法具体是如何执行的，也就是来了解 freememoryifneeded 函数的主要执行流程。\n\n# 近似 lru 算法具体如何执行？\n\n近似 lru 算法的执行可以分成三大步骤，分别是\n\n * 判断当前内存使用情况\n * 更新待淘汰的候选键值对集合\n * 选择被淘汰的键值对并删除\n\n下面我们就依次来看下。\n\n# 判断当前内存使用情况\n\n * 首先，freememoryifneeded 函数会调用 getmaxmemorystate 函数，评估当前的内存使用情况。getmaxmemorystate 函数是在 evict.c 文件中实现的，它会判断当前 redis server 使用的内存容量是否超过了 maxmemory 配置的值。\n * 如果当前内存使用量没有超过 maxmemory，那么，getmaxmemorystate 函数会返回 c_ok，紧接着，freememoryifneeded 函数也会直接返回了。\n\nint freememoryifneeded(void) {\n    ...\n    if (getmaxmemorystate(&mem_reported,null,&mem_tofree,null) == c_ok)\n            return c_ok;\n    ...\n}\n\n\n这里，你需要注意的是，getmaxmemorystate 函数在评估当前内存使用情况的时候，如果发现已用内存超出了 maxmemory，它就会计算需要释放的内存量。这个释放的内存大小等于已使用的内存量减去 maxmemory。不过，已使用的内存量并不包括用于主从复制的复制缓冲区大小，这是 getmaxmemorystate 函数，通过调用 freememorygetnotcountedmemory 函数来计算的。\n\n/* get the memory status from the point of view of the maxmemory directive:\n * if the memory used is under the maxmemory setting then c_ok is returned.\n * otherwise, if we are over the memory limit, the function returns\n * c_err.\n *\n * the function may return additional info via reference, only if the\n * pointers to the respective arguments is not null. certain fields are\n * populated only when c_err is returned:\n *\n *  'total'     total amount of bytes used.\n *              (populated both for c_err and c_ok)\n *\n *  'logical'   the amount of memory used minus the slaves/aof buffers.\n *              (populated when c_err is returned)\n *\n *  'tofree'    the amount of memory that should be released\n *              in order to return back into the memory limits.\n *              (populated when c_err is returned)\n *\n *  'level'     this usually ranges from 0 to 1, and reports the amount of\n *              memory currently used. may be > 1 if we are over the memory\n *              limit.\n *              (populated both for c_err and c_ok)\n */\nint getmaxmemorystate(size_t *total, size_t *logical, size_t *tofree, float *level) {\n    size_t mem_reported, mem_used, mem_tofree;\n\n    /* check if we are over the memory usage limit. if we are not, no need\n     * to subtract the slaves output buffers. we can just return asap. */\n    // 计算已使用的内存量\n    mem_reported = zmalloc_used_memory();\n    if (total) *total = mem_reported;\n\n    /* we may return asap if there is no need to compute the level. */\n    int return_ok_asap = !server.maxmemory || mem_reported <= server.maxmemory;\n    if (return_ok_asap && !level) return c_ok;\n\n    /* remove the size of slaves output buffers and aof buffer from the\n     * count of used memory. */\n    // 将用于主从复制的复制缓冲区大小和aof缓冲区大小从已使用内存量中扣除\n    mem_used = mem_reported;\n    size_t overhead = freememorygetnotcountedmemory();\n    mem_used = (mem_used > overhead) ? mem_used-overhead : 0;\n\n\n    /* compute the ratio of memory usage. */\n    // 计算内存使用率。\n    if (level) {\n        if (!server.maxmemory) {\n            *level = 0;\n        } else {\n            *level = (float)mem_used / (float)server.maxmemory;\n        }\n    }\n\n    if (return_ok_asap) return c_ok;\n\n    /* check if we are still over the memory limit. */\n    // 检查我们是否仍然超过内存限制。\n    if (mem_used <= server.maxmemory) return c_ok;\n\n    // 计算需要释放的内存量\n    /* compute how much memory we need to free. */\n    mem_tofree = mem_used - server.maxmemory;\n\n    if (logical) *logical = mem_used;\n    if (tofree) *tofree = mem_tofree;\n\n    return c_err;\n}\n\n\n而如果当前 server 使用的内存量，的确已经超出 maxmemory 的上限了，那么 freememoryifneeded 函数就会执行一个 while 循环，来淘汰数据释放内存。\n\n其实，为了淘汰数据，redis 定义了一个数组 evictionpoollru，用来保存待淘汰的候选键值对。这个数组的元素类型是 evictionpoolentry 结构体，该结构体保存了待淘汰键值对的空闲时间 idle、对应的 key 等信息。以下代码展示了 evictionpoollru 数组和 evictionpoolentry 结构体，它们都是在 evict.c 文件中定义的。\n\nstruct evictionpoolentry {\n    // 待淘汰的键值对的空闲时间\n    unsigned long long idle;    /* object idle time (inverse frequency for lfu) */\n    // 待淘汰的键值对的key\n    sds key;                    /* key name. */\n    // 缓存的sds对象\n    sds cached;                 /* cached sds object for key name. */\n    // 待淘汰键值对的key所在的数据库id\n    int dbid;                   /* key db number. */\n};\n\nstatic struct evictionpoolentry *evictionpoollru;\n\n\n这样，redis server 在执行 initsever 函数进行初始化时，会调用 evictionpoolalloc 函数（在 evict.c 文件中）为 evictionpoollru 数组分配内存空间，该数组的大小由宏定义 evpool_size（在 evict.c 文件中）决定，默认是 16 个元素，也就是可以保存 16 个待淘汰的候选键值对。\n\n#define evpool_size 16\n\n/* create a new eviction pool. */\nvoid evictionpoolalloc(void) {\n    struct evictionpoolentry *ep;\n    int j;\n\n    ep = zmalloc(sizeof(*ep)*evpool_size);\n    for (j = 0; j < evpool_size; j++) {\n        ep[j].idle = 0;\n        ep[j].key = null;\n        ep[j].cached = sdsnewlen(null,evpool_cached_sds_size);\n        ep[j].dbid = 0;\n    }\n    evictionpoollru = ep;\n}\n\n\n那么，freememoryifneeded 函数在淘汰数据的循环流程中，就会更新这个待淘汰的候选键值对集合，也就是 evictionpoollru 数组。下面我就来给你具体介绍一下。\n\n# 更新待淘汰的候选键值对集合\n\n首先，freememoryifneeded 函数会调用 evictionpoolpopulate 函数（在 evict.c 文件中），而 evictionpoolpopulate 函数会先调用 dictgetsomekeys 函数（在 dict.c 文件中），从待采样的哈希表中随机获取一定数量的 key。不过，这里还有两个地方你需要注意下。\n\n第一点，dictgetsomekeys 函数采样的哈希表，是由 maxmemory_policy 配置项来决定的。如果 maxmemory_policy 配置的是 allkeys_lru，那么待采样哈希表就是 redis server 的全局哈希表，也就是在所有键值对中进行采样；否则，待采样哈希表就是保存着设置了过期时间的 key 的哈希表。\n\n以下代码是 freememoryifneeded 函数中对 evictionpoolpopulate 函数的调用过程，你可以看下。\n\n/* we don't want to make local-db choices when expiring keys,\n * so to start populate the eviction pool sampling keys from\n * every db. */\nfor (i = 0; i < server.dbnum; i++) {\n    // 对redis server上的每一个数据库都执行\n    db = server.db+i;\n    // 根据淘汰策略，决定使用全局哈希表还是设置了过期时间的key的哈希表\n    dict = (server.maxmemory_policy & maxmemory_flag_allkeys) ?\n            db->dict : db->expires;\n    // 将选择的哈希表dict传入evictionpoolpopulate函数，同时将全局哈希表也传给evictionpoolpopulate函数\n    if ((keys = dictsize(dict)) != 0) {\n        evictionpoolpopulate(i, dict, db->dict, pool);\n        total_keys += keys;\n    }\n}\n\n\n第二点，dictgetsomekeys 函数采样的 key 的数量，是由 redis.conf 中的配置项 maxmemory-samples 决定的，该配置项的默认值是 5。下面代码就展示了 evictionpoolpopulate 函数对 dictgetsomekeys 函数的调用：\n\nvoid evictionpoolpopulate(int dbid, dict *sampledict, dict *keydict, struct evictionpoolentry *pool) {\n    ...\n    dictentry *samples[server.maxmemory_samples];  //采样后的集合，大小为maxmemory_samples\n    //将待采样的哈希表sampledict、采样后的集合samples、以及采样数量maxmemory_samples，作为参数传给dictgetsomekeys\n    count = dictgetsomekeys(sampledict,samples,server.maxmemory_samples);\n    ...\n}\n\n\n如此一来，dictgetsomekeys 函数就能返回采样的键值对集合了。然后，evictionpoolpopulate 函数会根据实际采样到的键值对数量 count，执行一个循环。\n\nfor (j = 0; j < count; j++) {\n...\nif (server.maxmemory_policy & maxmemory_flag_lru) {\n            idle = estimateobjectidletime(o);\n}\n...\n\n\n紧接着，evictionpoolpopulate 函数会遍历待淘汰的候选键值对集合，也就是 evictionpoollru 数组。在遍历过程中，它会尝试把采样的每一个键值对插入 evictionpoollru 数组，这主要取决于以下两个条件之一：\n\n * 一是，它能在数组中找到一个尚未插入键值对的空位；\n * 二是，它能在数组中找到一个空闲时间小于采样键值对空闲时间的键值对\n\n这两个条件有一个成立的话，evictionpoolpopulate 函数就可以把采样键值对插入 evictionpoollru 数组。等所有采样键值对都处理完后，evictionpoolpopulate 函数就完成对待淘汰候选键值对集合的更新了。\n\n接下来，freememoryifneeded 函数，就可以开始选择最终被淘汰的键值对了。\n\n# 选择被淘汰的键值对并删除\n\n因为 evictionpoolpopulate 函数已经更新了 evictionpoollru 数组，而且这个数组里面的 key，是按照空闲时间从小到大排好序了。所以，freememoryifneeded 函数会遍历一次 evictionpoollru 数组，从数组的最后一个 key 开始选择，如果选到的 key 不是空值，那么就把它作为最终淘汰的 key。\n\n// 从数组最后一个key开始查找\n/* go backward from best to worst element to evict. */\nfor (k = evpool_size-1; k >= 0; k--) {\n    // 当前key为空值，则查找下一个key\n    if (pool[k].key == null) continue;\n    bestdbid = pool[k].dbid;\n    // 从全局哈希表或是expire哈希表中，获取当前key对应的键值对；并将当前key从evictionpoollru数组删除\n    if (server.maxmemory_policy & maxmemory_flag_allkeys) {\n        de = dictfind(server.db[pool[k].dbid].dict,\n            pool[k].key);\n    } else {\n        de = dictfind(server.db[pool[k].dbid].expires,\n            pool[k].key);\n    }\n\n    /* remove the entry from the pool. */\n    if (pool[k].key != pool[k].cached)\n        sdsfree(pool[k].key);\n    pool[k].key = null;\n    pool[k].idle = 0;\n\n    /* if the key exists, is our pick. otherwise it is\n     * a ghost and we need to try the next element. */\n    // 如果当前key对应的键值对不为空，选择当前key为被淘汰的key\n    if (de) {\n        bestkey = dictgetkey(de);\n        break;\n    } else {\n        //否则，继续查找下个key\n        /* ghost... iterate again. */\n    }\n}\n\n\n最后，一旦选到了被淘汰的 key，freememoryifneeded 函数就会根据 redis server 的惰性删除配置，来执行同步删除或异步删除，如下所示：\n\nif (bestkey) {\n    db = server.db+bestdbid;\n    robj *keyobj = createstringobject(bestkey,sdslen(bestkey));        //将删除key的信息传递给从库和aof文件\n    propagateexpire(db,keyobj,server.lazyfree_lazy_eviction);\n    //如果配置了惰性删除，则进行异步删除\n    if (server.lazyfree_lazy_eviction)\n    \tdbasyncdelete(db,keyobj);\n    else  //否则进行同步删除\n    \tdbsyncdelete(db,keyobj);\n}\n\n\n好了，到这里，freememoryifneeded 函数就淘汰了一个 key。而如果此时，释放的内存空间还不够，也就是说没有达到我前面介绍的待释放空间，那么 freememoryifneeded 函数还会重复执行前面所说的更新待淘汰候选键值对集合、选择最终淘汰 key 的过程，直到满足待释放空间的大小要求。\n\n下图就展示了 freememoryifneeded 函数涉及的基本流程，你可以再来整体回顾下。\n\n\n\n其实，从刚才介绍的内容中，你就可以看到，近似 lru 算法并没有使用耗时耗空间的链表，而是使用了固定大小的待淘汰数据集合，每次随机选择一些 key 加入待淘汰数据集合中。最后，再按照待淘汰集合中 key 的空闲时间长度，删除空闲时间最长的 key。这样一来，redis 就近似实现了 lru 算法的效果了。\n\n\n# 总结\n\n你现在应该知道了 redis 是如何实现 lru 算法来进行缓存数据替换的。其中，我们根据 lru 算法的基本原理，可以发现如果严格按照原理来实现 lru 算法，那么开发的系统就需要用额外的内存空间来保存 lru 链表，而且系统运行时也会受到 lru 链表操作的开销影响。\n\n而对于 redis 来说，内存资源和性能都很重要，所以 redis 实现了近似 lru 算法。而为了实现近似 lru 算法，redis 首先是设置了全局 lru 时钟，并在键值对创建时获取全局 lru 时钟值作为访问时间戳，以及在每次访问时获取全局 lru 时钟值，更新访问时间戳。\n\n然后，当 redis 每处理一个命令时，都会调用 freememoryifneeded 函数来判断是否需要释放内存。如果已使用内存超出了 maxmemory，那么，近似 lru 算法就会随机选择一些键值对，组成待淘汰候选集合，并根据它们的访问时间戳，选出最旧的数据，将其淘汰。\n\nredis 计算实例内存时，不会把「主从复制」的缓冲区计算在内，也就是说不管一个实例后面挂了多少个从库，主库不会把主从复制所需的「缓冲区」内存，计算到实例内存中，即这部分内存增加，不会对数据淘汰产生影响。\n\n\n# 参考文献\n\nredis 源码剖析与实战 (geekbang.org)",charsets:{cjk:!0},lastUpdated:"2024/09/14, 11:14:17",lastUpdatedTimestamp:1726312457e3},{title:"LFU",frontmatter:{title:"LFU",date:"2024-09-14T18:14:42.000Z",permalink:"/pages/7d22be/"},regularPath:"/01.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95/01.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95/05.LFU.html",relativePath:"01.系统设计算法/01.系统设计算法/05.LFU.md",key:"v-24d5fda5",path:"/pages/7d22be/",headers:[{level:2,title:"引子",slug:"引子",normalizedTitle:"引子",charIndex:2},{level:2,title:"LFU算法的基本原理",slug:"lfu算法的基本原理",normalizedTitle:"lfu算法的基本原理",charIndex:182},{level:2,title:"LFU算法的实现",slug:"lfu算法的实现",normalizedTitle:"lfu算法的实现",charIndex:648},{level:3,title:"键值对访问频率记录",slug:"键值对访问频率记录",normalizedTitle:"键值对访问频率记录",charIndex:862},{level:3,title:"键值对访问频率的初始化与更新",slug:"键值对访问频率的初始化与更新",normalizedTitle:"键值对访问频率的初始化与更新",charIndex:1303},{level:4,title:"第一步，根据距离上次访问的时长，衰减访问次数。",slug:"第一步-根据距离上次访问的时长-衰减访问次数。",normalizedTitle:"第一步，根据距离上次访问的时长，衰减访问次数。",charIndex:3832},{level:4,title:"第二步，根据当前访问更新访问次数",slug:"第二步-根据当前访问更新访问次数",normalizedTitle:"第二步，根据当前访问更新访问次数",charIndex:6846},{level:4,title:"第三步，更新 lru 变量值",slug:"第三步-更新-lru-变量值",normalizedTitle:"第三步，更新 lru 变量值",charIndex:8610},{level:3,title:"LFU 算法淘汰数据",slug:"lfu-算法淘汰数据",normalizedTitle:"lfu 算法淘汰数据",charIndex:8954},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:9222},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:10702}],headersStr:"引子 LFU算法的基本原理 LFU算法的实现 键值对访问频率记录 键值对访问频率的初始化与更新 第一步，根据距离上次访问的时长，衰减访问次数。 第二步，根据当前访问更新访问次数 第三步，更新 lru 变量值 LFU 算法淘汰数据 总结 参考文献",content:"# 引子\n\nRedis在4.0版本后，还引入了LFU算法，也就是，最不频繁使用（Least Frequently Used，LFU）\n\nLFU算法在进行数据淘汰时，会把最不频繁访问的数据淘汰掉。而LRU算法是把最近最少使用的数据淘汰掉，看起来也是淘汰不频繁访问的数据。\n\nLFU算法和LRU算法的区别到底有哪些呢？我们在实际场景中，需要使用LFU算法吗？\n\n\n# LFU算法的基本原理\n\n因为LFU算法是根据数据访问的频率来选择被淘汰数据的，所以LFU算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。\n\n不过，访问次数和访问频率还不能完全等同。\n\n访问频率是指在一定时间内的访问次数，也就是说，在计算访问频率时，我们不仅需要记录访问次数，还要记录这些访问是在多长时间内执行的。否则，如果只记录访问次数的话，就缺少了时间维度的信息，进而就无法按照频率来淘汰数据了\n\n> 我来给你举个例子，假设数据A在15分钟内访问了15次，数据B在5分钟内访问了10次。如果只是按访问次数来统计的话，数据A的访问次数大于数据B，所以淘汰数据时会优先淘汰数据B。不过，如果按照访问频率来统计的话，数据A的访问频率是1分钟访问1次，而数据B的访问频率是1分钟访问2次，所以按访问频率淘汰数据的话，数据A应该被淘汰掉。 所以说，当要实现LFU算法时，我们需要能统计到数据的访问频率，而不是简单地记录数据访问次数就行。 那么接下来，我们就来学习下Redis是如何实现LFU算法的。\n\n\n# LFU算法的实现\n\n首先，LFU算法的启用，是通过设置Redis配置文件redis.conf中的maxmemory和maxmemory-policy。其中，maxmemory设置为Redis会用的最大内存容量，而maxmemory-policy可以设置为allkeys-lfu或是volatile-lfu，表示淘汰的键值对会分别从所有键值对或是设置了过期时间的键值对中筛选\n\nLFU算法的实现可以分成三部分内容，分别是\n\n * 键值对访问频率记录\n * 键值对访问频率初始化和更新\n * LFU算法淘汰数据\n\n\n# 键值对访问频率记录\n\n每个键值对的值都对应了一个redisObject结构体，其中有一个24 bits的lru变量。lru变量在LRU算法实现时，是用来记录数据的访问时间戳。因为Redis server每次运行时，只能将maxmemory-policy配置项设置为使用一种淘汰策略，所以，LRU算法和LFU算法并不会同时使用。而为了节省内存开销，Redis源码就复用了lru变量来记录LFU算法所需的访问频率信息。\n\n具体来说，当lru变量用来记录LFU算法的所需信息时，它会用24 bits中的低8 bits作为计数器，来记录键值对的访问次数，同时它会用24 bits中的高16 bits，记录访问的时间戳。下图就展示了用来记录访问频率时的lru变量内容，你可以看下。\n\n好，了解了 LFU 算法所需的访问频率是如何记录的，接下来，我们再来看下键值对的访问频率是如何初始化和更新的。\n\n\n# 键值对访问频率的初始化与更新\n\n首先，我们要知道，LFU 算法和 LRU 算法的基本步骤，实际上是在相同的入口函数中执行的。围绕 LRU 算法的实现，我们已经了解到这些基本步骤包括数据访问信息的初始化、访问信息更新，以及实际淘汰数据。这些步骤对应的入口函数如下表所示，你也可以再去回顾下内容。\n\n了解了这些入口函数后，我们再去分析 LFU 算法的实现，就容易找到对应的函数了。\n\n对于键值对访问频率的初始化来说，当一个键值对被创建后，createObject 函数就会被调用，用来分配 redisObject 结构体的空间和设置初始化值。如果 Redis 将 maxmemory-policy 设置为 LFU 算法，那么，键值对 redisObject 结构体中的 lru 变量初始化值，会由两部分组成：\n\n * 第一部分是 lru 变量的高 16 位，是以 1 分钟为精度的 UNIX 时间戳。这是通过调用 LFUGetTimeInMinutes 函数（在 evict.c 文件中）计算得到的。\n * 第二部分是 lru 变量的低 8 位，被设置为宏定义 LFU_INIT_VAL（在server.h文件中），默认值为 5。\n\n你会发现，这和我刚才给你介绍的键值对访问频率记录是一致的，也就是说，当使用 LFU 算法时，lru 变量包括了键值对的访问时间戳和访问次数。以下代码也展示了这部分的执行逻辑，你可以看下。\n\nrobj *createObject(int type, void *ptr) {\n    robj *o = zmalloc(sizeof(*o));\n    o->type = type;\n    o->encoding = OBJ_ENCODING_RAW;\n    o->ptr = ptr;\n    o->refcount = 1;\n\n    /* Set the LRU to the current lruclock (minutes resolution), or\n     * alternatively the LFU counter. */\n    // 使用LFU算法时，lru变量包括以分钟为精度的UNIX时间戳和访问次数5\n    if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {\n        o->lru = (LFUGetTimeInMinutes()<<8) | LFU_INIT_VAL;\n    } else {\n        o->lru = LRU_CLOCK();\n    }\n    return o;\n}\n\n\n/* Return the current time in minutes, just taking the least significant\n * 16 bits. The returned time is suitable to be stored as LDT (last decrement\n * time) for the LFU implementation. */\nunsigned long LFUGetTimeInMinutes(void) {\n    return (server.unixtime/60) & 65535;\n}\n\n\n#define LFU_INIT_VAL 5\n\n\n下面，我们再来看下键值对访问频率的更新。\n\n当一个键值对被访问时，Redis 会调用 lookupKey 函数进行查找。当 maxmemory-policy 设置使用 LFU 算法时，lookupKey 函数会调用 updateLFU 函数来更新键值对的访问频率，也就是 lru 变量值，如下所示：\n\n/* Low level key lookup API, not actually called directly from commands\n * implementations that should instead rely on lookupKeyRead(),\n * lookupKeyWrite() and lookupKeyReadWithFlags(). */\nrobj *lookupKey(redisDb *db, robj *key, int flags) {\n    dictEntry *de = dictFind(db->dict,key->ptr);\n    if (de) {\n        robj *val = dictGetVal(de);\n\n        /* Update the access time for the ageing algorithm.\n         * Don't do it if we have a saving child, as this will trigger\n         * a copy on write madness. */\n        if (!hasActiveChildProcess() && !(flags & LOOKUP_NOTOUCH)){\n            // 使用LFU算法时，调用updateLFU函数更新访问频率\n            if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {\n                updateLFU(val);\n            } else {\n                // 使用LRU算法时，调用LRU_CLOCK\n                val->lru = LRU_CLOCK();\n            }\n        }\n        return val;\n    } else {\n        return NULL;\n    }\n}\n\n\nupdateLFU 函数是在db.c文件中实现的，它的执行逻辑比较明确，一共分成三步。\n\n# 第一步，根据距离上次访问的时长，衰减访问次数。\n\nupdateLFU 函数首先会调用 LFUDecrAndReturn 函数（在 evict.c 文件中），对键值对的访问次数进行衰减操作，如下所示：\n\n/* Update LFU when an object is accessed.\n * Firstly, decrement the counter if the decrement time is reached.\n * Then logarithmically increment the counter, and update the access time. */\nvoid updateLFU(robj *val) {\n    // 首先，递减计数器\n    unsigned long counter = LFUDecrAndReturn(val);\n    // 然后以logN级别递增计数器，并更新访问次数。\n    counter = LFULogIncr(counter);\n    val->lru = (LFUGetTimeInMinutes()<<8) | counter;\n}\n\n\n看到这里，你可能会有疑问：访问键值对时不是要增加键值对的访问次数吗，为什么要先衰减访问次数呢？\n\n其实，这就是我在前面一开始和你介绍的，LFU 算法是根据访问频率来淘汰数据的，而不只是访问次数。访问频率需要考虑键值对的访问是多长时间段内发生的。键值对的先前访问距离当前时间越长，那么这个键值对的访问频率相应地也就会降低。\n\n我给你举个例子，假设数据 A 在时刻 T 到 T+10 分钟这段时间内，被访问了 30 次，那么，这段时间内数据 A 的访问频率可以计算为 3 次 / 分钟（30 次 /10 分钟 = 3 次 / 分钟）。\n\n紧接着，在 T+10 分钟到 T+20 分钟这段时间内，数据 A 没有再被访问，那么此时，如果我们计算数据 A 在 T 到 T+20 分钟这段时间内的访问频率，它的访问频率就会降为 1.5 次 / 分钟（30 次 /20 分钟 = 1.5 次 / 分钟）。以此类推，随着时间的推移，如果数据 A 在 T+10 分钟后一直没有新的访问，那么它的访问频率就会逐步降低。这就是所谓的访问频率衰减。\n\n因为 Redis 是使用 lru 变量中的访问次数来表示访问频率，所以在每次更新键值对的访问频率时，就会通过 LFUDecrAndReturn 函数对访问次数进行衰减。\n\n具体来说，LFUDecrAndReturn 函数会首先获取当前键值对的上一次访问时间，这是保存在 lru 变量高 16 位上的值。然后，LFUDecrAndReturn 函数会根据全局变量 server 的 lru_decay_time 成员变量的取值，来计算衰减的大小 num_period。\n\n这个计算过程会判断 lfu_decay_time 的值是否为 0。如果 lfu_decay_time 值为 0，那么衰减大小也为 0。此时，访问次数不进行衰减。\n\n否则的话，LFUDecrAndReturn 函数会调用 LFUTimeElapsed 函数（在 evict.c 文件中），计算距离键值对的上一次访问已经过去的时长。这个时长也是以 1 分钟为精度来计算的。有了距离上次访问的时长后，LFUDecrAndReturn 函数会把这个时长除以 lfu_decay_time 的值，并把结果作为访问次数的衰减大小。\n\n这里，你需要注意的是，lfu_decay_time 变量值，是由 redis.conf 文件中的配置项 lfu-decay-time 来决定的。Redis 在初始化时，会通过 initServerConfig 函数来设置 lfu_decay_time 变量的值，默认值为 1。所以，在默认情况下，访问次数的衰减大小就是等于上一次访问距离当前的分钟数。比如，假设上一次访问是 10 分钟前，那么在默认情况下，访问次数的衰减大小就等于 10。\n\n当然，如果上一次访问距离当前的分钟数，已经超过访问次数的值了，那么访问次数就会被设置为 0，这就表示键值对已经很长时间没有被访问了。\n\n下面的代码展示了 LFUDecrAndReturn 函数的执行逻辑，你可以看下。\n\n/* If the object decrement time is reached decrement the LFU counter but\n * do not update LFU fields of the object, we update the access time\n * and counter in an explicit way when the object is really accessed.\n * And we will times halve the counter according to the times of\n * elapsed time than server.lfu_decay_time.\n * Return the object frequency counter.\n *\n * This function is used in order to scan the dataset for the best object\n * to fit: as we check for the candidate, we incrementally decrement the\n * counter of the scanned objects if needed. */\nunsigned long LFUDecrAndReturn(robj *o) {\n    // 获取当前键值对的上一次访问时间，lru右移8位，相当于保留的是前面16位的时间戳\n    unsigned long ldt = o->lru >> 8;\n    // 获取当前的访问次数，相当于后8位与255做与运算，即得到计数器\n    unsigned long counter = o->lru & 255;\n    // 计算衰减大小\n    unsigned long num_periods = server.lfu_decay_time ? LFUTimeElapsed(ldt) / server.lfu_decay_time : 0;\n    // 如果衰减大小不为0\n    if (num_periods)\n        // 如果衰减大小小于当前访问次数，那么，衰减后的访问次数是当前访问次数减去衰减大小；否则，衰减后的访问次数等于0\n        counter = (num_periods > counter) ? 0 : counter - num_periods;\n    // 如果衰减大小为0，则返回原来的访问次数\n    return counter;\n}\t\n\n\n好了，到这里，updateLFU 函数就通过 LFUDecrAndReturn 函数，完成了键值对访问次数的衰减。紧接着，updateLFU 函数还是会基于键值对当前的这次访问，来更新它的访问次数。\n\n# 第二步，根据当前访问更新访问次数\n\n在这一步中，updateLFU 函数会调用 LFULogIncr 函数，来增加键值对的访问次数，如下所示：\n\n/* Logarithmically increment a counter. The greater is the current counter value\n * the less likely is that it gets really implemented. Saturate it at 255. */\n// 对数递增计数值\n//核心就是访问次数越大，访问次数被递增的可能性越小，最大 255，此外你可以在配置 redis.conf 中写明访问多少次递增多少。\nuint8_t LFULogIncr(uint8_t counter) {\n    // 到最大值了，不能在增加了\n    if (counter == 255) return 255;\n    //    rand()产生一个0-0x7fff的随机数,一个随机数去除以 RAND_MAX也就是Ox7FFF，也就是随机概率\n    double r = (double)rand()/RAND_MAX;\n    // 减去新对象初始化的基数值 (LFU_INIT_VAL 默认是 5)\n    double baseval = counter - LFU_INIT_VAL;\n    // baseval 如果小于零，说明这个对象快不行了，不过本次 incr 将会延长它的寿命\n    if (baseval < 0) baseval = 0;\n    // baseval * LFU 对数计数器因子 + 1保证分母大于1\n    // 当 baseval 特别大时，最大是 (255-5)，p 值会非常小，很难会走到 counter++ 这一步\n    // p 就是 counter 通往 [+1] 权力的门缝，baseval 越大，这个门缝越窄，通过就越艰难\n    double p = 1.0/(baseval*server.lfu_log_factor+1);\n    // 如果随机概率小于当前计算的访问概率，那么访问次数加1\n    if (r < p) counter++;\n    return counter;\n}\n\n\n * 第一个分支对应了当前访问次数等于最大值 255 的情况。此时，LFULogIncr 函数不再增加访问次数。\n\n * 第二个分支对应了当前访问次数小于 255 的情况。此时，LFULogIncr 函数会计算一个阈值 p，以及一个取值为 0 到 1 之间的随机概率值 r。如果概率 r 小于阈值 p，那么 LFULogIncr 函数才会将访问次数加 1。否则的话，LFULogIncr 函数会返回当前的访问次数，不做更新。\n\n从这里你可以看到，因为概率值 r 是随机定的，所以，阈值 p 的大小就决定了访问次数增加的难度。阈值 p 越小，概率值 r 小于 p 的可能性也越小，此时，访问次数也越难增加；相反，如果阈值 p 越大，概率值 r 小于 p 的可能性就越大，访问次数就越容易增加。\n\n而阈值 p 的值大小，其实是由两个因素决定的。一个是当前访问次数和宏定义 LFU_INIT_VAL 的差值 baseval，另一个是 reids.conf 文件中定义的配置项 lfu-log-factor。\n\n当计算阈值 p 时，我们是把 baseval 和 lfu-log-factor 乘积后，加上 1，然后再取其倒数。所以，baseval 或者 lfu-log-factor 越大，那么其倒数就越小，也就是阈值 p 就越小；反之，阈值 p 就越大。也就是说，这里其实就对应了两种影响因素。\n\n * baseval 的大小：这反映了当前访问次数的多少。比如，访问次数越多的键值对，它的访问次数再增加的难度就会越大；(有点类似指数退避算法)\n * lfu-log-factor 的大小：这是可以被设置的。也就是说，Redis 源码提供了让我们人为调节访问次数增加难度的方法。\n\n这样，等到 LFULogIncr 函数执行完成后，键值对的访问次数就算更新完了。\n\n# 第三步，更新 lru 变量值\n\n最后，到这一步，updateLFU 函数已经完成了键值对访问次数的更新。接着，它就会调用 LFUGetTimeInMinutes 函数，来获取当前的时间戳，并和更新后的访问次数组合，形成最新的访问频率信息，赋值给键值对的 lru 变量，如下所示：\n\n好了，到这里，你就了解了，Redis 源码在更新键值对访问频率时，对于访问次数，它是先按照上次访问距离当前的时长，来对访问次数进行衰减。然后，再按照一定概率增加访问次数。这样的设计方法，就既包含了访问的时间段对访问频率的影响，也避免了 8 bits 计数器对访问次数的影响。而对于访问时间来说，Redis 还会获取最新访问时间戳并更新到 lru 变量中。\n\n那么最后，我们再来看下 Redis 是如何基于 LFU 算法淘汰数据的。\n\n\n# LFU 算法淘汰数据\n\n在实现使用 LFU 算法淘汰数据时，Redis 是采用了和实现近似 LRU 算法相同的方法。也就是说，Redis 会使用一个全局数组 EvictionPoolLRU，来保存待淘汰候选键值对集合。然后，在 processCommand 函数处理每个命令时，它会调用 freeMemoryIfNeededAndSafe 函数和 freeMemoryIfNeeded 函数，来执行具体的数据淘汰流程。\n\n这个淘汰流程我在上篇文章已经给你介绍过了，你可以再去整体回顾下。这里，我也再简要总结下，也就是分成三个步骤：\n\n * 第一步，调用 getMaxmemoryState 函数计算待释放的内存空间；\n * 第二步，调用 evictionPoolPopulate 函数随机采样键值对，并插入到待淘汰集合 EvictionPoolLRU 中；\n * 第三步，遍历待淘汰集合 EvictionPoolLRU，选择实际被淘汰数据，并删除。\n\n虽然这个基本流程和 LRU 算法相同，但是你要注意，LFU 算法在淘汰数据时，在第二步的 evictionPoolPopulate 函数中，使用了不同的方法来计算每个待淘汰键值对的空闲时间\n\n具体来说，在实现 LRU 算法时，待淘汰候选键值对集合 EvictionPoolLRU 中的每个元素，都使用成员变量 idle 来记录它距离上次访问的空闲时间。\n\n而当实现 LFU 算法时，因为 LFU 算法会对访问次数进行衰减和按概率增加，所以，它是使用访问次数来近似表示访问频率的。相应的，LFU 算法其实是用 255 减去键值对的访问次数，这样来计算 EvictionPoolLRU 数组中每个元素的 idle 变量值的。而且，在计算 idle 变量值前，LFU 算法还会调用 LFUDecrAndReturn 函数，衰减一次键值对的访问次数，以便能更加准确地反映实际选择待淘汰数据时，数据的访问频率。\n\n下面的代码展示了 LFU 算法计算 idle 变量值的过程，你可以看下。\n\nif (server.maxmemory_policy & MAXMEMORY_FLAG_LRU) {\n    idle = estimateObjectIdleTime(o);\n} else if (server.maxmemory_policy & MAXMEMORY_FLAG_LFU) {\n    idle = 255-LFUDecrAndReturn(o);\n}\n\n\n所以说，当 LFU 算法按照访问频率，计算了待淘汰键值对集合中每个元素的 idle 值后，键值对访问次数越大，它的 idle 值就越小，反之 idle 值越大。而 EvictionPoolLRU 数组中的元素，是按 idle 值从小到大来排序的。最后当 freeMemoryIfNeeded 函数按照 idle 值从大到小，遍历 EvictionPoolLRU 数组，选择实际被淘汰的键值对时，它就能选出访问次数小的键值对了，也就是把访问频率低的键值对淘汰出去。\n\n这样，Redis 就完成了按访问频率来淘汰数据的操作了。\n\n\n# 总结\n\n 1. LFU 是在 Redis 4.0 新增的淘汰策略，它涉及的巧妙之处在于，其复用了 redisObject 结构的 lru 字段，把这个字段「一分为二」，高16位保存最后访问时间和低8位保存访问次数\n 2. key 的访问次数不能只增不减，它需要根据时间间隔来做衰减，才能达到 LFU 的目的\n 3. 每次在访问一个 key 时，会**「懒惰」**更新这个 key 的访问次数：先衰减访问次数，再更新访问次数\n 4. 衰减访问次数，会根据时间间隔计算，间隔时间越久，衰减越厉害\n 5. 因为 redisObject lru 字段宽度限制，这个访问次数是有上限的（8 bit 最大值 255），所以递增访问次数时，会根据「当前」访问次数和「概率」的方式做递增，访问次数越大，递增因子越大，递增概率越低\n 6. Redis 实现的 LFU 算法也是**「近似」**LFU，是在性能和内存方面平衡的结果\n\n\n# 参考文献\n\nhttps://time.geekbang.org/column/intro/100084301",normalizedContent:"# 引子\n\nredis在4.0版本后，还引入了lfu算法，也就是，最不频繁使用（least frequently used，lfu）\n\nlfu算法在进行数据淘汰时，会把最不频繁访问的数据淘汰掉。而lru算法是把最近最少使用的数据淘汰掉，看起来也是淘汰不频繁访问的数据。\n\nlfu算法和lru算法的区别到底有哪些呢？我们在实际场景中，需要使用lfu算法吗？\n\n\n# lfu算法的基本原理\n\n因为lfu算法是根据数据访问的频率来选择被淘汰数据的，所以lfu算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。\n\n不过，访问次数和访问频率还不能完全等同。\n\n访问频率是指在一定时间内的访问次数，也就是说，在计算访问频率时，我们不仅需要记录访问次数，还要记录这些访问是在多长时间内执行的。否则，如果只记录访问次数的话，就缺少了时间维度的信息，进而就无法按照频率来淘汰数据了\n\n> 我来给你举个例子，假设数据a在15分钟内访问了15次，数据b在5分钟内访问了10次。如果只是按访问次数来统计的话，数据a的访问次数大于数据b，所以淘汰数据时会优先淘汰数据b。不过，如果按照访问频率来统计的话，数据a的访问频率是1分钟访问1次，而数据b的访问频率是1分钟访问2次，所以按访问频率淘汰数据的话，数据a应该被淘汰掉。 所以说，当要实现lfu算法时，我们需要能统计到数据的访问频率，而不是简单地记录数据访问次数就行。 那么接下来，我们就来学习下redis是如何实现lfu算法的。\n\n\n# lfu算法的实现\n\n首先，lfu算法的启用，是通过设置redis配置文件redis.conf中的maxmemory和maxmemory-policy。其中，maxmemory设置为redis会用的最大内存容量，而maxmemory-policy可以设置为allkeys-lfu或是volatile-lfu，表示淘汰的键值对会分别从所有键值对或是设置了过期时间的键值对中筛选\n\nlfu算法的实现可以分成三部分内容，分别是\n\n * 键值对访问频率记录\n * 键值对访问频率初始化和更新\n * lfu算法淘汰数据\n\n\n# 键值对访问频率记录\n\n每个键值对的值都对应了一个redisobject结构体，其中有一个24 bits的lru变量。lru变量在lru算法实现时，是用来记录数据的访问时间戳。因为redis server每次运行时，只能将maxmemory-policy配置项设置为使用一种淘汰策略，所以，lru算法和lfu算法并不会同时使用。而为了节省内存开销，redis源码就复用了lru变量来记录lfu算法所需的访问频率信息。\n\n具体来说，当lru变量用来记录lfu算法的所需信息时，它会用24 bits中的低8 bits作为计数器，来记录键值对的访问次数，同时它会用24 bits中的高16 bits，记录访问的时间戳。下图就展示了用来记录访问频率时的lru变量内容，你可以看下。\n\n好，了解了 lfu 算法所需的访问频率是如何记录的，接下来，我们再来看下键值对的访问频率是如何初始化和更新的。\n\n\n# 键值对访问频率的初始化与更新\n\n首先，我们要知道，lfu 算法和 lru 算法的基本步骤，实际上是在相同的入口函数中执行的。围绕 lru 算法的实现，我们已经了解到这些基本步骤包括数据访问信息的初始化、访问信息更新，以及实际淘汰数据。这些步骤对应的入口函数如下表所示，你也可以再去回顾下内容。\n\n了解了这些入口函数后，我们再去分析 lfu 算法的实现，就容易找到对应的函数了。\n\n对于键值对访问频率的初始化来说，当一个键值对被创建后，createobject 函数就会被调用，用来分配 redisobject 结构体的空间和设置初始化值。如果 redis 将 maxmemory-policy 设置为 lfu 算法，那么，键值对 redisobject 结构体中的 lru 变量初始化值，会由两部分组成：\n\n * 第一部分是 lru 变量的高 16 位，是以 1 分钟为精度的 unix 时间戳。这是通过调用 lfugettimeinminutes 函数（在 evict.c 文件中）计算得到的。\n * 第二部分是 lru 变量的低 8 位，被设置为宏定义 lfu_init_val（在server.h文件中），默认值为 5。\n\n你会发现，这和我刚才给你介绍的键值对访问频率记录是一致的，也就是说，当使用 lfu 算法时，lru 变量包括了键值对的访问时间戳和访问次数。以下代码也展示了这部分的执行逻辑，你可以看下。\n\nrobj *createobject(int type, void *ptr) {\n    robj *o = zmalloc(sizeof(*o));\n    o->type = type;\n    o->encoding = obj_encoding_raw;\n    o->ptr = ptr;\n    o->refcount = 1;\n\n    /* set the lru to the current lruclock (minutes resolution), or\n     * alternatively the lfu counter. */\n    // 使用lfu算法时，lru变量包括以分钟为精度的unix时间戳和访问次数5\n    if (server.maxmemory_policy & maxmemory_flag_lfu) {\n        o->lru = (lfugettimeinminutes()<<8) | lfu_init_val;\n    } else {\n        o->lru = lru_clock();\n    }\n    return o;\n}\n\n\n/* return the current time in minutes, just taking the least significant\n * 16 bits. the returned time is suitable to be stored as ldt (last decrement\n * time) for the lfu implementation. */\nunsigned long lfugettimeinminutes(void) {\n    return (server.unixtime/60) & 65535;\n}\n\n\n#define lfu_init_val 5\n\n\n下面，我们再来看下键值对访问频率的更新。\n\n当一个键值对被访问时，redis 会调用 lookupkey 函数进行查找。当 maxmemory-policy 设置使用 lfu 算法时，lookupkey 函数会调用 updatelfu 函数来更新键值对的访问频率，也就是 lru 变量值，如下所示：\n\n/* low level key lookup api, not actually called directly from commands\n * implementations that should instead rely on lookupkeyread(),\n * lookupkeywrite() and lookupkeyreadwithflags(). */\nrobj *lookupkey(redisdb *db, robj *key, int flags) {\n    dictentry *de = dictfind(db->dict,key->ptr);\n    if (de) {\n        robj *val = dictgetval(de);\n\n        /* update the access time for the ageing algorithm.\n         * don't do it if we have a saving child, as this will trigger\n         * a copy on write madness. */\n        if (!hasactivechildprocess() && !(flags & lookup_notouch)){\n            // 使用lfu算法时，调用updatelfu函数更新访问频率\n            if (server.maxmemory_policy & maxmemory_flag_lfu) {\n                updatelfu(val);\n            } else {\n                // 使用lru算法时，调用lru_clock\n                val->lru = lru_clock();\n            }\n        }\n        return val;\n    } else {\n        return null;\n    }\n}\n\n\nupdatelfu 函数是在db.c文件中实现的，它的执行逻辑比较明确，一共分成三步。\n\n# 第一步，根据距离上次访问的时长，衰减访问次数。\n\nupdatelfu 函数首先会调用 lfudecrandreturn 函数（在 evict.c 文件中），对键值对的访问次数进行衰减操作，如下所示：\n\n/* update lfu when an object is accessed.\n * firstly, decrement the counter if the decrement time is reached.\n * then logarithmically increment the counter, and update the access time. */\nvoid updatelfu(robj *val) {\n    // 首先，递减计数器\n    unsigned long counter = lfudecrandreturn(val);\n    // 然后以logn级别递增计数器，并更新访问次数。\n    counter = lfulogincr(counter);\n    val->lru = (lfugettimeinminutes()<<8) | counter;\n}\n\n\n看到这里，你可能会有疑问：访问键值对时不是要增加键值对的访问次数吗，为什么要先衰减访问次数呢？\n\n其实，这就是我在前面一开始和你介绍的，lfu 算法是根据访问频率来淘汰数据的，而不只是访问次数。访问频率需要考虑键值对的访问是多长时间段内发生的。键值对的先前访问距离当前时间越长，那么这个键值对的访问频率相应地也就会降低。\n\n我给你举个例子，假设数据 a 在时刻 t 到 t+10 分钟这段时间内，被访问了 30 次，那么，这段时间内数据 a 的访问频率可以计算为 3 次 / 分钟（30 次 /10 分钟 = 3 次 / 分钟）。\n\n紧接着，在 t+10 分钟到 t+20 分钟这段时间内，数据 a 没有再被访问，那么此时，如果我们计算数据 a 在 t 到 t+20 分钟这段时间内的访问频率，它的访问频率就会降为 1.5 次 / 分钟（30 次 /20 分钟 = 1.5 次 / 分钟）。以此类推，随着时间的推移，如果数据 a 在 t+10 分钟后一直没有新的访问，那么它的访问频率就会逐步降低。这就是所谓的访问频率衰减。\n\n因为 redis 是使用 lru 变量中的访问次数来表示访问频率，所以在每次更新键值对的访问频率时，就会通过 lfudecrandreturn 函数对访问次数进行衰减。\n\n具体来说，lfudecrandreturn 函数会首先获取当前键值对的上一次访问时间，这是保存在 lru 变量高 16 位上的值。然后，lfudecrandreturn 函数会根据全局变量 server 的 lru_decay_time 成员变量的取值，来计算衰减的大小 num_period。\n\n这个计算过程会判断 lfu_decay_time 的值是否为 0。如果 lfu_decay_time 值为 0，那么衰减大小也为 0。此时，访问次数不进行衰减。\n\n否则的话，lfudecrandreturn 函数会调用 lfutimeelapsed 函数（在 evict.c 文件中），计算距离键值对的上一次访问已经过去的时长。这个时长也是以 1 分钟为精度来计算的。有了距离上次访问的时长后，lfudecrandreturn 函数会把这个时长除以 lfu_decay_time 的值，并把结果作为访问次数的衰减大小。\n\n这里，你需要注意的是，lfu_decay_time 变量值，是由 redis.conf 文件中的配置项 lfu-decay-time 来决定的。redis 在初始化时，会通过 initserverconfig 函数来设置 lfu_decay_time 变量的值，默认值为 1。所以，在默认情况下，访问次数的衰减大小就是等于上一次访问距离当前的分钟数。比如，假设上一次访问是 10 分钟前，那么在默认情况下，访问次数的衰减大小就等于 10。\n\n当然，如果上一次访问距离当前的分钟数，已经超过访问次数的值了，那么访问次数就会被设置为 0，这就表示键值对已经很长时间没有被访问了。\n\n下面的代码展示了 lfudecrandreturn 函数的执行逻辑，你可以看下。\n\n/* if the object decrement time is reached decrement the lfu counter but\n * do not update lfu fields of the object, we update the access time\n * and counter in an explicit way when the object is really accessed.\n * and we will times halve the counter according to the times of\n * elapsed time than server.lfu_decay_time.\n * return the object frequency counter.\n *\n * this function is used in order to scan the dataset for the best object\n * to fit: as we check for the candidate, we incrementally decrement the\n * counter of the scanned objects if needed. */\nunsigned long lfudecrandreturn(robj *o) {\n    // 获取当前键值对的上一次访问时间，lru右移8位，相当于保留的是前面16位的时间戳\n    unsigned long ldt = o->lru >> 8;\n    // 获取当前的访问次数，相当于后8位与255做与运算，即得到计数器\n    unsigned long counter = o->lru & 255;\n    // 计算衰减大小\n    unsigned long num_periods = server.lfu_decay_time ? lfutimeelapsed(ldt) / server.lfu_decay_time : 0;\n    // 如果衰减大小不为0\n    if (num_periods)\n        // 如果衰减大小小于当前访问次数，那么，衰减后的访问次数是当前访问次数减去衰减大小；否则，衰减后的访问次数等于0\n        counter = (num_periods > counter) ? 0 : counter - num_periods;\n    // 如果衰减大小为0，则返回原来的访问次数\n    return counter;\n}\t\n\n\n好了，到这里，updatelfu 函数就通过 lfudecrandreturn 函数，完成了键值对访问次数的衰减。紧接着，updatelfu 函数还是会基于键值对当前的这次访问，来更新它的访问次数。\n\n# 第二步，根据当前访问更新访问次数\n\n在这一步中，updatelfu 函数会调用 lfulogincr 函数，来增加键值对的访问次数，如下所示：\n\n/* logarithmically increment a counter. the greater is the current counter value\n * the less likely is that it gets really implemented. saturate it at 255. */\n// 对数递增计数值\n//核心就是访问次数越大，访问次数被递增的可能性越小，最大 255，此外你可以在配置 redis.conf 中写明访问多少次递增多少。\nuint8_t lfulogincr(uint8_t counter) {\n    // 到最大值了，不能在增加了\n    if (counter == 255) return 255;\n    //    rand()产生一个0-0x7fff的随机数,一个随机数去除以 rand_max也就是ox7fff，也就是随机概率\n    double r = (double)rand()/rand_max;\n    // 减去新对象初始化的基数值 (lfu_init_val 默认是 5)\n    double baseval = counter - lfu_init_val;\n    // baseval 如果小于零，说明这个对象快不行了，不过本次 incr 将会延长它的寿命\n    if (baseval < 0) baseval = 0;\n    // baseval * lfu 对数计数器因子 + 1保证分母大于1\n    // 当 baseval 特别大时，最大是 (255-5)，p 值会非常小，很难会走到 counter++ 这一步\n    // p 就是 counter 通往 [+1] 权力的门缝，baseval 越大，这个门缝越窄，通过就越艰难\n    double p = 1.0/(baseval*server.lfu_log_factor+1);\n    // 如果随机概率小于当前计算的访问概率，那么访问次数加1\n    if (r < p) counter++;\n    return counter;\n}\n\n\n * 第一个分支对应了当前访问次数等于最大值 255 的情况。此时，lfulogincr 函数不再增加访问次数。\n\n * 第二个分支对应了当前访问次数小于 255 的情况。此时，lfulogincr 函数会计算一个阈值 p，以及一个取值为 0 到 1 之间的随机概率值 r。如果概率 r 小于阈值 p，那么 lfulogincr 函数才会将访问次数加 1。否则的话，lfulogincr 函数会返回当前的访问次数，不做更新。\n\n从这里你可以看到，因为概率值 r 是随机定的，所以，阈值 p 的大小就决定了访问次数增加的难度。阈值 p 越小，概率值 r 小于 p 的可能性也越小，此时，访问次数也越难增加；相反，如果阈值 p 越大，概率值 r 小于 p 的可能性就越大，访问次数就越容易增加。\n\n而阈值 p 的值大小，其实是由两个因素决定的。一个是当前访问次数和宏定义 lfu_init_val 的差值 baseval，另一个是 reids.conf 文件中定义的配置项 lfu-log-factor。\n\n当计算阈值 p 时，我们是把 baseval 和 lfu-log-factor 乘积后，加上 1，然后再取其倒数。所以，baseval 或者 lfu-log-factor 越大，那么其倒数就越小，也就是阈值 p 就越小；反之，阈值 p 就越大。也就是说，这里其实就对应了两种影响因素。\n\n * baseval 的大小：这反映了当前访问次数的多少。比如，访问次数越多的键值对，它的访问次数再增加的难度就会越大；(有点类似指数退避算法)\n * lfu-log-factor 的大小：这是可以被设置的。也就是说，redis 源码提供了让我们人为调节访问次数增加难度的方法。\n\n这样，等到 lfulogincr 函数执行完成后，键值对的访问次数就算更新完了。\n\n# 第三步，更新 lru 变量值\n\n最后，到这一步，updatelfu 函数已经完成了键值对访问次数的更新。接着，它就会调用 lfugettimeinminutes 函数，来获取当前的时间戳，并和更新后的访问次数组合，形成最新的访问频率信息，赋值给键值对的 lru 变量，如下所示：\n\n好了，到这里，你就了解了，redis 源码在更新键值对访问频率时，对于访问次数，它是先按照上次访问距离当前的时长，来对访问次数进行衰减。然后，再按照一定概率增加访问次数。这样的设计方法，就既包含了访问的时间段对访问频率的影响，也避免了 8 bits 计数器对访问次数的影响。而对于访问时间来说，redis 还会获取最新访问时间戳并更新到 lru 变量中。\n\n那么最后，我们再来看下 redis 是如何基于 lfu 算法淘汰数据的。\n\n\n# lfu 算法淘汰数据\n\n在实现使用 lfu 算法淘汰数据时，redis 是采用了和实现近似 lru 算法相同的方法。也就是说，redis 会使用一个全局数组 evictionpoollru，来保存待淘汰候选键值对集合。然后，在 processcommand 函数处理每个命令时，它会调用 freememoryifneededandsafe 函数和 freememoryifneeded 函数，来执行具体的数据淘汰流程。\n\n这个淘汰流程我在上篇文章已经给你介绍过了，你可以再去整体回顾下。这里，我也再简要总结下，也就是分成三个步骤：\n\n * 第一步，调用 getmaxmemorystate 函数计算待释放的内存空间；\n * 第二步，调用 evictionpoolpopulate 函数随机采样键值对，并插入到待淘汰集合 evictionpoollru 中；\n * 第三步，遍历待淘汰集合 evictionpoollru，选择实际被淘汰数据，并删除。\n\n虽然这个基本流程和 lru 算法相同，但是你要注意，lfu 算法在淘汰数据时，在第二步的 evictionpoolpopulate 函数中，使用了不同的方法来计算每个待淘汰键值对的空闲时间\n\n具体来说，在实现 lru 算法时，待淘汰候选键值对集合 evictionpoollru 中的每个元素，都使用成员变量 idle 来记录它距离上次访问的空闲时间。\n\n而当实现 lfu 算法时，因为 lfu 算法会对访问次数进行衰减和按概率增加，所以，它是使用访问次数来近似表示访问频率的。相应的，lfu 算法其实是用 255 减去键值对的访问次数，这样来计算 evictionpoollru 数组中每个元素的 idle 变量值的。而且，在计算 idle 变量值前，lfu 算法还会调用 lfudecrandreturn 函数，衰减一次键值对的访问次数，以便能更加准确地反映实际选择待淘汰数据时，数据的访问频率。\n\n下面的代码展示了 lfu 算法计算 idle 变量值的过程，你可以看下。\n\nif (server.maxmemory_policy & maxmemory_flag_lru) {\n    idle = estimateobjectidletime(o);\n} else if (server.maxmemory_policy & maxmemory_flag_lfu) {\n    idle = 255-lfudecrandreturn(o);\n}\n\n\n所以说，当 lfu 算法按照访问频率，计算了待淘汰键值对集合中每个元素的 idle 值后，键值对访问次数越大，它的 idle 值就越小，反之 idle 值越大。而 evictionpoollru 数组中的元素，是按 idle 值从小到大来排序的。最后当 freememoryifneeded 函数按照 idle 值从大到小，遍历 evictionpoollru 数组，选择实际被淘汰的键值对时，它就能选出访问次数小的键值对了，也就是把访问频率低的键值对淘汰出去。\n\n这样，redis 就完成了按访问频率来淘汰数据的操作了。\n\n\n# 总结\n\n 1. lfu 是在 redis 4.0 新增的淘汰策略，它涉及的巧妙之处在于，其复用了 redisobject 结构的 lru 字段，把这个字段「一分为二」，高16位保存最后访问时间和低8位保存访问次数\n 2. key 的访问次数不能只增不减，它需要根据时间间隔来做衰减，才能达到 lfu 的目的\n 3. 每次在访问一个 key 时，会**「懒惰」**更新这个 key 的访问次数：先衰减访问次数，再更新访问次数\n 4. 衰减访问次数，会根据时间间隔计算，间隔时间越久，衰减越厉害\n 5. 因为 redisobject lru 字段宽度限制，这个访问次数是有上限的（8 bit 最大值 255），所以递增访问次数时，会根据「当前」访问次数和「概率」的方式做递增，访问次数越大，递增因子越大，递增概率越低\n 6. redis 实现的 lfu 算法也是**「近似」**lfu，是在性能和内存方面平衡的结果\n\n\n# 参考文献\n\nhttps://time.geekbang.org/column/intro/100084301",charsets:{cjk:!0},lastUpdated:"2024/09/14, 11:14:17",lastUpdatedTimestamp:1726312457e3},{title:"渐进式 hash",frontmatter:{title:"渐进式 hash",date:"2024-09-14T18:44:06.000Z",permalink:"/pages/2d43d1/"},regularPath:"/01.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95/01.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95/06.%E6%B8%90%E8%BF%9B%E5%BC%8F%20hash.html",relativePath:"01.系统设计算法/01.系统设计算法/06.渐进式 hash.md",key:"v-67babc0e",path:"/pages/2d43d1/",headers:[{level:2,title:"Redis 如何避免hash冲突？",slug:"redis-如何避免hash冲突",normalizedTitle:"redis 如何避免hash冲突？",charIndex:630},{level:2,title:"Redis 如何实现 rehash？",slug:"redis-如何实现-rehash",normalizedTitle:"redis 如何实现 rehash？",charIndex:1086},{level:3,title:"什么时候触发 rehash？",slug:"什么时候触发-rehash",normalizedTitle:"什么时候触发 rehash？",charIndex:1971},{level:3,title:"rehash 扩容扩多大？",slug:"rehash-扩容扩多大",normalizedTitle:"rehash 扩容扩多大？",charIndex:1989},{level:3,title:"渐进式 rehash 如何实现？",slug:"渐进式-rehash-如何实现",normalizedTitle:"渐进式 rehash 如何实现？",charIndex:6386},{level:2,title:"小结",slug:"小结",normalizedTitle:"小结",charIndex:12092},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:12506}],headersStr:"Redis 如何避免hash冲突？ Redis 如何实现 rehash？ 什么时候触发 rehash？ rehash 扩容扩多大？ 渐进式 rehash 如何实现？ 小结 参考文献",content:"今天我们来聊聊Redis中的Hash\n\n对于Redis键值数据库来说，Hash表既是键值对中的一种值类型，同时，Redis也使用一个全局Hash表来保存所有的键值对，从而既满足应用存取Hash结构数据需求，又能提供快速查询功能。 那么，Hash表应用如此广泛的一个重要原因，就是从理论上来说，它能以O(1)的复杂度快速查询数据。Hash表通过Hash函数的计算，就能定位数据在表中的位置，紧接着可以对数据进行操作，这就使得数据操作非常快速。\n\nHash 表这个结构也并不难理解，但是在实际应用 Hash 表时，当数据量不断增加，它的性能就经常会受到哈希冲突和 rehash 开销的影响。而这两个问题的核心，其实都来自于 Hash 表要保存的数据量，超过了当前 Hash 表能容纳的数据量。 那么要如何应对这两个问题呢？事实上，这也是在大厂面试中，面试官经常会考核的问题。所以你现在可以先想想，如果你在面试中遇到了这两个问题，你会怎么回答呢？ OK，思考先到这里，现在我来告诉你 Redis 是怎么很好地解决这两个问题的\n\nRedis 为我们提供了一个经典的 Hash 表实现方案。针对哈希冲突，Redis 采用了链式哈希，在不扩容哈希表的前提下，将具有相同哈希值的数据链接起来，以便这些数据在表中 仍然可以被查询到；对于 rehash 开销，Redis 实现了渐进式 rehash 设计，进而缓解了 rehash 操作带来的额外开销对系统的性能影响。\n\n\n# Redis 如何避免hash冲突？\n\n * 第一种方案，就是我接下来要给你介绍的链式哈希。这里你需要先知道，链式哈希的链 不能太长，否则会降低 Hash 表性能。\n * 第二种方案，就是当链式哈希的链长达到一定长度时，我们可以使用 rehash。不过， 执行 rehash 本身开销比较大，所以就需要采用我稍后会给你介绍的渐进式 rehash 设 计。\n\n这样，当我们要查询 key5 时，可以先通过哈希函数计算，得到 key5 的哈希值被映射到了桶 9 中。然后，我们再逐一比较桶 9 中串接的 key，直到查找到 key5。如此一来，我们就能在链式哈希中找到所查的哈希项了。 不过，链式哈希也存在局限性，那就是随着链表长度的增加，Hash 表在一个位置上查询哈希项的耗时就会增加，从而增加了 Hash 表的整体查询时间，这样也会导致 Hash 表的性能下降。\n\n那么，有没有什么其他的方法可以减少对 Hash 表性能的影响呢？当然是有的，这就是接 下来我要给你介绍的 rehash 的设计与实现了。\n\n\n# Redis 如何实现 rehash？\n\nrehash 操作，其实就是指扩大 Hash 表空间。而 Redis 实现 rehash 的基本思路是这样 的：\n\n首先，Redis 准备了两个哈希表，用于 rehash 时交替保存数据。我在前面给你介绍过，Redis 在 dict.h 文件中使用 dictht 结构体定义了 Hash 表。不过， 在实际使用 Hash 表时，Redis 又在 dict.h 文件中，定义了一个 dict 结构体。这个结构体中有一个数组（ht[2]），包含了两个 Hash 表 ht[0]和 ht[1]。dict 结构体的代码定义如下 所示：\n\ntypedef struct dict {\n    dictType *type;\n    void *privdata;\n    //两个Hash表，交替使用，用于rehash操作\n    dictht ht[2];\n    // Hash表是否在进行rehash的标识，-1表示没有进行rehash\n    long rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    int16_t pauserehash; /* If >0 rehashing is paused (<0 indicates coding error) */\n} dict;\n\n\n其次，在正常服务请求阶段，所有的键值对写入哈希表 ht[0]。\n\n接着，当进行 rehash 时，键值对被迁移到哈希表 ht[1]中。\n\n最后，当迁移完成后，ht[0]的空间会被释放，并把 ht[1]的地址赋值给 ht[0]，ht[1]的表 大小设置为 0。这样一来，又回到了正常服务请求的阶段，ht[0]接收和服务请求，ht[1] 作为下一次 rehash 时的迁移表。\n\n好，那么在了解了 Redis 交替使用两个 Hash 表实现 rehash 的基本思路后，我们还需要明确的是：在实现 rehash 时，都需要解决哪些问题？我认为主要有以下三点：\n\n * 什么时候触发 rehash？\n * rehash 扩容扩多大？\n * rehash 如何执行？\n\n所以下面，我就带你来逐一学习 Redis 对这三个问题的代码实现，通过代码实现，你就能明晰 Redis 针对这三个问题的设计思想了。\n\n\n# 什么时候触发 rehash？\n\n首先要知道，Redis 用来判断是否触发 rehash 的函数是 _dictExpandIfNeeded。所以接 下来我们就先看看， _dictExpandIfNeeded函数中进行扩容的触发条件；然后，我们再来了解下 _dictExpandIfNeeded又是在哪些函数中被调用的。\n\n实际上， _dictExpandIfNeeded 函数中定义了三个扩容条件。 下面的代码就展示了 _dictExpandIfNeeded 函数对这三个条件的定义，你可以看下。 那么，对于条件一来说，此时 Hash 表是空的，所以 Redis 就需要将 Hash 表空间设置为初始大小，而这是初始化的工作，并不属于 rehash 操作。\n\n什么时候触发 rehash？ rehash 扩容扩多大？ rehash 如何执行？\n\n * 条件一：ht[0]的大小为 0。\n * 条件二：ht[0]承载的元素个数已经超过了 ht[0]的大小，同时 Hash 表可以进行扩容。\n * 条件三：ht[0]承载的元素个数，是 ht[0]的大小的 dict_force_resize_ratio 倍，其中， dict_force_resize_ratio 的默认值是 5。\n\n/* Expand the hash table if needed */\nstatic int _dictExpandIfNeeded(dict *d)\n{\n    /* Incremental rehashing already in progress. Return. */\n    if (dictIsRehashing(d)) return DICT_OK;\n\n    /* If the hash table is empty expand it to the initial size. */\n    if (d->ht[0].size == 0) return dictExpand(d, DICT_HT_INITIAL_SIZE);\n\n    /* If we reached the 1:1 ratio, and we are allowed to resize the hash\n     * table (global setting) or we should avoid it but the ratio between\n     * elements/buckets is over the \"safe\" threshold, we resize doubling\n     * the number of buckets. */\n    // ht[0]表使用的元素个数超过当前大小\n    // 并且可以扩容或者 ht[0]使用的元素个数/ht[0]表的大小 大于 dict_force_resize_ratio\n    // 并且能够允许扩展\n    if (d->ht[0].used >= d->ht[0].size &&\n        (dict_can_resize ||\n         d->ht[0].used/d->ht[0].size > dict_force_resize_ratio) &&\n        dictTypeExpandAllowed(d))\n    {\n        return dictExpand(d, d->ht[0].used + 1);\n    }\n    return DICT_OK;\n}\n\n\n那么，对于条件一来说，此时 Hash 表是空的，所以 Redis 就需要将 Hash 表空间设置为初始大小，而这是初始化的工作，并不属于 rehash 操作。\n\n而条件二和三就对应了 rehash 的场景。因为在这两个条件中，都比较了 Hash 表当前承载 的元素个数（d->ht[0].used）和 Hash 表当前设定的大小（d->ht[0].size），这两个值的比值一般称为负载因子（load factor）。也就是说，Redis 判断是否进行 rehash 的条 件，就是看 load factor 是否大于等于 1 和是否大于 5。\n\n实际上，当 load factor 大于 5 时，就表明 Hash 表已经过载比较严重了，需要立刻进行库扩容。而当 load factor 大于等于 1 时，Redis 还会再判断 dict_can_resize 这个变量值，查看当前是否可以进行扩容。 你可能要问了，这里的 dict_can_resize 变量值是啥呀？其实，这个变量值是在 dictEnableResize 和 dictDisableResize 两个函数中设置的，它们的作用分别是启用和禁止哈希表执行 rehash 功能，如下所示：\n\nvoid dictEnableResize(void) {\n    dict_can_resize = 1;\n}\n\nvoid dictDisableResize(void) {\n    dict_can_resize = 0;\n}\n\n\n然后，这两个函数又被封装在了 updateDictResizePolicy 函数中。\n\nupdateDictResizePolicy 函数是用来启用或禁用 rehash 扩容功能的，这个函数调用 dictEnableResize 函数启用扩容功能的条件是：\n\n * 当前没有 RDB 子进程，并且也没有 AOF 子进程。\n\n这就对应了 Redis 没有执行 RDB 快照和没有进行 AOF 重写的场景。你可以参考下面给出的代码：\n\nvoid updateDictResizePolicy(void) {\nif (server.rdb_child_pid == -1 && server.aof_child_pid == -1)\n\tdictEnableResize();\nelse\n\tdictDisableResize();\n}\n\n\n好，到这里我们就了解了 _dictExpandIfNeeded 对 rehash 的判断触发条件，那么现在， 我们再来看下 Redis 会在哪些函数中，调用 _dictExpandIfNeeded 进行判断。 首先，通过在dict.c文件中查看 _dictExpandIfNeeded 的被调用关系，我们可以发现， _dictExpandIfNeeded 是被 _dictKeyIndex 函数调用的，而 _dictKeyIndex 函数又会被 dictAddRaw 函数调用，然后 dictAddRaw 会被以下三个函数调用。\n\n * dictAdd：用来往 Hash 表中添加一个键值对。\n * dictRelace：用来往 Hash 表中添加一个键值对，或者键值对存在时，修改键值对。\n * dictAddorFind：直接调用 dictAddRaw\n\n因此，当我们往 Redis 中写入新的键值对或是修改键值对时，Redis 都会判断下是否需要进行 rehash。这里你可以参考下面给出的示意图，其中就展示了 _dictExpandIfNeeded 被调用的关系。\n\n好了，简而言之，Redis 中触发 rehash 操作的关键，就是dictExpandIfNeeded 函数 和 updateDictResizePolicy 函数。dictExpandIfNeeded 函数会根据 Hash 表的负载因子 以及能否进行 rehash 的标识，判断是否进行 rehash，而 updateDictResizePolicy 函数 会根据 RDB 和 AOF 的执行情况，启用或禁用 rehash。\n\n接下来，我们继续探讨 Redis 在实现 rehash 时，要解决的第二个问题：rehash 扩容扩多 大？\n\n\n# rehash 扩容扩多大？\n\n在 Redis 中，rehash 对 Hash 表空间的扩容是通过调用 dictExpand 函数来完成的。 dictExpand 函数的参数有两个，一个是要扩容的 Hash 表，另一个是要扩到的容量，下面 的代码就展示了 dictExpand 函数的原型定义：\n\n int dictExpand(dict *d, unsigned long size);\n\n\n那么，对于一个 Hash 表来说，我们就可以根据前面提到的 _dictExpandIfNeeded 函数， 来判断是否要对其进行扩容。而一旦判断要扩容，Redis 在执行 rehash 操作时，对 Hash 表扩容的思路也很简单，就是如果当前表的已用空间大小为 size，那么就将表扩容到 size*2 的大小。\n\n如下所示，当 _dictExpandIfNeeded 函数在判断了需要进行 rehash 后，就调用 dictExpand 进行扩容。这里你可以看到，rehash 的扩容大小是当前 ht[0]已使用大小的 2 倍。\n\ndictExpand(d, d->ht[0].used*2);\n\n\n而在 dictExpand 函数中，具体执行是由 _dictNextPower 函数完成的，以下代码显示的 Hash 表扩容的操作，就是从 Hash 表的初始大小（DICT_HT_INITIAL_SIZE），不停地乘 以 2，直到达到目标大小。\n\nstatic unsigned long _dictNextPower(unsigned long size)\n{\n    // 哈希表的初始大小\n    unsigned long i = DICT_HT_INITIAL_SIZE;\n\t// 如果要扩容的大小已经超过最大值，则返回最大值加1\n    if (size >= LONG_MAX) return LONG_MAX + 1LU;\n    // 扩容大小没有超过最大值\n    while(1) {\n        if (i >= size)\n            return i;\n        // 每一步扩容都在现有大小基础上乘以2\n        i *= 2;\n    }\n}\n\n\n好，下面我们再来看看 Redis 要解决的第三个问题，即 rehash 要如何执行？而这个问 题，本质上就是 Redis 要如何实现渐进式 rehash 设计。\n\n\n# 渐进式 rehash 如何实现？\n\n那么这里，我们要先搞清楚一个问题，就是为什么要实现渐进式 rehash？ 其实这是因为，Hash 表在执行 rehash 时，由于 Hash 表空间扩大，原本映射到某一位置 的键可能会被映射到一个新的位置上，因此，很多键就需要从原来的位置拷贝到新的位 置。而在键拷贝时，由于 Redis 主线程无法执行其他请求，所以键拷贝会阻塞主线程，这样就会产生 rehash 开销。\n\n而为了降低 rehash 开销，Redis 就提出了渐进式 rehash 的方法。\n\n简单来说，渐进式 rehash 的意思就是 Redis 并不会一次性把当前 Hash 表中的所有键， 都拷贝到新位置，而是会分批拷贝，每次的键拷贝只拷贝 Hash 表中一个 bucket 中的哈希项。这样一来，每次键拷贝的时长有限，对主线程的影响也就有限了。\n\n那么，渐进式 rehash 在代码层面是如何实现的呢？这里有两个关键函数：dictRehash 和 _dictRehashStep。\n\n我们先来看 dictRehash 函数，这个函数实际执行键拷贝，它的输入参数有两个，分别是 全局哈希表（即前面提到的 dict 结构体，包含了 ht[0]和 ht[1]）和需要进行键拷贝的桶数量（bucket 数量）。\n\ndictRehash 函数的整体逻辑包括两部分：\n\n首先，该函数会执行一个循环，根据要进行键拷贝的 bucket 数量 n，依次完成这些 bucket 内部所有键的迁移。当然，如果 ht[0]哈希表中的数据已经都迁移完成了，键拷贝的循环也会停止执行\n\n其次，在完成了 n 个 bucket 拷贝后，dictRehash 函数的第二部分逻辑，就是判断 ht[0]表中数据是否都已迁移完。如果都迁移完了，那么 ht[0]的空间会被释放。因为 Redis 在处理请求时，代码逻辑中都是使用 ht[0]，所以当 rehash 执行完成后，虽然数据都在 ht[1]中了，但 Redis仍然会把 ht[1]赋值给ht[0]，以便其他部分的代码逻辑正常使用。\n\n而在 ht[1]赋值给 ht[0]后，它的大小就会被重置为 0，等待下一次 rehash。与此同时， 全局哈希表中的rehashidx 变量会被标为 -1，表示 rehash 结束了（这里的 rehashidx 变量用来表示 rehash 的进度，稍后我会给你具体解释）。\n\n我画了下面这张图，展示了 dictRehash 的主要执行流程，你可以看下。\n\nint dictRehash(dict *d, int n) {\n    int empty_visits = n*10; /* Max number of empty buckets to visit. */\n    if (!dictIsRehashing(d)) return 0;\n\n    // 主循环，根据要拷贝的bucket数量n，循环n次后停止或ht[0]中的数据迁移完停止\n    while(n-- && d->ht[0].used != 0) {\n        dictEntry *de, *nextde;\n\n        /* Note that rehashidx can't overflow as we are sure there are more\n         * elements because ht[0].used != 0 */\n        assert(d->ht[0].size > (unsigned long)d->rehashidx);\n        while(d->ht[0].table[d->rehashidx] == NULL) {\n            d->rehashidx++;\n            if (--empty_visits == 0) return 1;\n        }\n        de = d->ht[0].table[d->rehashidx];\n        /* Move all the keys in this bucket from the old to the new hash HT */\n        while(de) {\n            uint64_t h;\n\n            nextde = de->next;\n            /* Get the index in the new hash table */\n            h = dictHashKey(d, de->key) & d->ht[1].sizemask;\n            de->next = d->ht[1].table[h];\n            d->ht[1].table[h] = de;\n            d->ht[0].used--;\n            d->ht[1].used++;\n            de = nextde;\n        }\n        d->ht[0].table[d->rehashidx] = NULL;\n        d->rehashidx++;\n    }\n\n    //判断ht[0]的数据是否迁移完成\n    /* Check if we already rehashed the whole table... */\n    if (d->ht[0].used == 0) {\n        // ht[0]迁移完后，释放ht[0]内存空间\n        zfree(d->ht[0].table);\n        // 让ht[0]指向ht[1]，以便接受正常的请求\n        d->ht[0] = d->ht[1];\n        // 重置ht[1]的大小为0\n        _dictReset(&d->ht[1]);\n        // 设置全局哈希表的rehashidx标识为-1，表示rehash结束\n        d->rehashidx = -1;\n        // 返回0，表示ht[0]中所有元素都迁移完\n        return 0;\n    }\n\n    //返回1，表示ht[0]中仍然有元素没有迁移完\n    /* More to rehash... */\n    return 1;\n}\n\n\n好，在了解了 dictRehash 函数的主体逻辑后，我们再看下渐进式 rehash 是如何按照 bucket 粒度拷贝数据的，这其实就和全局哈希表 dict 结构中的 rehashidx 变量相关了。\n\nrehashidx 变量表示的是当前 rehash 在对哪个 bucket 做数据迁移。比如，当 rehashidx 等于 0 时，表示对 ht[0]中的第一个 bucket 进行数据迁移；当 rehashidx 等于 1 时，表 示对 ht[0]中的第二个 bucket 进行数据迁移，以此类推。\n\n而 dictRehash 函数的主循环，首先会判断 rehashidx 指向的 bucket 是否为空，如果为 空，那就将 rehashidx 的值加 1，检查下一个 bucket。\n\n那么，有没有可能连续几个 bucket 都为空呢？其实是有可能的，在这种情况下，渐进式 rehash 不会一直递增 rehashidx 进行检查。这是因为一旦执行了 rehash，Redis 主线程就无法处理其他请求了。\n\n所以，渐进式 rehash 在执行时设置了一个变量 empty_visits，用来表示已经检查过的空 bucket，当检查了一定数量的空 bucket 后，这一轮的 rehash 就停止执行，转而继续处理外来请求，避免了对 Redis 性能的影响。下面的代码显示了这部分逻辑，你可以看下。\n\n// 如果当前要迁移的bucket中没有元素\nwhile(d->ht[0].table[d->rehashidx] == NULL) {\n    d->rehashidx++;\n    if (--empty_visits == 0) return 1;\n}\n\n\n而如果 rehashidx 指向的 bucket 有数据可以迁移，那么 Redis 就会把这个 bucket 中的哈希项依次取出来，并根据 ht[1]的表空间大小，重新计算哈希项在 ht[1]中的 bucket 位置，然后把这个哈希项赋值到 ht[1]对应 bucket 中。\n\n这样，每做完一个哈希项的迁移，ht[0]和 ht[1]用来表示承载哈希项多少的变量 used，就 会分别减一和加一。当然，如果当前 rehashidx 指向的 bucket 中数据都迁移完了， rehashidx 就会递增加 1，指向下一个 bucket。下面的代码显示了这一迁移过程。\n\n while(n-- && d->ht[0].used != 0) {\n     dictEntry *de, *nextde;\n\n     /* Note that rehashidx can't overflow as we are sure there are more\n         * elements because ht[0].used != 0 */\n     assert(d->ht[0].size > (unsigned long)d->rehashidx);\n     while(d->ht[0].table[d->rehashidx] == NULL) {\n         d->rehashidx++;\n         if (--empty_visits == 0) return 1;\n     }\n     // 获得哈希表中哈希项\n     de = d->ht[0].table[d->rehashidx];\n     /* Move all the keys in this bucket from the old to the new hash HT */\n     while(de) {\n         uint64_t h;\n\t\t // 获得同一个bucket中下一个哈希项\n         nextde = de->next;\n         /* Get the index in the new hash table */\n         // 根据扩容后的哈希表ht[1]大小，计算当前哈希项在扩容后哈希表中的bucket位置\n         h = dictHashKey(d, de->key) & d->ht[1].sizemask;\n         // 将当前哈希项添加到扩容后的哈希表ht[1]中\n         de->next = d->ht[1].table[h];\n         d->ht[1].table[h] = de;\n         // 减少当前哈希表的哈希项个数\n         d->ht[0].used--;\n         // 增加扩容后哈希表的哈希项个数\n         d->ht[1].used++;\n         de = nextde;\n     }\n     // 如果当前bucket中已经没有哈希项了，将该bucket置为NULL\n     d->ht[0].table[d->rehashidx] = NULL;\n     // 将rehash加1，下一次将迁移下一个bucket中的元素\n     d->rehashidx++;\n }\n\n\n好了，到这里，我们就已经基本了解了 dictRehash 函数的全部逻辑。 现在我们知道，dictRehash 函数本身是按照 bucket 粒度执行哈希项迁移的，它内部执行 的 bucket 迁移个数，主要由传入的循环次数变量 n 来决定。但凡 Redis 要进行 rehash操作，最终都会调用 dictRehash 函数。\n\n接下来，我们来学习和渐进式 rehash 相关的第二个关键函数 _dictRehashStep，这个函 数实现了每次只对一个 bucket 执行 rehash。 从 Redis 的源码中我们可以看到，一共会有 5 个函数通过调用 _dictRehashStep 函数，进而调用 dictRehash 函数，来执行 rehash，它们分别是：dictAddRaw， dictGenericDelete，dictFind，dictGetRandomKey，dictGetSomeKeys。\n\n其中，dictAddRaw 和 dictGenericDelete 函数，分别对应了往 Redis 中增加和删除键值对，而后三个函数则对应了在 Redis 中进行查询操作。下图展示了这些函数间的调用关系：\n\n但你要注意，不管是增删查哪种操作，这 5 个函数调用的 _dictRehashStep 函数，给 dictRehash 传入的循环次数变量 n 的值都为 1，下面的代码就显示了这一传参的情况。\n\nstatic void _dictRehashStep(dict *d) {\n    // 给dictRehash传入的循环次数参数为1，表明每迁移完一个bucket ，就执行正常操作\n    if (d->pauserehash == 0) dictRehash(d,1);\n}\n\n\n这样一来，每次迁移完一个 bucket，Hash 表就会执行正常的增删查请求操作，这就是在代码层面实现渐进式 rehash 的方法。\n\n\n# 小结\n\n实现一个高性能的Hash表不仅是Redis的需求，也是很多计算机系统开发过程中的重要目标。而要想实现一个性能优异的Hash表，就需要重点解决哈希冲突和rehash开销这两个问题。 今天这节课，我带你学习了Redis中Hash表的结构设计、链式哈希方法的实现，以及渐进式rehash方法的设计实现。Redis中Hash表的结构设计很特别，它的每个哈希项都包含了一个指针，用于实现链式哈希。同时，Redis在全局哈希表中还包含了两个Hash表，这种设计思路也是为了在实现rehash时，帮助数据从一个表迁移到另一个表。 此外，Redis实现的渐进式rehash是一个用于Hash表扩容的通用方法，非常值得我们学习。这个设计方法的关键是每次仅迁移有限个数的bucket，避免一次性迁移给所有bucket带来的性能影响。当你掌握了渐进式rehash这个设计思想和实现方法，你就可以把它应用到自己的Hash表实现场景中。\n\n\n# 参考文献\n\nRedis 源码剖析与实战 (geekbang.org)",normalizedContent:"今天我们来聊聊redis中的hash\n\n对于redis键值数据库来说，hash表既是键值对中的一种值类型，同时，redis也使用一个全局hash表来保存所有的键值对，从而既满足应用存取hash结构数据需求，又能提供快速查询功能。 那么，hash表应用如此广泛的一个重要原因，就是从理论上来说，它能以o(1)的复杂度快速查询数据。hash表通过hash函数的计算，就能定位数据在表中的位置，紧接着可以对数据进行操作，这就使得数据操作非常快速。\n\nhash 表这个结构也并不难理解，但是在实际应用 hash 表时，当数据量不断增加，它的性能就经常会受到哈希冲突和 rehash 开销的影响。而这两个问题的核心，其实都来自于 hash 表要保存的数据量，超过了当前 hash 表能容纳的数据量。 那么要如何应对这两个问题呢？事实上，这也是在大厂面试中，面试官经常会考核的问题。所以你现在可以先想想，如果你在面试中遇到了这两个问题，你会怎么回答呢？ ok，思考先到这里，现在我来告诉你 redis 是怎么很好地解决这两个问题的\n\nredis 为我们提供了一个经典的 hash 表实现方案。针对哈希冲突，redis 采用了链式哈希，在不扩容哈希表的前提下，将具有相同哈希值的数据链接起来，以便这些数据在表中 仍然可以被查询到；对于 rehash 开销，redis 实现了渐进式 rehash 设计，进而缓解了 rehash 操作带来的额外开销对系统的性能影响。\n\n\n# redis 如何避免hash冲突？\n\n * 第一种方案，就是我接下来要给你介绍的链式哈希。这里你需要先知道，链式哈希的链 不能太长，否则会降低 hash 表性能。\n * 第二种方案，就是当链式哈希的链长达到一定长度时，我们可以使用 rehash。不过， 执行 rehash 本身开销比较大，所以就需要采用我稍后会给你介绍的渐进式 rehash 设 计。\n\n这样，当我们要查询 key5 时，可以先通过哈希函数计算，得到 key5 的哈希值被映射到了桶 9 中。然后，我们再逐一比较桶 9 中串接的 key，直到查找到 key5。如此一来，我们就能在链式哈希中找到所查的哈希项了。 不过，链式哈希也存在局限性，那就是随着链表长度的增加，hash 表在一个位置上查询哈希项的耗时就会增加，从而增加了 hash 表的整体查询时间，这样也会导致 hash 表的性能下降。\n\n那么，有没有什么其他的方法可以减少对 hash 表性能的影响呢？当然是有的，这就是接 下来我要给你介绍的 rehash 的设计与实现了。\n\n\n# redis 如何实现 rehash？\n\nrehash 操作，其实就是指扩大 hash 表空间。而 redis 实现 rehash 的基本思路是这样 的：\n\n首先，redis 准备了两个哈希表，用于 rehash 时交替保存数据。我在前面给你介绍过，redis 在 dict.h 文件中使用 dictht 结构体定义了 hash 表。不过， 在实际使用 hash 表时，redis 又在 dict.h 文件中，定义了一个 dict 结构体。这个结构体中有一个数组（ht[2]），包含了两个 hash 表 ht[0]和 ht[1]。dict 结构体的代码定义如下 所示：\n\ntypedef struct dict {\n    dicttype *type;\n    void *privdata;\n    //两个hash表，交替使用，用于rehash操作\n    dictht ht[2];\n    // hash表是否在进行rehash的标识，-1表示没有进行rehash\n    long rehashidx; /* rehashing not in progress if rehashidx == -1 */\n    int16_t pauserehash; /* if >0 rehashing is paused (<0 indicates coding error) */\n} dict;\n\n\n其次，在正常服务请求阶段，所有的键值对写入哈希表 ht[0]。\n\n接着，当进行 rehash 时，键值对被迁移到哈希表 ht[1]中。\n\n最后，当迁移完成后，ht[0]的空间会被释放，并把 ht[1]的地址赋值给 ht[0]，ht[1]的表 大小设置为 0。这样一来，又回到了正常服务请求的阶段，ht[0]接收和服务请求，ht[1] 作为下一次 rehash 时的迁移表。\n\n好，那么在了解了 redis 交替使用两个 hash 表实现 rehash 的基本思路后，我们还需要明确的是：在实现 rehash 时，都需要解决哪些问题？我认为主要有以下三点：\n\n * 什么时候触发 rehash？\n * rehash 扩容扩多大？\n * rehash 如何执行？\n\n所以下面，我就带你来逐一学习 redis 对这三个问题的代码实现，通过代码实现，你就能明晰 redis 针对这三个问题的设计思想了。\n\n\n# 什么时候触发 rehash？\n\n首先要知道，redis 用来判断是否触发 rehash 的函数是 _dictexpandifneeded。所以接 下来我们就先看看， _dictexpandifneeded函数中进行扩容的触发条件；然后，我们再来了解下 _dictexpandifneeded又是在哪些函数中被调用的。\n\n实际上， _dictexpandifneeded 函数中定义了三个扩容条件。 下面的代码就展示了 _dictexpandifneeded 函数对这三个条件的定义，你可以看下。 那么，对于条件一来说，此时 hash 表是空的，所以 redis 就需要将 hash 表空间设置为初始大小，而这是初始化的工作，并不属于 rehash 操作。\n\n什么时候触发 rehash？ rehash 扩容扩多大？ rehash 如何执行？\n\n * 条件一：ht[0]的大小为 0。\n * 条件二：ht[0]承载的元素个数已经超过了 ht[0]的大小，同时 hash 表可以进行扩容。\n * 条件三：ht[0]承载的元素个数，是 ht[0]的大小的 dict_force_resize_ratio 倍，其中， dict_force_resize_ratio 的默认值是 5。\n\n/* expand the hash table if needed */\nstatic int _dictexpandifneeded(dict *d)\n{\n    /* incremental rehashing already in progress. return. */\n    if (dictisrehashing(d)) return dict_ok;\n\n    /* if the hash table is empty expand it to the initial size. */\n    if (d->ht[0].size == 0) return dictexpand(d, dict_ht_initial_size);\n\n    /* if we reached the 1:1 ratio, and we are allowed to resize the hash\n     * table (global setting) or we should avoid it but the ratio between\n     * elements/buckets is over the \"safe\" threshold, we resize doubling\n     * the number of buckets. */\n    // ht[0]表使用的元素个数超过当前大小\n    // 并且可以扩容或者 ht[0]使用的元素个数/ht[0]表的大小 大于 dict_force_resize_ratio\n    // 并且能够允许扩展\n    if (d->ht[0].used >= d->ht[0].size &&\n        (dict_can_resize ||\n         d->ht[0].used/d->ht[0].size > dict_force_resize_ratio) &&\n        dicttypeexpandallowed(d))\n    {\n        return dictexpand(d, d->ht[0].used + 1);\n    }\n    return dict_ok;\n}\n\n\n那么，对于条件一来说，此时 hash 表是空的，所以 redis 就需要将 hash 表空间设置为初始大小，而这是初始化的工作，并不属于 rehash 操作。\n\n而条件二和三就对应了 rehash 的场景。因为在这两个条件中，都比较了 hash 表当前承载 的元素个数（d->ht[0].used）和 hash 表当前设定的大小（d->ht[0].size），这两个值的比值一般称为负载因子（load factor）。也就是说，redis 判断是否进行 rehash 的条 件，就是看 load factor 是否大于等于 1 和是否大于 5。\n\n实际上，当 load factor 大于 5 时，就表明 hash 表已经过载比较严重了，需要立刻进行库扩容。而当 load factor 大于等于 1 时，redis 还会再判断 dict_can_resize 这个变量值，查看当前是否可以进行扩容。 你可能要问了，这里的 dict_can_resize 变量值是啥呀？其实，这个变量值是在 dictenableresize 和 dictdisableresize 两个函数中设置的，它们的作用分别是启用和禁止哈希表执行 rehash 功能，如下所示：\n\nvoid dictenableresize(void) {\n    dict_can_resize = 1;\n}\n\nvoid dictdisableresize(void) {\n    dict_can_resize = 0;\n}\n\n\n然后，这两个函数又被封装在了 updatedictresizepolicy 函数中。\n\nupdatedictresizepolicy 函数是用来启用或禁用 rehash 扩容功能的，这个函数调用 dictenableresize 函数启用扩容功能的条件是：\n\n * 当前没有 rdb 子进程，并且也没有 aof 子进程。\n\n这就对应了 redis 没有执行 rdb 快照和没有进行 aof 重写的场景。你可以参考下面给出的代码：\n\nvoid updatedictresizepolicy(void) {\nif (server.rdb_child_pid == -1 && server.aof_child_pid == -1)\n\tdictenableresize();\nelse\n\tdictdisableresize();\n}\n\n\n好，到这里我们就了解了 _dictexpandifneeded 对 rehash 的判断触发条件，那么现在， 我们再来看下 redis 会在哪些函数中，调用 _dictexpandifneeded 进行判断。 首先，通过在dict.c文件中查看 _dictexpandifneeded 的被调用关系，我们可以发现， _dictexpandifneeded 是被 _dictkeyindex 函数调用的，而 _dictkeyindex 函数又会被 dictaddraw 函数调用，然后 dictaddraw 会被以下三个函数调用。\n\n * dictadd：用来往 hash 表中添加一个键值对。\n * dictrelace：用来往 hash 表中添加一个键值对，或者键值对存在时，修改键值对。\n * dictaddorfind：直接调用 dictaddraw\n\n因此，当我们往 redis 中写入新的键值对或是修改键值对时，redis 都会判断下是否需要进行 rehash。这里你可以参考下面给出的示意图，其中就展示了 _dictexpandifneeded 被调用的关系。\n\n好了，简而言之，redis 中触发 rehash 操作的关键，就是dictexpandifneeded 函数 和 updatedictresizepolicy 函数。dictexpandifneeded 函数会根据 hash 表的负载因子 以及能否进行 rehash 的标识，判断是否进行 rehash，而 updatedictresizepolicy 函数 会根据 rdb 和 aof 的执行情况，启用或禁用 rehash。\n\n接下来，我们继续探讨 redis 在实现 rehash 时，要解决的第二个问题：rehash 扩容扩多 大？\n\n\n# rehash 扩容扩多大？\n\n在 redis 中，rehash 对 hash 表空间的扩容是通过调用 dictexpand 函数来完成的。 dictexpand 函数的参数有两个，一个是要扩容的 hash 表，另一个是要扩到的容量，下面 的代码就展示了 dictexpand 函数的原型定义：\n\n int dictexpand(dict *d, unsigned long size);\n\n\n那么，对于一个 hash 表来说，我们就可以根据前面提到的 _dictexpandifneeded 函数， 来判断是否要对其进行扩容。而一旦判断要扩容，redis 在执行 rehash 操作时，对 hash 表扩容的思路也很简单，就是如果当前表的已用空间大小为 size，那么就将表扩容到 size*2 的大小。\n\n如下所示，当 _dictexpandifneeded 函数在判断了需要进行 rehash 后，就调用 dictexpand 进行扩容。这里你可以看到，rehash 的扩容大小是当前 ht[0]已使用大小的 2 倍。\n\ndictexpand(d, d->ht[0].used*2);\n\n\n而在 dictexpand 函数中，具体执行是由 _dictnextpower 函数完成的，以下代码显示的 hash 表扩容的操作，就是从 hash 表的初始大小（dict_ht_initial_size），不停地乘 以 2，直到达到目标大小。\n\nstatic unsigned long _dictnextpower(unsigned long size)\n{\n    // 哈希表的初始大小\n    unsigned long i = dict_ht_initial_size;\n\t// 如果要扩容的大小已经超过最大值，则返回最大值加1\n    if (size >= long_max) return long_max + 1lu;\n    // 扩容大小没有超过最大值\n    while(1) {\n        if (i >= size)\n            return i;\n        // 每一步扩容都在现有大小基础上乘以2\n        i *= 2;\n    }\n}\n\n\n好，下面我们再来看看 redis 要解决的第三个问题，即 rehash 要如何执行？而这个问 题，本质上就是 redis 要如何实现渐进式 rehash 设计。\n\n\n# 渐进式 rehash 如何实现？\n\n那么这里，我们要先搞清楚一个问题，就是为什么要实现渐进式 rehash？ 其实这是因为，hash 表在执行 rehash 时，由于 hash 表空间扩大，原本映射到某一位置 的键可能会被映射到一个新的位置上，因此，很多键就需要从原来的位置拷贝到新的位 置。而在键拷贝时，由于 redis 主线程无法执行其他请求，所以键拷贝会阻塞主线程，这样就会产生 rehash 开销。\n\n而为了降低 rehash 开销，redis 就提出了渐进式 rehash 的方法。\n\n简单来说，渐进式 rehash 的意思就是 redis 并不会一次性把当前 hash 表中的所有键， 都拷贝到新位置，而是会分批拷贝，每次的键拷贝只拷贝 hash 表中一个 bucket 中的哈希项。这样一来，每次键拷贝的时长有限，对主线程的影响也就有限了。\n\n那么，渐进式 rehash 在代码层面是如何实现的呢？这里有两个关键函数：dictrehash 和 _dictrehashstep。\n\n我们先来看 dictrehash 函数，这个函数实际执行键拷贝，它的输入参数有两个，分别是 全局哈希表（即前面提到的 dict 结构体，包含了 ht[0]和 ht[1]）和需要进行键拷贝的桶数量（bucket 数量）。\n\ndictrehash 函数的整体逻辑包括两部分：\n\n首先，该函数会执行一个循环，根据要进行键拷贝的 bucket 数量 n，依次完成这些 bucket 内部所有键的迁移。当然，如果 ht[0]哈希表中的数据已经都迁移完成了，键拷贝的循环也会停止执行\n\n其次，在完成了 n 个 bucket 拷贝后，dictrehash 函数的第二部分逻辑，就是判断 ht[0]表中数据是否都已迁移完。如果都迁移完了，那么 ht[0]的空间会被释放。因为 redis 在处理请求时，代码逻辑中都是使用 ht[0]，所以当 rehash 执行完成后，虽然数据都在 ht[1]中了，但 redis仍然会把 ht[1]赋值给ht[0]，以便其他部分的代码逻辑正常使用。\n\n而在 ht[1]赋值给 ht[0]后，它的大小就会被重置为 0，等待下一次 rehash。与此同时， 全局哈希表中的rehashidx 变量会被标为 -1，表示 rehash 结束了（这里的 rehashidx 变量用来表示 rehash 的进度，稍后我会给你具体解释）。\n\n我画了下面这张图，展示了 dictrehash 的主要执行流程，你可以看下。\n\nint dictrehash(dict *d, int n) {\n    int empty_visits = n*10; /* max number of empty buckets to visit. */\n    if (!dictisrehashing(d)) return 0;\n\n    // 主循环，根据要拷贝的bucket数量n，循环n次后停止或ht[0]中的数据迁移完停止\n    while(n-- && d->ht[0].used != 0) {\n        dictentry *de, *nextde;\n\n        /* note that rehashidx can't overflow as we are sure there are more\n         * elements because ht[0].used != 0 */\n        assert(d->ht[0].size > (unsigned long)d->rehashidx);\n        while(d->ht[0].table[d->rehashidx] == null) {\n            d->rehashidx++;\n            if (--empty_visits == 0) return 1;\n        }\n        de = d->ht[0].table[d->rehashidx];\n        /* move all the keys in this bucket from the old to the new hash ht */\n        while(de) {\n            uint64_t h;\n\n            nextde = de->next;\n            /* get the index in the new hash table */\n            h = dicthashkey(d, de->key) & d->ht[1].sizemask;\n            de->next = d->ht[1].table[h];\n            d->ht[1].table[h] = de;\n            d->ht[0].used--;\n            d->ht[1].used++;\n            de = nextde;\n        }\n        d->ht[0].table[d->rehashidx] = null;\n        d->rehashidx++;\n    }\n\n    //判断ht[0]的数据是否迁移完成\n    /* check if we already rehashed the whole table... */\n    if (d->ht[0].used == 0) {\n        // ht[0]迁移完后，释放ht[0]内存空间\n        zfree(d->ht[0].table);\n        // 让ht[0]指向ht[1]，以便接受正常的请求\n        d->ht[0] = d->ht[1];\n        // 重置ht[1]的大小为0\n        _dictreset(&d->ht[1]);\n        // 设置全局哈希表的rehashidx标识为-1，表示rehash结束\n        d->rehashidx = -1;\n        // 返回0，表示ht[0]中所有元素都迁移完\n        return 0;\n    }\n\n    //返回1，表示ht[0]中仍然有元素没有迁移完\n    /* more to rehash... */\n    return 1;\n}\n\n\n好，在了解了 dictrehash 函数的主体逻辑后，我们再看下渐进式 rehash 是如何按照 bucket 粒度拷贝数据的，这其实就和全局哈希表 dict 结构中的 rehashidx 变量相关了。\n\nrehashidx 变量表示的是当前 rehash 在对哪个 bucket 做数据迁移。比如，当 rehashidx 等于 0 时，表示对 ht[0]中的第一个 bucket 进行数据迁移；当 rehashidx 等于 1 时，表 示对 ht[0]中的第二个 bucket 进行数据迁移，以此类推。\n\n而 dictrehash 函数的主循环，首先会判断 rehashidx 指向的 bucket 是否为空，如果为 空，那就将 rehashidx 的值加 1，检查下一个 bucket。\n\n那么，有没有可能连续几个 bucket 都为空呢？其实是有可能的，在这种情况下，渐进式 rehash 不会一直递增 rehashidx 进行检查。这是因为一旦执行了 rehash，redis 主线程就无法处理其他请求了。\n\n所以，渐进式 rehash 在执行时设置了一个变量 empty_visits，用来表示已经检查过的空 bucket，当检查了一定数量的空 bucket 后，这一轮的 rehash 就停止执行，转而继续处理外来请求，避免了对 redis 性能的影响。下面的代码显示了这部分逻辑，你可以看下。\n\n// 如果当前要迁移的bucket中没有元素\nwhile(d->ht[0].table[d->rehashidx] == null) {\n    d->rehashidx++;\n    if (--empty_visits == 0) return 1;\n}\n\n\n而如果 rehashidx 指向的 bucket 有数据可以迁移，那么 redis 就会把这个 bucket 中的哈希项依次取出来，并根据 ht[1]的表空间大小，重新计算哈希项在 ht[1]中的 bucket 位置，然后把这个哈希项赋值到 ht[1]对应 bucket 中。\n\n这样，每做完一个哈希项的迁移，ht[0]和 ht[1]用来表示承载哈希项多少的变量 used，就 会分别减一和加一。当然，如果当前 rehashidx 指向的 bucket 中数据都迁移完了， rehashidx 就会递增加 1，指向下一个 bucket。下面的代码显示了这一迁移过程。\n\n while(n-- && d->ht[0].used != 0) {\n     dictentry *de, *nextde;\n\n     /* note that rehashidx can't overflow as we are sure there are more\n         * elements because ht[0].used != 0 */\n     assert(d->ht[0].size > (unsigned long)d->rehashidx);\n     while(d->ht[0].table[d->rehashidx] == null) {\n         d->rehashidx++;\n         if (--empty_visits == 0) return 1;\n     }\n     // 获得哈希表中哈希项\n     de = d->ht[0].table[d->rehashidx];\n     /* move all the keys in this bucket from the old to the new hash ht */\n     while(de) {\n         uint64_t h;\n\t\t // 获得同一个bucket中下一个哈希项\n         nextde = de->next;\n         /* get the index in the new hash table */\n         // 根据扩容后的哈希表ht[1]大小，计算当前哈希项在扩容后哈希表中的bucket位置\n         h = dicthashkey(d, de->key) & d->ht[1].sizemask;\n         // 将当前哈希项添加到扩容后的哈希表ht[1]中\n         de->next = d->ht[1].table[h];\n         d->ht[1].table[h] = de;\n         // 减少当前哈希表的哈希项个数\n         d->ht[0].used--;\n         // 增加扩容后哈希表的哈希项个数\n         d->ht[1].used++;\n         de = nextde;\n     }\n     // 如果当前bucket中已经没有哈希项了，将该bucket置为null\n     d->ht[0].table[d->rehashidx] = null;\n     // 将rehash加1，下一次将迁移下一个bucket中的元素\n     d->rehashidx++;\n }\n\n\n好了，到这里，我们就已经基本了解了 dictrehash 函数的全部逻辑。 现在我们知道，dictrehash 函数本身是按照 bucket 粒度执行哈希项迁移的，它内部执行 的 bucket 迁移个数，主要由传入的循环次数变量 n 来决定。但凡 redis 要进行 rehash操作，最终都会调用 dictrehash 函数。\n\n接下来，我们来学习和渐进式 rehash 相关的第二个关键函数 _dictrehashstep，这个函 数实现了每次只对一个 bucket 执行 rehash。 从 redis 的源码中我们可以看到，一共会有 5 个函数通过调用 _dictrehashstep 函数，进而调用 dictrehash 函数，来执行 rehash，它们分别是：dictaddraw， dictgenericdelete，dictfind，dictgetrandomkey，dictgetsomekeys。\n\n其中，dictaddraw 和 dictgenericdelete 函数，分别对应了往 redis 中增加和删除键值对，而后三个函数则对应了在 redis 中进行查询操作。下图展示了这些函数间的调用关系：\n\n但你要注意，不管是增删查哪种操作，这 5 个函数调用的 _dictrehashstep 函数，给 dictrehash 传入的循环次数变量 n 的值都为 1，下面的代码就显示了这一传参的情况。\n\nstatic void _dictrehashstep(dict *d) {\n    // 给dictrehash传入的循环次数参数为1，表明每迁移完一个bucket ，就执行正常操作\n    if (d->pauserehash == 0) dictrehash(d,1);\n}\n\n\n这样一来，每次迁移完一个 bucket，hash 表就会执行正常的增删查请求操作，这就是在代码层面实现渐进式 rehash 的方法。\n\n\n# 小结\n\n实现一个高性能的hash表不仅是redis的需求，也是很多计算机系统开发过程中的重要目标。而要想实现一个性能优异的hash表，就需要重点解决哈希冲突和rehash开销这两个问题。 今天这节课，我带你学习了redis中hash表的结构设计、链式哈希方法的实现，以及渐进式rehash方法的设计实现。redis中hash表的结构设计很特别，它的每个哈希项都包含了一个指针，用于实现链式哈希。同时，redis在全局哈希表中还包含了两个hash表，这种设计思路也是为了在实现rehash时，帮助数据从一个表迁移到另一个表。 此外，redis实现的渐进式rehash是一个用于hash表扩容的通用方法，非常值得我们学习。这个设计方法的关键是每次仅迁移有限个数的bucket，避免一次性迁移给所有bucket带来的性能影响。当你掌握了渐进式rehash这个设计思想和实现方法，你就可以把它应用到自己的hash表实现场景中。\n\n\n# 参考文献\n\nredis 源码剖析与实战 (geekbang.org)",charsets:{cjk:!0},lastUpdated:"2024/09/14, 11:14:17",lastUpdatedTimestamp:1726312457e3},{title:"README",frontmatter:{title:"README",date:"2024-09-14T02:07:49.000Z",permalink:"/pages/73ef48/"},regularPath:"/01.%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E7%AE%97%E6%B3%95/",relativePath:"01.系统设计算法/README.md",key:"v-639e0f9a",path:"/pages/73ef48/",headersStr:null,content:"# 介绍",normalizedContent:"# 介绍",charsets:{cjk:!0},lastUpdated:"2024/09/13, 19:57:43",lastUpdatedTimestamp:1726257463e3},{title:"设计 微信",frontmatter:{title:"设计 微信",date:"2024-09-14T02:08:51.000Z",permalink:"/pages/a95d7d/"},regularPath:"/02.%E8%AE%BE%E8%AE%A1%E7%83%AD%E9%97%A8%E5%BA%94%E7%94%A8/01.%E7%A4%BE%E4%BA%A4%E7%B1%BB/01.%E8%AE%BE%E8%AE%A1%20%E5%BE%AE%E4%BF%A1.html",relativePath:"02.设计热门应用/01.社交类/01.设计 微信.md",key:"v-fb7b08d2",path:"/pages/a95d7d/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/09/14, 08:54:46",lastUpdatedTimestamp:1726304086e3},{title:"设计Twitter",frontmatter:{title:"设计Twitter",date:"2024-09-14T02:08:51.000Z",permalink:"/pages/90ad66/"},regularPath:"/02.%E8%AE%BE%E8%AE%A1%E7%83%AD%E9%97%A8%E5%BA%94%E7%94%A8/01.%E7%A4%BE%E4%BA%A4%E7%B1%BB/02.%E8%AE%BE%E8%AE%A1Twitter.html",relativePath:"02.设计热门应用/01.社交类/02.设计Twitter.md",key:"v-d89ce0de",path:"/pages/90ad66/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/09/14, 08:54:46",lastUpdatedTimestamp:1726304086e3},{title:"README",frontmatter:{title:"README",date:"2024-09-14T02:08:51.000Z",permalink:"/pages/6e86ba/"},regularPath:"/02.%E8%AE%BE%E8%AE%A1%E7%83%AD%E9%97%A8%E5%BA%94%E7%94%A8/",relativePath:"02.设计热门应用/README.md",key:"v-2b8f38b0",path:"/pages/6e86ba/",headersStr:null,content:"# 介绍",normalizedContent:"# 介绍",charsets:{cjk:!0},lastUpdated:"2024/09/13, 19:57:43",lastUpdatedTimestamp:1726257463e3},{title:"双写一致性",frontmatter:{title:"双写一致性",date:"2024-09-14T16:50:17.000Z",permalink:"/pages/def08a/"},regularPath:"/03.%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/01.%E7%83%AD%E9%97%A8%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/01.%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7.html",relativePath:"03.场景设计/01.热门场景设计/01.双写一致性.md",key:"v-345df50e",path:"/pages/def08a/",headers:[{level:2,title:"引子",slug:"引子",normalizedTitle:"引子",charIndex:2},{level:2,title:"引入缓存提高性能",slug:"引入缓存提高性能",normalizedTitle:"引入缓存提高性能",charIndex:136},{level:2,title:"缓存利用率和一致性问题",slug:"缓存利用率和一致性问题",normalizedTitle:"缓存利用率和一致性问题",charIndex:841},{level:3,title:"先来看第一个问题，如何提高缓存利用率？",slug:"先来看第一个问题-如何提高缓存利用率",normalizedTitle:"先来看第一个问题，如何提高缓存利用率？",charIndex:857},{level:2,title:"并发引发的一致性问题",slug:"并发引发的一致性问题",normalizedTitle:"并发引发的一致性问题",charIndex:1822},{level:2,title:"删除缓存可以保证一致性吗？",slug:"删除缓存可以保证一致性吗",normalizedTitle:"删除缓存可以保证一致性吗？",charIndex:2434},{level:2,title:"如何保证两步都执行成功？",slug:"如何保证两步都执行成功",normalizedTitle:"如何保证两步都执行成功？",charIndex:3376},{level:2,title:"主从库延迟和延迟双删问题",slug:"主从库延迟和延迟双删问题",normalizedTitle:"主从库延迟和延迟双删问题",charIndex:4973},{level:2,title:"可以做到强一致吗？",slug:"可以做到强一致吗",normalizedTitle:"可以做到强一致吗？",charIndex:6103},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:6604},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:7140}],headersStr:"引子 引入缓存提高性能 缓存利用率和一致性问题 先来看第一个问题，如何提高缓存利用率？ 并发引发的一致性问题 删除缓存可以保证一致性吗？ 如何保证两步都执行成功？ 主从库延迟和延迟双删问题 可以做到强一致吗？ 总结 参考文献",content:"# 引子\n\n感觉这是一个很宏大的命题\n\n我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要\n\n可以将请求分流，要保证强一致的请求走数据库，能忍受不一致的请求走缓存\n\necho 带着你沿着场景渐进式的了解双写一致性问题\n\n\n# 引入缓存提高性能\n\n我们从最简单的场景开始讲起。\n\n如果你的业务处于起步阶段，流量非常小，那无论是读请求还是写请求，直接操作数据库即可，这时你的架构模型是这样的：\n\n\n\n但随着业务量的增长，你的项目请求量越来越大，这时如果每次都从数据库中读数据，那肯定会有性能问题。\n\n这个阶段通常的做法是，引入「缓存」来提高读性能，架构模型就变成了这样：\n\n\n\n当下优秀的缓存中间件，当属 Redis 莫属，它不仅性能非常高，还提供了很多友好的数据类型，可以很好地满足我们的业务需求。\n\n但引入缓存之后，你就会面临一个问题：之前数据只存在数据库中，现在要放到缓存中读取，具体要怎么存呢？\n\n有三种方案：\n\n * Cache Aside Pattern（旁路缓存模式）\n * Read/Write Through Pattern（读写穿透）\n * Write Behind Pattern（异步缓存写入）\n\n最简单直接的方案是「全量数据刷到缓存中」：\n\n * 数据库的数据，全量刷入缓存（不设置失效时间）\n * 写请求只更新数据库，不更新缓存\n * 启动一个定时任务，定时把数据库的数据，更新到缓存中\n\n\n\n这个方案的优点是，所有读请求都可以直接「命中」缓存，不需要再查数据库，性能非常高。\n\n但缺点也很明显，有 2 个问题：\n\n 1. 缓存利用率低：不经常访问的数据，还一直留在缓存中\n 2. 数据不一致：因为是「定时」刷新缓存，缓存和数据库存在不一致（取决于定时任务的执行频率）\n\n所以，这种方案一般更适合业务「体量小」，且对数据一致性要求不高的业务场景。\n\n那如果我们的业务体量很大，怎么解决这 2 个问题呢？\n\n\n# 缓存利用率和一致性问题\n\n\n# 先来看第一个问题，如何提高缓存利用率？\n\n想要缓存利用率「最大化」，我们很容易想到的方案是，缓存中只保留最近访问的「热数据」。但具体要怎么做呢？\n\n我们可以这样优化：\n\n * 写请求依旧只写数据库\n * 读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存\n * 同时，写入缓存中的数据，都设置失效时间\n\n\n\n这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「热数据」，缓存利用率得以最大化。\n\n再来看数据一致性问题。\n\n要想保证缓存和数据库「实时」一致，那就不能再用定时任务刷新缓存了。\n\n所以，当数据发生更新时，我们不仅要操作数据库，还要一并操作缓存。具体操作就是，修改一条数据时，不仅要更新数据库，也要连带缓存一起更新。\n\n但数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：\n\n 1. 先更新缓存，后更新数据库\n 2. 先更新数据库，后更新缓存\n\n哪个方案更好呢？\n\n先不考虑并发问题，正常情况下，无论谁先谁后，都可以让两者保持一致，但现在我们需要重点考虑「异常」情况。\n\n因为操作分为两步，那么就很有可能存在「第一步成功、第二步失败」的情况发生。\n\n这 2 种方案我们一个个来分析。\n\n1) 先更新缓存，后更新数据库\n\n如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。\n\n虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值。\n\n这时用户会发现自己之前修改的数据又「变回去」了，对业务造成影响。\n\n2) 先更新数据库，后更新缓存\n\n如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。\n\n之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。\n\n这时用户会发现，自己刚刚修改了数据，但却看不到变更，一段时间过后，数据才变更过来，对业务也会有影响。\n\n可见，无论谁先谁后，但凡后者发生异常，就会对业务造成影响。那怎么解决这个问题呢？\n\n别急，后面我会详细给出对应的解决方案。\n\n我们继续分析，除了操作失败问题，还有什么场景会影响数据一致性？\n\n这里我们还需要重点关注：并发问题。\n\n\n# 并发引发的一致性问题\n\n假设我们采用**「先更新数据库，再更新缓存」**的方案，并且两步都可以「成功执行」的前提下，如果存在并发，情况会是怎样的呢？\n\n有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：\n\n 1. 线程 A 更新数据库（X = 1）\n 2. 线程 B 更新数据库（X = 2）\n 3. 线程 B 更新缓存（X = 2）\n 4. 线程 A 更新缓存（X = 1）\n\n最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。\n\n也就是说，A 虽然先于 B 发生，但 B 操作数据库和缓存的时间，却要比 A 的时间短，执行时序发生「错乱」，最终这条数据结果是不符合预期的。\n\n> 同样地，采用「先更新缓存，再更新数据库」的方案，也会有类似问题，这里不再详述。\n\n除此之外，我们从「缓存利用率」的角度来评估这个方案，也是不太推荐的。\n\n这是因为每次数据发生变更，都「无脑」更新缓存，但是缓存中的数据不一定会被「马上读取」，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。\n\n而且很多情况下，写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列「计算」得出一个值，才把这个值才写到缓存中。\n\n由此可见，这种「更新数据库 + 更新缓存」的方案，不仅缓存利用率不高，还会造成机器性能的浪费。\n\n所以此时我们需要考虑另外一种方案：删除缓存。\n\n\n# 删除缓存可以保证一致性吗？\n\n删除缓存对应的方案也有 2 种：\n\n 1. 先删除缓存，后更新数据库\n 2. 先更新数据库，后删除缓存\n\n经过前面的分析我们已经得知，但凡「第二步」操作失败，都会导致数据不一致。\n\n这里我不再详述具体场景，你可以按照前面的思路推演一下，就可以看到依旧存在数据不一致的情况。\n\n这里我们重点来看「并发」问题。\n\n1) 先删除缓存，后更新数据库\n\n如果有 2 个线程要并发「读写」数据，可能会发生以下场景：\n\n 1. 线程 A 要更新 X = 2（原值 X = 1）\n 2. 线程 A 先删除缓存\n 3. 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）\n 4. 线程 A 将新值写入数据库（X = 2）\n 5. 线程 B 将旧值写入缓存（X = 1）\n\n最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。\n\n可见，先删除缓存，后更新数据库，当发生「读+写」并发时，还是存在数据不一致的情况。\n\n2) 先更新数据库，后删除缓存\n\n依旧是 2 个线程并发「读写」数据：\n\n 1. 缓存中 X 不存在（数据库 X = 1）\n 2. 线程 A 读取数据库，得到旧值（X = 1）\n 3. 线程 B 更新数据库（X = 2)\n 4. 线程 B 删除缓存\n 5. 线程 A 将旧值写入缓存（X = 1）\n\n最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。\n\n这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？\n\n其实概率「很低」，这是因为它必须满足 3 个条件：\n\n 1. 缓存刚好已失效\n 2. 读请求 + 写请求并发\n 3. 更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）\n\n仔细想一下，条件 3 发生的概率其实是非常低的。\n\n因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。\n\n这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的。\n\n所以，我们应该采用这种方案，来操作数据库和缓存。\n\n好，解决了并发问题，我们继续来看前面遗留的，第二步执行「失败」导致数据不一致的问题。\n\n\n# 如何保证两步都执行成功？\n\n前面我们分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。\n\n前面我们分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。\n\n保证第二步成功执行，就是解决问题的关键。\n\n想一下，程序在执行过程中发生异常，最简单的解决办法是什么？\n\n答案是：重试。\n\n是的，其实这里我们也可以这样做。\n\n无论是先操作缓存，还是先操作数据库，但凡后者执行失败了，我们就可以发起重试，尽可能地去做「补偿」。\n\n那这是不是意味着，只要执行失败，我们「无脑重试」就可以了呢？\n\n答案是否定的。现实情况往往没有想的这么简单，失败后立即重试的问题在于：\n\n * 立即重试很大概率「还会失败」\n * 「重试次数」设置多少才合理？\n * 重试会一直「占用」这个线程资源，无法服务其它客户端请求\n\n看到了么，虽然我们想通过重试的方式解决问题，但这种「同步」重试的方案依旧不严谨。\n\n那更好的方案应该怎么做？\n\n答案是：异步重试。什么是异步重试？\n\n其实就是把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。\n\n或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。\n\n到这里你可能会问，写消息队列也有可能会失败啊？而且，引入消息队列，这又增加了更多的维护成本，这样做值得吗？\n\n这个问题很好，但我们思考这样一个问题：如果在执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。\n\n所以，这里我们必须把重试或第二步操作放到另一个「服务」中，这个服务用「消息队列」最为合适。这是因为消息队列的特性，正好符合我们的需求：\n\n * 消息队列保证可靠性：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）\n * 消息队列保证消息成功投递：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）\n\n至于写队列失败和消息队列的维护成本问题：\n\n * 写队列失败：操作缓存和写消息队列，「同时失败」的概率其实是很小的\n * 维护成本：我们项目中一般都会用到消息队列，维护成本并没有新增很多\n\n所以，引入消息队列来解决这个问题，是比较合适的。这时架构模型就变成了这样：\n\n那如果你确实不想在应用中去写消息队列，是否有更简单的方案，同时又可以保证一致性呢？\n\n方案还是有的，这就是近几年比较流行的解决方案：订阅数据库变更日志，再操作缓存。\n\n具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。\n\n那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。\n\n拿 MySQL 举例，当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。\n\n订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：\n\n * 无需考虑写消息队列失败情况：只要写 MySQL 成功，Binlog 肯定会有\n * 自动投递到下游队列：canal 自动把数据库变更日志「投递」给下游的消息队列\n\n当然，与此同时，我们需要投入精力去维护 canal 的高可用和稳定性。\n\n> 如果你有留意观察很多数据库的特性，就会发现其实很多数据库都逐渐开始提供「订阅变更日志」的功能了，相信不远的将来，我们就不用通过中间件来拉取日志，自己写程序就可以订阅变更日志了，这样可以进一步简化流程。\n\n至此，我们可以得出结论，想要保证数据库和缓存一致性，推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做。\n\n\n# 主从库延迟和延迟双删问题\n\n到这里，还有 2 个问题，是我们没有重点分析过的。\n\n第一个问题，还记得前面讲到的「先删除缓存，再更新数据库」方案，导致不一致的场景么？\n\n这里我再把例子拿过来让你复习一下：\n\n2 个线程要并发「读写」数据，可能会发生以下场景：\n\n 1. 线程 A 要更新 X = 2（原值 X = 1）\n 2. 线程 A 先删除缓存\n 3. 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）\n 4. 线程 A 将新值写入数据库（X = 2）\n 5. 线程 B 将旧值写入缓存（X = 1）\n\n最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。\n\n第二个问题：是关于「读写分离 + 主从复制延迟」情况下，缓存和数据库一致性的问题。\n\n在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」其实也会导致不一致：\n\n 1. 线程 A 更新主库 X = 2（原值 X = 1）\n 2. 线程 A 删除缓存\n 3. 线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）\n 4. 从库「同步」完成（主从库 X = 2）\n 5. 线程 B 将「旧值」写入缓存（X = 1）\n\n最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。\n\n看到了么？这 2 个问题的核心在于：缓存都被回种了「旧值」。\n\n那怎么解决这类问题呢？\n\n最有效的办法就是，把缓存删掉。\n\n但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：缓存延迟双删策略。\n\n按照延时双删策略，这 2 个问题的解决方案是这样的：\n\n解决第一个问题：在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。\n\n解决第二个问题：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。\n\n这两个方案的目的，都是为了把缓存清掉，这样一来，下次就可以从数据库读取到最新值，写入缓存。\n\n但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？\n\n * 问题1：延迟时间要大于「主从复制」的延迟时间\n * 问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间\n\n但是，这个时间在分布式和高并发场景下，其实是很难评估的\n\n很多时候，我们都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。\n\n所以你看，采用这种方案，也只是尽可能保证一致性而已，极端情况下，还是有可能发生不一致。\n\n所以实际使用中，我还是建议你采用「先更新数据库，再删除缓存」的方案，同时，要尽可能地保证「主从复制」不要有太大延迟，降低出问题的概率。\n\n\n# 可以做到强一致吗？\n\n看到这里你可能会想，这些方案还是不够完美，我就想让缓存和数据库「强一致」，到底能不能做到呢？\n\n其实很难。\n\n要想做到强一致，最常见的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。\n\n相反，这时我们换个角度思考一下，我们引入缓存的目的是什么？\n\n没错，性能。\n\n一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。\n\n而且，就拿我们前面讲到的方案来说，当操作数据库和缓存完成之前，只要有其它请求可以进来，都有可能查到「中间状态」的数据。\n\n所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。\n\n虽然我们可以通过加「分布锁」的方式来实现，但我们要付出的代价，很可能会超过引入缓存带来的性能提升。\n\n所以，既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。\n\n同时我们也要知道，缓存都是有「失效时间」的，就算在这期间存在短期不一致，我们依旧有失效时间来兜底，这样也能达到最终一致。\n\n\n# 总结\n\n好了，总结一下这篇文章的重点。\n\n 1. 想要提高应用的性能，可以引入「缓存」来解决\n 2. 引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」\n 3. 更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生\n 4. 在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案\n 5. 在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性\n 6. 在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率\n 7. 如果要实现强一致性可以采用的方案是 2PC、3PC、Paxos、Raft 这类一致性协议，或者使用分布式锁\n\n\n# 参考文献\n\n缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹",normalizedContent:"# 引子\n\n感觉这是一个很宏大的命题\n\n我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要\n\n可以将请求分流，要保证强一致的请求走数据库，能忍受不一致的请求走缓存\n\necho 带着你沿着场景渐进式的了解双写一致性问题\n\n\n# 引入缓存提高性能\n\n我们从最简单的场景开始讲起。\n\n如果你的业务处于起步阶段，流量非常小，那无论是读请求还是写请求，直接操作数据库即可，这时你的架构模型是这样的：\n\n\n\n但随着业务量的增长，你的项目请求量越来越大，这时如果每次都从数据库中读数据，那肯定会有性能问题。\n\n这个阶段通常的做法是，引入「缓存」来提高读性能，架构模型就变成了这样：\n\n\n\n当下优秀的缓存中间件，当属 redis 莫属，它不仅性能非常高，还提供了很多友好的数据类型，可以很好地满足我们的业务需求。\n\n但引入缓存之后，你就会面临一个问题：之前数据只存在数据库中，现在要放到缓存中读取，具体要怎么存呢？\n\n有三种方案：\n\n * cache aside pattern（旁路缓存模式）\n * read/write through pattern（读写穿透）\n * write behind pattern（异步缓存写入）\n\n最简单直接的方案是「全量数据刷到缓存中」：\n\n * 数据库的数据，全量刷入缓存（不设置失效时间）\n * 写请求只更新数据库，不更新缓存\n * 启动一个定时任务，定时把数据库的数据，更新到缓存中\n\n\n\n这个方案的优点是，所有读请求都可以直接「命中」缓存，不需要再查数据库，性能非常高。\n\n但缺点也很明显，有 2 个问题：\n\n 1. 缓存利用率低：不经常访问的数据，还一直留在缓存中\n 2. 数据不一致：因为是「定时」刷新缓存，缓存和数据库存在不一致（取决于定时任务的执行频率）\n\n所以，这种方案一般更适合业务「体量小」，且对数据一致性要求不高的业务场景。\n\n那如果我们的业务体量很大，怎么解决这 2 个问题呢？\n\n\n# 缓存利用率和一致性问题\n\n\n# 先来看第一个问题，如何提高缓存利用率？\n\n想要缓存利用率「最大化」，我们很容易想到的方案是，缓存中只保留最近访问的「热数据」。但具体要怎么做呢？\n\n我们可以这样优化：\n\n * 写请求依旧只写数据库\n * 读请求先读缓存，如果缓存不存在，则从数据库读取，并重建缓存\n * 同时，写入缓存中的数据，都设置失效时间\n\n\n\n这样一来，缓存中不经常访问的数据，随着时间的推移，都会逐渐「过期」淘汰掉，最终缓存中保留的，都是经常被访问的「热数据」，缓存利用率得以最大化。\n\n再来看数据一致性问题。\n\n要想保证缓存和数据库「实时」一致，那就不能再用定时任务刷新缓存了。\n\n所以，当数据发生更新时，我们不仅要操作数据库，还要一并操作缓存。具体操作就是，修改一条数据时，不仅要更新数据库，也要连带缓存一起更新。\n\n但数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：\n\n 1. 先更新缓存，后更新数据库\n 2. 先更新数据库，后更新缓存\n\n哪个方案更好呢？\n\n先不考虑并发问题，正常情况下，无论谁先谁后，都可以让两者保持一致，但现在我们需要重点考虑「异常」情况。\n\n因为操作分为两步，那么就很有可能存在「第一步成功、第二步失败」的情况发生。\n\n这 2 种方案我们一个个来分析。\n\n1) 先更新缓存，后更新数据库\n\n如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。\n\n虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值。\n\n这时用户会发现自己之前修改的数据又「变回去」了，对业务造成影响。\n\n2) 先更新数据库，后更新缓存\n\n如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。\n\n之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。\n\n这时用户会发现，自己刚刚修改了数据，但却看不到变更，一段时间过后，数据才变更过来，对业务也会有影响。\n\n可见，无论谁先谁后，但凡后者发生异常，就会对业务造成影响。那怎么解决这个问题呢？\n\n别急，后面我会详细给出对应的解决方案。\n\n我们继续分析，除了操作失败问题，还有什么场景会影响数据一致性？\n\n这里我们还需要重点关注：并发问题。\n\n\n# 并发引发的一致性问题\n\n假设我们采用**「先更新数据库，再更新缓存」**的方案，并且两步都可以「成功执行」的前提下，如果存在并发，情况会是怎样的呢？\n\n有线程 a 和线程 b 两个线程，需要更新「同一条」数据，会发生这样的场景：\n\n 1. 线程 a 更新数据库（x = 1）\n 2. 线程 b 更新数据库（x = 2）\n 3. 线程 b 更新缓存（x = 2）\n 4. 线程 a 更新缓存（x = 1）\n\n最终 x 的值在缓存中是 1，在数据库中是 2，发生不一致。\n\n也就是说，a 虽然先于 b 发生，但 b 操作数据库和缓存的时间，却要比 a 的时间短，执行时序发生「错乱」，最终这条数据结果是不符合预期的。\n\n> 同样地，采用「先更新缓存，再更新数据库」的方案，也会有类似问题，这里不再详述。\n\n除此之外，我们从「缓存利用率」的角度来评估这个方案，也是不太推荐的。\n\n这是因为每次数据发生变更，都「无脑」更新缓存，但是缓存中的数据不一定会被「马上读取」，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。\n\n而且很多情况下，写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列「计算」得出一个值，才把这个值才写到缓存中。\n\n由此可见，这种「更新数据库 + 更新缓存」的方案，不仅缓存利用率不高，还会造成机器性能的浪费。\n\n所以此时我们需要考虑另外一种方案：删除缓存。\n\n\n# 删除缓存可以保证一致性吗？\n\n删除缓存对应的方案也有 2 种：\n\n 1. 先删除缓存，后更新数据库\n 2. 先更新数据库，后删除缓存\n\n经过前面的分析我们已经得知，但凡「第二步」操作失败，都会导致数据不一致。\n\n这里我不再详述具体场景，你可以按照前面的思路推演一下，就可以看到依旧存在数据不一致的情况。\n\n这里我们重点来看「并发」问题。\n\n1) 先删除缓存，后更新数据库\n\n如果有 2 个线程要并发「读写」数据，可能会发生以下场景：\n\n 1. 线程 a 要更新 x = 2（原值 x = 1）\n 2. 线程 a 先删除缓存\n 3. 线程 b 读缓存，发现不存在，从数据库中读取到旧值（x = 1）\n 4. 线程 a 将新值写入数据库（x = 2）\n 5. 线程 b 将旧值写入缓存（x = 1）\n\n最终 x 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。\n\n可见，先删除缓存，后更新数据库，当发生「读+写」并发时，还是存在数据不一致的情况。\n\n2) 先更新数据库，后删除缓存\n\n依旧是 2 个线程并发「读写」数据：\n\n 1. 缓存中 x 不存在（数据库 x = 1）\n 2. 线程 a 读取数据库，得到旧值（x = 1）\n 3. 线程 b 更新数据库（x = 2)\n 4. 线程 b 删除缓存\n 5. 线程 a 将旧值写入缓存（x = 1）\n\n最终 x 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。\n\n这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？\n\n其实概率「很低」，这是因为它必须满足 3 个条件：\n\n 1. 缓存刚好已失效\n 2. 读请求 + 写请求并发\n 3. 更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）\n\n仔细想一下，条件 3 发生的概率其实是非常低的。\n\n因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。\n\n这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的。\n\n所以，我们应该采用这种方案，来操作数据库和缓存。\n\n好，解决了并发问题，我们继续来看前面遗留的，第二步执行「失败」导致数据不一致的问题。\n\n\n# 如何保证两步都执行成功？\n\n前面我们分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。\n\n前面我们分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。\n\n保证第二步成功执行，就是解决问题的关键。\n\n想一下，程序在执行过程中发生异常，最简单的解决办法是什么？\n\n答案是：重试。\n\n是的，其实这里我们也可以这样做。\n\n无论是先操作缓存，还是先操作数据库，但凡后者执行失败了，我们就可以发起重试，尽可能地去做「补偿」。\n\n那这是不是意味着，只要执行失败，我们「无脑重试」就可以了呢？\n\n答案是否定的。现实情况往往没有想的这么简单，失败后立即重试的问题在于：\n\n * 立即重试很大概率「还会失败」\n * 「重试次数」设置多少才合理？\n * 重试会一直「占用」这个线程资源，无法服务其它客户端请求\n\n看到了么，虽然我们想通过重试的方式解决问题，但这种「同步」重试的方案依旧不严谨。\n\n那更好的方案应该怎么做？\n\n答案是：异步重试。什么是异步重试？\n\n其实就是把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。\n\n或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。\n\n到这里你可能会问，写消息队列也有可能会失败啊？而且，引入消息队列，这又增加了更多的维护成本，这样做值得吗？\n\n这个问题很好，但我们思考这样一个问题：如果在执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。\n\n所以，这里我们必须把重试或第二步操作放到另一个「服务」中，这个服务用「消息队列」最为合适。这是因为消息队列的特性，正好符合我们的需求：\n\n * 消息队列保证可靠性：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）\n * 消息队列保证消息成功投递：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）\n\n至于写队列失败和消息队列的维护成本问题：\n\n * 写队列失败：操作缓存和写消息队列，「同时失败」的概率其实是很小的\n * 维护成本：我们项目中一般都会用到消息队列，维护成本并没有新增很多\n\n所以，引入消息队列来解决这个问题，是比较合适的。这时架构模型就变成了这样：\n\n那如果你确实不想在应用中去写消息队列，是否有更简单的方案，同时又可以保证一致性呢？\n\n方案还是有的，这就是近几年比较流行的解决方案：订阅数据库变更日志，再操作缓存。\n\n具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。\n\n那什么时候操作缓存呢？这就和数据库的「变更日志」有关了。\n\n拿 mysql 举例，当一条数据发生修改时，mysql 就会产生一条变更日志（binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。\n\n订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：\n\n * 无需考虑写消息队列失败情况：只要写 mysql 成功，binlog 肯定会有\n * 自动投递到下游队列：canal 自动把数据库变更日志「投递」给下游的消息队列\n\n当然，与此同时，我们需要投入精力去维护 canal 的高可用和稳定性。\n\n> 如果你有留意观察很多数据库的特性，就会发现其实很多数据库都逐渐开始提供「订阅变更日志」的功能了，相信不远的将来，我们就不用通过中间件来拉取日志，自己写程序就可以订阅变更日志了，这样可以进一步简化流程。\n\n至此，我们可以得出结论，想要保证数据库和缓存一致性，推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做。\n\n\n# 主从库延迟和延迟双删问题\n\n到这里，还有 2 个问题，是我们没有重点分析过的。\n\n第一个问题，还记得前面讲到的「先删除缓存，再更新数据库」方案，导致不一致的场景么？\n\n这里我再把例子拿过来让你复习一下：\n\n2 个线程要并发「读写」数据，可能会发生以下场景：\n\n 1. 线程 a 要更新 x = 2（原值 x = 1）\n 2. 线程 a 先删除缓存\n 3. 线程 b 读缓存，发现不存在，从数据库中读取到旧值（x = 1）\n 4. 线程 a 将新值写入数据库（x = 2）\n 5. 线程 b 将旧值写入缓存（x = 1）\n\n最终 x 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。\n\n第二个问题：是关于「读写分离 + 主从复制延迟」情况下，缓存和数据库一致性的问题。\n\n在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」其实也会导致不一致：\n\n 1. 线程 a 更新主库 x = 2（原值 x = 1）\n 2. 线程 a 删除缓存\n 3. 线程 b 查询缓存，没有命中，查询「从库」得到旧值（从库 x = 1）\n 4. 从库「同步」完成（主从库 x = 2）\n 5. 线程 b 将「旧值」写入缓存（x = 1）\n\n最终 x 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。\n\n看到了么？这 2 个问题的核心在于：缓存都被回种了「旧值」。\n\n那怎么解决这类问题呢？\n\n最有效的办法就是，把缓存删掉。\n\n但是，不能立即删，而是需要「延迟删」，这就是业界给出的方案：缓存延迟双删策略。\n\n按照延时双删策略，这 2 个问题的解决方案是这样的：\n\n解决第一个问题：在线程 a 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。\n\n解决第二个问题：线程 a 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。\n\n这两个方案的目的，都是为了把缓存清掉，这样一来，下次就可以从数据库读取到最新值，写入缓存。\n\n但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？\n\n * 问题1：延迟时间要大于「主从复制」的延迟时间\n * 问题2：延迟时间要大于线程 b 读取数据库 + 写入缓存的时间\n\n但是，这个时间在分布式和高并发场景下，其实是很难评估的\n\n很多时候，我们都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。\n\n所以你看，采用这种方案，也只是尽可能保证一致性而已，极端情况下，还是有可能发生不一致。\n\n所以实际使用中，我还是建议你采用「先更新数据库，再删除缓存」的方案，同时，要尽可能地保证「主从复制」不要有太大延迟，降低出问题的概率。\n\n\n# 可以做到强一致吗？\n\n看到这里你可能会想，这些方案还是不够完美，我就想让缓存和数据库「强一致」，到底能不能做到呢？\n\n其实很难。\n\n要想做到强一致，最常见的方案是 2pc、3pc、paxos、raft 这类一致性协议，但它们的性能往往比较差，而且这些方案也比较复杂，还要考虑各种容错问题。\n\n相反，这时我们换个角度思考一下，我们引入缓存的目的是什么？\n\n没错，性能。\n\n一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。\n\n而且，就拿我们前面讲到的方案来说，当操作数据库和缓存完成之前，只要有其它请求可以进来，都有可能查到「中间状态」的数据。\n\n所以如果非要追求强一致，那必须要求所有更新操作完成之前期间，不能有「任何请求」进来。\n\n虽然我们可以通过加「分布锁」的方式来实现，但我们要付出的代价，很可能会超过引入缓存带来的性能提升。\n\n所以，既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。\n\n同时我们也要知道，缓存都是有「失效时间」的，就算在这期间存在短期不一致，我们依旧有失效时间来兜底，这样也能达到最终一致。\n\n\n# 总结\n\n好了，总结一下这篇文章的重点。\n\n 1. 想要提高应用的性能，可以引入「缓存」来解决\n 2. 引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」\n 3. 更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生\n 4. 在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案\n 5. 在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性\n 6. 在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率\n 7. 如果要实现强一致性可以采用的方案是 2pc、3pc、paxos、raft 这类一致性协议，或者使用分布式锁\n\n\n# 参考文献\n\n缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹",charsets:{cjk:!0},lastUpdated:"2024/09/14, 14:10:17",lastUpdatedTimestamp:1726323017e3},{title:"缓存穿透",frontmatter:{title:"缓存穿透",date:"2024-09-14T16:50:37.000Z",permalink:"/pages/1e9e8e/"},regularPath:"/03.%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/01.%E7%83%AD%E9%97%A8%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/02.%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F.html",relativePath:"03.场景设计/01.热门场景设计/02.缓存穿透.md",key:"v-33f15289",path:"/pages/1e9e8e/",headers:[{level:2,title:"引子",slug:"引子",normalizedTitle:"引子",charIndex:2},{level:2,title:"什么是缓存穿透",slug:"什么是缓存穿透",normalizedTitle:"什么是缓存穿透",charIndex:149},{level:2,title:"缓存穿透如何解决",slug:"缓存穿透如何解决",normalizedTitle:"缓存穿透如何解决",charIndex:606},{level:3,title:"设置空值",slug:"设置空值",normalizedTitle:"设置空值",charIndex:908},{level:3,title:"布隆过滤器",slug:"布隆过滤器",normalizedTitle:"布隆过滤器",charIndex:96},{level:3,title:"接口限流",slug:"接口限流",normalizedTitle:"接口限流",charIndex:1390}],headersStr:"引子 什么是缓存穿透 缓存穿透如何解决 设置空值 布隆过滤器 接口限流",content:"# 引子\n\n先来一个问题：如何解决复杂 where 下的缓存穿透？\n\n * 分为正常请求和非法请求\n * 正常请求：给 where 进行 hash，然后存 redis，合理设置过期时间，并利用布隆过滤器过滤\n * 非法请求：记录查询 null 的次数，如果太大，进行封禁，采用指数退避算法\n\n\n# 什么是缓存穿透\n\n缓存穿透最直白的意思就是，我们的业务系统在接收到请求时在缓存中并没有查到数据，从而穿透到了后端数据库里面查数据的过程。\n\n当然，既然使用了缓存，肯定会难免有穿透的发生，正常的少量穿透是对我们业务来说是不会造成任何影响的，因为:\n\n * 毕竟我们的缓存容量有限，不可能去缓存所有数据，当面临较大请求时，查询到未被缓存的数据时，就会发生穿透。\n * 互联网业务的数据访问模型一般是遵循“二八”原则的，即 20% 的数据为热点数据，80% 的数据是非热点不被常访问的数据。\n\n现在既然我们的缓存容量有限，然后 20% 的数据为热点数据，也就是说，我们可以利用有限的容量去缓存那 20% 的数据，其实就是可以保护我们的后端系统的，至于80%非热点不常用的数据发生穿透了，是我们能够接受的。\n\n那究竟什么的缓存穿透会影响到我们的系统呢？是大量的穿透请求超过了我们后端系统的承受范围，比如恶意的穿透攻击，这样的穿透就很有可能把我们的系统给干崩溃。接下来，我们就来基于相关应用场景来解决这种缓存穿透。\n\n\n# 缓存穿透如何解决\n\n在我们APP的在线搜索相关系统里面，有个产品product 1 并没有在数据库中进行存储，现在通过cache aside pattern 策略（缓存读写策略，开发必备）查这个product 1 。\n\n那查询一个数据库中本身就没有的数据后面会怎样呢？依照cache aside 策略，读取时，首先会读取缓存，没读到数据就会穿透到读数据库，现在数据库也没有，也就没有数据写回缓存。那么，再来个请求依然如此，更多的请求来还是一样，这样的缓存就没意义了。\n\n通过上面场景我们可以看到，这样的系统面临非正常的穿透是会崩溃掉的，那我们该怎么去解决呢？一般我们对此有两种方案，都是有用的：\n\n * 设置空值\n * 布隆过滤器\n\n\n# 设置空值\n\n通过上面场景我们知道，当有大量恶意的穿透请求到数据库，就会给我们系统带来灾难。\n\n所以，当我们请求数据中没有数据或者因为代码bug带来的异常造成的数据为空，这个时候我们就可以回写一个空值null到缓存中。同时，我们还要给这个null值设置过期时间，因为这个空值不具有实际业务性，而且还占用空间。\n\n可见设置空值是可以阻挡大量穿透请求的，但是如果有大量的获取并不存在数据的穿透请求的话例如恶意攻击，则会浪费缓存空间，如果这种null值过量的话，还会淘汰掉本身缓存存在的数据，这就会使我们的缓存命中率下降。\n\n**生产建议，**在使用设置空值方案时，我们要做好监控，预防缓存空间被过多null值占领造成的缓存空间浪费，如果这种数据量太大，就不再建议使用，那就使用另一种方案，即布隆过滤器。\n\n\n# 布隆过滤器\n\n生产建议：\n\n * 采用多个hash 算法计算hash 值，这样可以减少误判的几率。\n * 布隆过滤器会消耗一定内存空间，根据业务场景进行评估需要多大内存，最后依据公司资源以及成本，看是否能够接受。\n\n\n# 接口限流\n\n根据用户或者 IP 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 IP 列入黑名单。\n\n后面提到的缓存击穿和雪崩都可以配合接口限流来解决，毕竟这些问题的关键都是有很多请求落到了数据库上造成数据库压力过大。",normalizedContent:"# 引子\n\n先来一个问题：如何解决复杂 where 下的缓存穿透？\n\n * 分为正常请求和非法请求\n * 正常请求：给 where 进行 hash，然后存 redis，合理设置过期时间，并利用布隆过滤器过滤\n * 非法请求：记录查询 null 的次数，如果太大，进行封禁，采用指数退避算法\n\n\n# 什么是缓存穿透\n\n缓存穿透最直白的意思就是，我们的业务系统在接收到请求时在缓存中并没有查到数据，从而穿透到了后端数据库里面查数据的过程。\n\n当然，既然使用了缓存，肯定会难免有穿透的发生，正常的少量穿透是对我们业务来说是不会造成任何影响的，因为:\n\n * 毕竟我们的缓存容量有限，不可能去缓存所有数据，当面临较大请求时，查询到未被缓存的数据时，就会发生穿透。\n * 互联网业务的数据访问模型一般是遵循“二八”原则的，即 20% 的数据为热点数据，80% 的数据是非热点不被常访问的数据。\n\n现在既然我们的缓存容量有限，然后 20% 的数据为热点数据，也就是说，我们可以利用有限的容量去缓存那 20% 的数据，其实就是可以保护我们的后端系统的，至于80%非热点不常用的数据发生穿透了，是我们能够接受的。\n\n那究竟什么的缓存穿透会影响到我们的系统呢？是大量的穿透请求超过了我们后端系统的承受范围，比如恶意的穿透攻击，这样的穿透就很有可能把我们的系统给干崩溃。接下来，我们就来基于相关应用场景来解决这种缓存穿透。\n\n\n# 缓存穿透如何解决\n\n在我们app的在线搜索相关系统里面，有个产品product 1 并没有在数据库中进行存储，现在通过cache aside pattern 策略（缓存读写策略，开发必备）查这个product 1 。\n\n那查询一个数据库中本身就没有的数据后面会怎样呢？依照cache aside 策略，读取时，首先会读取缓存，没读到数据就会穿透到读数据库，现在数据库也没有，也就没有数据写回缓存。那么，再来个请求依然如此，更多的请求来还是一样，这样的缓存就没意义了。\n\n通过上面场景我们可以看到，这样的系统面临非正常的穿透是会崩溃掉的，那我们该怎么去解决呢？一般我们对此有两种方案，都是有用的：\n\n * 设置空值\n * 布隆过滤器\n\n\n# 设置空值\n\n通过上面场景我们知道，当有大量恶意的穿透请求到数据库，就会给我们系统带来灾难。\n\n所以，当我们请求数据中没有数据或者因为代码bug带来的异常造成的数据为空，这个时候我们就可以回写一个空值null到缓存中。同时，我们还要给这个null值设置过期时间，因为这个空值不具有实际业务性，而且还占用空间。\n\n可见设置空值是可以阻挡大量穿透请求的，但是如果有大量的获取并不存在数据的穿透请求的话例如恶意攻击，则会浪费缓存空间，如果这种null值过量的话，还会淘汰掉本身缓存存在的数据，这就会使我们的缓存命中率下降。\n\n**生产建议，**在使用设置空值方案时，我们要做好监控，预防缓存空间被过多null值占领造成的缓存空间浪费，如果这种数据量太大，就不再建议使用，那就使用另一种方案，即布隆过滤器。\n\n\n# 布隆过滤器\n\n生产建议：\n\n * 采用多个hash 算法计算hash 值，这样可以减少误判的几率。\n * 布隆过滤器会消耗一定内存空间，根据业务场景进行评估需要多大内存，最后依据公司资源以及成本，看是否能够接受。\n\n\n# 接口限流\n\n根据用户或者 ip 对接口进行限流，对于异常频繁的访问行为，还可以采取黑名单机制，例如将异常 ip 列入黑名单。\n\n后面提到的缓存击穿和雪崩都可以配合接口限流来解决，毕竟这些问题的关键都是有很多请求落到了数据库上造成数据库压力过大。",charsets:{cjk:!0},lastUpdated:"2024/09/14, 14:10:17",lastUpdatedTimestamp:1726323017e3},{title:"缓存击穿",frontmatter:{title:"缓存击穿",date:"2024-09-14T16:50:56.000Z",permalink:"/pages/1d96b2/"},regularPath:"/03.%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/01.%E7%83%AD%E9%97%A8%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/03.%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.html",relativePath:"03.场景设计/01.热门场景设计/03.缓存击穿.md",key:"v-71660c7c",path:"/pages/1d96b2/",headers:[{level:2,title:"什么是缓存击穿",slug:"什么是缓存击穿",normalizedTitle:"什么是缓存击穿",charIndex:2},{level:2,title:"有哪些解决办法",slug:"有哪些解决办法",normalizedTitle:"有哪些解决办法",charIndex:206},{level:2,title:"双检锁解决缓存击穿",slug:"双检锁解决缓存击穿",normalizedTitle:"双检锁解决缓存击穿",charIndex:364}],headersStr:"什么是缓存击穿 有哪些解决办法 双检锁解决缓存击穿",content:'# 什么是缓存击穿\n\n缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期） 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\n\n\n\n举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力\n\n\n# 有哪些解决办法\n\n 1. 永不过期（不推荐）：设置热点数据永不过期或者过期时间比较长。\n 2. 提前预热（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。\n 3. 加锁（看情况）：在缓存失效后，通过设置互斥锁确保只有一个请求去查询数据库并更新缓存。\n\n\n# 双检锁解决缓存击穿\n\n> 单例模式的一种实现，双重检测，其中的一层检测是为了提高效率。由于项目中采用了多线程，所以在第一个线程没有从缓存中获取到数据之后，有可能其他线程已经完成了读取数据库写入缓存的操作，也就是说，第一个线程再次得到时间片的时候，就没有必要访问数据库获取数据了。第二层检测是为了避免额外的访库操作。\n\npublic  Student getStudentById(Integer id) {\n    redisTemplate.setKeySerializer(new StringRedisSerializer());\n    //查询缓存\n    Student student = (Student) redisTemplate.opsForValue().get("studentKey");\n    //判断缓存是否为空\n    if (null == student) {\n\n        //双重检测锁实现\n        synchronized (this) {\n\n            student = (Student) redisTemplate.opsForValue().get("studentKey");\n\n            if (null == student) {\n                System.out.println("查询了数据库......");\n                //查询数据库\n                student = studentMapper.selectByPrimaryKey(id);\n                //放入缓存\n                redisTemplate.opsForValue().set("studentKey", student);\n            }\n        }\n    } else {\n        System.out.println("查询了缓存......");\n    }\n    return student;\n}\n',normalizedContent:'# 什么是缓存击穿\n\n缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期） 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\n\n\n\n举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力\n\n\n# 有哪些解决办法\n\n 1. 永不过期（不推荐）：设置热点数据永不过期或者过期时间比较长。\n 2. 提前预热（推荐）：针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。\n 3. 加锁（看情况）：在缓存失效后，通过设置互斥锁确保只有一个请求去查询数据库并更新缓存。\n\n\n# 双检锁解决缓存击穿\n\n> 单例模式的一种实现，双重检测，其中的一层检测是为了提高效率。由于项目中采用了多线程，所以在第一个线程没有从缓存中获取到数据之后，有可能其他线程已经完成了读取数据库写入缓存的操作，也就是说，第一个线程再次得到时间片的时候，就没有必要访问数据库获取数据了。第二层检测是为了避免额外的访库操作。\n\npublic  student getstudentbyid(integer id) {\n    redistemplate.setkeyserializer(new stringredisserializer());\n    //查询缓存\n    student student = (student) redistemplate.opsforvalue().get("studentkey");\n    //判断缓存是否为空\n    if (null == student) {\n\n        //双重检测锁实现\n        synchronized (this) {\n\n            student = (student) redistemplate.opsforvalue().get("studentkey");\n\n            if (null == student) {\n                system.out.println("查询了数据库......");\n                //查询数据库\n                student = studentmapper.selectbyprimarykey(id);\n                //放入缓存\n                redistemplate.opsforvalue().set("studentkey", student);\n            }\n        }\n    } else {\n        system.out.println("查询了缓存......");\n    }\n    return student;\n}\n',charsets:{cjk:!0},lastUpdated:"2024/09/14, 14:10:17",lastUpdatedTimestamp:1726323017e3},{title:"任务补偿",frontmatter:{title:"任务补偿",date:"2024-09-14T16:51:13.000Z",permalink:"/pages/24abe0/"},regularPath:"/03.%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/01.%E7%83%AD%E9%97%A8%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/04.%E4%BB%BB%E5%8A%A1%E8%A1%A5%E5%81%BF.html",relativePath:"03.场景设计/01.热门场景设计/04.任务补偿.md",key:"v-072dd135",path:"/pages/24abe0/",headers:[{level:2,title:"补偿 机制的意义？",slug:"补偿-机制的意义",normalizedTitle:"补偿 机制的意义？",charIndex:2},{level:2,title:"补偿 该怎么做？",slug:"补偿-该怎么做",normalizedTitle:"补偿 该怎么做？",charIndex:724},{level:3,title:"回滚",slug:"回滚",normalizedTitle:"回滚",charIndex:769},{level:3,title:"重试",slug:"重试",normalizedTitle:"重试",charIndex:316},{level:2,title:"重试 的最佳实践",slug:"重试-的最佳实践",normalizedTitle:"重试 的最佳实践",charIndex:3583},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:4106},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:4242}],headersStr:"补偿 机制的意义？ 补偿 该怎么做？ 回滚 重试 重试 的最佳实践 总结 参考文献",content:"# 补偿 机制的意义？\n\n以电商的购物场景为例：\n\n客户端 ----\x3e购物车微服务 ----\x3e订单微服务 ----\x3e 支付微服务。\n\n这种调用链非常普遍。\n\n那么为什么需要考虑补偿机制呢？\n\n正如之前几篇文章所说，一次跨机器的通信可能会经过DNS 服务，网卡、交换机、路由器、负载均衡等设备，这些设备都不一定是一直稳定的，在数据传输的整个过程中，只要任意一个环节出错，都会导致问题的产生。\n\n而在分布式场景中，一个完整的业务又是由多次跨机器通信组成的，所以产生问题的概率成倍数增加。\n\n但是，这些问题并不完全代表真正的系统无法处理请求，所以我们应当尽可能的自动消化掉这些异常。\n\n可能你会问，之前也看到过「补偿」和「事务补偿」或者「重试」，它们之间的关系是什么？\n\n你其实可以不用太纠结这些名字，从目的来说都是一样的。就是一旦某个操作发生了异常，如何通过内部机制将这个异常产生的「不一致」状态消除掉。\n\n> 在 echo 看来，不管用什么方式，只要通过额外的方式解决了问题都可以理解为是「补偿」，所以「事务补偿」和「重试」都是「补偿」的子集。前者是一个逆向操作，而后者则是一个正向操作。\n\n只是从结果来看，两者的意义不同。「事务补偿」意味着“放弃”，当前操作必然会失败。\n\n事务补偿\n\n\n\n「重试」则还有处理成功的机会。这两种方式分别适用于不同的场景。\n\n重试\n\n\n\n因为「补偿」已经是一个额外流程了，既然能够走这个额外流程，说明时效性并不是第一考虑的因素，所以做补偿的核心要点是：宁可慢，不可错。\n\n因此，不要草率的就确定了补偿的实施方案，需要谨慎的评估。虽说错误无法100%避免，但是抱着这样的一个心态或多或少可以减少一些错误的发生。\n\n\n# 补偿 该怎么做？\n\n做「补偿」的主流方式就前面提到的「事务补偿」和「重试」，以下会被称作「回滚」和「重试」。\n\n我们先来聊聊「回滚」。相比「重试」，它逻辑上更简单一些。\n\n\n# 回滚\n\necho 将回滚分为2种模式，一种叫「显式回滚」（调用逆向接口），一种叫「隐式回滚」（无需调用逆向接口）。\n\n最常见的就是「显式回滚」。这个方案无非就是做2个事情：\n\n首先要确定失败的步骤和状态，从而确定需要回滚的范围。一个业务的流程，往往在设计之初就制定好了，所以确定回滚的范围比较容易。但这里唯一需要注意的一点就是：如果在一个业务处理中涉及到的服务并不是都提供了「回滚接口」，那么在编排服务时应该把提供「回滚接口」的服务放在前面，这样当后面的工作服务错误时还有机会「回滚」。\n\n其次要能提供「回滚」操作使用到的业务数据。「回滚」时提供的数据越多，越有益于程序的健壮性。因为程序可以在收到「回滚」操作的时候可以做业务的检查，比如检查账户是否相等，金额是否一致等等。\n\n由于这个中间状态的数据结构和数据大小并不固定，所以echo建议你在实现这点的时候可以将相关的数据序列化成一个json，然后存放到一个nosql类型的存储中。\n\n「隐式回滚」相对来说运用场景比较少。它意味着这个回滚动作你不需要进行额外处理，下游服务内部有类似“预占”并且“超时失效”的机制的。例如：\n\n电商场景中，会将订单中的商品先预占库存，等待用户在 15 分钟内支付。如果没有收到用户的支付，则释放库存。\n\n下面聊聊可以有很多玩法，也更容易陷入坑里的「重试」。\n\n\n# 重试\n\n「重试」最大的好处在于，业务系统可以不需要提供「逆向接口」，这是一个对长期开发成本特别大的利好，毕竟业务是天天在变的。所以，在可能的情况下，应该优先考虑使用「重试」。\n\n不过，相比「回滚」来说「重试」的适用场景更少一些，所以我们第一步首先要判断，当前场景是否适合「重试」。比如：\n\n * 下游系统返回「请求超时」、「被限流中」等临时状态的时候，我们可以考虑重试\n * 而如果是返回“余额不足”、“无权限”等明确无法继续的业务性错误的时候就不需要重试了\n * 一些中间件或者rpc框架中返回Http503、404等没有何时恢复的预期的时候，也不需要重试\n\n如果确定要进行「重试」，我们还需要选定一个合适的「重试策略」。主流的「重试策略」主要是以下几种。\n\n策略1.立即重试。有时故障是候暂时性，可能是因网络数据包冲突或硬件组件流量高峰等事件造成的。在此情况下，适合立即重试操作。不过，立即重试次数不应超过一次，如果立即重试失败，应改用其它的策略。\n\n策略2.固定间隔。应用程序每次尝试的间隔时间相同。 这个好理解，例如，固定每 3 秒重试操作。（以下所有示例代码中的具体的数字仅供参考。）\n\n策略1和策略2多用于前端系统的交互式操作中。\n\n策略3.增量间隔。每一次的重试间隔时间增量递增。比如，第一次0秒、第二次3秒、第三次6秒，9、12、15这样。\n\nreturn (retryCount - 1) * incrementInterval;\n\n\n使得失败次数越多的重试请求优先级排到越后面，给新进入的重试请求让道。\n\n策略4.指数间隔。每一次的重试间隔呈指数级增加。和增量间隔“殊途同归”，都是想让失败次数越多的重试请求优先级排到越后面，只不过这个方案的增长幅度更大一些。\n\nreturn 2 ^ retryCount;\n\n\n策略5.全抖动。在递增的基础上，增加随机性（可以把其中的指数增长部分替换成增量增长。）。适用于将某一时刻集中产生的大量重试请求进行压力分散的场景。\n\nreturn random(0 , 2 ^ retryCount);\n\n\n策略6.等抖动。在「指数间隔」和「全抖动」之间寻求一个中庸的方案，降低随机性的作用。适用场景和「全抖动」一样。\n\nvar baseNum = 2 ^ retryCount;return baseNum + random(0 , baseNum);\n\n\n3、4、5、6策略的表现情况大致是这样。(x轴为重试次数)\n\n\n\n为什么说「重试」有坑呢？\n\n正如前面聊到的那样，出于对开发成本考虑，你在做「重试」的时候可能是复用的常规调用的接口。那么此时就不得不提一个「幂等性」问题。\n\n如果实现「重试」选用的技术方案不能100%确保不会重复发起重试，那么「幂等性」问题是一个必须要考虑的问题。哪怕技术方案可以确保100%不会重复发起重试，出于对意外情况的考量，尽量也考虑一下「幂等性」问题。\n\n**幂等性：**不管对程序发起几次重复调用，程序表现的状态（所有相关的数据变化）与调用一次的结果是一致的话，就是保证了幂等性。\n\n这意味着可以根据需要重复或重试操作，而不会导致意外的影响。对于非幂等操作，算法可能必须跟踪操作是否已经执行。\n\n所以，一旦某个功能支持「重试」，那么整个链路上的接口都需要考虑幂等性问题，不能因为服务的多次调用而导致业务数据的累计增加或减少。\n\n满足「幂等性」其实就是需要想办法识别重复的请求，并且将其过滤掉。思路就是：\n\n 1. 给每个请求定义一个唯一标识。\n 2. 在进行「重试」的时候判断这个请求是否已经被执行或者正在被执行，如果是则抛弃该请求。\n\n**第1点，**我们可以使用一个全局唯一id生成器或者生成服务（可以扩展阅读，分布式系统中的必备良药 —— 全局唯一单据号生成）。 或者简单粗暴一些，使用官方类库自带的Guid、uuid之类的也行。\n\n然后通过rpc框架在发起调用的客户端中，对每个请求增加一个唯一标识的字段进行赋值。\n\n**第2点，**我们可以在服务端通过Aop的方式切入到实际的处理逻辑代码之前和之后，一起配合做验证。\n\n\n\n大致的代码思路如下。\n\n【方法执行前】if(isExistLog(requestId)){  //1.判断请求是否已被接收过。  对应序号3\n    var lastResult = getLastResult();  //2.获取用于判断之前的请求是否已经处理完成。  对应序号4\n    if(lastResult == null){  \n        var result = waitResult();  //挂起等待处理完成\n        return result;\n    }\n    else{\n        return lastResult;\n    }  \n}\nelse{\n    log(requestId);  //3.记录该请求已接收\n}\n\n//do something..【方法执行后】\n\nlogResult(requestId, result);  //4.将结果也更新一下。\n\n\n如果「补偿」这个工作是通过MQ来进行的话，这事就可以直接在对接MQ所封装的SDK中做。在生产端赋值全局唯一标识，在消费端通过唯一标识消重。\n\n\n# 重试 的最佳实践\n\n再聊一些 echo 积累的最佳实践吧，都是针对「重试」的，的确这也是工作中最常用的方案。\n\n「重试」特别适合在高负载情况下被「降级」，当然也应当受到「限流」和「熔断」机制的影响。当「重试」的“矛”与「限流」和「熔断」的“盾”搭配使用，效果才是最好。\n\n需要衡量增加补偿机制的投入产出比。一些不是很重要的问题时，应该「快速失败」而不是「重试」。\n\n过度积极的重试策略（例如间隔太短或重试次数过多）会对下游服务造成不利影响，这点一定要注意。\n\n一定要给「重试」制定一个终止策略。\n\n当回滚的过程很困难或代价很大的情况下，可以接受很长的间隔及大量的重试次数，DDD中经常被提到的「saga」模式其实也是这样的思路。不过，前提是不会因为保留或锁定稀缺资源而阻止其他操作（比如1、2、3、4、5几个串行操作。由于2一直没处理完成导致3、4、5没法继续进行）。\n\n可以离线的事务一致性维护机制\n\n 1. 第一步：在线业务生成可疑记录\n 2. 第二步：离线服务诊断可疑记录，生成故障记录\n 3. 第三步：离线服务尝试对故障记录进行智能修复（补偿或重试）\n 4. 第四步：对于无法修复，或者修复过程失败的记录发出告警，交由人工处理。\n\n\n# 总结\n\n这篇我们先聊了下做「补偿」的意义，以及做补偿的2个方式「回滚」和「重试」的实现思路。\n\n然后，提醒你要注意「重试」的时候需要考虑幂等性问题，并且z哥也给出了一个解决思路。\n\n最后，分享了几个 echo 总结的针对「重试」的最佳实践。\n\n希望对你有所帮助。\n\n\n# 参考文献\n\n99%的人都能看懂的分布式系统「补偿」机制 - 知乎 (zhihu.com)",normalizedContent:"# 补偿 机制的意义？\n\n以电商的购物场景为例：\n\n客户端 ----\x3e购物车微服务 ----\x3e订单微服务 ----\x3e 支付微服务。\n\n这种调用链非常普遍。\n\n那么为什么需要考虑补偿机制呢？\n\n正如之前几篇文章所说，一次跨机器的通信可能会经过dns 服务，网卡、交换机、路由器、负载均衡等设备，这些设备都不一定是一直稳定的，在数据传输的整个过程中，只要任意一个环节出错，都会导致问题的产生。\n\n而在分布式场景中，一个完整的业务又是由多次跨机器通信组成的，所以产生问题的概率成倍数增加。\n\n但是，这些问题并不完全代表真正的系统无法处理请求，所以我们应当尽可能的自动消化掉这些异常。\n\n可能你会问，之前也看到过「补偿」和「事务补偿」或者「重试」，它们之间的关系是什么？\n\n你其实可以不用太纠结这些名字，从目的来说都是一样的。就是一旦某个操作发生了异常，如何通过内部机制将这个异常产生的「不一致」状态消除掉。\n\n> 在 echo 看来，不管用什么方式，只要通过额外的方式解决了问题都可以理解为是「补偿」，所以「事务补偿」和「重试」都是「补偿」的子集。前者是一个逆向操作，而后者则是一个正向操作。\n\n只是从结果来看，两者的意义不同。「事务补偿」意味着“放弃”，当前操作必然会失败。\n\n事务补偿\n\n\n\n「重试」则还有处理成功的机会。这两种方式分别适用于不同的场景。\n\n重试\n\n\n\n因为「补偿」已经是一个额外流程了，既然能够走这个额外流程，说明时效性并不是第一考虑的因素，所以做补偿的核心要点是：宁可慢，不可错。\n\n因此，不要草率的就确定了补偿的实施方案，需要谨慎的评估。虽说错误无法100%避免，但是抱着这样的一个心态或多或少可以减少一些错误的发生。\n\n\n# 补偿 该怎么做？\n\n做「补偿」的主流方式就前面提到的「事务补偿」和「重试」，以下会被称作「回滚」和「重试」。\n\n我们先来聊聊「回滚」。相比「重试」，它逻辑上更简单一些。\n\n\n# 回滚\n\necho 将回滚分为2种模式，一种叫「显式回滚」（调用逆向接口），一种叫「隐式回滚」（无需调用逆向接口）。\n\n最常见的就是「显式回滚」。这个方案无非就是做2个事情：\n\n首先要确定失败的步骤和状态，从而确定需要回滚的范围。一个业务的流程，往往在设计之初就制定好了，所以确定回滚的范围比较容易。但这里唯一需要注意的一点就是：如果在一个业务处理中涉及到的服务并不是都提供了「回滚接口」，那么在编排服务时应该把提供「回滚接口」的服务放在前面，这样当后面的工作服务错误时还有机会「回滚」。\n\n其次要能提供「回滚」操作使用到的业务数据。「回滚」时提供的数据越多，越有益于程序的健壮性。因为程序可以在收到「回滚」操作的时候可以做业务的检查，比如检查账户是否相等，金额是否一致等等。\n\n由于这个中间状态的数据结构和数据大小并不固定，所以echo建议你在实现这点的时候可以将相关的数据序列化成一个json，然后存放到一个nosql类型的存储中。\n\n「隐式回滚」相对来说运用场景比较少。它意味着这个回滚动作你不需要进行额外处理，下游服务内部有类似“预占”并且“超时失效”的机制的。例如：\n\n电商场景中，会将订单中的商品先预占库存，等待用户在 15 分钟内支付。如果没有收到用户的支付，则释放库存。\n\n下面聊聊可以有很多玩法，也更容易陷入坑里的「重试」。\n\n\n# 重试\n\n「重试」最大的好处在于，业务系统可以不需要提供「逆向接口」，这是一个对长期开发成本特别大的利好，毕竟业务是天天在变的。所以，在可能的情况下，应该优先考虑使用「重试」。\n\n不过，相比「回滚」来说「重试」的适用场景更少一些，所以我们第一步首先要判断，当前场景是否适合「重试」。比如：\n\n * 下游系统返回「请求超时」、「被限流中」等临时状态的时候，我们可以考虑重试\n * 而如果是返回“余额不足”、“无权限”等明确无法继续的业务性错误的时候就不需要重试了\n * 一些中间件或者rpc框架中返回http503、404等没有何时恢复的预期的时候，也不需要重试\n\n如果确定要进行「重试」，我们还需要选定一个合适的「重试策略」。主流的「重试策略」主要是以下几种。\n\n策略1.立即重试。有时故障是候暂时性，可能是因网络数据包冲突或硬件组件流量高峰等事件造成的。在此情况下，适合立即重试操作。不过，立即重试次数不应超过一次，如果立即重试失败，应改用其它的策略。\n\n策略2.固定间隔。应用程序每次尝试的间隔时间相同。 这个好理解，例如，固定每 3 秒重试操作。（以下所有示例代码中的具体的数字仅供参考。）\n\n策略1和策略2多用于前端系统的交互式操作中。\n\n策略3.增量间隔。每一次的重试间隔时间增量递增。比如，第一次0秒、第二次3秒、第三次6秒，9、12、15这样。\n\nreturn (retrycount - 1) * incrementinterval;\n\n\n使得失败次数越多的重试请求优先级排到越后面，给新进入的重试请求让道。\n\n策略4.指数间隔。每一次的重试间隔呈指数级增加。和增量间隔“殊途同归”，都是想让失败次数越多的重试请求优先级排到越后面，只不过这个方案的增长幅度更大一些。\n\nreturn 2 ^ retrycount;\n\n\n策略5.全抖动。在递增的基础上，增加随机性（可以把其中的指数增长部分替换成增量增长。）。适用于将某一时刻集中产生的大量重试请求进行压力分散的场景。\n\nreturn random(0 , 2 ^ retrycount);\n\n\n策略6.等抖动。在「指数间隔」和「全抖动」之间寻求一个中庸的方案，降低随机性的作用。适用场景和「全抖动」一样。\n\nvar basenum = 2 ^ retrycount;return basenum + random(0 , basenum);\n\n\n3、4、5、6策略的表现情况大致是这样。(x轴为重试次数)\n\n\n\n为什么说「重试」有坑呢？\n\n正如前面聊到的那样，出于对开发成本考虑，你在做「重试」的时候可能是复用的常规调用的接口。那么此时就不得不提一个「幂等性」问题。\n\n如果实现「重试」选用的技术方案不能100%确保不会重复发起重试，那么「幂等性」问题是一个必须要考虑的问题。哪怕技术方案可以确保100%不会重复发起重试，出于对意外情况的考量，尽量也考虑一下「幂等性」问题。\n\n**幂等性：**不管对程序发起几次重复调用，程序表现的状态（所有相关的数据变化）与调用一次的结果是一致的话，就是保证了幂等性。\n\n这意味着可以根据需要重复或重试操作，而不会导致意外的影响。对于非幂等操作，算法可能必须跟踪操作是否已经执行。\n\n所以，一旦某个功能支持「重试」，那么整个链路上的接口都需要考虑幂等性问题，不能因为服务的多次调用而导致业务数据的累计增加或减少。\n\n满足「幂等性」其实就是需要想办法识别重复的请求，并且将其过滤掉。思路就是：\n\n 1. 给每个请求定义一个唯一标识。\n 2. 在进行「重试」的时候判断这个请求是否已经被执行或者正在被执行，如果是则抛弃该请求。\n\n**第1点，**我们可以使用一个全局唯一id生成器或者生成服务（可以扩展阅读，分布式系统中的必备良药 —— 全局唯一单据号生成）。 或者简单粗暴一些，使用官方类库自带的guid、uuid之类的也行。\n\n然后通过rpc框架在发起调用的客户端中，对每个请求增加一个唯一标识的字段进行赋值。\n\n**第2点，**我们可以在服务端通过aop的方式切入到实际的处理逻辑代码之前和之后，一起配合做验证。\n\n\n\n大致的代码思路如下。\n\n【方法执行前】if(isexistlog(requestid)){  //1.判断请求是否已被接收过。  对应序号3\n    var lastresult = getlastresult();  //2.获取用于判断之前的请求是否已经处理完成。  对应序号4\n    if(lastresult == null){  \n        var result = waitresult();  //挂起等待处理完成\n        return result;\n    }\n    else{\n        return lastresult;\n    }  \n}\nelse{\n    log(requestid);  //3.记录该请求已接收\n}\n\n//do something..【方法执行后】\n\nlogresult(requestid, result);  //4.将结果也更新一下。\n\n\n如果「补偿」这个工作是通过mq来进行的话，这事就可以直接在对接mq所封装的sdk中做。在生产端赋值全局唯一标识，在消费端通过唯一标识消重。\n\n\n# 重试 的最佳实践\n\n再聊一些 echo 积累的最佳实践吧，都是针对「重试」的，的确这也是工作中最常用的方案。\n\n「重试」特别适合在高负载情况下被「降级」，当然也应当受到「限流」和「熔断」机制的影响。当「重试」的“矛”与「限流」和「熔断」的“盾”搭配使用，效果才是最好。\n\n需要衡量增加补偿机制的投入产出比。一些不是很重要的问题时，应该「快速失败」而不是「重试」。\n\n过度积极的重试策略（例如间隔太短或重试次数过多）会对下游服务造成不利影响，这点一定要注意。\n\n一定要给「重试」制定一个终止策略。\n\n当回滚的过程很困难或代价很大的情况下，可以接受很长的间隔及大量的重试次数，ddd中经常被提到的「saga」模式其实也是这样的思路。不过，前提是不会因为保留或锁定稀缺资源而阻止其他操作（比如1、2、3、4、5几个串行操作。由于2一直没处理完成导致3、4、5没法继续进行）。\n\n可以离线的事务一致性维护机制\n\n 1. 第一步：在线业务生成可疑记录\n 2. 第二步：离线服务诊断可疑记录，生成故障记录\n 3. 第三步：离线服务尝试对故障记录进行智能修复（补偿或重试）\n 4. 第四步：对于无法修复，或者修复过程失败的记录发出告警，交由人工处理。\n\n\n# 总结\n\n这篇我们先聊了下做「补偿」的意义，以及做补偿的2个方式「回滚」和「重试」的实现思路。\n\n然后，提醒你要注意「重试」的时候需要考虑幂等性问题，并且z哥也给出了一个解决思路。\n\n最后，分享了几个 echo 总结的针对「重试」的最佳实践。\n\n希望对你有所帮助。\n\n\n# 参考文献\n\n99%的人都能看懂的分布式系统「补偿」机制 - 知乎 (zhihu.com)",charsets:{cjk:!0},lastUpdated:"2024/09/14, 14:10:17",lastUpdatedTimestamp:1726323017e3},{title:"海量数据计数",frontmatter:{title:"海量数据计数",date:"2024-09-14T16:52:01.000Z",permalink:"/pages/f3295f/"},regularPath:"/03.%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/01.%E7%83%AD%E9%97%A8%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/06.%E6%B5%B7%E9%87%8F%E6%95%B0%E6%8D%AE%E8%AE%A1%E6%95%B0.html",relativePath:"03.场景设计/01.热门场景设计/06.海量数据计数.md",key:"v-2d6b4bec",path:"/pages/f3295f/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/09/14, 10:38:36",lastUpdatedTimestamp:1726310316e3},{title:"超时&重试",frontmatter:{title:"超时&重试",date:"2024-09-14T16:52:35.000Z",permalink:"/pages/0dfb49/"},regularPath:"/03.%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/01.%E7%83%AD%E9%97%A8%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/08.%E8%B6%85%E6%97%B6&%E9%87%8D%E8%AF%95.html",relativePath:"03.场景设计/01.热门场景设计/08.超时&重试.md",key:"v-5d56c92a",path:"/pages/0dfb49/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/09/14, 10:38:36",lastUpdatedTimestamp:1726310316e3},{title:"多级缓存",frontmatter:{title:"多级缓存",date:"2024-09-14T16:52:24.000Z",permalink:"/pages/51aa8b/"},regularPath:"/03.%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/01.%E7%83%AD%E9%97%A8%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/07.%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98.html",relativePath:"03.场景设计/01.热门场景设计/07.多级缓存.md",key:"v-0ac18964",path:"/pages/51aa8b/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/09/14, 10:38:36",lastUpdatedTimestamp:1726310316e3},{title:"幂等&防重",frontmatter:{title:"幂等&防重",date:"2024-09-14T16:52:57.000Z",permalink:"/pages/4fc8cb/"},regularPath:"/03.%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/01.%E7%83%AD%E9%97%A8%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/09.%E5%B9%82%E7%AD%89&%E9%98%B2%E9%87%8D.html",relativePath:"03.场景设计/01.热门场景设计/09.幂等&防重.md",key:"v-23e43bec",path:"/pages/4fc8cb/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/09/14, 10:38:36",lastUpdatedTimestamp:1726310316e3},{title:"README",frontmatter:{title:"README",date:"2024-09-14T16:58:03.000Z",permalink:"/pages/a027c2/"},regularPath:"/03.%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/",relativePath:"03.场景设计/README.md",key:"v-0e70e808",path:"/pages/a027c2/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/09/14, 10:38:36",lastUpdatedTimestamp:1726310316e3},{title:"秒杀",frontmatter:{title:"秒杀",date:"2024-09-14T16:51:28.000Z",permalink:"/pages/a72629/"},regularPath:"/03.%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/01.%E7%83%AD%E9%97%A8%E5%9C%BA%E6%99%AF%E8%AE%BE%E8%AE%A1/05.%E7%A7%92%E6%9D%80.html",relativePath:"03.场景设计/01.热门场景设计/05.秒杀.md",key:"v-4fb0b446",path:"/pages/a72629/",headers:[{level:2,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:2},{level:2,title:"秒杀会有哪些问题",slug:"秒杀会有哪些问题",normalizedTitle:"秒杀会有哪些问题",charIndex:21},{level:2,title:"解决方案",slug:"解决方案",normalizedTitle:"解决方案",charIndex:1438},{level:3,title:"前端",slug:"前端",normalizedTitle:"前端",charIndex:1447},{level:3,title:"Nginx",slug:"nginx",normalizedTitle:"nginx",charIndex:2626},{level:3,title:"风控",slug:"风控",normalizedTitle:"风控",charIndex:2613},{level:3,title:"后端",slug:"后端",normalizedTitle:"后端",charIndex:1535},{level:3,title:"数据库",slug:"数据库",normalizedTitle:"数据库",charIndex:1180},{level:3,title:"分布式事务",slug:"分布式事务",normalizedTitle:"分布式事务",charIndex:4905},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:5198},{level:2,title:"参考文献",slug:"参考文献",normalizedTitle:"参考文献",charIndex:5347}],headersStr:"背景 秒杀会有哪些问题 解决方案 前端 Nginx 风控 后端 数据库 分布式事务 总结 参考文献",content:"# 背景\n\n秒杀系统的架构图\n\n\n\n\n# 秒杀会有哪些问题\n\n高并发\n\n是的高并发这个是我们想都不用想的一个点，一瞬间这么多人进来这不是高并发什么时候是呢？\n\n是吧，秒杀的特点就是这样时间极短、 瞬间用户量大。\n\n正常的店铺营销都是用极低的价格配合上短信、APP的精准推送，吸引特别多的用户来参与这场秒杀，爽了商家苦了开发呀。\n\n秒杀大家都知道如果真的营销到位，价格诱人，几十万的流量我觉得完全不是问题，那单机的Redis我感觉3-4W的QPS还是能顶得住的，但是再高了就没办法了，那这个数据随便搞个热销商品的秒杀可能都不止了。\n\n大量的请求进来，我们需要考虑的点就很多了，缓存雪崩，缓存击穿，缓存穿透这些我之前提到的点都是有可能发生的，出现问题打挂DB那就很难受了，活动失败用户体验差，活动人气没了，最后背锅的还是开发\n\n超卖\n\n但凡是个秒杀，都怕超卖，如果卖的是尿不湿还好，要是换成100个MacBook Pro，商家的预算经费卖100个可以赚点还可以造势，结果你写错程序多卖出去200个，你不发货用户投诉你，平台封你店，你发货就血亏，你怎么办？\n\n那最后只能杀个开发祭天解气了，秒杀的价格本来就低了，基本上都是不怎么赚钱的，超卖了就恐怖了呀，所以超卖也是很关键的一个点。\n\n恶意请求\n\n你这么低的价格，假如我抢到了，我转手卖掉我不是血赚？就算我不卖我也不亏啊，那用户知道，你知道，别的别有用心的人（黑客、黄牛…）肯定也知道的。\n\n那简单啊，我知道你什么时候抢，我搞个几十台机器搞点脚本，我也模拟出来十几万个人左右的请求，那我是不是意味着我基本上有80%的成功率了。\n\n真实情况可能远远不止，因为机器请求的速度比人的手速往往快太多了，在贵州的敖丙我每年回家抢高铁票都是秒光的，我也不知道有没有黄牛的功劳，我要Diss你，黄牛。杰伦演唱会门票抢不到，我也Diss你。\n\nTip：科普下，小道消息了解到的，黄牛的抢票系统，比国内很多小公司的系统还吊很多，架构设计都是顶级的，我用顶配的服务加上顶配的架构设计，你还想看演唱会？还想回家？\n\n不过不用黄牛我回家都难，我们云贵川跟我一样要回家过年的仔太多了555！\n\n链接暴露\n\n前面几个问题大家可能都很好理解，一看到这个有的小伙伴可能会比较疑惑，啥是链接暴露呀？\n\n相信是个开发同学都对这个画面一点都不陌生吧，懂点行的仔都可以打开谷歌的开发者模式，然后看看你的网页代码，有的就有URL，但是我写VUE的时候是事件触发然后去调用文件里面的接口看源码看不到，但是我可以点击一下查看你的请求地址啊，不过你好像可以对按钮在秒杀前置灰。\n\n不管怎么样子都有危险，撇开外面的所有的东西你都挡住了，你卖这个东西实在便宜得过分，有诱惑力，你能保证开发不动心？开发知道地址，在秒杀的时候自己提前请求。。。（开发：怎么TM又是我）\n\n数据库\n\n每秒上万甚至十几万的QPS（每秒请求数）直接打到数据库，基本上都要把库打挂掉，而且你服务不单单是做秒杀的还涉及其他的业务，你没做降级、限流、熔断啥的，别的一起挂，小公司的话可能全站崩溃404。\n\n反正不管你秒杀怎么挂，你别把别的搞挂了对吧，搞挂了就不是杀一个程序员能搞定的。\n\n程序员：我TM好难啊！\n\n问题都列出来了，那怎么设计，怎么解决这些问题就是接下去要考虑的了，我们对症下药。\n\n我会从我设计的秒杀系统从上到下去给大家介绍我们正常电商秒杀系统在每一层做了些什么，每一层存在的问题，难点等。\n\n\n# 解决方案\n\n\n# 前端\n\n秒杀系统普遍都是商城网页、H5、APP、小程序这几项。\n\n在前端这一层其实我们可以做的事情有很多，如果用node去做，甚至能直接处理掉整个秒杀，但是node其实应该属于后端，所以我不讨论node Service了。\n\n资源静态化\n\n秒杀一般都是特定的商品还有页面模板，现在一般都是前后端分离的，页面一般都是不会经过后端的，但是前端也要自己的服务器啊，那就把能提前放入cdn服务器的东西都放进去，反正把所有能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力。\n\n秒杀链接加盐\n\n我们上面说了链接要是提前暴露出去可能有人直接访问url就提前秒杀了，那又有小伙伴要说了我做个时间的校验就好了呀，那我告诉你，知道链接的地址比起页面人工点击的还是有很大优势。\n\n我知道url了，那我通过程序不断获取最新的北京时间，可以达到毫秒级别的，我就在00毫秒的时候请求，我敢说绝对比你人工点的成功率大太多了，而且我可以一毫秒发送N次请求，搞不好你卖100个产品我全拿了。\n\n那这种情况怎么避免？把URL动态化，就连写代码的人都不知道，你就通过MD5之类的摘要算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过。\n\n这个只能防止一部分没耐心继续破解下去的黑客，有耐心的人研究出来还是能破解，在电商场景存在很多这样的羊毛党，那怎么做呢？后面我会说。\n\n限流\n\n限流这里我觉得应该分为前端限流和后端限流。\n\n物理控制\n\n大家有没有发现没到秒杀前，一般按钮都是置灰的，只有时间到了，才能点击。\n\n这是因为怕大家在时间快到的最后几秒秒疯狂请求服务器，然后还没到秒杀的时候基本上服务器就挂了。\n\n这个时候就需要前端的配合，定时去请求你的后端服务器，获取最新的北京时间，到时间点再给按钮可用状态。\n\n按钮可以点击之后也得给他置灰几秒，不然他一样在开始之后一直点的。\n\n你敢说你们秒杀的时候不是这样的？\n\n前端限流：这个很简单，一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。\n\n后端限流：秒杀的时候肯定是涉及到后续的订单生成和支付等操作，但是都只是成功的幸运儿才会走到那一步，那一旦100个产品卖光了，return了一个false，前端直接秒杀结束，然后你后端也关闭后续无效请求的介入了。\n\nTip：真正的限流还会有限流组件的加入例如：阿里的Sentinel、Hystrix等。我这里就不展开了，就说一下物理的限流。\n\n我们卖1000件商品，请求有10W，我们不需要把十万都放进来，你可以放1W请求进来，然后再进行操作，因为秒杀对于用户本身就是黑盒的，所以你怎么做的他们是没感知的，至于为啥放1W进来，而不是刚好1000，是因为会丢掉一些薅羊毛的用户，至于怎么判断，后面的风控阶段我会说。\n\n\n# Nginx\n\nNginx大家想必都不陌生了吧，这玩意是高性能的web服务器，并发也随便顶几万不是梦，但是我们的Tomcat只能顶几百的并发呀，那简单呀负载均衡嘛，一台服务几百，那就多搞点，在秒杀的时候多租点流量机。\n\nTip：据我所知国内某大厂就是在去年春节活动期间租光了亚洲所有的服务器，小公司也很喜欢在双十一期间买流量机来顶住压力。\n\n恶意请求拦截也需要用到它，一般单个用户请求次数太夸张，不像人为的请求在网关那一层就得拦截掉了，不然请求多了他抢不抢得到是一回事，服务器压力上去了，可能占用网络带宽或者把服务器打崩、缓存击穿等等\n\n\n# 风控\n\n我可以明确的告诉大家，前面的所有措施还是拦不住很多羊毛党，因为他们是专业的团队，他们可以注册很多账号来薅你的羊毛，而且不用机器请求，就用群控，操作几乎跟真实用户一模一样。\n\n那怎么办，是不是无解了？\n\n这个时候就需要风控同学的介入了，在请求到达后端之前，风控可以根据账号行为分析出这个账号机器人的概率大不大，我现在负责公司的某些特殊系统，每个用户的行为都是会送到我们大数据团队进行分析处理，给你打上对应标签的。\n\n那黑客其实也有办法：养号\n\n他们去黑市买真实用户有过很多记录的账号，买到了还不闲着，帮他们去购物啥的，让系统无法识别他们是黑号还是真实用户的号。\n\n怎么办？\n\n通杀！是的没有办法，只能通杀了，通杀的意思就是，我们通过风管分析出来这个用户是真实用户的概率没有其他用户概率大，那就认为他是机器了，丢弃他的请求。\n\n之前的限流我们放进来10000个请求，但是我们真正的库存只有1000个，那我们就算出最有可能是真实用户的1000人进行秒杀，丢弃其他请求，因为秒杀本来就是黑盒操作的，用户层面是无感知的，这样设计能让真实的用户买到东西，还可以减少自己被薅羊毛的概率。\n\n风控可以说是流量进入的最后一道门槛了，所以很多公司的风控是很强的，蚂蚁金服的风控大家如果了解过就知道了，你的资金在支付宝被盗了，他们是能做到全款补偿是有原因的。\n\n\n# 后端\n\n服务单一职责\n\n设计个能抗住高并发的系统，我觉得还是得单一职责。\n\n什么意思呢，大家都知道现在设计都是微服务的设计思想，然后再用分布式的部署方式。\n\n也就是我们下单是有个订单服务，用户登录管理等有个用户服务等等，那为啥我们不给秒杀也开个服务，我们把秒杀的代码业务逻辑放一起。\n\n单一职责的好处就是就算秒杀没抗住，秒杀库崩了，服务挂了，也不会影响到其他的服务。（高可用）\n\nRedis 集群\n\n之前不是说单机的Redis顶不住嘛，那简单多找几个兄弟啊，秒杀本来就是读多写少，那你们是不是瞬间想起来我之前跟你们提到过的，Redis集群，主从同步、读写分离，我们还搞点哨兵，开启持久化直接无敌高可用！\n\n库存预热\n\n秒杀的本质，就是对库存的抢夺，每个秒杀的用户来你都去数据库查询库存校验库存，然后扣减库存，撇开性能因数，你不觉得这样好繁琐，对业务开发人员都不友好，而且数据库顶不住啊。\n\n我们都知道数据库顶不住但是他的兄弟非关系型的数据库Redis能顶啊！\n\n那不简单了，我们要开始秒杀前你通过定时任务或者运维同学提前把商品的库存加载到Redis中去，让整个流程都在Redis里面去做，然后等秒杀介绍了，再异步的去修改库存就好了。\n\n但是用了Redis就有一个问题了，我们上面说了我们采用主从，就是我们会去读取库存然后再判断然后有库存才去减库存，正常情况没问题，但是高并发的情况问题就很大了。\n\n**多品几遍！！！**就比如现在库存只剩下1个了，我们高并发嘛，4个服务器一起查询了发现都是还有1个，那大家都觉得是自己抢到了，就都去扣库存，那结果就变成了-3，是的只有一个是真的抢到了，别的都是超卖的。咋办？\n\n事务\n\nRedis本身是支持事务的，而且他有很多原子命令的，大家也可以用LUA，还可以用他的管道，乐观锁他也知支持。\n\n限流&降级&熔断&隔离\n\n这个为啥要做呢，不怕一万就怕万一，万一你真的顶不住了，限流，顶不住就挡一部分出去但是不能说不行，降级，降级了还是被打挂了，熔断，至少不要影响别的系统，隔离，你本身就独立的，但是你会调用其他的系统嘛，你快不行了你别拖累兄弟们啊。\n\n消息队列（削峰填谷）\n\n一说到这个名词，很多小伙伴就知道了，对的MQ，你买东西少了你直接100个请求改库我觉得没问题，但是万一秒杀一万个，10万个呢？服务器挂了，程序员又要背锅的。\n\n秒杀就是这种瞬间流量很高，但是平时又没有流量的场景，那消息队列完全契合这样的场景了呀，削峰填谷。\n\n\n\nTip：可能小伙伴说我们业务达不到这个量级，没必要。但是我想说我们写代码，就不应该写出有逻辑漏洞的代码，至少以后公司体量上去了，别人一看居然不用改代码，一看代码作者是xxx？有点东西！\n\n你可以把它放消息队列，然后一点点消费去改库存就好了嘛，不过单个商品其实一次修改就够了，我这里说的是某个点多个商品一起秒杀的场景，像极了双十一零点。\n\n\n# 数据库\n\n数据库用MySQL只要连接池设置合理一般问题是不大的，不过一般大公司不缺钱而且秒杀这样的活动十分频繁，我之前所在的公司就是这样秒杀特卖这样的场景一直都是不间断的。\n\n单独给秒杀建立一个数据库，为秒杀服务，表的设计也是竟可能的简单点，现在的互联网架构部署都是分库的。\n\n至于表就看大家怎么设计了，该设置索引的地方还是要设置索引的，建完后记得用explain看看SQL的执行计划。（不了解的小伙伴也没事，MySQL章节去康康）\n\n\n# 分布式事务\n\n这为啥我不放在后端而放到最后来讲呢？\n\n因为上面的任何一步都是可能出错的，而且我们是在不同的服务里面出错的，那就涉及分布式事务了，但是分布式事务大家想的是一定要成功什么的那就不对了，还是那句话，几个请求丢了就丢了，要保证时效和服务的可用可靠。\n\n所以TCC和最终一致性其实不是很适合，TCC开发成本很大，所有接口都要写三次，因为涉及TCC的三个阶段。\n\n最终一致性基本上都是靠轮训的操作去保证一个操作一定成功，那时效性就大打折扣了。\n\n大家觉得不那么可靠的**两段式（2PC）和三段式（3PC）**就派上用场了，他们不一定能保证数据最终一致，但是效率上还算ok。\n\n\n# 总结\n\n到这里我想我已经基本上把该考虑的点还有对应的解决方案也都说了一下，不知道还有没有没考虑到的，但是就算没考虑到我想我这个设计，应该也能撑住一个完整的秒杀流程。\n\n最后大家再看看这个秒杀系统或许会有新的感悟，是不是一个系统真的没有大家想的那么简单，而且我还是有漏掉的细节，这是一定的。\n\n\n# 参考文献\n\n面试了十个应届生九个都是秒杀系统，你确定你们那是秒杀？_小公司的qps只有几十-CSDN博客",normalizedContent:"# 背景\n\n秒杀系统的架构图\n\n\n\n\n# 秒杀会有哪些问题\n\n高并发\n\n是的高并发这个是我们想都不用想的一个点，一瞬间这么多人进来这不是高并发什么时候是呢？\n\n是吧，秒杀的特点就是这样时间极短、 瞬间用户量大。\n\n正常的店铺营销都是用极低的价格配合上短信、app的精准推送，吸引特别多的用户来参与这场秒杀，爽了商家苦了开发呀。\n\n秒杀大家都知道如果真的营销到位，价格诱人，几十万的流量我觉得完全不是问题，那单机的redis我感觉3-4w的qps还是能顶得住的，但是再高了就没办法了，那这个数据随便搞个热销商品的秒杀可能都不止了。\n\n大量的请求进来，我们需要考虑的点就很多了，缓存雪崩，缓存击穿，缓存穿透这些我之前提到的点都是有可能发生的，出现问题打挂db那就很难受了，活动失败用户体验差，活动人气没了，最后背锅的还是开发\n\n超卖\n\n但凡是个秒杀，都怕超卖，如果卖的是尿不湿还好，要是换成100个macbook pro，商家的预算经费卖100个可以赚点还可以造势，结果你写错程序多卖出去200个，你不发货用户投诉你，平台封你店，你发货就血亏，你怎么办？\n\n那最后只能杀个开发祭天解气了，秒杀的价格本来就低了，基本上都是不怎么赚钱的，超卖了就恐怖了呀，所以超卖也是很关键的一个点。\n\n恶意请求\n\n你这么低的价格，假如我抢到了，我转手卖掉我不是血赚？就算我不卖我也不亏啊，那用户知道，你知道，别的别有用心的人（黑客、黄牛…）肯定也知道的。\n\n那简单啊，我知道你什么时候抢，我搞个几十台机器搞点脚本，我也模拟出来十几万个人左右的请求，那我是不是意味着我基本上有80%的成功率了。\n\n真实情况可能远远不止，因为机器请求的速度比人的手速往往快太多了，在贵州的敖丙我每年回家抢高铁票都是秒光的，我也不知道有没有黄牛的功劳，我要diss你，黄牛。杰伦演唱会门票抢不到，我也diss你。\n\ntip：科普下，小道消息了解到的，黄牛的抢票系统，比国内很多小公司的系统还吊很多，架构设计都是顶级的，我用顶配的服务加上顶配的架构设计，你还想看演唱会？还想回家？\n\n不过不用黄牛我回家都难，我们云贵川跟我一样要回家过年的仔太多了555！\n\n链接暴露\n\n前面几个问题大家可能都很好理解，一看到这个有的小伙伴可能会比较疑惑，啥是链接暴露呀？\n\n相信是个开发同学都对这个画面一点都不陌生吧，懂点行的仔都可以打开谷歌的开发者模式，然后看看你的网页代码，有的就有url，但是我写vue的时候是事件触发然后去调用文件里面的接口看源码看不到，但是我可以点击一下查看你的请求地址啊，不过你好像可以对按钮在秒杀前置灰。\n\n不管怎么样子都有危险，撇开外面的所有的东西你都挡住了，你卖这个东西实在便宜得过分，有诱惑力，你能保证开发不动心？开发知道地址，在秒杀的时候自己提前请求。。。（开发：怎么tm又是我）\n\n数据库\n\n每秒上万甚至十几万的qps（每秒请求数）直接打到数据库，基本上都要把库打挂掉，而且你服务不单单是做秒杀的还涉及其他的业务，你没做降级、限流、熔断啥的，别的一起挂，小公司的话可能全站崩溃404。\n\n反正不管你秒杀怎么挂，你别把别的搞挂了对吧，搞挂了就不是杀一个程序员能搞定的。\n\n程序员：我tm好难啊！\n\n问题都列出来了，那怎么设计，怎么解决这些问题就是接下去要考虑的了，我们对症下药。\n\n我会从我设计的秒杀系统从上到下去给大家介绍我们正常电商秒杀系统在每一层做了些什么，每一层存在的问题，难点等。\n\n\n# 解决方案\n\n\n# 前端\n\n秒杀系统普遍都是商城网页、h5、app、小程序这几项。\n\n在前端这一层其实我们可以做的事情有很多，如果用node去做，甚至能直接处理掉整个秒杀，但是node其实应该属于后端，所以我不讨论node service了。\n\n资源静态化\n\n秒杀一般都是特定的商品还有页面模板，现在一般都是前后端分离的，页面一般都是不会经过后端的，但是前端也要自己的服务器啊，那就把能提前放入cdn服务器的东西都放进去，反正把所有能提升效率的步骤都做一下，减少真正秒杀时候服务器的压力。\n\n秒杀链接加盐\n\n我们上面说了链接要是提前暴露出去可能有人直接访问url就提前秒杀了，那又有小伙伴要说了我做个时间的校验就好了呀，那我告诉你，知道链接的地址比起页面人工点击的还是有很大优势。\n\n我知道url了，那我通过程序不断获取最新的北京时间，可以达到毫秒级别的，我就在00毫秒的时候请求，我敢说绝对比你人工点的成功率大太多了，而且我可以一毫秒发送n次请求，搞不好你卖100个产品我全拿了。\n\n那这种情况怎么避免？把url动态化，就连写代码的人都不知道，你就通过md5之类的摘要算法加密随机的字符串去做url，然后通过前端代码获取url后台校验才能通过。\n\n这个只能防止一部分没耐心继续破解下去的黑客，有耐心的人研究出来还是能破解，在电商场景存在很多这样的羊毛党，那怎么做呢？后面我会说。\n\n限流\n\n限流这里我觉得应该分为前端限流和后端限流。\n\n物理控制\n\n大家有没有发现没到秒杀前，一般按钮都是置灰的，只有时间到了，才能点击。\n\n这是因为怕大家在时间快到的最后几秒秒疯狂请求服务器，然后还没到秒杀的时候基本上服务器就挂了。\n\n这个时候就需要前端的配合，定时去请求你的后端服务器，获取最新的北京时间，到时间点再给按钮可用状态。\n\n按钮可以点击之后也得给他置灰几秒，不然他一样在开始之后一直点的。\n\n你敢说你们秒杀的时候不是这样的？\n\n前端限流：这个很简单，一般秒杀不会让你一直点的，一般都是点击一下或者两下然后几秒之后才可以继续点击，这也是保护服务器的一种手段。\n\n后端限流：秒杀的时候肯定是涉及到后续的订单生成和支付等操作，但是都只是成功的幸运儿才会走到那一步，那一旦100个产品卖光了，return了一个false，前端直接秒杀结束，然后你后端也关闭后续无效请求的介入了。\n\ntip：真正的限流还会有限流组件的加入例如：阿里的sentinel、hystrix等。我这里就不展开了，就说一下物理的限流。\n\n我们卖1000件商品，请求有10w，我们不需要把十万都放进来，你可以放1w请求进来，然后再进行操作，因为秒杀对于用户本身就是黑盒的，所以你怎么做的他们是没感知的，至于为啥放1w进来，而不是刚好1000，是因为会丢掉一些薅羊毛的用户，至于怎么判断，后面的风控阶段我会说。\n\n\n# nginx\n\nnginx大家想必都不陌生了吧，这玩意是高性能的web服务器，并发也随便顶几万不是梦，但是我们的tomcat只能顶几百的并发呀，那简单呀负载均衡嘛，一台服务几百，那就多搞点，在秒杀的时候多租点流量机。\n\ntip：据我所知国内某大厂就是在去年春节活动期间租光了亚洲所有的服务器，小公司也很喜欢在双十一期间买流量机来顶住压力。\n\n恶意请求拦截也需要用到它，一般单个用户请求次数太夸张，不像人为的请求在网关那一层就得拦截掉了，不然请求多了他抢不抢得到是一回事，服务器压力上去了，可能占用网络带宽或者把服务器打崩、缓存击穿等等\n\n\n# 风控\n\n我可以明确的告诉大家，前面的所有措施还是拦不住很多羊毛党，因为他们是专业的团队，他们可以注册很多账号来薅你的羊毛，而且不用机器请求，就用群控，操作几乎跟真实用户一模一样。\n\n那怎么办，是不是无解了？\n\n这个时候就需要风控同学的介入了，在请求到达后端之前，风控可以根据账号行为分析出这个账号机器人的概率大不大，我现在负责公司的某些特殊系统，每个用户的行为都是会送到我们大数据团队进行分析处理，给你打上对应标签的。\n\n那黑客其实也有办法：养号\n\n他们去黑市买真实用户有过很多记录的账号，买到了还不闲着，帮他们去购物啥的，让系统无法识别他们是黑号还是真实用户的号。\n\n怎么办？\n\n通杀！是的没有办法，只能通杀了，通杀的意思就是，我们通过风管分析出来这个用户是真实用户的概率没有其他用户概率大，那就认为他是机器了，丢弃他的请求。\n\n之前的限流我们放进来10000个请求，但是我们真正的库存只有1000个，那我们就算出最有可能是真实用户的1000人进行秒杀，丢弃其他请求，因为秒杀本来就是黑盒操作的，用户层面是无感知的，这样设计能让真实的用户买到东西，还可以减少自己被薅羊毛的概率。\n\n风控可以说是流量进入的最后一道门槛了，所以很多公司的风控是很强的，蚂蚁金服的风控大家如果了解过就知道了，你的资金在支付宝被盗了，他们是能做到全款补偿是有原因的。\n\n\n# 后端\n\n服务单一职责\n\n设计个能抗住高并发的系统，我觉得还是得单一职责。\n\n什么意思呢，大家都知道现在设计都是微服务的设计思想，然后再用分布式的部署方式。\n\n也就是我们下单是有个订单服务，用户登录管理等有个用户服务等等，那为啥我们不给秒杀也开个服务，我们把秒杀的代码业务逻辑放一起。\n\n单一职责的好处就是就算秒杀没抗住，秒杀库崩了，服务挂了，也不会影响到其他的服务。（高可用）\n\nredis 集群\n\n之前不是说单机的redis顶不住嘛，那简单多找几个兄弟啊，秒杀本来就是读多写少，那你们是不是瞬间想起来我之前跟你们提到过的，redis集群，主从同步、读写分离，我们还搞点哨兵，开启持久化直接无敌高可用！\n\n库存预热\n\n秒杀的本质，就是对库存的抢夺，每个秒杀的用户来你都去数据库查询库存校验库存，然后扣减库存，撇开性能因数，你不觉得这样好繁琐，对业务开发人员都不友好，而且数据库顶不住啊。\n\n我们都知道数据库顶不住但是他的兄弟非关系型的数据库redis能顶啊！\n\n那不简单了，我们要开始秒杀前你通过定时任务或者运维同学提前把商品的库存加载到redis中去，让整个流程都在redis里面去做，然后等秒杀介绍了，再异步的去修改库存就好了。\n\n但是用了redis就有一个问题了，我们上面说了我们采用主从，就是我们会去读取库存然后再判断然后有库存才去减库存，正常情况没问题，但是高并发的情况问题就很大了。\n\n**多品几遍！！！**就比如现在库存只剩下1个了，我们高并发嘛，4个服务器一起查询了发现都是还有1个，那大家都觉得是自己抢到了，就都去扣库存，那结果就变成了-3，是的只有一个是真的抢到了，别的都是超卖的。咋办？\n\n事务\n\nredis本身是支持事务的，而且他有很多原子命令的，大家也可以用lua，还可以用他的管道，乐观锁他也知支持。\n\n限流&降级&熔断&隔离\n\n这个为啥要做呢，不怕一万就怕万一，万一你真的顶不住了，限流，顶不住就挡一部分出去但是不能说不行，降级，降级了还是被打挂了，熔断，至少不要影响别的系统，隔离，你本身就独立的，但是你会调用其他的系统嘛，你快不行了你别拖累兄弟们啊。\n\n消息队列（削峰填谷）\n\n一说到这个名词，很多小伙伴就知道了，对的mq，你买东西少了你直接100个请求改库我觉得没问题，但是万一秒杀一万个，10万个呢？服务器挂了，程序员又要背锅的。\n\n秒杀就是这种瞬间流量很高，但是平时又没有流量的场景，那消息队列完全契合这样的场景了呀，削峰填谷。\n\n\n\ntip：可能小伙伴说我们业务达不到这个量级，没必要。但是我想说我们写代码，就不应该写出有逻辑漏洞的代码，至少以后公司体量上去了，别人一看居然不用改代码，一看代码作者是xxx？有点东西！\n\n你可以把它放消息队列，然后一点点消费去改库存就好了嘛，不过单个商品其实一次修改就够了，我这里说的是某个点多个商品一起秒杀的场景，像极了双十一零点。\n\n\n# 数据库\n\n数据库用mysql只要连接池设置合理一般问题是不大的，不过一般大公司不缺钱而且秒杀这样的活动十分频繁，我之前所在的公司就是这样秒杀特卖这样的场景一直都是不间断的。\n\n单独给秒杀建立一个数据库，为秒杀服务，表的设计也是竟可能的简单点，现在的互联网架构部署都是分库的。\n\n至于表就看大家怎么设计了，该设置索引的地方还是要设置索引的，建完后记得用explain看看sql的执行计划。（不了解的小伙伴也没事，mysql章节去康康）\n\n\n# 分布式事务\n\n这为啥我不放在后端而放到最后来讲呢？\n\n因为上面的任何一步都是可能出错的，而且我们是在不同的服务里面出错的，那就涉及分布式事务了，但是分布式事务大家想的是一定要成功什么的那就不对了，还是那句话，几个请求丢了就丢了，要保证时效和服务的可用可靠。\n\n所以tcc和最终一致性其实不是很适合，tcc开发成本很大，所有接口都要写三次，因为涉及tcc的三个阶段。\n\n最终一致性基本上都是靠轮训的操作去保证一个操作一定成功，那时效性就大打折扣了。\n\n大家觉得不那么可靠的**两段式（2pc）和三段式（3pc）**就派上用场了，他们不一定能保证数据最终一致，但是效率上还算ok。\n\n\n# 总结\n\n到这里我想我已经基本上把该考虑的点还有对应的解决方案也都说了一下，不知道还有没有没考虑到的，但是就算没考虑到我想我这个设计，应该也能撑住一个完整的秒杀流程。\n\n最后大家再看看这个秒杀系统或许会有新的感悟，是不是一个系统真的没有大家想的那么简单，而且我还是有漏掉的细节，这是一定的。\n\n\n# 参考文献\n\n面试了十个应届生九个都是秒杀系统，你确定你们那是秒杀？_小公司的qps只有几十-csdn博客",charsets:{cjk:!0},lastUpdated:"2024/09/14, 14:10:17",lastUpdatedTimestamp:1726323017e3},{title:"分布式缓存",frontmatter:{title:"分布式缓存",date:"2024-09-14T02:09:39.000Z",permalink:"/pages/84cb49/"},regularPath:"/04.%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/01.%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/01.%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98.html",relativePath:"04.设计基础设施/01.基础设施/01.分布式缓存.md",key:"v-4e80661c",path:"/pages/84cb49/",headers:[{level:2,title:"需求",slug:"需求",normalizedTitle:"需求",charIndex:2},{level:2,title:"前置知识",slug:"前置知识",normalizedTitle:"前置知识",charIndex:124},{level:2,title:"渐进式设计",slug:"渐进式设计",normalizedTitle:"渐进式设计",charIndex:251},{level:3,title:"本地缓存",slug:"本地缓存",normalizedTitle:"本地缓存",charIndex:261},{level:3,title:"分布式缓存",slug:"分布式缓存",normalizedTitle:"分布式缓存",charIndex:272},{level:4,title:"认识分布式缓存",slug:"认识分布式缓存",normalizedTitle:"认识分布式缓存",charIndex:281},{level:4,title:"如何选择缓存节点？",slug:"如何选择缓存节点",normalizedTitle:"如何选择缓存节点？",charIndex:294},{level:4,title:"缓存客户端是什么？",slug:"缓存客户端是什么",normalizedTitle:"缓存客户端是什么？",charIndex:311},{level:4,title:"获取缓存节点列表",slug:"获取缓存节点列表",normalizedTitle:"获取缓存节点列表",charIndex:332},{level:2,title:"非功能设计",slug:"非功能设计",normalizedTitle:"非功能设计",charIndex:383},{level:3,title:"高可用",slug:"高可用",normalizedTitle:"高可用",charIndex:74},{level:3,title:"高可靠",slug:"高可靠",normalizedTitle:"高可靠",charIndex:403},{level:2,title:"还有什么重要的",slug:"还有什么重要的",normalizedTitle:"还有什么重要的",charIndex:482},{level:3,title:"一致性",slug:"一致性",normalizedTitle:"一致性",charIndex:149},{level:3,title:"数据过期",slug:"数据过期",normalizedTitle:"数据过期",charIndex:221},{level:3,title:"数据淘汰策略",slug:"数据淘汰策略",normalizedTitle:"数据淘汰策略",charIndex:533},{level:3,title:"本地缓存+远程缓存",slug:"本地缓存-远程缓存",normalizedTitle:"本地缓存+远程缓存",charIndex:544},{level:3,title:"安全",slug:"安全",normalizedTitle:"安全",charIndex:234},{level:3,title:"监控和日志",slug:"监控和日志",normalizedTitle:"监控和日志",charIndex:238},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:575}],headersStr:"需求 前置知识 渐进式设计 本地缓存 分布式缓存 认识分布式缓存 如何选择缓存节点？ 缓存客户端是什么？ 获取缓存节点列表 非功能设计 高可用 高可靠 还有什么重要的 一致性 数据过期 数据淘汰策略 本地缓存+远程缓存 安全 监控和日志 总结",content:"# 需求\n\n功能性\n\n * put(key,value)\n * get(key)\n\n非功能性\n\n * 高扩展（随着数据和请求的增加轻松扩展）\n * 高可用（硬件/网络故障下仍然可用）\n * 高性能（put和get的高性能！）\n * 持久化\n\n\n# 前置知识\n\n * LRU 算法\n\n * 哈希取模与一致性哈希算法\n\n * 专用缓存集群与共存缓存\n\n * 缓存客户端\n\n * 静态与动态缓存服务器列表配置\n\n * 主从复制\n\n * 缓存一致性、数据过期、本地和远程缓存、安全性、监控和日志记录。\n\n\n# 渐进式设计\n\n\n# 本地缓存\n\n\n\n\n# 分布式缓存\n\n# 认识分布式缓存\n\n\n\n# 如何选择缓存节点？\n\n\n\n\n\n# 缓存客户端是什么？\n\n\n\n * 客户端如何获取缓存节点列表？\n * 当扩容或缩容时，缓存节点列表如何更新？\n\n# 获取缓存节点列表\n\n\n\n\n# 非功能设计\n\n\n# 高可用\n\n\n\n\n# 高可靠\n\n * 数据异步复制到replica\n * 数据同步复制到replica\n * 数据同步复制到所有replica然后返回？\n\n我们需要权衡！\n\n\n# 还有什么重要的\n\n\n# 一致性\n\n引入同步复制，确保所有缓存节点的视图一致\n\n\n# 数据过期\n\n\n# 数据淘汰策略\n\n\n# 本地缓存+远程缓存\n\n\n# 安全\n\n\n# 监控和日志\n\n\n# 总结\n\n",normalizedContent:"# 需求\n\n功能性\n\n * put(key,value)\n * get(key)\n\n非功能性\n\n * 高扩展（随着数据和请求的增加轻松扩展）\n * 高可用（硬件/网络故障下仍然可用）\n * 高性能（put和get的高性能！）\n * 持久化\n\n\n# 前置知识\n\n * lru 算法\n\n * 哈希取模与一致性哈希算法\n\n * 专用缓存集群与共存缓存\n\n * 缓存客户端\n\n * 静态与动态缓存服务器列表配置\n\n * 主从复制\n\n * 缓存一致性、数据过期、本地和远程缓存、安全性、监控和日志记录。\n\n\n# 渐进式设计\n\n\n# 本地缓存\n\n\n\n\n# 分布式缓存\n\n# 认识分布式缓存\n\n\n\n# 如何选择缓存节点？\n\n\n\n\n\n# 缓存客户端是什么？\n\n\n\n * 客户端如何获取缓存节点列表？\n * 当扩容或缩容时，缓存节点列表如何更新？\n\n# 获取缓存节点列表\n\n\n\n\n# 非功能设计\n\n\n# 高可用\n\n\n\n\n# 高可靠\n\n * 数据异步复制到replica\n * 数据同步复制到replica\n * 数据同步复制到所有replica然后返回？\n\n我们需要权衡！\n\n\n# 还有什么重要的\n\n\n# 一致性\n\n引入同步复制，确保所有缓存节点的视图一致\n\n\n# 数据过期\n\n\n# 数据淘汰策略\n\n\n# 本地缓存+远程缓存\n\n\n# 安全\n\n\n# 监控和日志\n\n\n# 总结\n\n",charsets:{cjk:!0},lastUpdated:"2024/09/14, 08:54:46",lastUpdatedTimestamp:1726304086e3},{title:"限流器",frontmatter:{title:"限流器",date:"2024-09-14T02:09:39.000Z",permalink:"/pages/57d5a5/"},regularPath:"/04.%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/01.%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/02.%E9%99%90%E6%B5%81%E5%99%A8.html",relativePath:"04.设计基础设施/01.基础设施/02.限流器.md",key:"v-ca3de854",path:"/pages/57d5a5/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"需求",slug:"需求",normalizedTitle:"需求",charIndex:190},{level:2,title:"前置知识",slug:"前置知识",normalizedTitle:"前置知识",charIndex:299},{level:2,title:"组件架构",slug:"组件架构",normalizedTitle:"组件架构",charIndex:438},{level:2,title:"接口和类",slug:"接口和类",normalizedTitle:"接口和类",charIndex:449},{level:2,title:"消息广播",slug:"消息广播",normalizedTitle:"消息广播",charIndex:355},{level:2,title:"如何集成",slug:"如何集成",normalizedTitle:"如何集成",charIndex:471},{level:2,title:"答疑解惑",slug:"答疑解惑",normalizedTitle:"答疑解惑",charIndex:482},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:753}],headersStr:"概述 需求 前置知识 组件架构 接口和类 消息广播 如何集成 答疑解惑 总结",content:"# 概述\n\n\n\n * 我们需要编写一个可扩展以处理高负载的软件吗？\n\n * 负载均衡器中已经实现了最大连接数和服务端点上的最大线程数呢。我们还需要节流吗？\n\n * * 这种机制是不加区别的，有些操作快，有些操作慢，负载均衡器不了解每个操作的成本，如果我们想对某个操作实现特定的限流，负载均衡器就不好使了\n\n * 我们如何单独控制每个主机呢？\n\n * * 主机间相互通信！\n\n\n# 需求\n\n功能性\n\n * allowRequest(request)\n\n非功能性\n\n * 低延迟（尽快做出决定）\n * 准确性（尽可能准确）\n * 可扩展（支持集群中任意数量的主机）\n * 高可用\n * 高可靠\n\n\n# 前置知识\n\n * 令牌桶算法\n * 速率限制解决方案的面向对象设计\n * 负载均衡器最大连接数，自动扩展\n * 消息广播：全网状网络拓扑、gossip 通信、分布式缓存、协调服务\n * 通信协议：TCP、UDP\n * 嵌入式速率限制器与守护进程\n * 存储桶管理、同步\n\n\n# 组件架构\n\n\n\n\n# 接口和类\n\n\n\n\n# 消息广播\n\n\n\n\n# 如何集成\n\n\n\n\n# 答疑解惑\n\n * 我的服务非常受欢迎，有数百万用户。这是否意味着内存中存储了数百万个桶？\n\n * * 可以瞬间增加很多桶，但是当桶没用的时候，可以删除桶\n\n * 有哪些失败的场景？\n\n * * 守护线程失败\n   * 网络分区，无法传播消息，每个主机将允许更多的请求\n\n * 我们是否需要一个自动配置管理服务？\n\n * 我有点担心同步问题。这不是瓶颈吗？\n\n * * 原则上来说 我们要重视并发安全\n   * 但是我们没有必要实现，会对性能造成影响\n\n * 当客户的请求被拒绝时，他们应该做什么？\n\n * * 重试（指数退避、抖动）\n\n\n# 总结\n\n",normalizedContent:"# 概述\n\n\n\n * 我们需要编写一个可扩展以处理高负载的软件吗？\n\n * 负载均衡器中已经实现了最大连接数和服务端点上的最大线程数呢。我们还需要节流吗？\n\n * * 这种机制是不加区别的，有些操作快，有些操作慢，负载均衡器不了解每个操作的成本，如果我们想对某个操作实现特定的限流，负载均衡器就不好使了\n\n * 我们如何单独控制每个主机呢？\n\n * * 主机间相互通信！\n\n\n# 需求\n\n功能性\n\n * allowrequest(request)\n\n非功能性\n\n * 低延迟（尽快做出决定）\n * 准确性（尽可能准确）\n * 可扩展（支持集群中任意数量的主机）\n * 高可用\n * 高可靠\n\n\n# 前置知识\n\n * 令牌桶算法\n * 速率限制解决方案的面向对象设计\n * 负载均衡器最大连接数，自动扩展\n * 消息广播：全网状网络拓扑、gossip 通信、分布式缓存、协调服务\n * 通信协议：tcp、udp\n * 嵌入式速率限制器与守护进程\n * 存储桶管理、同步\n\n\n# 组件架构\n\n\n\n\n# 接口和类\n\n\n\n\n# 消息广播\n\n\n\n\n# 如何集成\n\n\n\n\n# 答疑解惑\n\n * 我的服务非常受欢迎，有数百万用户。这是否意味着内存中存储了数百万个桶？\n\n * * 可以瞬间增加很多桶，但是当桶没用的时候，可以删除桶\n\n * 有哪些失败的场景？\n\n * * 守护线程失败\n   * 网络分区，无法传播消息，每个主机将允许更多的请求\n\n * 我们是否需要一个自动配置管理服务？\n\n * 我有点担心同步问题。这不是瓶颈吗？\n\n * * 原则上来说 我们要重视并发安全\n   * 但是我们没有必要实现，会对性能造成影响\n\n * 当客户的请求被拒绝时，他们应该做什么？\n\n * * 重试（指数退避、抖动）\n\n\n# 总结\n\n",charsets:{cjk:!0},lastUpdated:"2024/09/14, 08:54:46",lastUpdatedTimestamp:1726304086e3},{title:"热点探查（Top k）",frontmatter:{title:"热点探查（Top k）",date:"2024-09-14T03:52:03.000Z",permalink:"/pages/5dcb6b/"},regularPath:"/04.%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/01.%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/03.%E7%83%AD%E7%82%B9%E6%8E%A2%E6%9F%A5%EF%BC%88Top%20k%EF%BC%89.html",relativePath:"04.设计基础设施/01.基础设施/03.热点探查（Top k）.md",key:"v-82af755a",path:"/pages/5dcb6b/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"前置知识",slug:"前置知识",normalizedTitle:"前置知识",charIndex:313},{level:2,title:"需求",slug:"需求",normalizedTitle:"需求",charIndex:373},{level:2,title:"渐进设计",slug:"渐进设计",normalizedTitle:"渐进设计",charIndex:600},{level:3,title:"哈希表+单主机",slug:"哈希表-单主机",normalizedTitle:"哈希表+单主机",charIndex:609},{level:3,title:"哈希表+多主机",slug:"哈希表-多主机",normalizedTitle:"哈希表+多主机",charIndex:739},{level:3,title:"哈希表+多主机+分区",slug:"哈希表-多主机-分区",normalizedTitle:"哈希表+多主机+分区",charIndex:830},{level:3,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:959},{level:2,title:"高层架构",slug:"高层架构",normalizedTitle:"高层架构",charIndex:1630},{level:2,title:"客户端检索数据",slug:"客户端检索数据",normalizedTitle:"客户端检索数据",charIndex:2400},{level:2,title:"解答疑惑",slug:"解答疑惑",normalizedTitle:"解答疑惑",charIndex:2485},{level:2,title:"参考资料",slug:"参考资料",normalizedTitle:"参考资料",charIndex:5033}],headersStr:"概述 前置知识 需求 渐进设计 哈希表+单主机 哈希表+多主机 哈希表+多主机+分区 总结 高层架构 客户端检索数据 解答疑惑 参考资料",content:"# 概述\n\nTop k 问题解决方案的各种应用（Google/Twitter/YouTube 趋势、热门产品、波动性股票、DDoS 攻击预防）。\n\n在这样的规模下，数据库或分布式缓存不是一个选项。我们可能正在处理 1M RPS。如果我们使用 DB 来跟踪视图计数，首先写入/更新会非常慢，然后找到前 K 项需要扫描整个数据集。\n\n也许 MapReduce 可以提供帮助。但这还不够。我们需要尽可能接近实时地返回重磅统计数据。\n\n例如：\n\n * Calculate top 100 list for last\n * 1 min, 5 min, 15 mins, 60 mins etc.\n\n这使得这个问题成为流处理问题\n\n\n# 前置知识\n\nMapReduce\n\nCount-min sketch\n\n数据聚合原理\n\n合并 N 个排序列表问题\n\n\n# 需求\n\n功能\n\n * topK(k,startTime,endTime)\n\n非功能\n\n * 高扩展（随着数据量的增加而扩展：视频、推文、帖子等）\n * 高可用性（在硬件/网络故障中幸存，没有 SPOF）\n * 高性能（返回前100名列表需要几十毫秒，考虑到性能要求，这暗示了最终列表应该预先计算，我们应该避免在调用 top K API 时进行繁重的计算。）\n * 准确性（例如，通过使用数据采样，我们可能不会计算每个元素，而只计算一小部分事件）\n\n\n# 渐进设计\n\n\n# 哈希表+单主机\n\n * 在 hashmap 中保留传入事件列表的计数\n\n * * 按频率对 hashmap 中的条目列表进行排序，并返回前 K 个元素。时间 O(nLogN)\n   * 将元素放在大小为 K 的堆上。时间复杂度O(nLogK)\n\n\n\n\n\n\n# 哈希表+多主机\n\n * 如果您将所有 youtube 视频 ID 存储在您作为主机的内存中，内存将是一个问题\n\n\n\n虽然增加了吞吐量，但是有内存瓶颈，hash 表会越来越大\n\n\n# 哈希表+多主机+分区\n\n * 我们不会将所有哈希表数据从所有主机发送到存储主机。相反，我们会在每个主机上单独计算 topK 列表，最后我们需要在存储主机上合并这些排序的列表。\n\n\n\n数据分区可以不将所有数据存储到一个主机上，减少了每个主机内存的压力\n\n\n# 总结\n\n问题\n\n * 我们认为数据集是无界的，这就是为什么我们能够考虑将其划分为多个块。但流数据没有界限。它不断涌现。在这种情况下，处理器主机只能在一段时间内继续积累数据，在此之前它将耗尽内存。比如 1 分钟。\n\n * * 我们将 1 min 数据刷新到存储主机\n   * 存储主机存储每分钟的热点列表\n   * 我们故意丢失了有关非 topK 元素的所有信息。我们负担不起在内存中存储每个视频的信息。\n   * 但是，如果我们想找到过去 1 小时或过去 1 天的 topK，我们如何使用 60 个 1 分钟 list 来构建它呢。鉴于当前的方法，没有解决此问题的正确方法。要找到当天的 topK，我们需要全天的完整数据集。\n   * 需求冲突，保留完整的 1 天数据（以满足需求）或丢失它以负担存储。让我们把所有数据存储在磁盘上，因为它无法放入内存，并使用批处理框架来做 topK 列表。Map Reduce 架构将发挥作用\n\n * 每次引入数据分区时，我们都必须考虑数据复制，以便将每个分区的副本存储在多个节点上。我们需要考虑在集群中添加/删除新节点时重新平衡。我们需要处理热分区。\n\n解决方案\n\n在进入上面讨论的方法之前，让我们想一想是否有一个简单的解决方案来解决 topK 问题？\n\n权衡利弊权衡利弊，所有的选择，不过是权衡利弊罢了\n\n我们需要在此过程中做出牺牲。准确性就是牺牲\n\n我们要合理利用数据结构，这将帮助我们使用固定大小的内存计算 topK，但结果可能不是 100% 准确\n\nCount-Min Sketch！\n\n\n\n\n# 高层架构\n\n\n\n * API Gateway：连接到视频内容交付系统，该系统将提供视频请求\n\n * * 对于我们的用例，我们对 API 网关的 1 个功能感兴趣，即日志生成，其中记录对 API 的每次调用。通常这些日志用于监控、日志记录和审计。我们将使用这些日志来计算每个视频的观看次数。我们可能有一个后台进程，它从日志中读取数据，进行一些初始聚合并发送数据进行进一步处理。\n   * 为 API 网关服务上的缓冲区分配内存，读取日志行，并构建频率计数哈希表。此缓冲区的大小应有限，当缓冲区已满时，将刷新数据。如果缓冲区在某个时间段内未满，我们可以根据时间段进行 flush。\n   * 其他选项可以是动态聚合数据，而不写入日志文件。或者完全跳过 API 网关端的数据聚合，并将有关每个事件（正在查看的视频）的信息进一步发送以进行处理。评估每个选项的优缺点。\n   * 我们可以通过以紧凑的二进制格式（例如 Apache Avro）序列化数据来节省网络 IO 利用率，并让 CPU 付出代价。所有这些注意事项都取决于 API 网关主机上可用的资源，即内存、CPU、网络和磁盘 IO。\n\n * distributed messaging system：初始聚合数据将发送到分布式消息传递系统，如 Apache Kafka。\n\n * Fast path and Slow path\n\n * * 在 Fast path 中，我们将大致计算 topK hitter 的结果。结果将在几秒钟内提供。\n   * 在 slow path 中，我们将精确计算 topK hitter 的结果。几分钟/几小时内即可获得结果。\n   * 根据系统对系统时序的限制（是否需要近实时结果，或者延迟是否可以接受以实现精度），您应该选择任一路径。\n\n\n\n\n\n\n\n\n# 客户端检索数据\n\n\n\n合并 2 个不同的结果集来回答 API 调用并不准确，但这是一种权衡。您无法在任何时间聚合数据。您必须了解确切需要的东西，并据此进行构建。\n\n\n# 解答疑惑\n\n * 我们是否可以使用哈希映射，但每隔几秒钟将其内容（转换为堆后）刷新到存储中，而不是使用 CMS？\n\n * * 对于小规模，使用哈希映射是完全可以的。当规模增长时，哈希映射可能会变得太大（使用大量内存）。为了防止这种情况，我们可以对数据进行分区，以便只有所有数据的子集进入 Fast Processor 服务主机。但它使架构复杂化。CMS 的美妙之处在于它消耗有限的（定义的）内存，并且无需对数据进行分区。CMS 的缺点是它大约计算数字。权衡，权衡......\n\n * 我们如何将 count-min sketch 和 heap 存储到数据库中？如何设计 table 架构？\n\n * * Heap 只是一个一维数组。CMS 是一个二维数组。这意味着两者都可以很容易地序列化为字节数组。使用语言原生序列化 API 或备受推崇的序列化框架（Protobufs、Thrift、Avro）。我们可以将它们以这种形式存储在数据库中。\n\n * 虽然 CMS 是为了节省内存，但我们还有 n log k 时间来获得前 k，对吧？\n\n * * 是的。它是 O(nlogk)（用于堆）+ O(klogk)（用于对最终列表进行排序）。N 通常比 k 大得多。所以，O(nlogk) 是主导的。\n\n * 如果 CMS 只用于 1 min 计数，为什么我们不直接使用哈希表来计数呢？毕竟，数据集的大小不会无限增长。\n\n * * 对于中小规模，哈希表解决方案可能效果很好。但请记住，如果我们尝试创建一个需要为许多不同场景查找前 K 个列表的服务，则可能会有很多这样的哈希表，并且它不会很好地扩展。例如，最常喜欢/不喜欢的视频、观看次数最多（基于时间）的视频、评论次数最多的视频、视频打开期间异常数量最多的前 K 名等。类似的统计数据可以按渠道级别、每个国家/地区等进行计算。长话短说，我们可能需要使用我们的服务来计算许多不同的前 K 名列表\n\n * 如何合并两个 1 小时的 top k 列表，以获得 2 小时的 top k？\n\n * * 我们需要对相同标识符的值求和。换句话说，我们会汇总两个列表中相同视频的观看次数。并获取合并列表的前 K （通过排序或使用 Heap）。 [不过，这不一定是 100% 准确的结果]\n\n * 当存在您提到的不同情况时，CMS 如何工作......最赞/最不喜欢的视频。我们需要构建多个 CMS 吗？我们是否需要为每个类别指定哈希值？无论哪种方式，它们都需要更多的内存，就像哈希表一样。\n\n * * 正确。我们需要特定的 CMS 来计算不同的事件类型：视频观看次数、喜欢、不喜欢、提交评论等。\n\n * 关于慢路径，我对数据分区器感到困惑。我们是否可以删除第一个 Distribute Messaging System 和 data partitioner？API 网关将根据其分区直接向第二个 Distribute Messaging System 发送消息。例如，API 网关会将所有 B 消息发送到分区 1，将所有 A 消息发送到分区 2，将所有 C 消息发送到分区 3。为什么我们需要第一个 Distribute Messaging System 和data partitioner？如果我们使用 Kalfa 作为 Distribute Messaging System，我们可以只为一组消息类型创建一个主题。\n\n * * 在大规模（例如 YouTube 规模）的情况下，API Gateway 集群将处理大量请求。我假设这些是数千甚至数万台 CPU 密集型计算机。主要目标是提供视频内容并尽可能少地做 “其他” 事情。在这样的机器上，我们通常希望避免任何繁重的聚合或逻辑。我们能做的最简单的事情是将每个视频观看请求批处理在一起。我的意思是根本不做任何聚合。创建包含如下内容的单个消息：{A = 1， B = 1， C = 1}，并将其发送以进行进一步处理。在您提到的选项中，我们仍然需要在 API Gateway 端进行聚合。由于规模很大，我们无法承受每个视频观看请求向第二个 DMS 发送一条消息的后果。我的意思是我们不能有三条消息，比如：{A = 1}、{B = 1}、{C = 1}。如视频中所述，我们希望在每个下一个阶段降低请求率。\n\n * 我有一个关于快速路径的问题，似乎您将聚合后的 CMS 存储在存储系统中，但这足以计算前 k 个吗？我觉得我们需要有一个网站列表，并在某个地方维护一个大小为 k 的堆，以找出前 k 个。\n\n * * 你是对的。我们始终保留两种数据结构：一个 count-min sketch 和一个 Fast Processor 中的堆。我们使用 count-min sketch 进行计数，而 heap 存储前 k 个列表。在 Storage 服务中，我们也可以同时保留两者或仅保留堆。但是 heap 始终存在。\n\n * 所以总的来说，我们仍然需要存储 keys。。。Count-min Sketch 无需单独维护 Key 的计数，从而有助于节省成本...当必须找到前 k 个元素时，必须遍历每个键并使用 count-min sketch 来找到前 k 个元素......这种理解准确吗？\n\n * * 我们需要存储 keys ，但只需要存储其中的 K（或更多）。并非全部。\n   * 当每个 key 到来时，我们执行以下操作：\n * * * 将其添加到 count-min 草图中。\n     * 从 count-min 草图中获取密钥计数。\n     * 检查当前 key 是否在堆中。如果它出现在堆中，我们在那里更新它的 count 值。如果它不存在于堆中，我们检查堆是否已满。如果未满，我们将此键添加到堆中。如果 heap 已满，则检查最小 heap 元素并将其值与当前 key count 值进行比较。此时，我们可以删除最小元素并添加当前键（如果当前键计数 > 最小元素值）。\n * * 这样我们只保留预定义数量的 key。这保证了我们永远不会超过内存，因为 count-min sketch 和堆的大小都是有限的\n\n\n# 参考资料\n\nhttps://www.youtube.com/watch?v=kx-XDoPjoHw",normalizedContent:"# 概述\n\ntop k 问题解决方案的各种应用（google/twitter/youtube 趋势、热门产品、波动性股票、ddos 攻击预防）。\n\n在这样的规模下，数据库或分布式缓存不是一个选项。我们可能正在处理 1m rps。如果我们使用 db 来跟踪视图计数，首先写入/更新会非常慢，然后找到前 k 项需要扫描整个数据集。\n\n也许 mapreduce 可以提供帮助。但这还不够。我们需要尽可能接近实时地返回重磅统计数据。\n\n例如：\n\n * calculate top 100 list for last\n * 1 min, 5 min, 15 mins, 60 mins etc.\n\n这使得这个问题成为流处理问题\n\n\n# 前置知识\n\nmapreduce\n\ncount-min sketch\n\n数据聚合原理\n\n合并 n 个排序列表问题\n\n\n# 需求\n\n功能\n\n * topk(k,starttime,endtime)\n\n非功能\n\n * 高扩展（随着数据量的增加而扩展：视频、推文、帖子等）\n * 高可用性（在硬件/网络故障中幸存，没有 spof）\n * 高性能（返回前100名列表需要几十毫秒，考虑到性能要求，这暗示了最终列表应该预先计算，我们应该避免在调用 top k api 时进行繁重的计算。）\n * 准确性（例如，通过使用数据采样，我们可能不会计算每个元素，而只计算一小部分事件）\n\n\n# 渐进设计\n\n\n# 哈希表+单主机\n\n * 在 hashmap 中保留传入事件列表的计数\n\n * * 按频率对 hashmap 中的条目列表进行排序，并返回前 k 个元素。时间 o(nlogn)\n   * 将元素放在大小为 k 的堆上。时间复杂度o(nlogk)\n\n\n\n\n\n\n# 哈希表+多主机\n\n * 如果您将所有 youtube 视频 id 存储在您作为主机的内存中，内存将是一个问题\n\n\n\n虽然增加了吞吐量，但是有内存瓶颈，hash 表会越来越大\n\n\n# 哈希表+多主机+分区\n\n * 我们不会将所有哈希表数据从所有主机发送到存储主机。相反，我们会在每个主机上单独计算 topk 列表，最后我们需要在存储主机上合并这些排序的列表。\n\n\n\n数据分区可以不将所有数据存储到一个主机上，减少了每个主机内存的压力\n\n\n# 总结\n\n问题\n\n * 我们认为数据集是无界的，这就是为什么我们能够考虑将其划分为多个块。但流数据没有界限。它不断涌现。在这种情况下，处理器主机只能在一段时间内继续积累数据，在此之前它将耗尽内存。比如 1 分钟。\n\n * * 我们将 1 min 数据刷新到存储主机\n   * 存储主机存储每分钟的热点列表\n   * 我们故意丢失了有关非 topk 元素的所有信息。我们负担不起在内存中存储每个视频的信息。\n   * 但是，如果我们想找到过去 1 小时或过去 1 天的 topk，我们如何使用 60 个 1 分钟 list 来构建它呢。鉴于当前的方法，没有解决此问题的正确方法。要找到当天的 topk，我们需要全天的完整数据集。\n   * 需求冲突，保留完整的 1 天数据（以满足需求）或丢失它以负担存储。让我们把所有数据存储在磁盘上，因为它无法放入内存，并使用批处理框架来做 topk 列表。map reduce 架构将发挥作用\n\n * 每次引入数据分区时，我们都必须考虑数据复制，以便将每个分区的副本存储在多个节点上。我们需要考虑在集群中添加/删除新节点时重新平衡。我们需要处理热分区。\n\n解决方案\n\n在进入上面讨论的方法之前，让我们想一想是否有一个简单的解决方案来解决 topk 问题？\n\n权衡利弊权衡利弊，所有的选择，不过是权衡利弊罢了\n\n我们需要在此过程中做出牺牲。准确性就是牺牲\n\n我们要合理利用数据结构，这将帮助我们使用固定大小的内存计算 topk，但结果可能不是 100% 准确\n\ncount-min sketch！\n\n\n\n\n# 高层架构\n\n\n\n * api gateway：连接到视频内容交付系统，该系统将提供视频请求\n\n * * 对于我们的用例，我们对 api 网关的 1 个功能感兴趣，即日志生成，其中记录对 api 的每次调用。通常这些日志用于监控、日志记录和审计。我们将使用这些日志来计算每个视频的观看次数。我们可能有一个后台进程，它从日志中读取数据，进行一些初始聚合并发送数据进行进一步处理。\n   * 为 api 网关服务上的缓冲区分配内存，读取日志行，并构建频率计数哈希表。此缓冲区的大小应有限，当缓冲区已满时，将刷新数据。如果缓冲区在某个时间段内未满，我们可以根据时间段进行 flush。\n   * 其他选项可以是动态聚合数据，而不写入日志文件。或者完全跳过 api 网关端的数据聚合，并将有关每个事件（正在查看的视频）的信息进一步发送以进行处理。评估每个选项的优缺点。\n   * 我们可以通过以紧凑的二进制格式（例如 apache avro）序列化数据来节省网络 io 利用率，并让 cpu 付出代价。所有这些注意事项都取决于 api 网关主机上可用的资源，即内存、cpu、网络和磁盘 io。\n\n * distributed messaging system：初始聚合数据将发送到分布式消息传递系统，如 apache kafka。\n\n * fast path and slow path\n\n * * 在 fast path 中，我们将大致计算 topk hitter 的结果。结果将在几秒钟内提供。\n   * 在 slow path 中，我们将精确计算 topk hitter 的结果。几分钟/几小时内即可获得结果。\n   * 根据系统对系统时序的限制（是否需要近实时结果，或者延迟是否可以接受以实现精度），您应该选择任一路径。\n\n\n\n\n\n\n\n\n# 客户端检索数据\n\n\n\n合并 2 个不同的结果集来回答 api 调用并不准确，但这是一种权衡。您无法在任何时间聚合数据。您必须了解确切需要的东西，并据此进行构建。\n\n\n# 解答疑惑\n\n * 我们是否可以使用哈希映射，但每隔几秒钟将其内容（转换为堆后）刷新到存储中，而不是使用 cms？\n\n * * 对于小规模，使用哈希映射是完全可以的。当规模增长时，哈希映射可能会变得太大（使用大量内存）。为了防止这种情况，我们可以对数据进行分区，以便只有所有数据的子集进入 fast processor 服务主机。但它使架构复杂化。cms 的美妙之处在于它消耗有限的（定义的）内存，并且无需对数据进行分区。cms 的缺点是它大约计算数字。权衡，权衡......\n\n * 我们如何将 count-min sketch 和 heap 存储到数据库中？如何设计 table 架构？\n\n * * heap 只是一个一维数组。cms 是一个二维数组。这意味着两者都可以很容易地序列化为字节数组。使用语言原生序列化 api 或备受推崇的序列化框架（protobufs、thrift、avro）。我们可以将它们以这种形式存储在数据库中。\n\n * 虽然 cms 是为了节省内存，但我们还有 n log k 时间来获得前 k，对吧？\n\n * * 是的。它是 o(nlogk)（用于堆）+ o(klogk)（用于对最终列表进行排序）。n 通常比 k 大得多。所以，o(nlogk) 是主导的。\n\n * 如果 cms 只用于 1 min 计数，为什么我们不直接使用哈希表来计数呢？毕竟，数据集的大小不会无限增长。\n\n * * 对于中小规模，哈希表解决方案可能效果很好。但请记住，如果我们尝试创建一个需要为许多不同场景查找前 k 个列表的服务，则可能会有很多这样的哈希表，并且它不会很好地扩展。例如，最常喜欢/不喜欢的视频、观看次数最多（基于时间）的视频、评论次数最多的视频、视频打开期间异常数量最多的前 k 名等。类似的统计数据可以按渠道级别、每个国家/地区等进行计算。长话短说，我们可能需要使用我们的服务来计算许多不同的前 k 名列表\n\n * 如何合并两个 1 小时的 top k 列表，以获得 2 小时的 top k？\n\n * * 我们需要对相同标识符的值求和。换句话说，我们会汇总两个列表中相同视频的观看次数。并获取合并列表的前 k （通过排序或使用 heap）。 [不过，这不一定是 100% 准确的结果]\n\n * 当存在您提到的不同情况时，cms 如何工作......最赞/最不喜欢的视频。我们需要构建多个 cms 吗？我们是否需要为每个类别指定哈希值？无论哪种方式，它们都需要更多的内存，就像哈希表一样。\n\n * * 正确。我们需要特定的 cms 来计算不同的事件类型：视频观看次数、喜欢、不喜欢、提交评论等。\n\n * 关于慢路径，我对数据分区器感到困惑。我们是否可以删除第一个 distribute messaging system 和 data partitioner？api 网关将根据其分区直接向第二个 distribute messaging system 发送消息。例如，api 网关会将所有 b 消息发送到分区 1，将所有 a 消息发送到分区 2，将所有 c 消息发送到分区 3。为什么我们需要第一个 distribute messaging system 和data partitioner？如果我们使用 kalfa 作为 distribute messaging system，我们可以只为一组消息类型创建一个主题。\n\n * * 在大规模（例如 youtube 规模）的情况下，api gateway 集群将处理大量请求。我假设这些是数千甚至数万台 cpu 密集型计算机。主要目标是提供视频内容并尽可能少地做 “其他” 事情。在这样的机器上，我们通常希望避免任何繁重的聚合或逻辑。我们能做的最简单的事情是将每个视频观看请求批处理在一起。我的意思是根本不做任何聚合。创建包含如下内容的单个消息：{a = 1， b = 1， c = 1}，并将其发送以进行进一步处理。在您提到的选项中，我们仍然需要在 api gateway 端进行聚合。由于规模很大，我们无法承受每个视频观看请求向第二个 dms 发送一条消息的后果。我的意思是我们不能有三条消息，比如：{a = 1}、{b = 1}、{c = 1}。如视频中所述，我们希望在每个下一个阶段降低请求率。\n\n * 我有一个关于快速路径的问题，似乎您将聚合后的 cms 存储在存储系统中，但这足以计算前 k 个吗？我觉得我们需要有一个网站列表，并在某个地方维护一个大小为 k 的堆，以找出前 k 个。\n\n * * 你是对的。我们始终保留两种数据结构：一个 count-min sketch 和一个 fast processor 中的堆。我们使用 count-min sketch 进行计数，而 heap 存储前 k 个列表。在 storage 服务中，我们也可以同时保留两者或仅保留堆。但是 heap 始终存在。\n\n * 所以总的来说，我们仍然需要存储 keys。。。count-min sketch 无需单独维护 key 的计数，从而有助于节省成本...当必须找到前 k 个元素时，必须遍历每个键并使用 count-min sketch 来找到前 k 个元素......这种理解准确吗？\n\n * * 我们需要存储 keys ，但只需要存储其中的 k（或更多）。并非全部。\n   * 当每个 key 到来时，我们执行以下操作：\n * * * 将其添加到 count-min 草图中。\n     * 从 count-min 草图中获取密钥计数。\n     * 检查当前 key 是否在堆中。如果它出现在堆中，我们在那里更新它的 count 值。如果它不存在于堆中，我们检查堆是否已满。如果未满，我们将此键添加到堆中。如果 heap 已满，则检查最小 heap 元素并将其值与当前 key count 值进行比较。此时，我们可以删除最小元素并添加当前键（如果当前键计数 > 最小元素值）。\n * * 这样我们只保留预定义数量的 key。这保证了我们永远不会超过内存，因为 count-min sketch 和堆的大小都是有限的\n\n\n# 参考资料\n\nhttps://www.youtube.com/watch?v=kx-xdopjohw",charsets:{cjk:!0},lastUpdated:"2024/09/14, 08:54:46",lastUpdatedTimestamp:1726304086e3},{title:"消息队列",frontmatter:{title:"消息队列",date:"2024-09-14T16:43:00.000Z",permalink:"/pages/567090/"},regularPath:"/04.%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/01.%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/04.%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97.html",relativePath:"04.设计基础设施/01.基础设施/04.消息队列.md",key:"v-f75dbe40",path:"/pages/567090/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"需求",slug:"需求",normalizedTitle:"需求",charIndex:11},{level:2,title:"高层抽象",slug:"高层抽象",normalizedTitle:"高层抽象",charIndex:78},{level:2,title:"虚拟IP和负载均衡",slug:"虚拟ip和负载均衡",normalizedTitle:"虚拟ip和负载均衡",charIndex:89},{level:2,title:"前端服务",slug:"前端服务",normalizedTitle:"前端服务",charIndex:105},{level:2,title:"元数据服务",slug:"元数据服务",normalizedTitle:"元数据服务",charIndex:116},{level:2,title:"后端服务",slug:"后端服务",normalizedTitle:"后端服务",charIndex:128},{level:2,title:"还有什么重要的？",slug:"还有什么重要的",normalizedTitle:"还有什么重要的？",charIndex:145},{level:3,title:"队列的创建与删除",slug:"队列的创建与删除",normalizedTitle:"队列的创建与删除",charIndex:160},{level:3,title:"消息的删除",slug:"消息的删除",normalizedTitle:"消息的删除",charIndex:173},{level:2,title:"总结",slug:"总结",normalizedTitle:"总结",charIndex:183}],headersStr:"概述 需求 高层抽象 虚拟IP和负载均衡 前端服务 元数据服务 后端服务 还有什么重要的？ 队列的创建与删除 消息的删除 总结",content:"# 概述\n\n\n\n\n# 需求\n\n功能性\n\n * sendMessage(messageBody)\n * receiveMessage()\n\n非功能性\n\n\n# 高层抽象\n\n\n\n\n# 虚拟IP和负载均衡\n\n\n\n\n# 前端服务\n\n\n\n\n# 元数据服务\n\n\n\n\n# 后端服务\n\n\n\n\n\n\n\n\n\n\n# 还有什么重要的？\n\n\n\n\n# 队列的创建与删除\n\n\n# 消息的删除\n\n\n# 总结\n\n",normalizedContent:"# 概述\n\n\n\n\n# 需求\n\n功能性\n\n * sendmessage(messagebody)\n * receivemessage()\n\n非功能性\n\n\n# 高层抽象\n\n\n\n\n# 虚拟ip和负载均衡\n\n\n\n\n# 前端服务\n\n\n\n\n# 元数据服务\n\n\n\n\n# 后端服务\n\n\n\n\n\n\n\n\n\n\n# 还有什么重要的？\n\n\n\n\n# 队列的创建与删除\n\n\n# 消息的删除\n\n\n# 总结\n\n",charsets:{cjk:!0},lastUpdated:"2024/09/14, 08:54:46",lastUpdatedTimestamp:1726304086e3},{title:"README",frontmatter:{title:"README",date:"2024-09-14T02:09:39.000Z",permalink:"/pages/3c1db5/"},regularPath:"/04.%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/",relativePath:"04.设计基础设施/README.md",key:"v-4985a9a2",path:"/pages/3c1db5/",headersStr:null,content:"# 介绍",normalizedContent:"# 介绍",charsets:{cjk:!0},lastUpdated:"2024/09/14, 08:54:46",lastUpdatedTimestamp:1726304086e3},{title:"服务通知",frontmatter:{title:"服务通知",date:"2024-09-14T16:43:28.000Z",permalink:"/pages/8416e6/"},regularPath:"/04.%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/01.%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD/05.%E8%AE%A2%E9%98%85%E5%8F%91%E5%B8%83.html",relativePath:"04.设计基础设施/01.基础设施/05.订阅发布.md",key:"v-15eefc95",path:"/pages/8416e6/",headers:[{level:2,title:"需求",slug:"需求",normalizedTitle:"需求",charIndex:2},{level:2,title:"高层架构",slug:"高层架构",normalizedTitle:"高层架构",charIndex:142},{level:2,title:"客户端主机",slug:"客户端主机",normalizedTitle:"客户端主机",charIndex:153}],headersStr:"需求 高层架构 客户端主机",content:"# 需求\n\n功能性\n\n * createTopic(topicname)\n * publish(topicName,message)\n * subscribe(topicName,endpoint)\n\n非功能性\n\n * 高可扩展性\n * 高可用性\n * 高性能\n * 持久性\n\n\n# 高层架构\n\n\n\n\n# 客户端主机",normalizedContent:"# 需求\n\n功能性\n\n * createtopic(topicname)\n * publish(topicname,message)\n * subscribe(topicname,endpoint)\n\n非功能性\n\n * 高可扩展性\n * 高可用性\n * 高性能\n * 持久性\n\n\n# 高层架构\n\n\n\n\n# 客户端主机",charsets:{cjk:!0},lastUpdated:"2024/09/14, 08:54:46",lastUpdatedTimestamp:1726304086e3},{title:"README",frontmatter:{title:"README",date:"2024-09-14T02:09:48.000Z",permalink:"/pages/92b2ee/"},regularPath:"/05.%E9%97%AE%E7%AD%94/",relativePath:"05.问答/README.md",key:"v-0b0ed22c",path:"/pages/92b2ee/",headersStr:null,content:"# 介绍",normalizedContent:"# 介绍",charsets:{cjk:!0},lastUpdated:"2024/09/14, 08:54:46",lastUpdatedTimestamp:1726304086e3},{title:"README",frontmatter:{title:"README",date:"2024-09-14T02:09:52.000Z",permalink:"/pages/9b3c80/"},regularPath:"/06.%E5%8A%A8%E6%80%81/",relativePath:"06.动态/README.md",key:"v-551313d7",path:"/pages/9b3c80/",headersStr:null,content:"# 介绍\n\n我每天的工作：\n\n 1. 打开图床 picgo\n 2. 在正确的路径下开始写文章\n 3. 技术调研\n 4. 总结所有问题\n 5. 睡觉",normalizedContent:"# 介绍\n\n我每天的工作：\n\n 1. 打开图床 picgo\n 2. 在正确的路径下开始写文章\n 3. 技术调研\n 4. 总结所有问题\n 5. 睡觉",charsets:{cjk:!0},lastUpdated:"2024/09/14, 08:54:46",lastUpdatedTimestamp:1726304086e3},{title:"博客文章",frontmatter:{archivesPage:!0,title:"博客文章",permalink:"/blog/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-61d0fb85",path:"/blog/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/09/13, 19:57:43",lastUpdatedTimestamp:1726257463e3},{title:"首页",frontmatter:{home:!0,title:"首页",heroImage:"/img/hero.png",heroText:"Echo 系统设计之美",tagline:"🚀将系统设计技能提升到一个新水平所需的一切🚀",actionText:"开始使用 →",actionLink:"/pages/3c1db5/",bannerBg:"none",features:[{title:"设计基础设施",details:"你可以跟随我一起去设计后端核心基础设施，并深入了解其原理"},{title:"设计热门应用",details:"你可以跟随我一起去设计当下最热门的应用，并深入了解其原理"},{title:"系统设计算法",details:"你可以在这里充分了解我们后端开发所必备的系统设计算法，算法是必需品"},{title:"设计理论",details:"对系统设计的相关概念理论进行详细讲解，良药苦口"},{title:"问答归档",details:"对系统设计的常见问题进行汇总、归档，定期对所有常见问题进行归档"},{title:"学习路线",details:"记录一些比较优质的学习方法与路线，别走弯路"}],postList:"none"},regularPath:"/",relativePath:"index.md",key:"v-a11d1cc4",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2024/09/13, 19:57:43",lastUpdatedTimestamp:1726257463e3}],themeConfig:{pageButton:!1,nav:[{text:"首页",link:"/"},{text:"设计基础设施",link:"/pages/3c1db5/"},{text:"设计热门应用",link:"/pages/6e86ba/"},{text:"场景设计",link:"/pages/a027c2/"},{text:"系统设计算法",link:"/pages/73ef48/"},{text:"问答归档",link:"/pages/92b2ee/"},{text:"网站动态",link:"/pages/9b3c80/"}],sidebarDepth:2,logo:"/img/logo.png",repo:"echo-lxy/echo-system-design",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",sidebar:{"/01.系统设计算法/":[{title:"系统设计算法",collapsable:!1,children:[["01.系统设计算法/01.布隆过滤.md","布隆过滤","/pages/fccd91/"],["01.系统设计算法/02.一致性哈希.md","一致性哈希","/pages/1e28a2/"],["01.系统设计算法/03.Count-Min Sketch.md","Count-Min Sketch","/pages/8624c5"],["01.系统设计算法/04.LRU.md","LRU 算法","/pages/87589a"],["01.系统设计算法/05.LFU.md","LFU","/pages/7d22be/"],["01.系统设计算法/06.渐进式 hash.md","渐进式 hash","/pages/2d43d1/"]]}],catalogue:{},"/02.设计热门应用/":[{title:"社交类",collapsable:!1,children:[["01.社交类/01.设计 微信.md","设计 微信","/pages/a95d7d/"],["01.社交类/02.设计Twitter.md","设计Twitter","/pages/90ad66/"]]}],"/03.场景设计/":[{title:"热门场景设计",collapsable:!1,children:[["01.热门场景设计/01.双写一致性.md","双写一致性","/pages/def08a/"],["01.热门场景设计/02.缓存穿透.md","缓存穿透","/pages/1e9e8e/"],["01.热门场景设计/03.缓存击穿.md","缓存击穿","/pages/1d96b2/"],["01.热门场景设计/04.任务补偿.md","任务补偿","/pages/24abe0/"],["01.热门场景设计/05.秒杀.md","秒杀","/pages/a72629/"],["01.热门场景设计/06.海量数据计数.md","海量数据计数","/pages/f3295f/"],["01.热门场景设计/07.多级缓存.md","多级缓存","/pages/51aa8b/"],["01.热门场景设计/08.超时&重试.md","超时&重试","/pages/0dfb49/"],["01.热门场景设计/09.幂等&防重.md","幂等&防重","/pages/4fc8cb/"]]}],"/04.设计基础设施/":[{title:"基础设施",collapsable:!1,children:[["01.基础设施/01.分布式缓存.md","分布式缓存","/pages/84cb49/"],["01.基础设施/02.限流器.md","限流器","/pages/57d5a5/"],["01.基础设施/03.热点探查（Top k）.md","热点探查（Top k）","/pages/5dcb6b/"],["01.基础设施/04.消息队列.md","消息队列","/pages/567090/"],["01.基础设施/05.订阅发布.md","服务通知","/pages/8416e6/"]]}]},updateBar:{showToArticle:!1},pageStyle:"line",category:!1,tag:!1,author:{name:"echo",href:"https://gitee.com/brother-one"},social:{icons:[{iconClass:"icon-youjian",title:"发邮件",link:"mailto:lixinyang2002@163.com"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/echo-lxy"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/playlist?id=755597173"}]},footer:{createYear:2024,copyrightInfo:"Xinyang Li | MIT License"},htmlModules:{pageT:'\n    <div class="wwads-cn wwads-horizontal page-wwads" data-id="136"></div>\n    <style>\n      .page-wwads{\n        width:100%!important;\n        min-height: 0;\n        margin: 0;\n      }\n      .page-wwads .wwads-img img{\n        width:80px!important;\n      }\n      .page-wwads .wwads-poweredby{\n        width: 40px;\n        position: absolute;\n        right: 25px;\n        bottom: 3px;\n      }\n      .wwads-content .wwads-text, .page-wwads .wwads-text{\n        height: 100%;\n        padding-top: 5px;\n        display: block;\n      }\n  </style>\n  '}}};var Tc=t(95),Rc=t(96),Sc=t(11);var Oc={computed:{$filterPosts(){return this.$site.pages.filter(e=>{const{frontmatter:{pageComponent:n,article:t,home:r}}=e;return!(n||!1===t||!0===r)})},$sortPosts(){return(e=this.$filterPosts).sort((e,n)=>{const t=e.frontmatter.sticky,r=n.frontmatter.sticky;return t&&r?t==r?Object(Sc.a)(e,n):t-r:t&&!r?-1:!t&&r?1:Object(Sc.a)(e,n)}),e;var e},$sortPostsByDate(){return(e=this.$filterPosts).sort((e,n)=>Object(Sc.a)(e,n)),e;var e},$groupPosts(){return function(e){const n={},t={};for(let r=0,i=e.length;r<i;r++){const{frontmatter:{categories:i,tags:o}}=e[r];"array"===Object(Sc.n)(i)&&i.forEach(t=>{t&&(n[t]||(n[t]=[]),n[t].push(e[r]))}),"array"===Object(Sc.n)(o)&&o.forEach(n=>{n&&(t[n]||(t[n]=[]),t[n].push(e[r]))})}return{categories:n,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(e){const n=[],t=[];for(let t in e.categories)n.push({key:t,length:e.categories[t].length});for(let n in e.tags)t.push({key:n,length:e.tags[n].length});return{categories:n,tags:t}}(this.$groupPosts)}}};Xt.component(Tc.default),Xt.component(Rc.default);function jc(e){return e.toString().padStart(2,"0")}t(245);Xt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,366))),Xt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,95))),Xt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,96)));t(246);var Uc=[({Vue:e,options:n,router:t,siteData:r,isServer:i})=>{i||t.afterEach(()=>{var e;e=function(){setTimeout((function(){void 0===window._AdBlockInit&&function(){const e=document.getElementsByClassName("wwads-cn"),n=document.querySelector(".wwads-content");e[0]&&!n&&(e[0].innerHTML=h)}()}),3e3)},"complete"===document.readyState||"interactive"===document.readyState?setTimeout(e,1):document.addEventListener("DOMContentLoaded",e),setTimeout(()=>{const e=document.querySelector(".page-wwads");if(!e)return;const n=e.querySelector(".wwads-hide");n&&(n.onclick=()=>{e.style.display="none"}),"none"===e.style.display&&(e.style.display="flex")},900)})},({Vue:e,options:n,router:t,siteData:r})=>{r.pages.map(e=>{const{frontmatter:{date:n,author:t}}=e;"string"==typeof n&&"Z"===n.charAt(n.length-1)&&(e.frontmatter.date=function(e){e instanceof Date||(e=new Date(e));return`${e.getUTCFullYear()}-${jc(e.getUTCMonth()+1)}-${jc(e.getUTCDate())} ${jc(e.getUTCHours())}:${jc(e.getUTCMinutes())}:${jc(e.getUTCSeconds())}`}(n)),t?e.author=t:r.themeConfig.author&&(e.author=r.themeConfig.author)}),e.mixin(Oc)},{},({Vue:e})=>{e.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:e})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?01293bffa6c3962016c08ba685c79d78";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(e,n)}(),e.afterEach((function(e){_hmt.push(["_trackPageview",e.fullPath])})))}],Ic=[];class zc extends class{constructor(){this.store=new Xt({data:{state:{}}})}$get(e){return this.store.state[e]}$set(e,n){Xt.set(this.store.state,e,n)}$emit(...e){this.store.$emit(...e)}$on(...e){this.store.$on(...e)}}{}Object.assign(zc.prototype,{getPageAsyncComponent:cs,getLayoutAsyncComponent:ls,getAsyncComponent:us,getVueComponent:ds});var Pc={install(e){const n=new zc;e.$vuepress=n,e.prototype.$vuepress=n}};function Bc(e,n){const t=n.toLowerCase();return e.options.routes.some(e=>e.path.toLowerCase()===t)}var $c={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(e){const n=this.pageKey||this.$parent.$page.key;return ps("pageKey",n),Xt.component(n)||Xt.component(n,cs(n)),Xt.component(n)?e(n):e("")}},Mc={functional:!0,props:{slotKey:String,required:!0},render:(e,{props:n,slots:t})=>e("div",{class:["content__"+n.slotKey]},t()[n.slotKey])},Fc={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Dc=(t(247),t(248),Object(Os.a)(Fc,(function(){var e=this._self._c;return e("span",[e("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[e("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),e("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),e("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Nc={functional:!0,render(e,{parent:n,children:t}){if(n._isMounted)return t;n.$once("hook:mounted",()=>{n.$forceUpdate()})}};Xt.config.productionTip=!1,Xt.use(Va),Xt.use(Pc),Xt.mixin(function(e,n,t=Xt){!function(e){e.locales&&Object.keys(e.locales).forEach(n=>{e.locales[n].path=n});Object.freeze(e)}(n),t.$vuepress.$set("siteData",n);const r=new(e(t.$vuepress.$get("siteData"))),i=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(r)),o={};return Object.keys(i).reduce((e,n)=>(n.startsWith("$")&&(e[n]=i[n].get),e),o),{computed:o}}(e=>class{setPage(e){this.__page=e}get $site(){return e}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:e={}}=this.$site;let n,t;for(const r in e)"/"===r?t=e[r]:0===this.$page.path.indexOf(r)&&(n=e[r]);return n||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:e}=this.$page.frontmatter;return"string"==typeof e&&e}get $title(){const e=this.$page,{metaTitle:n}=this.$page.frontmatter;if("string"==typeof n)return n;const t=this.$siteTitle,r=e.frontmatter.home?null:e.frontmatter.title||e.title;return t?r?r+" | "+t:t:r||"VuePress"}get $description(){const e=function(e){if(e){const n=e.filter(e=>"description"===e.name)[0];if(n)return n.content}}(this.$page.frontmatter.meta);return e||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(e,n){for(let t=0;t<e.length;t++){const r=e[t];if(r.path.toLowerCase()===n.toLowerCase())return r}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},Lc)),Xt.component("Content",$c),Xt.component("ContentSlotsDistributor",Mc),Xt.component("OutboundLink",Dc),Xt.component("ClientOnly",Nc),Xt.component("Layout",ls("Layout")),Xt.component("NotFound",ls("NotFound")),Xt.prototype.$withBase=function(e){const n=this.$site.base;return"/"===e.charAt(0)?n+e.slice(1):e},window.__VUEPRESS__={version:"1.9.9",hash:"3b0bd5a"},async function(e){const n="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:Lc.routerBase||Lc.base,t=new Va({base:n,mode:"history",fallback:!1,routes:Cc,scrollBehavior:(e,n,t)=>t||(e.hash?!Xt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(e.hash)}:{x:0,y:0})});!function(e){e.beforeEach((n,t,r)=>{if(Bc(e,n.path))r();else if(/(\/|\.html)$/.test(n.path))if(/\/$/.test(n.path)){const t=n.path.replace(/\/$/,"")+".html";Bc(e,t)?r(t):r()}else r();else{const t=n.path+"/",i=n.path+".html";Bc(e,i)?r(i):Bc(e,t)?r(t):r()}})}(t);const r={};try{await Promise.all(Uc.filter(e=>"function"==typeof e).map(n=>n({Vue:Xt,options:r,router:t,siteData:Lc,isServer:e})))}catch(e){console.error(e)}return{app:new Xt(Object.assign(r,{router:t,render:e=>e("div",{attrs:{id:"app"}},[e("RouterView",{ref:"layout"}),e("div",{class:"global-ui"},Ic.map(n=>e(n)))])})),router:t}}(!1).then(({app:e,router:n})=>{n.onReady(()=>{e.$mount("#app")})})}]);