(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{379:function(e,o,r){"use strict";r.r(o);var t=r(4),n=Object(t.a)({},(function(){var e=this,o=e._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h2",{attrs:{id:"简约图"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#简约图"}},[e._v("#")]),e._v(" 简约图")]),e._v(" "),o("p",[e._v("Netty 的设计主要基于主从 Reactor 多线程模式，并做了一定的改进")]),e._v(" "),o("p",[e._v("简单版本的 Netty 的模样如下：")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409182102744.png",alt:"img"}})]),e._v(" "),o("p",[e._v("解释如下：")]),e._v(" "),o("ol",[o("li",[e._v("BossGroup 线程维护 Selector，ServerSocketChannel 注册到这个 Selector 上，只关注连接建立请求事件（相当于主 Reactor）")]),e._v(" "),o("li",[e._v("当接收到来自客户端的连接建立请求事件的时候，通过 ServerSocketChannel.accept 方法获得对应的 SocketChannel，并封装成 NioSocketChannel 注册到 WorkerGroup 线程中的 Selector，每个 Selector 运行在一个线程中（相当于从 Reactor）")]),e._v(" "),o("li",[e._v("当 WorkerGroup 线程中的 Selector 监听到自己感兴趣的 IO 事件后，就调用 Handler 进行处理")])]),e._v(" "),o("h2",{attrs:{id:"二级图"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#二级图"}},[e._v("#")]),e._v(" 二级图")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409182104860.png",alt:"img"}})]),e._v(" "),o("ol",[o("li",[e._v("有两组线程池：BossGroup 和 WorkerGroup，BossGroup 中的线程（可以有多个，图中只画了一个）专门负责和客户端建立连接，WorkerGroup 中的线程专门负责处理连接上的读写")]),e._v(" "),o("li",[e._v("BossGroup 和 WorkerGroup 含有多个不断循环的执行事件处理的线程，每个线程都包含一个 Selector，用于监听注册在其上的 Channel")]),e._v(" "),o("li",[e._v("每个 BossGroup 中的线程循环执行以下三个步骤：\n"),o("ol",[o("li",[e._v("轮训注册在其上的 ServerSocketChannel 的 accept 事件（OP_ACCEPT 事件）")]),e._v(" "),o("li",[e._v("处理 accept 事件，与客户端建立连接，生成一个 NioSocketChannel，并将其注册到 WorkerGroup 中某个线程上的 Selector 上")]),e._v(" "),o("li",[e._v("再去以此循环处理任务队列中的下一个事件")])])]),e._v(" "),o("li",[e._v("每个 WorkerGroup 中的线程循环执行以下三个步骤：\n"),o("ol",[o("li",[e._v("轮训注册在其上的 NioSocketChannel 的 read/write 事件（OP_READ/OP_WRITE 事件）")]),e._v(" "),o("li",[e._v("在对应的 NioSocketChannel 上处理 read/write 事件")]),e._v(" "),o("li",[e._v("再去以此循环处理任务队列中的下一个事件")])])])]),e._v(" "),o("h2",{attrs:{id:"终极图"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#终极图"}},[e._v("#")]),e._v(" 终极图")]),e._v(" "),o("p",[o("img",{attrs:{src:"https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409182105437.png",alt:"img"}})]),e._v(" "),o("ol",[o("li",[e._v("Netty 抽象出两组线程池：BossGroup 和 WorkerGroup，也可以叫做 BossNioEventLoopGroup 和 WorkerNioEventLoopGroup。每个线程池中都有 NioEventLoop 线程。BossGroup 中的线程专门负责和客户端建立连接，WorkerGroup 中的线程专门负责处理连接上的读写。BossGroup 和 WorkerGroup 的类型都是 NioEventLoopGroup。")]),e._v(" "),o("li",[e._v("NioEventLoopGroup 相当于一个事件循环组，这个组中含有多个事件循环，每个事件循环就是一个 NioEventLoop")]),e._v(" "),o("li",[e._v("NioEventLoop 表示一个不断循环的执行事件处理的线程，每个 NioEventLoop 都包含一个 Selector，用于监听注册在其上的 Socket 网络连接（Channel）")]),e._v(" "),o("li",[e._v("NioEventLoopGroup 可以含有多个线程，即可以含有多个 NioEventLoop")]),e._v(" "),o("li",[e._v("每个 BossNioEventLoop 中循环执行以下三个步骤\n"),o("ol",[o("li",[o("strong",[e._v("select")]),e._v("：轮训注册在其上的 ServerSocketChannel 的 accept 事件（OP_ACCEPT 事件）")]),e._v(" "),o("li",[o("strong",[e._v("processSelectedKeys")]),e._v("：处理 accept 事件，与客户端建立连接，生成一个 NioSocketChannel，并将其注册到某个 WorkerNioEventLoop 上的 Selector 上")]),e._v(" "),o("li",[o("strong",[e._v("runAllTasks")]),e._v("：再去以此循环处理任务队列中的其他任务")])])]),e._v(" "),o("li",[e._v("每个 WorkerNioEventLoop 中循环执行以下三个步骤：\n"),o("ol",[o("li",[o("strong",[e._v("select")]),e._v("：轮训注册在其上的 NioSocketChannel 的 read/write 事件（OP_READ/OP_WRITE 事件）")]),e._v(" "),o("li",[o("strong",[e._v("processSelectedKeys")]),e._v("：在对应的 NioSocketChannel 上处理 read/write 事件")]),e._v(" "),o("li",[o("strong",[e._v("runAllTasks")]),e._v("：再去以此循环处理任务队列中的其他任务")])])]),e._v(" "),o("li",[e._v("在以上两个"),o("strong",[e._v("processSelectedKeys")]),e._v("步骤中，会使用 Pipeline（管道），Pipeline 中引用了 Channel，即通过 Pipeline 可以获取到对应的 Channel，Pipeline 中维护了很多的处理器（拦截处理器、过滤处理器、自定义处理器等）。这里暂时不详细展开讲解 Pipeline。")])])])}),[],!1,null,null,null);o.default=n.exports}}]);