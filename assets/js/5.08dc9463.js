(window.webpackJsonp=window.webpackJsonp||[]).push([[5],{340:function(s,v,_){"use strict";_.r(v);var t=_(4),a=Object(t.a)({},(function(){var s=this,v=s._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[v("h2",{attrs:{id:"前言"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[s._v("#")]),s._v(" 前言")]),s._v(" "),v("p",[s._v("布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是 "),v("strong",[s._v("一个很长的二进制向量")]),s._v(" 和 "),v("strong",[s._v("一系列随机映射函数")]),s._v("。布隆过滤器可以用于 "),v("strong",[s._v("检索一个元素是否在一个集合中")]),s._v("。")]),s._v(" "),v("p",[s._v("如果还是不太好理解的话，就可以把布隆过滤器理解为一个 "),v("code",[s._v("set")]),s._v(" 集合，我们可以通过 "),v("code",[s._v("add")]),s._v(" 往里面添加元素，通过 "),v("code",[s._v("contains")]),s._v(" 来判断是否包含某个元素")]),s._v(" "),v("h3",{attrs:{id:"优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点"}},[s._v("#")]),s._v(" 优点")]),s._v(" "),v("ul",[v("li",[v("strong",[s._v("时间复杂度低")]),s._v("，增加和查询元素的时间复杂为 O(N)，（N 为哈希函数的个数，通常情况比较小）")]),s._v(" "),v("li",[v("strong",[s._v("保密性强")]),s._v("，布隆过滤器不存储元素本身")]),s._v(" "),v("li",[v("strong",[s._v("存储空间小")]),s._v("，如果允许存在一定的误判，布隆过滤器是非常节省空间的（相比其他数据结构如Set集合）")])]),s._v(" "),v("h3",{attrs:{id:"缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点"}},[s._v("#")]),s._v(" 缺点")]),s._v(" "),v("ul",[v("li",[s._v("有点一定的"),v("strong",[s._v("误判率")]),s._v("，但是可以通过调整参数来降低")]),s._v(" "),v("li",[v("strong",[s._v("无法获取元素本身")])]),s._v(" "),v("li",[s._v("很"),v("strong",[s._v("难删除")]),s._v("元素")])]),s._v(" "),v("h3",{attrs:{id:"使用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#使用场景"}},[s._v("#")]),s._v(" 使用场景")]),s._v(" "),v("p",[s._v("布隆过滤器可以告诉我们 “某样东西"),v("strong",[s._v("一定不存在或者可能存在")]),s._v("”，也就是说布隆过滤器说这个数"),v("strong",[s._v("不存在则一定不存")]),s._v("，布隆过滤器说这个数"),v("strong",[s._v("存在则可能不存在")]),s._v("（误判，后续会讲），利用这个判断是否存在的特点可以做很多有趣的事情。")]),s._v(" "),v("ul",[v("li",[s._v("解决 Redis 缓存穿透问题（面试重点）")]),s._v(" "),v("li",[s._v("邮件过滤，使用布隆过滤器来做邮件黑名单过滤")]),s._v(" "),v("li",[s._v("对爬虫网址进行过滤，爬过的不再爬")]),s._v(" "),v("li",[s._v("解决新闻推荐过的不再推荐(类似抖音刷过的往下滑动不再刷到)")]),s._v(" "),v("li",[s._v("HBase RocksDB LevelDB 等数据库内置布隆过滤器，用于判断数据是否存在，可以减少数据库的IO请求")])]),s._v(" "),v("h2",{attrs:{id:"布隆过滤器的原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#布隆过滤器的原理"}},[s._v("#")]),s._v(" 布隆过滤器的原理")]),s._v(" "),v("h3",{attrs:{id:"数据结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[s._v("#")]),s._v(" 数据结构")]),s._v(" "),v("p",[s._v("布隆过滤器它实际上是 "),v("strong",[s._v("一个很长的二进制向量")]),s._v(" 和 "),v("strong",[s._v("一系列随机映射函数")]),s._v("。以Redis中的布隆过滤器实现为例，Redis 中的布隆过滤器底层是一个大型位数组（二进制数组）+多个无偏hash函数。")]),s._v(" "),v("p",[v("img",{attrs:{src:"https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141132367.png",alt:"img"}})]),s._v(" "),v("p",[s._v("多个无偏hash函数")]),s._v(" "),v("p",[s._v("无偏hash函数就是能把元素的hash值计算的 "),v("strong",[s._v("比较均匀")]),s._v(" 的hash函数，能使得计算后的元素下标比较均匀的映射到位数组中。能有效减少误差。")]),s._v(" "),v("p",[s._v("如下就是一个简单的布隆过滤器示意图，其中 k1、k2 代表增加的元素，a、b、c即为无偏hash函数，最下层则为二进制数组。")]),s._v(" "),v("p",[v("img",{attrs:{src:"https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141132401.png",alt:"img"}})]),s._v(" "),v("h3",{attrs:{id:"空间计算"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#空间计算"}},[s._v("#")]),s._v(" 空间计算")]),s._v(" "),v("p",[s._v("在布隆过滤器增加元素之前，首先需要初始化布隆过滤器的空间，也就是上面说的二进制数组，除此之外还需要计算无偏hash函数的个数。")]),s._v(" "),v("p",[s._v("布隆过滤器提供了两个参数，分别是预计加入元素的大小 n，运行的错误率 p。")]),s._v(" "),v("p",[s._v("布隆过滤器中有算法根据这两个参数会计算出二进制数组的大小 m，以及无偏hash函数的个数 k。")]),s._v(" "),v("p",[s._v("它们之间的关系比较简单：")]),s._v(" "),v("p",[s._v("如下地址是一个免费的在线布隆过滤器在线计算的网址：")]),s._v(" "),v("blockquote",[v("p",[s._v("https://krisives.github.io/bloom-calculator/")])]),s._v(" "),v("p",[v("img",{attrs:{src:"https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141132411.png",alt:"img"}})]),s._v(" "),v("h3",{attrs:{id:"增加元素"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#增加元素"}},[s._v("#")]),s._v(" 增加元素")]),s._v(" "),v("p",[s._v("往布隆过滤器增加元素，添加的key需要根据"),v("code",[s._v("k")]),s._v("个无偏hash函数计算得到多个hash值，然后对数组长度进行取模得到数组下标的位置，然后将对应数组下标的位置的值置为1")]),s._v(" "),v("ul",[v("li",[s._v("通过k个无偏hash函数计算得到k个hash值")]),s._v(" "),v("li",[s._v("依次取模数组长度，得到数组索引")]),s._v(" "),v("li",[s._v("将计算得到的数组索引下标位置数据修改为1")])]),s._v(" "),v("p",[s._v("例如，"),v("code",[s._v("key = Liziba")]),s._v("，无偏"),v("code",[s._v("hash")]),s._v("函数的个数"),v("code",[s._v("k=3")]),s._v("，分别为hash1、hash2、hash3。三个hash函数计算后得到三个数组下标值，并将其值修改为1.")]),s._v(" "),v("p",[s._v("如图所示")]),s._v(" "),v("p",[v("img",{attrs:{src:"https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409141132392.png",alt:"img"}})]),s._v(" "),v("h3",{attrs:{id:"查询元素"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#查询元素"}},[s._v("#")]),s._v(" 查询元素")]),s._v(" "),v("p",[s._v("布隆过滤器最大的用处就在于判断某样东西一定不存在或者可能存在，而这个就是查询元素的结果。其查询元素的过程如下：")]),s._v(" "),v("ul",[v("li",[s._v("通过 k 个无偏hash函数计算得到 k 个hash值")]),s._v(" "),v("li",[s._v("依次取模数组长度，得到数组索引")]),s._v(" "),v("li",[s._v("判断索引处的值是否全部为 1，如果全部为 1 则存在（这种存在可能是误判），如果存在一个 0 则必定不存在")])]),s._v(" "),v("p",[s._v("关于误判，其实非常好理解，hash函数再怎么牛逼，也无法完全避免hash冲突，也就是说可能会存在多个元素计算的hash值是相同的，那么它们取模数组长度后的到的数组索引也是相同的，这就是误判的原因。例如李子捌和李子柒的hash值取模后得到的数组索引都是1，但其实这里只有李子捌，如果此时判断李子柒在不在这里，误判就出现啦！因此布隆过滤器最大的缺点误判只要知道其判断元素是否存在的原理就很容易明白了！")]),s._v(" "),v("h3",{attrs:{id:"修改元素"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#修改元素"}},[s._v("#")]),s._v(" 修改元素")]),s._v(" "),v("p",[s._v("不允许修改")]),s._v(" "),v("h3",{attrs:{id:"删除元素"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#删除元素"}},[s._v("#")]),s._v(" 删除元素")]),s._v(" "),v("p",[s._v("布隆过滤器对元素的删除不太支持，目前有一些变形的特定布隆过滤器支持元素的删除！关于为什么对删除不太支持，其实也非常好理解，hash冲突必然存在，删除肯定是很苦难的！你将 A 的数组下标置为 0，那可能 B 也为受到影响")]),s._v(" "),v("h2",{attrs:{id:"redis-中的-布隆过滤器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis-中的-布隆过滤器"}},[s._v("#")]),s._v(" Redis 中的 布隆过滤器")]),s._v(" "),v("h2",{attrs:{id:"参考文献"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[s._v("#")]),s._v(" 参考文献")]),s._v(" "),v("p",[v("a",{attrs:{href:"https://blog.csdn.net/qq_41125219/article/details/119982158",target:"_blank",rel:"noopener noreferrer"}},[s._v("布隆(Bloom Filter)过滤器——全面讲解，建议收藏-CSDN博客"),v("OutboundLink")],1)])])}),[],!1,null,null,null);v.default=a.exports}}]);