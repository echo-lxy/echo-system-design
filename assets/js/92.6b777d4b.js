(window.webpackJsonp=window.webpackJsonp||[]).push([[92],{429:function(t,s,a){"use strict";a.r(s);var e=a(4),r=Object(e.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h2",{attrs:{id:"前言-补偿机制的意义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#前言-补偿机制的意义"}},[t._v("#")]),t._v(" 前言：补偿机制的意义？")]),t._v(" "),s("p",[t._v("以电商的购物场景为例：")]),t._v(" "),s("p",[t._v("客户端 ----\x3e购物车"),s("a",{attrs:{href:"https://zhida.zhihu.com/search?q=%E5%BE%AE%E6%9C%8D%E5%8A%A1&zhida_source=entity&is_preview=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("微服务"),s("OutboundLink")],1),t._v(" ----\x3e订单微服务 ----\x3e 支付微服务。")]),t._v(" "),s("p",[t._v("这种调用链非常普遍。")]),t._v(" "),s("p",[t._v("那么为什么需要考虑"),s("a",{attrs:{href:"https://zhida.zhihu.com/search?q=%E8%A1%A5%E5%81%BF%E6%9C%BA%E5%88%B6&zhida_source=entity&is_preview=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("补偿机制"),s("OutboundLink")],1),t._v("呢？")]),t._v(" "),s("p",[t._v("正如之前几篇文章所说，一次跨机器的通信可能会经过DNS 服务，网卡、交换机、路由器、"),s("a",{attrs:{href:"https://zhida.zhihu.com/search?q=%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1&zhida_source=entity&is_preview=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("负载均衡"),s("OutboundLink")],1),t._v("等设备，这些设备都不一定是一直稳定的，在数据传输的整个过程中，只要任意一个环节出错，都会导致问题的产生。")]),t._v(" "),s("p",[t._v("而在分布式场景中，一个完整的业务又是由多次跨机器通信组成的，所以产生问题的概率成倍数增加。")]),t._v(" "),s("p",[t._v("但是，这些问题并不完全代表真正的系统无法处理请求，所以我们应当尽可能的自动消化掉这些异常。")]),t._v(" "),s("p",[t._v("可能你会问，之前也看到过「补偿」和「事务补偿」或者「重试」，它们之间的关系是什么？")]),t._v(" "),s("p",[t._v("你其实可以不用太纠结这些名字，从目的来说都是一样的。"),s("strong",[t._v("就是一旦某个操作发生了异常，如何通过内部机制将这个异常产生的「不一致」状态消除掉")]),t._v("。")]),t._v(" "),s("blockquote",[s("p",[t._v("在 echo 看来，不管用什么方式，只要通过额外的方式解决了问题都可以理解为是「补偿」，所以「事务补偿」和「重试」都是「补偿」的子集。前者是一个逆向操作，而后者则是一个正向操作。")])]),t._v(" "),s("p",[t._v("只是从结果来看，两者的意义不同。「事务补偿」意味着“放弃”，当前操作必然会失败。")]),t._v(" "),s("p",[s("strong",[t._v("事务补偿")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409142016174.webp",alt:"img"}})]),t._v(" "),s("p",[t._v("「重试」则还有处理成功的机会。这两种方式分别适用于不同的场景。")]),t._v(" "),s("p",[s("strong",[t._v("重试")])]),t._v(" "),s("p",[s("img",{attrs:{src:"https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409142017049.webp",alt:"img"}})]),t._v(" "),s("p",[t._v("因为「补偿」已经是一个额外流程了，既然能够走这个额外流程，说明时效性并不是第一考虑的因素，所以做补偿的核心要点是："),s("strong",[t._v("宁可慢，不可错")]),t._v("。")]),t._v(" "),s("p",[t._v("因此，不要草率的就确定了补偿的实施方案，需要谨慎的评估。虽说错误无法100%避免，但是抱着这样的一个心态或多或少可以减少一些错误的发生。")]),t._v(" "),s("h2",{attrs:{id:"补偿-该怎么做"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#补偿-该怎么做"}},[t._v("#")]),t._v(" 补偿 该怎么做？")]),t._v(" "),s("p",[t._v("做「补偿」的主流方式就前面提到的「事务补偿」和「重试」，以下会被称作「回滚」和「重试」。")]),t._v(" "),s("p",[t._v("我们先来聊聊「回滚」。相比「重试」，它逻辑上更简单一些。")]),t._v(" "),s("h3",{attrs:{id:"回滚"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#回滚"}},[t._v("#")]),t._v(" 回滚")]),t._v(" "),s("p",[t._v("echo 将回滚分为2种模式，一种叫「显式回滚」（调用逆向接口），一种叫「隐式回滚」（无需调用逆向接口）。")]),t._v(" "),s("p",[t._v("最常见的就是「显式回滚」。这个方案无非就是做2个事情：")]),t._v(" "),s("p",[t._v("首先要确定失败的步骤和状态，从而确定需要回滚的范围。一个业务的流程，往往在设计之初就制定好了，所以确定回滚的范围比较容易。但这里唯一需要注意的一点就是："),s("strong",[t._v("如果在一个业务处理中涉及到的服务并不是都提供了「回滚接口」，那么在编排服务时应该把提供「回滚接口」的服务放在前面，这样当后面的工作服务错误时还有机会「回滚」")]),t._v("。")]),t._v(" "),s("p",[t._v("其次要能提供「回滚」操作使用到的业务数据。"),s("strong",[t._v("「回滚」时提供的数据越多，越有益于程序的健壮性")]),t._v("。因为程序可以在收到「回滚」操作的时候可以做业务的检查，比如检查账户是否相等，金额是否一致等等。")]),t._v(" "),s("p",[t._v("由于这个中间状态的数据结构和数据大小并不固定，所以echo建议你在实现这点的时候可以将相关的数据序列化成一个json，然后存放到一个nosql类型的存储中。")]),t._v(" "),s("p",[t._v("「隐式回滚」相对来说运用场景比较少。它意味着这个回滚动作你不需要进行额外处理，下游服务内部有类似“预占”并且“超时失效”的机制的。例如：")]),t._v(" "),s("p",[t._v("电商场景中，会将订单中的商品先预占库存，等待用户在 15 分钟内支付。如果没有收到用户的支付，则释放库存。")]),t._v(" "),s("p",[t._v("下面聊聊可以有很多玩法，也更容易陷入坑里的「重试」。")]),t._v(" "),s("h3",{attrs:{id:"重试"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重试"}},[t._v("#")]),t._v(" 重试")]),t._v(" "),s("p",[s("strong",[t._v("「重试」最大的好处在于，业务系统可以不需要提供「逆向接口」")]),t._v("，这是一个对长期开发成本特别大的利好，毕竟业务是天天在变的。所以，"),s("strong",[t._v("在可能的情况下，应该优先考虑使用「重试」。")])]),t._v(" "),s("p",[t._v("不过，相比「回滚」来说「重试」的适用场景更少一些，所以我们第一步首先要判断，当前场景是否适合「重试」。比如：")]),t._v(" "),s("ul",[s("li",[t._v("下游系统返回「请求超时」、「被限流中」等临时状态的时候，我们"),s("strong",[t._v("可以考虑重试")])]),t._v(" "),s("li",[t._v("而如果是返回“余额不足”、“无权限”等明确无法继续的业务性错误的时候就"),s("strong",[t._v("不需要重试")]),t._v("了")]),t._v(" "),s("li",[t._v("一些"),s("a",{attrs:{href:"https://zhida.zhihu.com/search?q=%E4%B8%AD%E9%97%B4%E4%BB%B6&zhida_source=entity&is_preview=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("中间件"),s("OutboundLink")],1),t._v("或者rpc框架中返回Http503、404等没有何时恢复的预期的时候，也"),s("strong",[t._v("不需要重试")])])]),t._v(" "),s("p",[t._v("如果确定要进行「重试」，我们还需要选定一个合适的「重试策略」。主流的「重试策略」主要是以下几种。")]),t._v(" "),s("p",[s("strong",[t._v("策略1.立即重试")]),t._v("。有时故障是候暂时性，可能是因网络数据包冲突或硬件组件流量高峰等事件造成的。在此情况下，适合立即重试操作。不过，立即重试次数不应超过一次，如果立即重试失败，应改用其它的策略。")]),t._v(" "),s("p",[s("strong",[t._v("策略2.固定间隔")]),t._v("。应用程序每次尝试的间隔时间相同。 这个好理解，例如，固定每 3 秒重试操作。（以下所有示例代码中的具体的数字仅供参考。）")]),t._v(" "),s("p",[t._v("策略1和策略2多用于前端系统的交互式操作中。")]),t._v(" "),s("p",[s("strong",[t._v("策略3.增量间隔")]),t._v("。每一次的重试间隔时间增量递增。比如，第一次0秒、第二次3秒、第三次6秒，9、12、15这样。")]),t._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("return (retryCount - 1) * incrementInterval;\n")])])]),s("p",[t._v("使得失败次数越多的重试请求优先级排到越后面，给新进入的重试请求让道。")]),t._v(" "),s("p",[s("strong",[t._v("策略4.指数间隔")]),t._v("。每一次的重试间隔呈指数级增加。和增量间隔“"),s("a",{attrs:{href:"https://zhida.zhihu.com/search?q=%E6%AE%8A%E9%80%94%E5%90%8C%E5%BD%92&zhida_source=entity&is_preview=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("殊途同归"),s("OutboundLink")],1),t._v("”，都是想让失败次数越多的重试请求优先级排到越后面，只不过这个方案的增长幅度更大一些。")]),t._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("return 2 ^ retryCount;\n")])])]),s("p",[s("strong",[t._v("策略5.全抖动")]),t._v("。在递增的基础上，增加"),s("a",{attrs:{href:"https://zhida.zhihu.com/search?q=%E9%9A%8F%E6%9C%BA%E6%80%A7&zhida_source=entity&is_preview=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("随机性"),s("OutboundLink")],1),t._v("（可以把其中的指数增长部分替换成增量增长。）。适用于将某一时刻集中产生的大量重试请求进行压力分散的场景。")]),t._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("return random(0 , 2 ^ retryCount);\n")])])]),s("p",[s("strong",[t._v("策略6.等抖动")]),t._v("。在「指数间隔」和「全抖动」之间寻求一个中庸的方案，降低随机性的作用。适用场景和「全抖动」一样。")]),t._v(" "),s("div",{staticClass:"language-text extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[t._v("var baseNum = 2 ^ retryCount;return baseNum + random(0 , baseNum);\n")])])]),s("p",[t._v("3、4、5、6策略的表现情况大致是这样。(x轴为重试次数)")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409142021804.webp",alt:"img"}})]),t._v(" "),s("p",[s("strong",[t._v("为什么说「重试」有坑呢？")])]),t._v(" "),s("p",[t._v("正如前面聊到的那样，出于对开发成本考虑，你在做「重试」的时候可能是复用的常规调用的接口。那么此时就不得不提一个「幂等性」问题。")]),t._v(" "),s("p",[t._v("如果实现「重试」选用的"),s("a",{attrs:{href:"https://zhida.zhihu.com/search?q=%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88&zhida_source=entity&is_preview=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("技术方案"),s("OutboundLink")],1),t._v("不能100%确保不会重复发起重试，那么「"),s("a",{attrs:{href:"https://zhida.zhihu.com/search?q=%E5%B9%82%E7%AD%89%E6%80%A7&zhida_source=entity&is_preview=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("幂等性"),s("OutboundLink")],1),t._v("」问题是一个必须要考虑的问题。哪怕技术方案可以确保100%不会重复发起重试，出于对意外情况的考量，尽量也考虑一下「幂等性」问题。")]),t._v(" "),s("p",[t._v("**幂等性：**不管对程序发起几次重复调用，程序表现的状态（所有相关的数据变化）与调用一次的结果是一致的话，就是保证了幂等性。")]),t._v(" "),s("p",[t._v("这意味着可以根据需要重复或重试操作，而不会导致意外的影响。对于非幂等操作，算法可能必须跟踪操作是否已经执行。")]),t._v(" "),s("p",[t._v("所以，"),s("strong",[t._v("一旦某个功能支持「重试」，那么整个链路上的接口都需要考虑幂等性问题")]),t._v("，"),s("strong",[t._v("不能因为服务的多次调用而导致业务数据的累计增加或减少。")])]),t._v(" "),s("p",[t._v("满足「幂等性」其实就是需要想办法识别重复的请求，并且将其过滤掉。思路就是：")]),t._v(" "),s("ol",[s("li",[t._v("给每个请求定义一个唯一标识。")]),t._v(" "),s("li",[t._v("在进行「重试」的时候判断这个请求是否已经被执行或者正在被执行，如果是则抛弃该请求。")])]),t._v(" "),s("p",[t._v("**第1点，**我们可以使用一个全局唯一id"),s("a",{attrs:{href:"https://zhida.zhihu.com/search?q=%E7%94%9F%E6%88%90%E5%99%A8&zhida_source=entity&is_preview=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("生成器"),s("OutboundLink")],1),t._v("或者生成服务（可以扩展阅读，"),s("a",{attrs:{href:"https://link.zhihu.com/?target=https%3A//www.cnblogs.com/Zachary-Fan/p/Global_Unique_No.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("分布式系统中的必备良药 —— 全局唯一单据号生成"),s("OutboundLink")],1),t._v("）。 或者简单粗暴一些，使用官方类库自带的Guid、uuid之类的也行。")]),t._v(" "),s("p",[t._v("然后通过"),s("a",{attrs:{href:"https://zhida.zhihu.com/search?q=rpc%E6%A1%86%E6%9E%B6&zhida_source=entity&is_preview=1",target:"_blank",rel:"noopener noreferrer"}},[t._v("rpc框架"),s("OutboundLink")],1),t._v("在发起调用的客户端中，对每个请求增加一个唯一标识的字段进行赋值。")]),t._v(" "),s("p",[t._v("**第2点，**我们可以在服务端通过Aop的方式切入到实际的处理逻辑代码之前和之后，一起配合做验证。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://echo798.oss-cn-shenzhen.aliyuncs.com/img/202409142022021.webp",alt:"img"}})]),t._v(" "),s("p",[t._v("大致的代码思路如下。")]),t._v(" "),s("div",{staticClass:"language-java extra-class"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("【方法执行前】"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("isExistLog")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("requestId"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//1.判断请求是否已被接收过。  对应序号3")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" lastResult "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("getLastResult")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//2.获取用于判断之前的请求是否已经处理完成。  对应序号4")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("lastResult "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("  \n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("var")]),t._v(" result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("waitResult")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//挂起等待处理完成")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" lastResult"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("  \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("else")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("requestId"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//3.记录该请求已接收")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//do something..【方法执行后】")]),t._v("\n\n"),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("logResult")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("requestId"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("//4.将结果也更新一下。")]),t._v("\n")])])]),s("p",[t._v("如果「补偿」这个工作是通过MQ来进行的话，这事就可以直接在对接MQ所封装的SDK中做。在生产端赋值全局唯一标识，在消费端通过唯一标识消重。")]),t._v(" "),s("h2",{attrs:{id:"重试-的最佳实践"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重试-的最佳实践"}},[t._v("#")]),t._v(" 重试 的最佳实践")]),t._v(" "),s("p",[t._v("再聊一些 echo 积累的最佳实践吧，都是针对「重试」的，的确这也是工作中最常用的方案。")]),t._v(" "),s("p",[t._v("「重试」特别适合在高负载情况下被「降级」，当然也应当受到「限流」和「熔断」机制的影响。当「重试」的“矛”与「限流」和「熔断」的“盾”搭配使用，效果才是最好。")]),t._v(" "),s("p",[t._v("需要衡量增加补偿机制的投入产出比。一些不是很重要的问题时，应该「快速失败」而不是「重试」。")]),t._v(" "),s("p",[t._v("过度积极的重试策略（例如间隔太短或重试次数过多）会对下游服务造成不利影响，这点一定要注意。")]),t._v(" "),s("p",[s("strong",[t._v("一定要给「重试」制定一个终止策略。")])]),t._v(" "),s("p",[t._v("当回滚的过程很困难或代价很大的情况下，可以接受很长的间隔及大量的重试次数，DDD中经常被提到的「saga」模式其实也是这样的思路。不过，前提是不会因为保留或锁定稀缺资源而阻止其他操作（比如1、2、3、4、5几个串行操作。由于2一直没处理完成导致3、4、5没法继续进行）。")]),t._v(" "),s("p",[s("strong",[t._v("可以离线的事务一致性维护机制")])]),t._v(" "),s("ol",[s("li",[t._v("第一步：在线业务生成可疑记录")]),t._v(" "),s("li",[t._v("第二步：离线服务诊断可疑记录，生成故障记录")]),t._v(" "),s("li",[t._v("第三步：离线服务尝试对故障记录进行智能修复（补偿或重试）")]),t._v(" "),s("li",[t._v("第四步：对于无法修复，或者修复过程失败的记录发出告警，交由人工处理。")])]),t._v(" "),s("h2",{attrs:{id:"总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),s("p",[t._v("这篇我们先聊了下做「补偿」的意义，以及做补偿的2个方式「回滚」和「重试」的实现思路。")]),t._v(" "),s("p",[t._v("然后，提醒你要注意「重试」的时候需要考虑幂等性问题，并且z哥也给出了一个解决思路。")]),t._v(" "),s("p",[t._v("最后，分享了几个 echo 总结的针对「重试」的最佳实践。")]),t._v(" "),s("p",[t._v("希望对你有所帮助。")]),t._v(" "),s("h2",{attrs:{id:"参考文献"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#参考文献"}},[t._v("#")]),t._v(" 参考文献")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/258741780",target:"_blank",rel:"noopener noreferrer"}},[t._v("99%的人都能看懂的分布式系统「补偿」机制 - 知乎 (zhihu.com)"),s("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=r.exports}}]);